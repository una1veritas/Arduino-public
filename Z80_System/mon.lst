                        ; --------------------------------------
                        ; zasm: assemble "mon.asm"
                        ; date: 2025-09-13 01:12:28
                        ; --------------------------------------


                        ;
0000:                   	org 	0000h
0000:                   rst:
0000: 310002   [10]     	ld 		sp, 0200h
0003: C31000   [20]     	jp  	main
                        
                        	org 	0010h
0010:                   main:
0010: 210A01   [10]     	ld 		hl, prompt
0013: CDE900   [27]     	call 	print_hl_str
0016: 210D01   [37]     	ld 		hl, inputbuffer
0019: 067F     [44]     	ld 		b, 127
001B: CD3900   [61]     	call 	getline
001E: 210D01   [71]     	ld 		hl, inputbuffer
0021: CDE900   [88]     	call 	print_hl_str
0024: CDF200   [105]    	call 	print_endl
0027: 210D01   [115]    	ld 		hl, inputbuffer
002A: CD5A00   [132]    	call    hexstr4_de
002D: 626B     [140]    	ld 		hl, de
002F: CD9500   [157]    	call    print_hl_dec
0032: CDF200   [174]    	call 	print_endl
                        
0035: C31000   [184]    	jp 		main
                        
0038: 76       [188]    	halt
                        
                        ; read and store line until the 1st occurrence of cr or nl
                        ; in (hl)
0039:                   getline:
0039: DB00     [11]     	in 		a, (0)		; con status
003B: A7       [15]     	and 	a			; 
003C: 28FB     [22|27]  	jr 		z, getline 	; repeat until available
003E: DB01     [33]     	in 		a, (1)		; getchar
0040: 77       [40]     	ld 		(hl), a		; store
0041: FE0A     [47]     	cp 		10			; if nl
0043: 2807     [54|59]  	jr 		z, getline_end
0045: FE0D     [61]     	cp 		13			; if cr
0047: 2803     [68|73]  	jr 		z, getline_end
0049: 23       [74]     	inc 	hl			; ++hl
004A: 10ED     [82|87]  	djnz 	getline		; get next char
004C:                   getline_end:
004C: 3600     [10]     	ld 		(hl), 0		; terminate by null
004E:                   getline_clrbuf:
004E: DB00     [11]     	in 		a, (0)		; waste remaining chars in con buffer
0050: A7       [15]     	and 	a
0051: C8       [20|26]  	ret 	z
0052: DB01     [31]     	in 		a, (1)
0054: 18F8     [43]     	jr 		getline_clrbuf
                        
                        
                        ; read hexadecimal string upto 2 or 4 (set in c) 
                        ; bytes from (hl) and return integer val in de
                        ;
0056:                   hexstr2_de:
0056: 0E02     [ 7]     	ld 		c, 2
0058: 1804     [19]     	jr 		hexstr_de
                        
005A:                   hexstr4_de:
005A: 0E04     [ 7]     	ld 		c, 4
005C: 1800     [19]     	jr 		hexstr_de
                        
005E:                   hexstr_de:
005E: 110000   [10]         ld      de, 0000h
0061:                   hexstr_de_lp:
0061: 7E       [ 7]         ld      a, (hl)
0062: CD7800   [24]     	call 	hex2nibble
0065: FEFF     [31]     	cp 		$ff
0067: C8       [36|42]  	ret 	z
0068: A7       [40]     	and 	a		; clear Carry bit
0069: 0604     [47]     	ld 		b, 4
006B:                   hexstr_de_rl4:
006B: CB13     [ 8]         rl      e		 ;rotate left entire de
006D: CB12     [16]         rl      d
006F: 10FA     [24|29]      djnz    hexstr_de_rl4
0071: 83       [28]     	add 	e
0072: 5F       [32]     	ld 		e, a
0073: 23       [38]         inc     hl
0074: 0D       [42]     	dec 	c
0075: 20EA     [49|54]      jr      nz, hexstr_de_lp
0077: C9       [59]     	ret
                        
                        ;convert one hexadecimal char in a to nibble in a 
                        ;
0078:                   hex2nibble:
0078: FE61     [ 7]         cp      'a'     ; check whether a lower case
007A: 3802     [14|19]      jr      c, hex2nibble_digit_or_upper  ; a digit or an upper case if carry set
007C: E6DF     [21]         and     $df     ; lower case to upper case
007E:                   hex2nibble_digit_or_upper:
007E: FE3A     [ 7]         cp      '9' + 1 ; check whether a digit
0080: 3005     [14|19]      jr      nc, hex2nibble_upper  ; possibly an upper case letter if carry not set
0082: D630     [21]         sub     a, '0'  ; digit to int value
0084: 380C     [28|33]      jr      c, hex2nibble_err     ; it was not '0' - '9' 
0086: C9       [38]         ret
0087:                   hex2nibble_upper:
0087: FE47     [ 7]         cp      'F'+1   ; check the digit whether less than 'F'
0089: 3007     [14|19]      jr      nc, hex2nibble_err      ; error if it is larger than 'F'
008B: D641     [21]         sub     'A'  	; A - F to integer 0 - 5
008D: 3803     [28|33]      jr      c, hex2nibble_err       ; it was not 'A' - 'F'
008F: C60A     [35]         add     a, 10   ; A - F to 10 - 15 by +5
0091:                   hex2nibble_output:
0091: C9       [10]         ret
                        
0092:                   hex2nibble_err:
0092: 3EFF     [ 7]     	ld 		a, 0xff
0094: C9       [17]     	ret
                        
                        
                        
                        ; print the decimal integer in HL 
0095:                   print_hl_dec:
0095: DD210000 [14]     	ld 		ix, 0
0099: DDE5     [29]     	push 	ix  ; secure 6 bytes (null + 5 digits for 16 bit)
009B: DDE5     [44]     	push 	ix
009D: DDE5     [59]     	push 	ix
009F: DD39     [74]     	add 	ix, sp
00A1: 0E0A     [81]     	ld 		c, 10 	; radix = 10
00A3:                   print_hl_dec_loop0:
00A3: DD23     [10]     	inc 	ix  ; at first, skip the place for terminal null char 
00A5: CDFB00   [27]     	call 	div_hl_c 	; a = hl % 10, hl = hl / 10
00A8: C630     [34]     	add 	a, $30		; to ascii code '0' to '9'
00AA: DD7700   [53]     	ld 		(ix), a		; ix stays on the last written char
00AD: 7C       [57]     	ld 		a, h 		; are there bits remained in hl?
00AE: B5       [61]     	or 		l
00AF: 2802     [68|73]  	jr 		z, print_hl_dec_output		; if conversion finished
00B1: 18F0     [80]     	jr 		print_hl_dec_loop0
00B3:                   print_hl_dec_output:
00B3: DD7E00   [19]     	ld 		a, (ix)
00B6: A7       [23]     	and 	a
00B7: 2806     [30|35]  	jr 		z, print_hl_dec_exit
00B9: D302     [41]     	out 	(2), a
00BB: DD2B     [51]     	dec 	ix
00BD: 18F4     [63]     	jr 		print_hl_dec_output
00BF:                   print_hl_dec_exit:
00BF: DDE1     [14]     	pop 	ix 
00C1: DDE1     [28]     	pop 	ix 
00C3: DDE1     [42]     	pop 	ix 
00C5: C9       [52]     	ret
                        
                        
00C6:                   print_a_hex:
00C6: 67       [ 4]     	ld 		h, a
00C7: 0E02     [11]     	ld 		c, 2
00C9: 1802     [23]     	jr 		print_hl_hex_loop
                        
00CB:                   print_hl_hex:
00CB: 0E04     [ 7]     	ld 		c, 4
00CD:                   print_hl_hex_loop:
00CD: CDDE00   [17]     	call 	rotleft_ahl_4
00D0: C630     [24]     	add 	'0'
00D2: FE3A     [31]     	cp 		':'
00D4: 3802     [38|43]  	jr 		c, print_hl_hex_loop_out
00D6: C607     [45]     	add 	7
00D8:                   print_hl_hex_loop_out:
00D8: D302     [11]     	out 	(2), a
00DA: 0D       [15]     	dec 	c
00DB: 20F0     [22|27]  	jr 		nz, print_hl_hex_loop
00DD: C9       [32]     	ret
                        
00DE:                   rotleft_ahl_4:
00DE: 0604     [ 7]     	ld 	b, 4
00E0: AF       [11]     	xor a
00E1:                   rotleft_ahl_4_loop:
00E1: CB15     [ 8]     	rl 	l
00E3: CB14     [16]     	rl 	h
00E5: 17       [20]     	rla
00E6: 10F9     [28|33]  	djnz rotleft_ahl_4_loop
00E8: C9       [38]     	ret
                        
00E9:                   print_hl_str:
00E9: 7E       [ 7]     	ld	a, (HL)
00EA: B7       [11]     	or	a
00EB: C8       [16|22]  	ret	z
00EC: D302     [27]     	out	(2),a
00EE: 23       [33]     	inc HL
00EF: C3E900   [43]     	jp	print_hl_str
                        
00F2:                   print_endl:
00F2: 3E0D     [ 7]     	ld 		a, 13
00F4: D302     [18]     	out		(2), a
00F6: 3E0A     [25]     	ld 		a, 10
00F8: D302     [36]     	out 	(2), a
00FA: C9       [46]     	ret
                        
                        ; divides hl by c and places the quotient in hl 
                        ; and the remainder in a
00FB:                   div_hl_c:
00FB: AF       [ 4]        xor	a
00FC: 0610     [11]        ld	b, 16
                        
00FE:                   div_hl_c_loop:
00FE: 29       [11]        add	hl, hl
00FF: 17       [15]        rla
0100: 3803     [22|27]     jr	c, $+5
0102: B9       [26]        cp	c
0103: 3802     [33|38]     jr	c, $+4
                        
0105: 91       [37]        sub	c
0106: 2C       [41]        inc	l
                           
0107: 10F5     [49|54]     djnz	div_hl_c_loop
                           
0109: C9       [59]        ret
                        
                        
010A:                   prompt:
010A: 3E20              	db 	"> "
010C: 00                	db 	0
                        
010D:                   inputbuffer:
010D: 00000000          	ds 		16,0
0111: 00...             


; +++ segments +++

#CODE          = $0000 =     0,  size = $011D =   285

; +++ global symbols +++

_end                  = $011D =   285          mon.asm:2 (unused)
_size                 = $011D =   285          mon.asm:2 (unused)
div_hl_c              = $00FB =   251          mon.asm:186
div_hl_c_loop         = $00FE =   254          mon.asm:190
getline               = $0039 =    57          mon.asm:29
getline_clrbuf        = $004E =    78          mon.asm:43
getline_end           = $004C =    76          mon.asm:41
hex2nibble            = $0078 =   120          mon.asm:84
hex2nibble_digit_or_upper = $007E =   126          mon.asm:88
hex2nibble_err        = $0092 =   146          mon.asm:103
hex2nibble_output     = $0091 =   145          mon.asm:100 (unused)
hex2nibble_upper      = $0087 =   135          mon.asm:94
hexstr2_de            = $0056 =    86          mon.asm:54 (unused)
hexstr4_de            = $005A =    90          mon.asm:58
hexstr_de             = $005E =    94          mon.asm:62
hexstr_de_lp          = $0061 =    97          mon.asm:64
hexstr_de_rl4         = $006B =   107          mon.asm:71
inputbuffer           = $010D =   269          mon.asm:209
main                  = $0010 =    16          mon.asm:8
print_a_hex           = $00C6 =   198          mon.asm:140 (unused)
print_endl            = $00F2 =   242          mon.asm:177
print_hl_dec          = $0095 =   149          mon.asm:110
print_hl_dec_exit     = $00BF =   191          mon.asm:133
print_hl_dec_loop0    = $00A3 =   163          mon.asm:117
print_hl_dec_output   = $00B3 =   179          mon.asm:126
print_hl_hex          = $00CB =   203          mon.asm:145 (unused)
print_hl_hex_loop     = $00CD =   205          mon.asm:147
print_hl_hex_loop_out = $00D8 =   216          mon.asm:153
print_hl_str          = $00E9 =   233          mon.asm:169
prompt                = $010A =   266          mon.asm:205
rotleft_ahl_4         = $00DE =   222          mon.asm:159
rotleft_ahl_4_loop    = $00E1 =   225          mon.asm:162
rst                   = $0000 =     0          mon.asm:3 (unused)


total time: 0.0012 sec.
no errors
