                        ; --------------------------------------
                        ; zasm: assemble "nascom8krombasic.asm"
                        ; date: 2025-09-29 21:04:14
                        ; --------------------------------------


                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        
                        #include 'nascom8k.inc'
                        
                        ; MONITOR EQUATES (RESTART INSTRUCTIONS)
                        
00F7:                   _ROUT   EQU     0F7H            ; ROUT - Output char in A
7BDF:                   _BLNK   EQU     07BDFH          ; SCAL BLINK - Get input char in A
63DF:                   _INLN   EQU     063DFH          ; SCAL INLIN - Get input line
5FDF:                   _MFLP   EQU     05FDFH          ; SCAL MFLP - Toggle tape drv LED
5BDF:                   _MRET   EQU     05BDFH          ; SCAL MRET - Return to monitor
52DF:                   _READ   EQU     052DFH          ; SCAL READ
62DF:                   _RIN    EQU     062DFH          ; SCAL RIN - Scan for input char
56DF:                   _VRFY   EQU     056DFH          ; SCAL VERIFY
57DF:                   _WRIT   EQU     057DFH          ; SCAL WRITE
                        
                        ; GENERAL EQUATES
                        
0001:                   UARTD   EQU     01H             ; UART data port
0002:                   UARTS   EQU     02H             ; UART status port
0003:                   CTRLC   EQU     03H             ; Control "C"
0007:                   CTRLG   EQU     07H             ; Control "G"
0008:                   BKSP    EQU     08H             ; Back space
000A:                   LF      EQU     0AH             ; Line feed
000C:                   CS      EQU     0CH             ; Clear screen
000D:                   CR      EQU     0DH             ; Carriage return
000F:                   CTRLO   EQU     0FH             ; Control "O"
0012:                   CTRLR   EQU     12H             ; Control "R"
0013:                   CTRLS   EQU     13H             ; Control "S"
0015:                   CTRLU   EQU     15H             ; Control "U"
001A:                   CTRLZ   EQU     1AH             ; Control "Z"
001B:                   ESC     EQU     1BH             ; Escape
001C:                   TBRK    EQU     1CH             ; "T" monitor break
001D:                   TBS     EQU     1DH             ; "T" monitor back space
001E:                   TCS     EQU     1EH             ; "T" monitor clear screen
001F:                   TCR     EQU     1FH             ; "T" monitor carriage return
007F:                   DEL     EQU     7FH             ; Delete
                        
                        ; MONITOR LOCATIONS
                        
0000:                   MONSTT  EQU     0000H           ; Start of monitor
000D:                   STMON   EQU     000DH           ; NAS-SYS initialisation
0051:                   MFLP    EQU     0051H           ; Flip tape LED ("T")
008D:                   MONTYP  EQU     008DH           ; Type of "T" monitor
03D1:                   T2DUMP  EQU     03D1H           ; "T2" Dump routine
0400:                   T4WR    EQU     0400H           ; "T4" Write routine
070C:                   T4READ  EQU     070CH           ; "T4" Read routine
0800:                   VDU     EQU     0800H           ; NASCOM Video RAM base
                        
                        ; MONITOR WORK SPACE LOCATIONS
                        
0C00:                   PORT0   EQU     0C00H           ; Copy of output port 0
0C0C:                   ARG1    EQU     0C0CH           ; Argument 1
0C0E:                   ARG2    EQU     0C0EH           ; Argument 2
0C18:                   TCUR    EQU     0C18H           ; "T" monitor cursor
0C29:                   CURSOR  EQU     0C29H           ; NAS-SYS Cursor
0C2B:                   ARGN    EQU     0C2BH           ; Number of ARGS
0C4A:                   TOUT    EQU     0C4AH           ; "T" Output reflection
0C4D:                   TIN     EQU     0C4DH           ; "T" Input reflection
0C75:                   CIN     EQU     0C75H           ; NAS-SYS Input table
0C7E:                   NMI     EQU     0C7EH           ; NAS-SYS NMI Jump
                        
                        ; BASIC WORK SPACE LOCATIONS
                        
1000:                   WRKSPC  EQU     1000H           ; BASIC Work space
1003:                   USR     EQU     1003H           ; "USR (x)" jump
1006:                   OUTSUB  EQU     1006H           ; "OUT p,n"
1007:                   OTPORT  EQU     1007H           ; Port (p)
1009:                   DIVSUP  EQU     1009H           ; Division support routine
100A:                   DIV1    EQU     100AH           ; <- Values
100E:                   DIV2    EQU     100EH           ; <-   to
1012:                   DIV3    EQU     1012H           ; <-   be
1015:                   DIV4    EQU     1015H           ; <-inserted
1017:                   SEED    EQU     1017H           ; Random number seed
103A:                   LSTRND  EQU     103AH           ; Last random number
103E:                   INPSUB  EQU     103EH           ; #INP (x)" Routine
103F:                   INPORT  EQU     103FH           ; PORT (x)
1041:                   NULLS   EQU     1041H           ; Number of nulls
1042:                   LWIDTH  EQU     1042H           ; Terminal width
1043:                   COMMAN  EQU     1043H           ; Width for commas
1044:                   NULFLG  EQU     1044H           ; Null after input byte flag
1045:                   CTLOFG  EQU     1045H           ; Control "O" flag
1046:                   LINESC  EQU     1046H           ; Lines counter
1048:                   LINESN  EQU     1048H           ; Lines number
104A:                   CHKSUM  EQU     104AH           ; Array load/save check sum
104C:                   NMIFLG  EQU     104CH           ; Flag for NMI break routine
104D:                   BRKFLG  EQU     104DH           ; Break flag
104E:                   RINPUT  EQU     104EH           ; Input reflection
1051:                   POINT   EQU     1051H           ; "POINT" reflection (unused)
1054:                   PSET    EQU     1054H           ; "SET"   reflection
1057:                   RESET   EQU     1057H           ; "RESET" reflection
105A:                   STRSPC  EQU     105AH           ; Bottom of string space
105C:                   LINEAT  EQU     105CH           ; Current line number
105E:                   BASTXT  EQU     105EH           ; Pointer to start of program
1061:                   BUFFER  EQU     1061H           ; Input buffer
1066:                   STACK   EQU     1066H           ; Initial stack
10AB:                   CURPOS  EQU     10ABH           ; Character position on line
10AC:                   LCRFLG  EQU     10ACH           ; Locate/Create flag
10AD:                   TYPE    EQU     10ADH           ; Data type flag
10AE:                   DATFLG  EQU     10AEH           ; Literal statement flag
10AF:                   LSTRAM  EQU     10AFH           ; Last available RAM
10B1:                   TMSTPT  EQU     10B1H           ; Temporary string pointer
10B3:                   TMSTPL  EQU     10B3H           ; Temporary string pool
10BF:                   TMPSTR  EQU     10BFH           ; Temporary string
10C3:                   STRBOT  EQU     10C3H           ; Bottom of string space
10C5:                   CUROPR  EQU     10C5H           ; Current operator in EVAL
10C7:                   LOOPST  EQU     10C7H           ; First statement of loop
10C9:                   DATLIN  EQU     10C9H           ; Line of current DATA item
10CB:                   FORFLG  EQU     10CBH           ; "FOR" loop flag
10CC:                   LSTBIN  EQU     10CCH           ; Last byte entered
10CD:                   READFG  EQU     10CDH           ; Read/Input flag
10CE:                   BRKLIN  EQU     10CEH           ; Line of break
10D0:                   NXTOPR  EQU     10D0H           ; Next operator in EVAL
10D2:                   ERRLIN  EQU     10D2H           ; Line of error
10D4:                   CONTAD  EQU     10D4H           ; Where to CONTinue
10D6:                   PROGND  EQU     10D6H           ; End of program
10D8:                   VAREND  EQU     10D8H           ; End of variables
10DA:                   ARREND  EQU     10DAH           ; End of arrays
10DC:                   NXTDAT  EQU     10DCH           ; Next data item
10DE:                   FNRGNM  EQU     10DEH           ; Name of FN argument
10E0:                   FNARG   EQU     10E0H           ; FN argument value
10E4:                   FPREG   EQU     10E4H           ; Floating point register
10E7:                   FPEXP   EQU     FPREG+3         ; Floating point exponent
10E8:                   SGNRES  EQU     10E8H           ; Sign of result
10E9:                   PBUFF   EQU     10E9H           ; Number print buffer
10F6:                   MULVAL  EQU     10F6H           ; Multiplier
10F9:                   PROGST  EQU     10F9H           ; Start of program text area
115D:                   STLOOK  EQU     115DH           ; Start of memory test
                        
                        ; BASIC ERROR CODE VALUES
                        
0000:                   NF      EQU     00H             ; NEXT without FOR
0002:                   SN      EQU     02H             ; Syntax error
0004:                   RG      EQU     04H             ; RETURN without GOSUB
0006:                   OD      EQU     06H             ; Out of DATA
0008:                   FC      EQU     08H             ; Function call error
000A:                   OV      EQU     0AH             ; Overflow
000C:                   OM      EQU     0CH             ; Out of memory
000E:                   UL      EQU     0EH             ; Undefined line number
0010:                   BS      EQU     10H             ; Bad subscript
0012:                   DD      EQU     12H             ; Re-DIMensioned array
0014:                   DZ      EQU     14H             ; Division by zero (/0)
0016:                   ID      EQU     16H             ; Illegal direct
0018:                   TM      EQU     18H             ; Type miss-match
001A:                   OS      EQU     1AH             ; Out of string space
001C:                   LS      EQU     1CH             ; String too long
001E:                   ST      EQU     1EH             ; String formula too complex
0020:                   CN      EQU     20H             ; Can't CONTinue
0022:                   UF      EQU     22H             ; UnDEFined FN function
0024:                   MO      EQU     24H             ; Missing operand
                        
E000:                           ORG     0E000H
                        
E000: C303E0   [10]     START:  JP      STARTB          ; Jump for restart jump
E003: F3       [ 4]     STARTB: DI                      ; No interrupts
E004: DD210000 [18]             LD      IX,0            ; Flag cold start
E008: C312E0   [28]             JP      CSTART          ; Jump to initialise
                        
E00B: 8BE9                      DW      DEINT           ; Get integer -32768 to 32767
E00D: F2F0                      DW      ABPASS          ; Return integer in AB
                        
E00F: C33CE7   [38]             JP      LDNMI1          ; << NO REFERENCE TO HERE >>
                        
E012: 210010   [10]     CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
E015: F9       [16]             LD      SP,HL           ; Set up a temporary stack
E016: C3BBFE   [26]             JP      INITST          ; Go to initialise
                        
E019: 11DFE2   [10]     INIT:   LD      DE,INITAB       ; Initialise workspace
E01C: 0663     [17]             LD      B,INITBE-INITAB+3; Bytes to copy
E01E: 210010   [27]             LD      HL,WRKSPC       ; Into workspace RAM
E021: 1A       [ 7]     COPY:   LD      A,(DE)          ; Get source
E022: 77       [14]             LD      (HL),A          ; To destination
E023: 23       [20]             INC     HL              ; Next destination
E024: 13       [26]             INC     DE              ; Next source
E025: 05       [30]             DEC     B               ; Count bytes
E026: C221E0   [40|40]          JP      NZ,COPY         ; More to move
E029: F9       [46]             LD      SP,HL           ; Temporary stack
E02A: CDDFE4   [63]             CALL    CLREG           ; Clear registers and stack
E02D: CD81EB   [80]             CALL    PRNTCR          ; Output CRLF
E030: 32AA10   [93]             LD      (BUFFER+72+1),A ; Mark end of buffer
E033: 32F910   [106]            LD      (PROGST),A      ; Initialise program area
E036: 2103E1   [10]     MSIZE:  LD      HL,MEMMSG       ; Point to message
E039: CD10F2   [27]             CALL    PRS             ; Output "Memory size"
E03C: CDFCE4   [44]             CALL    PROMPT          ; Get input with "?"
E03F: CD36E8   [61]             CALL    GETCHR          ; Get next character
E042: B7       [65]             OR      A               ; Set flags
E043: C25BE0   [75|75]          JP      NZ,TSTMEM       ; If number - Test if RAM there
E046: 215D11   [85]             LD      HL,STLOOK       ; Point to start of RAM
E049: 23       [ 6]     MLOOP:  INC     HL              ; Next byte
E04A: 7C       [10]             LD      A,H             ; Above address FFFF ?
E04B: B5       [14]             OR      L
E04C: CA6DE0   [24|24]          JP      Z,SETTOP        ; Yes - 64K RAM
E04F: 7E       [31]             LD      A,(HL)          ; Get contents
E050: 47       [35]             LD      B,A             ; Save it
E051: 2F       [39]             CPL                     ; Flip all bits
E052: 77       [46]             LD      (HL),A          ; Put it back
E053: BE       [53]             CP      (HL)            ; RAM there if same
E054: 70       [60]             LD      (HL),B          ; Restore old contents
E055: CA49E0   [70|70]          JP      Z,MLOOP         ; If RAM - test next byte
E058: C36DE0   [80]             JP      SETTOP          ; Top of RAM found
                        
E05B: CDA5E9   [17]     TSTMEM: CALL    ATOH            ; Get high memory into DE
E05E: B7       [21]             OR      A               ; Set flags on last byte
E05F: C2ADE3   [31|31]          JP      NZ,SNERR        ; ?SN Error if bad character
E062: EB       [35]             EX      DE,HL           ; Address into HL
E063: 2B       [41]             DEC     HL              ; Back one byte
E064: 3ED9     [48]             LD      A,11011001B     ; Test byte
E066: 46       [55]             LD      B,(HL)          ; Get old contents
E067: 77       [62]             LD      (HL),A          ; Load test byte
E068: BE       [69]             CP      (HL)            ; RAM there if same
E069: 70       [76]             LD      (HL),B          ; Restore old contents
E06A: C236E0   [86|86]          JP      NZ,MSIZE        ; Ask again if no RAM
                        
E06D: 2B       [ 6]     SETTOP: DEC     HL              ; Back one byte
E06E: 115C11   [16]             LD      DE,STLOOK-1     ; See if enough RAM
E071: CD8AE6   [33]             CALL    CPDEHL          ; Compare DE with HL
E074: DA36E0   [43|43]          JP      C,MSIZE         ; Ask again if not enough RAM
E077: 00       [47]             NOP
E078: 00       [51]             NOP
E079: 00       [55]             NOP
E07A: 00       [59]             NOP
E07B: 00       [63]             NOP
E07C: 00       [67]             NOP
E07D: 00       [71]             NOP
E07E: 00       [75]             NOP
E07F: 00       [79]             NOP
E080: 11CEFF   [89]             LD      DE,0-50         ; 50 Bytes string space
E083: 22AF10   [105]            LD      (LSTRAM),HL     ; Save last available RAM
E086: 19       [116]            ADD     HL,DE           ; Allocate string space
E087: 225A10   [132]            LD      (STRSPC),HL     ; Save string space
E08A: CDBAE4   [149]            CALL    CLRPTR          ; Clear program area
E08D: 2A5A10   [165]            LD      HL,(STRSPC)     ; Get end of memory
E090: 11EFFF   [175]            LD      DE,0-17         ; Offset for free bytes
E093: 19       [186]            ADD     HL,DE           ; Adjust HL
E094: 11F910   [196]            LD      DE,PROGST       ; Start of program text
E097: 7D       [200]            LD      A,L             ; Get LSB
E098: 93       [204]            SUB     E               ; Adjust it
E099: 6F       [208]            LD      L,A             ; Re-save
E09A: 7C       [212]            LD      A,H             ; Get MSB
E09B: 9A       [216]            SBC     A,D             ; Adjust it
E09C: 67       [220]            LD      H,A             ; Re-save
E09D: E5       [231]            PUSH    HL              ; Save bytes free
E09E: 21C5E0   [241]            LD      HL,SIGNON       ; Sign-on message
E0A1: CD10F2   [258]            CALL    PRS             ; Output string
E0A4: E1       [268]            POP     HL              ; Get bytes free back
E0A5: CDADF9   [285]            CALL    PRNTHL          ; Output amount of free memory
E0A8: 21B7E0   [295]            LD      HL,BFREE        ; " Bytes free" message
E0AB: CD10F2   [312]            CALL    PRS             ; Output string
                        
E0AE: 316610   [10]     WARMST: LD      SP,STACK        ; Temporary stack
E0B1: CDDFE4   [17]     BRKRET: CALL    CLREG           ; Clear registers and stack
E0B4: C3F8E3   [27]             JP      PRNTOK          ; Go to get command line
                        
E0B7: 20427974          BFREE:  DB      " Bytes free",CR,0,0
E0BB: 65732066          
E0BF: 7265650D          
E0C3: 0000              
                        
E0C5: 4E415343          SIGNON: DB      "NASCOM ROM BASIC Ver 4.7   ",CR
E0C9: 4F4D2052          
E0CD: 4F4D2042          
E0D1: 41534943          
E0D5: 20566572          
E0D9: 20342E37          
E0DD: 2020200D          
E0E1: 436F7079                  DB      "Copyright (C) 1978 by Microsoft",CR,0,0
E0E5: 72696768          
E0E9: 74202843          
E0ED: 29203139          
E0F1: 37382062          
E0F5: 79204D69          
E0F9: 63726F73          
E0FD: 6F66740D          
E101: 0000              
                        
E103: 4D656D6F          MEMMSG: DB      "Memory size",0
E107: 72792073          
E10B: 697A6500          
                        
                        ; FUNCTION ADDRESS TABLE
                        
E10F: 22F8              FNCTAB: DW      SGN
E111: E6F8                      DW      INT
E113: 38F8                      DW      ABS
E115: 0310                      DW      USR
E117: D0F0                      DW      FRE
E119: 41F4                      DW      INP
E11B: FEF0                      DW      POS
E11D: ACFA                      DW      SQR
E11F: 8BFB                      DW      RND
E121: C7F6                      DW      LOG
E123: FAFA                      DW      EXP
E125: 00FC                      DW      COS
E127: 06FC                      DW      SIN
E129: 67FC                      DW      TAN
E12B: 7CFC                      DW      ATN
E12D: A3F5                      DW      PEEK
E12F: BCFD                      DW      DEEK
E131: 5110                      DW      POINT
E133: 82F3                      DW      LEN
E135: 9AF1                      DW      STR
E137: 1CF4                      DW      VAL
E139: 91F3                      DW      ASC
E13B: A2F3                      DW      CHR
E13D: B2F3                      DW      LEFT
E13F: E2F3                      DW      RIGHT
E141: ECF3                      DW      MID
                        
                        ; RESERVED WORD LIST
                        
E143: C54E44            WORDS:  DB      "E"+80H,"ND"
E146: C64F52                    DB      "F"+80H,"OR"
E149: CE455854                  DB      "N"+80H,"EXT"
E14D: C4415441                  DB      "D"+80H,"ATA"
E151: C94E5055                  DB      "I"+80H,"NPUT"
E155: 54                
E156: C4494D                    DB      "D"+80H,"IM"
E159: D2454144                  DB      "R"+80H,"EAD"
E15D: CC4554                    DB      "L"+80H,"ET"
E160: C74F544F                  DB      "G"+80H,"OTO"
E164: D2554E                    DB      "R"+80H,"UN"
E167: C946                      DB      "I"+80H,"F"
E169: D2455354                  DB      "R"+80H,"ESTORE"
E16D: 4F5245            
E170: C74F5355                  DB      "G"+80H,"OSUB"
E174: 42                
E175: D2455455                  DB      "R"+80H,"ETURN"
E179: 524E              
E17B: D2454D                    DB      "R"+80H,"EM"
E17E: D3544F50                  DB      "S"+80H,"TOP"
E182: CF5554                    DB      "O"+80H,"UT"
E185: CF4E                      DB      "O"+80H,"N"
E187: CE554C4C                  DB      "N"+80H,"ULL"
E18B: D7414954                  DB      "W"+80H,"AIT"
E18F: C44546                    DB      "D"+80H,"EF"
E192: D04F4B45                  DB      "P"+80H,"OKE"
E196: C44F4B45                  DB      "D"+80H,"OKE"
E19A: D3435245                  DB      "S"+80H,"CREEN"
E19E: 454E              
E1A0: CC494E45                  DB      "L"+80H,"INES"
E1A4: 53                
E1A5: C34C53                    DB      "C"+80H,"LS"
E1A8: D7494454                  DB      "W"+80H,"IDTH"
E1AC: 48                
E1AD: CD4F4E49                  DB      "M"+80H,"ONITOR"
E1B1: 544F52            
E1B4: D34554                    DB      "S"+80H,"ET"
E1B7: D2455345                  DB      "R"+80H,"ESET"
E1BB: 54                
E1BC: D052494E                  DB      "P"+80H,"RINT"
E1C0: 54                
E1C1: C34F4E54                  DB      "C"+80H,"ONT"
E1C5: CC495354                  DB      "L"+80H,"IST"
E1C9: C34C4541                  DB      "C"+80H,"LEAR"
E1CD: 52                
E1CE: C34C4F41                  DB      "C"+80H,"LOAD"
E1D2: 44                
E1D3: C3534156                  DB      "C"+80H,"SAVE"
E1D7: 45                
E1D8: CE4557                    DB      "N"+80H,"EW"
E1DB: D4414228                  DB      "T"+80H,"AB("
E1DF: D44F                      DB      "T"+80H,"O"
E1E1: C64E                      DB      "F"+80H,"N"
E1E3: D3504328                  DB      "S"+80H,"PC("
E1E7: D448454E                  DB      "T"+80H,"HEN"
E1EB: CE4F54                    DB      "N"+80H,"OT"
E1EE: D3544550                  DB      "S"+80H,"TEP"
                        
E1F2: AB                        DB      "+"+80H
E1F3: AD                        DB      "-"+80H
E1F4: AA                        DB      "*"+80H
E1F5: AF                        DB      "/"+80H
E1F6: DE                        DB      "^"+80H
E1F7: C14E44                    DB      "A"+80H,"ND"
E1FA: CF52                      DB      "O"+80H,"R"
E1FC: BE                        DB      ">"+80H
E1FD: BD                        DB      "="+80H
E1FE: BC                        DB      "<"+80H
                        
E1FF: D3474E                    DB      "S"+80H,"GN"
E202: C94E54                    DB      "I"+80H,"NT"
E205: C14253                    DB      "A"+80H,"BS"
E208: D55352                    DB      "U"+80H,"SR"
E20B: C65245                    DB      "F"+80H,"RE"
E20E: C94E50                    DB      "I"+80H,"NP"
E211: D04F53                    DB      "P"+80H,"OS"
E214: D35152                    DB      "S"+80H,"QR"
E217: D24E44                    DB      "R"+80H,"ND"
E21A: CC4F47                    DB      "L"+80H,"OG"
E21D: C55850                    DB      "E"+80H,"XP"
E220: C34F53                    DB      "C"+80H,"OS"
E223: D3494E                    DB      "S"+80H,"IN"
E226: D4414E                    DB      "T"+80H,"AN"
E229: C1544E                    DB      "A"+80H,"TN"
E22C: D045454B                  DB      "P"+80H,"EEK"
E230: C445454B                  DB      "D"+80H,"EEK"
E234: D04F494E                  DB      "P"+80H,"OINT"
E238: 54                
E239: CC454E                    DB      "L"+80H,"EN"
E23C: D3545224                  DB      "S"+80H,"TR$"
E240: D6414C                    DB      "V"+80H,"AL"
E243: C15343                    DB      "A"+80H,"SC"
E246: C3485224                  DB      "C"+80H,"HR$"
E24A: CC454654                  DB      "L"+80H,"EFT$"
E24E: 24                
E24F: D2494748                  DB      "R"+80H,"IGHT$"
E253: 5424              
E255: CD494424                  DB      "M"+80H,"ID$"
E259: 80                        DB      80H             ; End of list marker
                        
                        ; KEYWORD ADDRESS TABLE
                        
E25A: 72E8              WORDTB: DW      PEND
E25C: 79E7                      DW      FOR
E25E: F6EC                      DW      NEXT
E260: 70EA                      DW      DATA
E262: FDEB                      DW      INPUT
E264: 28EF                      DW      DIM
E266: 2CEC                      DW      READ
E268: 87EA                      DW      LET
E26A: 2DEA                      DW      GOTO
E26C: 10EA                      DW      RUN
E26E: FFEA                      DW      IF
E270: 46E8                      DW      RESTOR
E272: 1CEA                      DW      GOSUB
E274: 4BEA                      DW      RETURN
E276: 72EA                      DW      REM
E278: 70E8                      DW      STOP
E27A: 4DF4                      DW      POUT
E27C: E1EA                      DW      ON
E27E: B1E8                      DW      NULL
E280: 53F4                      DW      WAIT
E282: 06F1                      DW      DEF
E284: AAF5                      DW      POKE
E286: C7FD                      DW      DOKE
E288: E6FD                      DW      SCREEN
E28A: ADFD                      DW      LINES
E28C: 8BFD                      DW      CLS
E28E: A5FD                      DW      WIDTH
E290: A2FE                      DW      MONITR
E292: 5410                      DW      PSET
E294: 5710                      DW      RESET
E296: 23EB                      DW      PRINT
E298: 9EE8                      DW      CONT
E29A: DDE6                      DW      LIST
E29C: CAE9                      DW      CLEAR
E29E: F9F4                      DW      CLOAD
E2A0: C3F4                      DW      CSAVE
E2A2: B9E4                      DW      NEW
                        
                        ; RESERVED WORD TOKEN VALUES
                        
0080:                   ZEND    EQU     080H            ; END
0081:                   ZFOR    EQU     081H            ; FOR
0083:                   ZDATA   EQU     083H            ; DATA
0088:                   ZGOTO   EQU     088H            ; GOTO
008C:                   ZGOSUB  EQU     08CH            ; GOSUB
008E:                   ZREM    EQU     08EH            ; REM
009E:                   ZPRINT  EQU     09EH            ; PRINT
00A4:                   ZNEW    EQU     0A4H            ; NEW
                        
00A5:                   ZTAB    EQU     0A5H            ; TAB
00A6:                   ZTO     EQU     0A6H            ; TO
00A7:                   ZFN     EQU     0A7H            ; FN
00A8:                   ZSPC    EQU     0A8H            ; SPC
00A9:                   ZTHEN   EQU     0A9H            ; THEN
00AA:                   ZNOT    EQU     0AAH            ; NOT
00AB:                   ZSTEP   EQU     0ABH            ; STEP
                        
00AC:                   ZPLUS   EQU     0ACH            ; +
00AD:                   ZMINUS  EQU     0ADH            ; -
00AE:                   ZTIMES  EQU     0AEH            ; *
00AF:                   ZDIV    EQU     0AFH            ; /
00B2:                   ZOR     EQU     0B2H            ; OR
00B3:                   ZGTR    EQU     0B3H            ; >
00B4:                   ZEQUAL  EQU     0B4H            ; M
00B5:                   ZLTH    EQU     0B5H            ; <
00B6:                   ZSGN    EQU     0B6H            ; SGN
00C7:                   ZPOINT  EQU     0C7H            ; POINT
00CD:                   ZLEFT   EQU     0CDH            ; LEFT$
                        
                        ; ARITHMETIC PRECEDENCE TABLE
                        
E2A4: 79                PRITAB: DB      79H             ; Precedence value
E2A5: 94F9                      DW      PADD            ; FPREG = <last> + FPREG
                        
E2A7: 79                        DB      79H             ; Precedence value
E2A8: C8F5                      DW      PSUB            ; FPREG = <last> - FPREG
                        
E2AA: 7C                        DB      7CH             ; Precedence value
E2AB: 06F7                      DW      MULT            ; PPREG = <last> * FPREG
                        
E2AD: 7C                        DB      7CH             ; Precedence value
E2AE: 67F7                      DW      DIV             ; FPREG = <last> / FPREG
                        
E2B0: 7F                        DB      7FH             ; Precedence value
E2B1: B5FA                      DW      POWER           ; FPREG = <last> ^ FPREG
                        
E2B3: 50                        DB      50H             ; Precedence value
E2B4: 81EE                      DW      PAND            ; FPREG = <last> AND FPREG
                        
E2B6: 46                        DB      46H             ; Precedence value
E2B7: 80EE                      DW      POR             ; FPREG = <last> OR FPREG
                        
                        ; BASIC ERROR CODE LIST
                        
E2B9: 4E46              ERRORS: DB      "NF"            ; NEXT without FOR
E2BB: 534E                      DB      "SN"            ; Syntax error
E2BD: 5247                      DB      "RG"            ; RETURN without GOSUB
E2BF: 4F44                      DB      "OD"            ; Out of DATA
E2C1: 4643                      DB      "FC"            ; Illegal function call
E2C3: 4F56                      DB      "OV"            ; Overflow error
E2C5: 4F4D                      DB      "OM"            ; Out of memory
E2C7: 554C                      DB      "UL"            ; Undefined line
E2C9: 4253                      DB      "BS"            ; Bad subscript
E2CB: 4444                      DB      "DD"            ; Re-DIMensioned array
E2CD: 2F30                      DB      "/0"            ; Division by zero
E2CF: 4944                      DB      "ID"            ; Illegal direct
E2D1: 544D                      DB      "TM"            ; Type mis-match
E2D3: 4F53                      DB      "OS"            ; Out of string space
E2D5: 4C53                      DB      "LS"            ; String too long
E2D7: 5354                      DB      "ST"            ; String formula too complex
E2D9: 434E                      DB      "CN"            ; Can't CONTinue
E2DB: 5546                      DB      "UF"            ; Undefined FN function
E2DD: 4D4F                      DB      "MO"            ; Missing operand
                        
                        ; INITIALISATION TABLE
                        
E2DF: C3AEE0   [10]     INITAB: JP      WARMST          ; Warm start jump
E2E2: C3A0E9   [20]             JP      FCERR           ; "USR (X)" jump (Set to Error)
                        
E2E5: D300     [31]             OUT     (0),A           ; "OUT p,n" skeleton
E2E7: C9       [41]             RET
                        
E2E8: D600     [48]             SUB     0               ; Division support routine
E2EA: 6F       [52]             LD      L,A
E2EB: 7C       [56]             LD      A,H
E2EC: DE00     [63]             SBC     A,0
E2EE: 67       [67]             LD      H,A
E2EF: 78       [71]             LD      A,B
E2F0: DE00     [78]             SBC     A,0
E2F2: 47       [82]             LD      B,A
E2F3: 3E00     [89]             LD      A,0
E2F5: C9       [99]             RET
                        
E2F6: 000000                    DB      0,0,0                   ; Random number seed
                                                                ; Table used by RND
E2F9: 354ACA99                  DB      035H,04AH,0CAH,099H     ;-2.65145E+07
E2FD: 391C7698                  DB      039H,01CH,076H,098H     ; 1.61291E+07
E301: 2295B398                  DB      022H,095H,0B3H,098H     ;-1.17691E+07
E305: 0ADD4798                  DB      00AH,0DDH,047H,098H     ; 1.30983E+07
E309: 53D19999                  DB      053H,0D1H,099H,099H     ;-2-01612E+07
E30D: 0A1A9F98                  DB      00AH,01AH,09FH,098H     ;-1.04269E+07
E311: 65BCCD98                  DB      065H,0BCH,0CDH,098H     ;-1.34831E+07
E315: D6773E98                  DB      0D6H,077H,03EH,098H     ; 1.24825E+07
E319: 52C74F80                  DB      052H,0C7H,04FH,080H     ; Last random number
                        
E31D: DB00     [110]            IN      A,(0)           ; INP (x) skeleton
E31F: C9       [120]            RET
                        
E320: 01                        DB      1               ; POS (x) number (1)
E321: 2F                        DB      47              ; Terminal width (47)
E322: 1C                        DB      28              ; Width for commas (3 columns)
E323: 00                        DB      0               ; No nulls after input bytes
E324: 00                        DB      0               ; Output enabled (^O off)
                        
E325: 0500                      DW      5               ; Initial lines counter
E327: 0500                      DW      5               ; Initial lines number
E329: 0000                      DW      0               ; Array load/save check sum
                        
E32B: 00                        DB      0               ; Break not by NMI
E32C: 00                        DB      0               ; Break flag
                        
E32D: C307E6   [130]            JP      TTYLIN          ; Input reflection (set to TTY)
E330: C379FF   [140]            JP      POINTB          ; POINT reflection unused
E333: C340FF   [150]            JP      SETB            ; SET reflection
E336: C355FF   [160]            JP      RESETB          ; RESET reflection
                        
E339: 5D11                      DW      STLOOK          ; Temp string space
E33B: FEFF                      DW      -2              ; Current line number (cold)
E33D: FA10                      DW      PROGST+1        ; Start of program text
E33F:                   INITBE:                         ; END OF INITIALISATION TABLE
                        
E33F: 20457272          ERRMSG: DB      " Error",0
E343: 6F7200            
E346: 20696E20          INMSG:  DB      " in ",0
E34A: 00                
E34A:                   ZERBYT  EQU     $-1             ; A zero byte
E34B: 4F6B0D00          OKMSG:  DB      "Ok",CR,0,0
E34F: 00                
E350: 42726561          BRKMSG: DB      "Break",0
E354: 6B00              
                        
E356: 210400   [10]     BAKSTK: LD      HL,4            ; Look for "FOR" block with
E359: 39       [21]             ADD     HL,SP           ; same index as specified
E35A: 7E       [ 7]     LOKFOR: LD      A,(HL)          ; Get block ID
E35B: 23       [13]             INC     HL              ; Point to index address
E35C: FE81     [20]             CP      ZFOR            ; Is it a "FOR" token
E35E: C0       [25|31]          RET     NZ              ; No - exit
E35F: 4E       [32]             LD      C,(HL)          ; BC = Address of "FOR" index
E360: 23       [38]             INC     HL
E361: 46       [45]             LD      B,(HL)
E362: 23       [51]             INC     HL              ; Point to sign of STEP
E363: E5       [62]             PUSH    HL              ; Save pointer to sign
E364: 69       [66]             LD      L,C             ; HL = address of "FOR" index
E365: 60       [70]             LD      H,B
E366: 7A       [74]             LD      A,D             ; See if an index was specified
E367: B3       [78]             OR      E               ; DE = 0 if no index specified
E368: EB       [82]             EX      DE,HL           ; Specified index into HL
E369: CA70E3   [92|92]          JP      Z,INDFND        ; Skip if no index given
E36C: EB       [96]             EX      DE,HL           ; Index back into DE
E36D: CD8AE6   [113]            CALL    CPDEHL          ; Compare index with one given
E370: 010D00   [10]     INDFND: LD      BC,16-3         ; Offset to next block
E373: E1       [20]             POP     HL              ; Restore pointer to sign
E374: C8       [25|31]          RET     Z               ; Return if block found
E375: 09       [36]             ADD     HL,BC           ; Point to next block
E376: C35AE3   [46]             JP      LOKFOR          ; Keep on looking
                        
E379: CD93E3   [17]     MOVUP:  CALL    ENFMEM          ; See if enough memory
E37C: C5       [11]     MOVSTR: PUSH    BC              ; Save end of source
E37D: E3       [30]             EX      (SP),HL         ; Swap source and dest" end
E37E: C1       [40]             POP     BC              ; Get end of destination
E37F: CD8AE6   [17]     MOVLP:  CALL    CPDEHL          ; See if list moved
E382: 7E       [24]             LD      A,(HL)          ; Get byte
E383: 02       [31]             LD      (BC),A          ; Move it
E384: C8       [36|42]          RET     Z               ; Exit if all done
E385: 0B       [42]             DEC     BC              ; Next byte to move to
E386: 2B       [48]             DEC     HL              ; Next byte to move
E387: C37FE3   [58]             JP      MOVLP           ; Loop until all bytes moved
                        
E38A: E5       [11]     CHKSTK: PUSH    HL              ; Save code string address
E38B: 2ADA10   [27]             LD      HL,(ARREND)     ; Lowest free memory
E38E: 0600     [34]             LD      B,0             ; BC = Number of levels to test
E390: 09       [45]             ADD     HL,BC           ; 2 Bytes for each level
E391: 09       [56]             ADD     HL,BC
E392: 3E                        DB      3EH             ; Skip "PUSH HL"
E393: E5       [11]     ENFMEM: PUSH    HL              ; Save code string address
E394: FFFF     [33]             LD      A,LOW -48       ; 48 Bytes minimum RAM
***ERROR***                                  ^ label "LOW" not found
E396: 95       [37]             SUB     L
E397: 6F       [41]             LD      L,A
E398: FFFF     [63]             LD      A,HIGH -48      ; 48 Bytes minimum RAM
***ERROR***                                   ^ label "HIGH" not found
E39A: 9C       [67]             SBC     A,H
E39B: DAA2E3   [77|77]          JP      C,OMERR         ; Not enough - ?OM Error
E39E: 67       [81]             LD      H,A
E39F: 39       [92]             ADD     HL,SP           ; Test if stack is overflowed
E3A0: E1       [102]            POP     HL              ; Restore code string address
E3A1: D8       [107|113]        RET     C               ; Return if enough mmory
E3A2: 1E0C     [ 7]     OMERR:  LD      E,OM            ; ?OM Error
E3A4: C3C1E3   [17]             JP      ERROR
                        
E3A7: 2AC910   [16]     DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
E3AA: 225C10   [32]             LD      (LINEAT),HL     ; Save as current line
E3AD: 1E02     [ 7]     SNERR:  LD      E,SN            ; ?SN Error
E3AF: 01                        DB      01H             ; Skip "LD E,DZ"
E3B0: 1E14     [ 7]     DZERR:  LD      E,DZ            ; ?/0 Error
E3B2: 01                        DB      01H             ; Skip "LD E,NF"
E3B3: 1E00     [ 7]     NFERR:  LD      E,NF            ; ?NF Error
E3B5: 01                        DB      01H             ; Skip "LD E,DD"
E3B6: 1E12     [ 7]     DDERR:  LD      E,DD            ; ?DD Error
E3B8: 01                        DB      01H             ; Skip "LD E,UF"
E3B9: 1E22     [ 7]     UFERR:  LD      E,UF            ; ?UF Error
E3BB: 01                        DB      01H             ; Skip "LD E,OV
E3BC: 1E0A     [ 7]     OVERR:  LD      E,OV            ; ?OV Error
E3BE: 01                        DB      01H             ; Skip "LD E,TM"
E3BF: 1E18     [ 7]     TMERR:  LD      E,TM            ; ?TM Error
                        
E3C1: CDDFE4   [17]     ERROR:  CALL    CLREG           ; Clear registers and stack
E3C4: 324510   [30]             LD      (CTLOFG),A      ; Enable output (A is 0)
E3C7: CD74EB   [47]             CALL    STTLIN          ; Start new line
E3CA: 21B9E2   [57]             LD      HL,ERRORS       ; Point to error codes
E3CD: 57       [61]             LD      D,A             ; D = 0 (A is 0)
E3CE: 3E3F     [68]             LD      A,"?"
E3D0: CD9BE6   [85]             CALL    OUTC            ; Output "?"
E3D3: 19       [96]             ADD     HL,DE           ; Offset to correct error code
E3D4: 7E       [103]            LD      A,(HL)          ; First character
E3D5: CD9BE6   [120]            CALL    OUTC            ; Output it
E3D8: CD36E8   [137]            CALL    GETCHR          ; Get next character
E3DB: CD9BE6   [154]            CALL    OUTC            ; Output it
E3DE: 213FE3   [164]            LD      HL,ERRMSG       ; "Error" message
E3E1: CD10F2   [17]     ERRIN:  CALL    PRS             ; Output message
E3E4: 2A5C10   [33]             LD      HL,(LINEAT)     ; Get line of error
E3E7: 11FEFF   [43]             LD      DE,-2           ; Cold start error if -2
E3EA: CD8AE6   [60]             CALL    CPDEHL          ; See if cold start error
E3ED: CA12E0   [70|70]          JP      Z,CSTART        ; Cold start error - Restart
E3F0: 7C       [74]             LD      A,H             ; Was it a direct error?
E3F1: A5       [78]             AND     L               ; Line = -1 if direct error
E3F2: 3C       [82]             INC     A
E3F3: C4A5F9   [92|99]          CALL    NZ,LINEIN       ; No - output line of error
E3F6: 3E                        DB      3EH             ; Skip "POP BC"
E3F7: C1       [10]     POPNOK: POP     BC              ; Drop address in input buffer
                        
E3F8: AF       [ 4]     PRNTOK: XOR     A               ; Output "Ok" and get command
E3F9: 324510   [17]             LD      (CTLOFG),A      ; Enable output
E3FC: CD74EB   [34]             CALL    STTLIN          ; Start new line
E3FF: 214BE3   [44]             LD      HL,OKMSG        ; "Ok" message
E402: CD10F2   [61]             CALL    PRS             ; Output "Ok"
E405: 21FFFF   [10]     GETCMD: LD      HL,-1           ; Flag direct mode
E408: 225C10   [26]             LD      (LINEAT),HL     ; Save as current line
E40B: CDF2E5   [43]             CALL    GETLIN          ; Get an input line
E40E: DA05E4   [53|53]          JP      C,GETCMD        ; Get line again if break
E411: CD36E8   [70]             CALL    GETCHR          ; Get first character
E414: 3C       [74]             INC     A               ; Test if end of line
E415: 3D       [78]             DEC     A               ; Without affecting Carry
E416: CA05E4   [88|88]          JP      Z,GETCMD        ; Nothing entered - Get another
E419: F5       [99]             PUSH    AF              ; Save Carry status
E41A: CDA5E9   [116]            CALL    ATOH            ; Get line number into DE
E41D: D5       [127]            PUSH    DE              ; Save line number
E41E: CD09E5   [144]            CALL    CRUNCH          ; Tokenise rest of line
E421: 47       [148]            LD      B,A             ; Length of tokenised line
E422: D1       [158]            POP     DE              ; Restore line number
E423: F1       [168]            POP     AF              ; Restore Carry
E424: D216E8   [178|178]        JP      NC,EXCUTE       ; No line number - Direct mode
E427: D5       [189]            PUSH    DE              ; Save line number
E428: C5       [200]            PUSH    BC              ; Save length of tokenised line
E429: AF       [204]            XOR     A
E42A: 32CC10   [217]            LD      (LSTBIN),A      ; Clear last byte input
E42D: CD36E8   [234]            CALL    GETCHR          ; Get next character
E430: B7       [238]            OR      A               ; Set flags
E431: F5       [249]            PUSH    AF              ; And save them
E432: CD99E4   [266]            CALL    SRCHLN          ; Search for line number in DE
E435: DA3EE4   [276|276]        JP      C,LINFND        ; Jump if line found
E438: F1       [286]            POP     AF              ; Get status
E439: F5       [297]            PUSH    AF              ; And re-save
E43A: CA46EA   [307|307]        JP      Z,ULERR         ; Nothing after number - Error
E43D: B7       [311]            OR      A               ; Clear Carry
E43E: C5       [11]     LINFND: PUSH    BC              ; Save address of line in prog
E43F: D255E4   [21|21]          JP      NC,INEWLN       ; Line not found - Insert new
E442: EB       [25]             EX      DE,HL           ; Next line address in DE
E443: 2AD610   [41]             LD      HL,(PROGND)     ; End of program
E446: 1A       [ 7]     SFTPRG: LD      A,(DE)          ; Shift rest of program down
E447: 02       [14]             LD      (BC),A
E448: 03       [20]             INC     BC              ; Next destination
E449: 13       [26]             INC     DE              ; Next source
E44A: CD8AE6   [43]             CALL    CPDEHL          ; All done?
E44D: C246E4   [53|53]          JP      NZ,SFTPRG       ; More to do
E450: 60       [57]             LD      H,B             ; HL - New end of program
E451: 69       [61]             LD      L,C
E452: 22D610   [77]             LD      (PROGND),HL     ; Update end of program
                        
E455: D1       [10]     INEWLN: POP     DE              ; Get address of line,
E456: F1       [20]             POP     AF              ; Get status
E457: CA7CE4   [30|30]          JP      Z,SETPTR        ; No text - Set up pointers
E45A: 2AD610   [46]             LD      HL,(PROGND)     ; Get end of program
E45D: E3       [65]             EX      (SP),HL         ; Get length of input line
E45E: C1       [75]             POP     BC              ; End of program to BC
E45F: 09       [86]             ADD     HL,BC           ; Find new end
E460: E5       [97]             PUSH    HL              ; Save new end
E461: CD79E3   [114]            CALL    MOVUP           ; Make space for line
E464: E1       [124]            POP     HL              ; Restore new end
E465: 22D610   [140]            LD      (PROGND),HL     ; Update end of program pointer
E468: EB       [144]            EX      DE,HL           ; Get line to move up in HL
E469: 74       [151]            LD      (HL),H          ; Save MSB
E46A: D1       [161]            POP     DE              ; Get new line number
E46B: 23       [167]            INC     HL              ; Skip pointer
E46C: 23       [173]            INC     HL
E46D: 73       [180]            LD      (HL),E          ; Save LSB of line number
E46E: 23       [186]            INC     HL
E46F: 72       [193]            LD      (HL),D          ; Save MSB of line number
E470: 23       [199]            INC     HL              ; To first byte in line
E471: 116110   [209]            LD      DE,BUFFER       ; Copy buffer to program
E474: 1A       [ 7]     MOVBUF: LD      A,(DE)          ; Get source
E475: 77       [14]             LD      (HL),A          ; Save destinations
E476: 23       [20]             INC     HL              ; Next source
E477: 13       [26]             INC     DE              ; Next destination
E478: B7       [30]             OR      A               ; Done?
E479: C274E4   [40|40]          JP      NZ,MOVBUF       ; No - Repeat
E47C: CDC5E4   [17]     SETPTR: CALL    RUNFST          ; Set line pointers
E47F: 23       [23]             INC     HL              ; To LSB of pointer
E480: EB       [27]             EX      DE,HL           ; Address to DE
E481: 62       [ 4]     PTRLP:  LD      H,D             ; Address to HL
E482: 6B       [ 8]             LD      L,E
E483: 7E       [15]             LD      A,(HL)          ; Get LSB of pointer
E484: 23       [21]             INC     HL              ; To MSB of pointer
E485: B6       [28]             OR      (HL)            ; Compare with MSB pointer
E486: CA05E4   [38|38]          JP      Z,GETCMD        ; Get command line if end
E489: 23       [44]             INC     HL              ; To LSB of line number
E48A: 23       [50]             INC     HL              ; Skip line number
E48B: 23       [56]             INC     HL              ; Point to first byte in line
E48C: AF       [60]             XOR     A               ; Looking for 00 byte
E48D: BE       [ 7]     FNDEND: CP      (HL)            ; Found end of line?
E48E: 23       [13]             INC     HL              ; Move to next byte
E48F: C28DE4   [23|23]          JP      NZ,FNDEND       ; No - Keep looking
E492: EB       [27]             EX      DE,HL           ; Next line address to HL
E493: 73       [34]             LD      (HL),E          ; Save LSB of pointer
E494: 23       [40]             INC     HL
E495: 72       [47]             LD      (HL),D          ; Save MSB of pointer
E496: C381E4   [57]             JP      PTRLP           ; Do next line
                        
E499: 2A5E10   [16]     SRCHLN: LD      HL,(BASTXT)     ; Start of program text
E49C: 44       [ 4]     SRCHLP: LD      B,H             ; BC = Address to look at
E49D: 4D       [ 8]             LD      C,L
E49E: 7E       [15]             LD      A,(HL)          ; Get address of next line
E49F: 23       [21]             INC     HL
E4A0: B6       [28]             OR      (HL)            ; End of program found?
E4A1: 2B       [34]             DEC     HL
E4A2: C8       [39|45]          RET     Z               ; Yes - Line not found
E4A3: 23       [45]             INC     HL
E4A4: 23       [51]             INC     HL
E4A5: 7E       [58]             LD      A,(HL)          ; Get LSB of line number
E4A6: 23       [64]             INC     HL
E4A7: 66       [71]             LD      H,(HL)          ; Get MSB of line number
E4A8: 6F       [75]             LD      L,A
E4A9: CD8AE6   [92]             CALL    CPDEHL          ; Compare with line in DE
E4AC: 60       [96]             LD      H,B             ; HL = Start of this line
E4AD: 69       [100]            LD      L,C
E4AE: 7E       [107]            LD      A,(HL)          ; Get LSB of next line address
E4AF: 23       [113]            INC     HL
E4B0: 66       [120]            LD      H,(HL)          ; Get MSB of next line address
E4B1: 6F       [124]            LD      L,A             ; Next line to HL
E4B2: 3F       [128]            CCF
E4B3: C8       [133|139]        RET     Z               ; Lines found - Exit
E4B4: 3F       [137]            CCF
E4B5: D0       [142|148]        RET     NC              ; Line not found,at line after
E4B6: C39CE4   [152]            JP      SRCHLP          ; Keep looking
                        
E4B9: C0       [ 5|11]  NEW:    RET     NZ              ; Return if any more on line
E4BA: 2A5E10   [16]     CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
E4BD: AF       [20]             XOR     A               ; Set program area to empty
E4BE: 77       [27]             LD      (HL),A          ; Save LSB = 00
E4BF: 23       [33]             INC     HL
E4C0: 77       [40]             LD      (HL),A          ; Save MSB = 00
E4C1: 23       [46]             INC     HL
E4C2: 22D610   [62]             LD      (PROGND),HL     ; Set program end
                        
E4C5: 2A5E10   [16]     RUNFST: LD      HL,(BASTXT)     ; Clear all variables
E4C8: 2B       [22]             DEC     HL
                        
E4C9: 22CE10   [16]     INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
E4CC: 2AAF10   [32]             LD      HL,(LSTRAM)     ; Get end of RAM
E4CF: 22C310   [48]             LD      (STRBOT),HL     ; Clear string space
E4D2: AF       [52]             XOR     A
E4D3: CD46E8   [69]             CALL    RESTOR          ; Reset DATA pointers
E4D6: 2AD610   [85]             LD      HL,(PROGND)     ; Get end of program
E4D9: 22D810   [101]            LD      (VAREND),HL     ; Clear variables
E4DC: 22DA10   [117]            LD      (ARREND),HL     ; Clear arrays
                        
E4DF: C1       [10]     CLREG:  POP     BC              ; Save return address
E4E0: 2A5A10   [26]             LD      HL,(STRSPC)     ; Get end of working RAN
E4E3: F9       [32]             LD      SP,HL           ; Set stack
E4E4: 21B310   [42]             LD      HL,TMSTPL       ; Temporary string pool
E4E7: 22B110   [58]             LD      (TMSTPT),HL     ; Reset temporary string ptr
E4EA: AF       [62]             XOR     A               ; A = 00
E4EB: 6F       [66]             LD      L,A             ; HL = 0000
E4EC: 67       [70]             LD      H,A
E4ED: 22D410   [86]             LD      (CONTAD),HL     ; No CONTinue
E4F0: 32CB10   [99]             LD      (FORFLG),A      ; Clear FOR flag
E4F3: 22DE10   [115]            LD      (FNRGNM),HL     ; Clear FN argument
E4F6: E5       [126]            PUSH    HL              ; HL = 0000
E4F7: C5       [137]            PUSH    BC              ; Put back return
E4F8: 2ACE10   [16]     DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
E4FB: C9       [26]             RET                     ; Return to execution driver
                        
E4FC: 3E3F     [ 7]     PROMPT: LD      A,"?"           ; "?"
E4FE: CD9BE6   [24]             CALL    OUTC            ; Output character
E501: 3E20     [31]             LD      A," "           ; Space
E503: CD9BE6   [48]             CALL    OUTC            ; Output character
E506: C34E10   [58]             JP      RINPUT          ; Get input line
                        
E509: AF       [ 4]     CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
E50A: 32AE10   [17]             LD      (DATFLG),A      ; Reset literal flag
E50D: 0E05     [24]             LD      C,2+3           ; 2 byte number and 3 nulls
E50F: 116110   [34]             LD      DE,BUFFER       ; Start of input buffer
E512: 7E       [ 7]     CRNCLP: LD      A,(HL)          ; Get byte
E513: FE20     [14]             CP      " "             ; Is it a space?
E515: CA91E5   [24|24]          JP      Z,MOVDIR        ; Yes - Copy direct
E518: 47       [28]             LD      B,A             ; Save character
E519: FE22     [35]             CP      '"'             ; Is it a quote?
E51B: CAB1E5   [45|45]          JP      Z,CPYLIT        ; Yes - Copy literal string
E51E: B7       [49]             OR      A               ; Is it end of buffer?
E51F: CAB8E5   [59|59]          JP      Z,ENDBUF        ; Yes - End buffer
E522: 3AAE10   [72]             LD      A,(DATFLG)      ; Get data type
E525: B7       [76]             OR      A               ; Literal?
E526: 7E       [83]             LD      A,(HL)          ; Get byte to copy
E527: C291E5   [93|93]          JP      NZ,MOVDIR       ; Literal - Copy direct
E52A: FE3F     [100]            CP      "?"             ; Is it "?" short for PRINT
E52C: 3E9E     [107]            LD      A,ZPRINT        ; "PRINT" token
E52E: CA91E5   [117|117]        JP      Z,MOVDIR        ; Yes - replace it
E531: 7E       [124]            LD      A,(HL)          ; Get byte again
E532: FE30     [131]            CP      "0"             ; Is it less than "0"
E534: DA3CE5   [141|141]        JP      C,FNDWRD        ; Yes - Look for reserved words
E537: FE3C     [148]            CP      ";"+1           ; Is it "0123456789:;" ?
E539: DA91E5   [158|158]        JP      C,MOVDIR        ; Yes - copy it direct
E53C: D5       [11]     FNDWRD: PUSH    DE              ; Look for reserved words
E53D: 1142E1   [21]             LD      DE,WORDS-1      ; Point to table
E540: C5       [32]             PUSH    BC              ; Save count
E541: 018DE5   [42]             LD      BC,RETNAD       ; Where to return to
E544: C5       [53]             PUSH    BC              ; Save return address
E545: 067F     [60]             LD      B,ZEND-1        ; First token value -1
E547: 7E       [67]             LD      A,(HL)          ; Get byte
E548: FE61     [74]             CP      "a"             ; Less than "a" ?
E54A: DA55E5   [84|84]          JP      C,SEARCH        ; Yes - search for words
E54D: FE7B     [91]             CP      "z"+1           ; Greater than "z" ?
E54F: D255E5   [101|101]        JP      NC,SEARCH       ; Yes - search for words
E552: E65F     [108]            AND     01011111B       ; Force upper case
E554: 77       [115]            LD      (HL),A          ; Replace byte
E555: 4E       [ 7]     SEARCH: LD      C,(HL)          ; Search for a word
E556: EB       [11]             EX      DE,HL
E557: 23       [ 6]     GETNXT: INC     HL              ; Get next reserved word
E558: B6       [13]             OR      (HL)            ; Start of word?
E559: F257E5   [23|23]          JP      P,GETNXT        ; No - move on
E55C: 04       [27]             INC     B               ; Increment token value
E55D: 7E       [34]             LD      A, (HL)         ; Get byte from table
E55E: E67F     [41]             AND     01111111B       ; Strip bit 7
E560: C8       [46|52]          RET     Z               ; Return if end of list
E561: B9       [50]             CP      C               ; Same character as in buffer?
E562: C257E5   [60|60]          JP      NZ,GETNXT       ; No - get next word
E565: EB       [64]             EX      DE,HL
E566: E5       [75]             PUSH    HL              ; Save start of word
                        
E567: 13       [ 6]     NXTBYT: INC     DE              ; Look through rest of word
E568: 1A       [13]             LD      A,(DE)          ; Get byte from table
E569: B7       [17]             OR      A               ; End of word ?
E56A: FA89E5   [27|27]          JP      M,MATCH         ; Yes - Match found
E56D: 4F       [31]             LD      C,A             ; Save it
E56E: 78       [35]             LD      A,B             ; Get token value
E56F: FE88     [42]             CP      ZGOTO           ; Is it "GOTO" token ?
E571: C278E5   [52|52]          JP      NZ,NOSPC        ; No - Don't allow spaces
E574: CD36E8   [69]             CALL    GETCHR          ; Get next character
E577: 2B       [75]             DEC     HL              ; Cancel increment from GETCHR
E578: 23       [ 6]     NOSPC:  INC     HL              ; Next byte
E579: 7E       [13]             LD      A,(HL)          ; Get byte
E57A: FE61     [20]             CP      "a"             ; Less than "a" ?
E57C: DA81E5   [30|30]          JP      C,NOCHNG        ; Yes - don't change
E57F: E65F     [37]             AND     01011111B       ; Make upper case
E581: B9       [ 4]     NOCHNG: CP      C               ; Same as in buffer ?
E582: CA67E5   [14|14]          JP      Z,NXTBYT        ; Yes - keep testing
E585: E1       [24]             POP     HL              ; Get back start of word
E586: C355E5   [34]             JP      SEARCH          ; Look at next word
                        
E589: 48       [ 4]     MATCH:  LD      C,B             ; Word found - Save token value
E58A: F1       [14]             POP     AF              ; Throw away return
E58B: EB       [18]             EX      DE,HL
E58C: C9       [28]             RET                     ; Return to "RETNAD"
E58D: EB       [ 4]     RETNAD: EX      DE,HL           ; Get address in string
E58E: 79       [ 8]             LD      A,C             ; Get token value
E58F: C1       [18]             POP     BC              ; Restore buffer length
E590: D1       [28]             POP     DE              ; Get destination address
E591: 23       [ 6]     MOVDIR: INC     HL              ; Next source in buffer
E592: 12       [13]             LD      (DE),A          ; Put byte in buffer
E593: 13       [19]             INC     DE              ; Move up buffer
E594: 0C       [23]             INC     C               ; Increment length of buffer
E595: D63A     [30]             SUB     ":"             ; End of statement?
E597: CA9FE5   [40|40]          JP      Z,SETLIT        ; Jump if multi-statement line
E59A: FE49     [47]             CP      ZDATA-3AH       ; Is it DATA statement ?
E59C: C2A2E5   [57|57]          JP      NZ,TSTREM       ; No - see if REM
E59F: 32AE10   [13]     SETLIT: LD      (DATFLG),A      ; Set literal flag
E5A2: D654     [ 7]     TSTREM: SUB     ZREM-3AH        ; Is it REM?
E5A4: C212E5   [17|17]          JP      NZ,CRNCLP       ; No - Leave flag
E5A7: 47       [21]             LD      B,A             ; Copy rest of buffer
E5A8: 7E       [ 7]     NXTCHR: LD      A,(HL)          ; Get byte
E5A9: B7       [11]             OR      A               ; End of line ?
E5AA: CAB8E5   [21|21]          JP      Z,ENDBUF        ; Yes - Terminate buffer
E5AD: B8       [25]             CP      B               ; End of statement ?
E5AE: CA91E5   [35|35]          JP      Z,MOVDIR        ; Yes - Get next one
E5B1: 23       [ 6]     CPYLIT: INC     HL              ; Move up source string
E5B2: 12       [13]             LD      (DE),A          ; Save in destination
E5B3: 0C       [17]             INC     C               ; Increment length
E5B4: 13       [23]             INC     DE              ; Move up destination
E5B5: C3A8E5   [33]             JP      NXTCHR          ; Repeat
                        
E5B8: 216010   [10]     ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
E5BB: 12       [17]             LD      (DE),A          ; Mark end of buffer (A = 00)
E5BC: 13       [23]             INC     DE
E5BD: 12       [30]             LD      (DE),A          ; A = 00
E5BE: 13       [36]             INC     DE
E5BF: 12       [43]             LD      (DE),A          ; A = 00
E5C0: C9       [53]             RET
                        
E5C1: 3A4410   [13]     DODEL:  LD      A,(NULFLG)      ; Get null flag status
E5C4: B7       [17]             OR      A               ; Is it zero?
E5C5: 3E00     [24]             LD      A,0             ; Zero A - Leave flags
E5C7: 324410   [37]             LD      (NULFLG),A      ; Zero null flag
E5CA: C2D5E5   [47|47]          JP      NZ,ECHDEL       ; Set - Echo it
E5CD: 05       [51]             DEC     B               ; Decrement length
E5CE: CAF2E5   [61|61]          JP      Z,GETLIN        ; Get line again if empty
E5D1: CD9BE6   [78]             CALL    OUTC            ; Output null character
E5D4: 3E                        DB      3EH             ; Skip "DEC B"
E5D5: 05       [ 4]     ECHDEL: DEC     B               ; Count bytes in buffer
E5D6: 2B       [10]             DEC     HL              ; Back space buffer
E5D7: CAE9E5   [20|20]          JP      Z,OTKLN         ; No buffer - Try again
E5DA: 7E       [27]             LD      A,(HL)          ; Get deleted byte
E5DB: CD9BE6   [44]             CALL    OUTC            ; Echo it
E5DE: C310E6   [54]             JP      MORINP          ; Get more input
                        
E5E1: 05       [ 4]     DELCHR: DEC     B               ; Count bytes in buffer
E5E2: 2B       [10]             DEC     HL              ; Back space buffer
E5E3: CD9BE6   [27]             CALL    OUTC            ; Output character in A
E5E6: C210E6   [37|37]          JP      NZ,MORINP       ; Not end - Get more
E5E9: CD9BE6   [17]     OTKLN:  CALL    OUTC            ; Output character in A
E5EC: CD81EB   [17]     KILIN:  CALL    PRNTCR          ; Output CRLF
E5EF: C307E6   [27]             JP      TTYLIN          ; Get line again
                        
E5F2: CD6DFE   [17]     GETLIN: CALL    MONTST          ; Is it NAS-SYS?
E5F5: CA07E6   [27|27]          JP      Z,TTYLIN        ; No - Character input
E5F8: 2A750C   [43]             LD      HL,(CIN)        ; Point to NAS-SYS input table
E5FB: 7E       [50]             LD      A,(HL)          ; Get input mode
E5FC: FE74     [57]             CP      74H             ; Is it "X" mode?
E5FE: CA07E6   [67|67]          JP      Z,TTYLIN        ; Yes - Teletype line input
E601: CDE8FE   [84]             CALL    INLINE          ; Get a line from NAS-SYS
E604: C386EB   [94]             JP      DONULL          ; POS(X)=0 and do nulls
                        
E607: 216110   [10]     TTYLIN: LD      HL,BUFFER       ; Get a line by character
E60A: 0601     [17]             LD      B,1             ; Set buffer as empty
E60C: AF       [21]             XOR     A
E60D: 324410   [34]             LD      (NULFLG),A      ; Clear null flag
E610: CDCCE6   [17]     MORINP: CALL    CLOTST          ; Get character and test ^O
E613: 4F       [21]             LD      C,A             ; Save character in C
E614: FE7F     [28]             CP      DEL             ; Delete character?
E616: CAC1E5   [38|38]          JP      Z,DODEL         ; Yes - Process it
E619: 3A4410   [51]             LD      A,(NULFLG)      ; Get null flag
E61C: B7       [55]             OR      A               ; Test null flag status
E61D: CA29E6   [65|65]          JP      Z,PROCES        ; Reset - Process character
E620: 3E00     [72]             LD      A,0             ; Set a null
E622: CD9BE6   [89]             CALL    OUTC            ; Output null
E625: AF       [93]             XOR     A               ; Clear A
E626: 324410   [106]            LD      (NULFLG),A      ; Reset null flag
E629: 79       [ 4]     PROCES: LD      A,C             ; Get character
E62A: FE07     [11]             CP      CTRLG           ; Bell?
E62C: CA6DE6   [21|21]          JP      Z,PUTCTL        ; Yes - Save it
E62F: FE03     [28]             CP      CTRLC           ; Is it control "C"?
E631: CC81EB   [38|45]          CALL    Z,PRNTCR        ; Yes - Output CRLF
E634: 37       [42]             SCF                     ; Flag break
E635: C8       [47|53]          RET     Z               ; Return if control "C"
E636: FE0D     [54]             CP      CR              ; Is it enter?
E638: CA7CEB   [64|64]          JP      Z,ENDINP        ; Yes - Terminate input
E63B: FE15     [71]             CP      CTRLU           ; Is it control "U"?
E63D: CAECE5   [81|81]          JP      Z,KILIN         ; Yes - Get another line
E640: FE40     [88]             CP      "@"             ; Is it "kill line"?
E642: CAE9E5   [98|98]          JP      Z,OTKLN         ; Yes - Kill line
E645: FE5F     [105]            CP      "_"             ; Is it delete?
E647: CAE1E5   [115|115]        JP      Z,DELCHR        ; Yes - Delete character
E64A: FE08     [122]            CP      BKSP            ; Is it backspace?
E64C: CAE1E5   [132|132]        JP      Z,DELCHR        ; Yes - Delete character
E64F: FE12     [139]            CP      CTRLR           ; Is it control "R"?
E651: C268E6   [149|149]        JP      NZ,PUTBUF       ; No - Put in buffer
E654: C5       [160]            PUSH    BC              ; Save buffer length
E655: D5       [171]            PUSH    DE              ; Save DE
E656: E5       [182]            PUSH    HL              ; Save buffer address
E657: 3600     [192]            LD      (HL),0          ; Mark end of buffer
E659: CDF4FF   [209]            CALL    OUTNCR          ; Output and do CRLF
E65C: 216110   [219]            LD      HL,BUFFER       ; Point to buffer start
E65F: CD10F2   [236]            CALL    PRS             ; Output buffer
E662: E1       [246]            POP     HL              ; Restore buffer address
E663: D1       [256]            POP     DE              ; Restore DE
E664: C1       [266]            POP     BC              ; Restore buffer length
E665: C310E6   [276]            JP      MORINP          ; Get another character
                        
E668: FE20     [ 7]     PUTBUF: CP      " "             ; Is it a control code?
E66A: DA10E6   [17|17]          JP      C,MORINP        ; Yes - Ignore
E66D: 78       [ 4]     PUTCTL: LD      A,B             ; Get number of bytes in buffer
E66E: FE49     [11]             CP      72+1            ; Test for line overflow
E670: 3E07     [18]             LD      A,CTRLG         ; Set a bell
E672: D282E6   [28|28]          JP      NC,OUTNBS       ; Ring bell if buffer full
E675: 79       [32]             LD      A,C             ; Get character
E676: 71       [39]             LD      (HL),C          ; Save in buffer
E677: 32CC10   [52]             LD      (LSTBIN),A      ; Save last input byte
E67A: 23       [58]             INC     HL              ; Move up buffer
E67B: 04       [62]             INC     B               ; Increment length
E67C: CD9BE6   [17]     OUTIT:  CALL    OUTC            ; Output the character entered
E67F: C310E6   [27]             JP      MORINP          ; Get another character
                        
E682: CD9BE6   [17]     OUTNBS: CALL    OUTC            ; Output bell and back over it
E685: 3E08     [24]             LD      A,BKSP          ; Set back space
E687: C37CE6   [34]             JP      OUTIT           ; Output it and get more
                        
E68A: 7C       [ 4]     CPDEHL: LD      A,H             ; Get H
E68B: 92       [ 8]             SUB     D               ; Compare with D
E68C: C0       [13|19]          RET     NZ              ; Different - Exit
E68D: 7D       [17]             LD      A,L             ; Get L
E68E: 93       [21]             SUB     E               ; Compare with E
E68F: C9       [31]             RET                     ; Return status
                        
E690: 7E       [ 7]     CHKSYN: LD      A,(HL)          ; Check syntax of character
E691: E3       [26]             EX      (SP),HL         ; Address of test byte
E692: BE       [33]             CP      (HL)            ; Same as in code string?
E693: 23       [39]             INC     HL              ; Return address
E694: E3       [58]             EX      (SP),HL         ; Put it back
E695: CA36E8   [68|68]          JP      Z,GETCHR        ; Yes - Get next character
E698: C3ADE3   [78]             JP      SNERR           ; Different - ?SN Error
                        
E69B: F5       [11]     OUTC:   PUSH    AF              ; Save character
E69C: 3A4510   [24]             LD      A,(CTLOFG)      ; Get control "O" flag
E69F: B7       [28]             OR      A               ; Is it set?
E6A0: C245F2   [38|38]          JP      NZ,POPAF        ; Yes - don't output
E6A3: F1       [48]             POP     AF              ; Restore character
E6A4: C5       [59]             PUSH    BC              ; Save buffer length
E6A5: F5       [70]             PUSH    AF              ; Save character
E6A6: FE20     [77]             CP      " "             ; Is it a control code?
E6A8: DABFE6   [87|87]          JP      C,DINPOS        ; Yes - Don't INC POS(X)
E6AB: 3A4210   [100]            LD      A,(LWIDTH)      ; Get line width
E6AE: 47       [104]            LD      B,A             ; To B
E6AF: 3AAB10   [117]            LD      A,(CURPOS)      ; Get cursor position
E6B2: 04       [121]            INC     B               ; Width 255?
E6B3: CABBE6   [131|131]        JP      Z,INCLEN        ; Yes - No width limit
E6B6: 05       [135]            DEC     B               ; Restore width
E6B7: B8       [139]            CP      B               ; At end of line?
E6B8: CC81EB   [149|156]        CALL    Z,PRNTCR        ; Yes - output CRLF
E6BB: 3C       [ 4]     INCLEN: INC     A               ; Move on one character
E6BC: 32AB10   [17]             LD      (CURPOS),A      ; Save new position
E6BF: F1       [10]     DINPOS: POP     AF              ; Restore character
E6C0: C1       [20]             POP     BC              ; Restore buffer length
E6C1: F5       [31]             PUSH    AF              ; << This sequence >>
E6C2: F1       [41]             POP     AF              ; << is not needed >>
E6C3: F5       [52]             PUSH    AF              ; Save character
E6C4: C5       [63]             PUSH    BC              ; Save buffer length
E6C5: 4F       [67]             LD      C,A             ; Character to C
E6C6: CDD9FC   [84]             CALL    CONMON          ; Send it
E6C9: C1       [94]             POP     BC              ; Restore buffer length
E6CA: F1       [104]            POP     AF              ; Restore character
E6CB: C9       [114]            RET
                        
E6CC: CD05FD   [17]     CLOTST: CALL    GETINP          ; Get input character
E6CF: E67F     [24]             AND     01111111B       ; Strip bit 7
E6D1: FE0F     [31]             CP      CTRLO           ; Is it control "O"?
E6D3: C0       [36|42]          RET     NZ              ; No don't flip flag
E6D4: 3A4510   [49]             LD      A,(CTLOFG)      ; Get flag
E6D7: 2F       [53]             CPL                     ; Flip it
E6D8: 324510   [66]             LD      (CTLOFG),A      ; Put it back
E6DB: AF       [70]             XOR     A               ; Null character
E6DC: C9       [80]             RET
                        
E6DD: CDA5E9   [17]     LIST:   CALL    ATOH            ; ASCII number to DE
E6E0: C0       [22|28]          RET     NZ              ; Return if anything extra
E6E1: C1       [32]             POP     BC              ; Rubbish - Not needed
E6E2: CD99E4   [49]             CALL    SRCHLN          ; Search for line number in DE
E6E5: C5       [60]             PUSH    BC              ; Save address of line
E6E6: CD33E7   [77]             CALL    SETLIN          ; Set up lines counter
E6E9: E1       [10]     LISTLP: POP     HL              ; Restore address of line
E6EA: 4E       [17]             LD      C,(HL)          ; Get LSB of next line
E6EB: 23       [23]             INC     HL
E6EC: 46       [30]             LD      B,(HL)          ; Get MSB of next line
E6ED: 23       [36]             INC     HL
E6EE: 78       [40]             LD      A,B             ; BC = 0 (End of program)?
E6EF: B1       [44]             OR      C
E6F0: CAF8E3   [54|54]          JP      Z,PRNTOK        ; Yes - Go to command mode
E6F3: CD46E7   [71]             CALL    COUNT           ; Count lines
E6F6: CD61E8   [88]             CALL    TSTBRK          ; Test for break key
E6F9: C5       [99]             PUSH    BC              ; Save address of next line
E6FA: CD81EB   [116]            CALL    PRNTCR          ; Output CRLF
E6FD: 5E       [123]            LD      E,(HL)          ; Get LSB of line number
E6FE: 23       [129]            INC     HL
E6FF: 56       [136]            LD      D,(HL)          ; Get MSB of line number
E700: 23       [142]            INC     HL
E701: E5       [153]            PUSH    HL              ; Save address of line start
E702: EB       [157]            EX      DE,HL           ; Line number to HL
E703: CDADF9   [174]            CALL    PRNTHL          ; Output line number in decimal
E706: 3E20     [181]            LD      A," "           ; Space after line number
E708: E1       [191]            POP     HL              ; Restore start of line address
E709: CD9BE6   [17]     LSTLP2: CALL    OUTC            ; Output character in A
E70C: 7E       [ 7]     LSTLP3: LD      A,(HL)          ; Get next byte in line
E70D: B7       [11]             OR      A               ; End of line?
E70E: 23       [17]             INC     HL              ; To next byte in line
E70F: CAE9E6   [27|27]          JP      Z,LISTLP        ; Yes - get next line
E712: F209E7   [37|37]          JP      P,LSTLP2        ; No token - output it
E715: D67F     [44]             SUB     ZEND-1          ; Find and output word
E717: 4F       [48]             LD      C,A             ; Token offset+1 to C
E718: 1143E1   [58]             LD      DE,WORDS        ; Reserved word list
E71B: 1A       [ 7]     FNDTOK: LD      A,(DE)          ; Get character in list
E71C: 13       [13]             INC     DE              ; Move on to next
E71D: B7       [17]             OR      A               ; Is it start of word?
E71E: F21BE7   [27|27]          JP      P,FNDTOK        ; No - Keep looking for word
E721: 0D       [31]             DEC     C               ; Count words
E722: C21BE7   [41|41]          JP      NZ,FNDTOK       ; Not there - keep looking
E725: E67F     [ 7]     OUTWRD: AND     01111111B       ; Strip bit 7
E727: CD9BE6   [24]             CALL    OUTC            ; Output first character
E72A: 1A       [31]             LD      A,(DE)          ; Get next character
E72B: 13       [37]             INC     DE              ; Move on to next
E72C: B7       [41]             OR      A               ; Is it end of word?
E72D: F225E7   [51|51]          JP      P,OUTWRD        ; No - output the rest
E730: C30CE7   [61]             JP      LSTLP3          ; Next byte in line
                        
E733: E5       [11]     SETLIN: PUSH    HL              ; Set up LINES counter
E734: 2A4810   [27]             LD      HL,(LINESN)     ; Get LINES number
E737: 224610   [43]             LD      (LINESC),HL     ; Save in LINES counter
E73A: E1       [53]             POP     HL
E73B: C9       [63]             RET
                        
E73C: 21DEFE   [10]     LDNMI1: LD      HL,BREAK        ; Break routine
E73F: 227E0C   [26]             LD      (NMI),HL        ; NMI forces break
E742: C3F8E3   [36]             JP      PRNTOK          ; Go to command mode
                        
E745: FE                        DB      0FEH            ; <<< NO REFERENCE TO HERE >>>
                        
E746: E5       [11]     COUNT:  PUSH    HL              ; Save code string address
E747: D5       [22]             PUSH    DE
E748: 2A4610   [38]             LD      HL,(LINESC)     ; Get LINES counter
E74B: 11FFFF   [48]             LD      DE,-1
E74E: ED5A     [63]             ADC     HL,DE           ; Decrement
E750: 224610   [79]             LD      (LINESC),HL     ; Put it back
E753: D1       [89]             POP     DE
E754: E1       [99]             POP     HL              ; Restore code string address
E755: F0       [104|110]        RET     P               ; Return if more lines to go
E756: E5       [115]            PUSH    HL              ; Save code string address
E757: 2A4810   [131]            LD      HL,(LINESN)     ; Get LINES number
E75A: 224610   [147]            LD      (LINESC),HL     ; Reset LINES counter
E75D: 3A4C10   [160]            LD      A,(NMIFLG)      ; Break by NMI?
E760: B7       [164]            OR      A
E761: C2E5FE   [174|174]        JP      NZ,ARETN        ; Yes - "RETN"
E764: CD05FD   [191]            CALL    GETINP          ; Get input character
E767: FE03     [198]            CP      CTRLC           ; Is it control "C"?
E769: CA70E7   [208|208]        JP      Z,RSLNBK        ; Yes - Reset LINES an break
E76C: E1       [218]            POP     HL              ; Restore code string address
E76D: C346E7   [228]            JP      COUNT           ; Keep on counting
                        
E770: 2A4810   [16]     RSLNBK: LD      HL,(LINESN)     ; Get LINES number
E773: 224610   [32]             LD      (LINESC),HL     ; Reset LINES counter
E776: C3B1E0   [42]             JP      BRKRET          ; Go and output "Break"
                        
E779: 3E64     [ 7]     FOR:    LD      A,64H           ; Flag "FOR" assignment
E77B: 32CB10   [20]             LD      (FORFLG),A      ; Save "FOR" flag
E77E: CD87EA   [37]             CALL    LET             ; Set up initial index
E781: C1       [47]             POP     BC              ; Drop RETurn address
E782: E5       [58]             PUSH    HL              ; Save code string address
E783: CD70EA   [75]             CALL    DATA            ; Get next statement address
E786: 22C710   [91]             LD      (LOOPST),HL     ; Save it for start of lo6p
E789: 210200   [101]            LD      HL,2            ; Offset for "FOR" block
E78C: 39       [112]            ADD     HL,SP           ; Point to it
E78D: CD5AE3   [17]     FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
E790: D1       [27]             POP     DE              ; Get code string address
E791: C2A9E7   [37|37]          JP      NZ,FORFND       ; No nesting found
E794: 09       [48]             ADD     HL,BC           ; Move into "FOR" block
E795: D5       [59]             PUSH    DE              ; Save code string address
E796: 2B       [65]             DEC     HL
E797: 56       [72]             LD      D,(HL)          ; Get MSB of loop statement
E798: 2B       [78]             DEC     HL
E799: 5E       [85]             LD      E,(HL)          ; Get LSB of loop statement
E79A: 23       [91]             INC     HL
E79B: 23       [97]             INC     HL
E79C: E5       [108]            PUSH    HL              ; Save block address
E79D: 2AC710   [124]            LD      HL,(LOOPST)     ; Get address of loop statement
E7A0: CD8AE6   [141]            CALL    CPDEHL          ; Compare the FOR loops
E7A3: E1       [151]            POP     HL              ; Restore block address
E7A4: C28DE7   [161|161]        JP      NZ,FORSLP       ; Different FORs - Find another
E7A7: D1       [171]            POP     DE              ; Restore code string address
E7A8: F9       [177]            LD      SP,HL           ; Remove all nested loops
                        
E7A9: EB       [ 4]     FORFND: EX      DE,HL           ; Code string address to HL
E7AA: 0E08     [11]             LD      C,8
E7AC: CD8AE3   [28]             CALL    CHKSTK          ; Check for 8 levels of stack
E7AF: E5       [39]             PUSH    HL              ; Save code string address
E7B0: 2AC710   [55]             LD      HL,(LOOPST)     ; Get first statement of loop
E7B3: E3       [74]             EX      (SP),HL         ; Save and restore code string
E7B4: E5       [85]             PUSH    HL              ; Re-save code string address
E7B5: 2A5C10   [101]            LD      HL,(LINEAT)     ; Get current line number
E7B8: E3       [120]            EX      (SP),HL         ; Save and restore code string
E7B9: CD44ED   [137]            CALL    TSTNUM          ; Make sure it's a number
E7BC: CD90E6   [154]            CALL    CHKSYN          ; Make sure "TO" is next
E7BF: A6                        DB      ZTO             ; "TO" token
E7C0: CD41ED   [171]            CALL    GETNUM          ; Get "TO" expression value
E7C3: E5       [182]            PUSH    HL              ; Save code string address
E7C4: CD5FF8   [199]            CALL    BCDEFP          ; Move "TO" value to BCDE
E7C7: E1       [209]            POP     HL              ; Restore code string address
E7C8: C5       [220]            PUSH    BC              ; Save "TO" value in block
E7C9: D5       [231]            PUSH    DE
E7CA: 010081   [241]            LD      BC,8100H        ; BCDE - 1 (default STEP)
E7CD: 51       [245]            LD      D,C             ; C=0
E7CE: 5A       [249]            LD      E,D             ; D=0
E7CF: 7E       [256]            LD      A,(HL)          ; Get next byte in code string
E7D0: FEAB     [263]            CP      ZSTEP           ; See if "STEP" is stated
E7D2: 3E01     [270]            LD      A,1             ; Sign of step = 1
E7D4: C2E5E7   [280|280]        JP      NZ,SAVSTP       ; No STEP given - Default to 1
E7D7: CD36E8   [297]            CALL    GETCHR          ; Jump over "STEP" token
E7DA: CD41ED   [314]            CALL    GETNUM          ; Get step value
E7DD: E5       [325]            PUSH    HL              ; Save code string address
E7DE: CD5FF8   [342]            CALL    BCDEFP          ; Move STEP to BCDE
E7E1: CD13F8   [359]            CALL    TSTSGN          ; Test sign of FPREG
E7E4: E1       [369]            POP     HL              ; Restore code string address
E7E5: C5       [11]     SAVSTP: PUSH    BC              ; Save the STEP value in block
E7E6: D5       [22]             PUSH    DE
E7E7: F5       [33]             PUSH    AF              ; Save sign of STEP
E7E8: 33       [39]             INC     SP              ; Don't save flags
E7E9: E5       [50]             PUSH    HL              ; Save code string address
E7EA: 2ACE10   [66]             LD      HL,(BRKLIN)     ; Get address of index variable
E7ED: E3       [85]             EX      (SP),HL         ; Save and restore code string
E7EE: 0681     [ 7]     PUTFID: LD      B,ZFOR          ; "FOR" block marker
E7F0: C5       [18]             PUSH    BC              ; Save it
E7F1: 33       [24]             INC     SP              ; Don't save C
                        
E7F2: CD40FD   [17]     RUNCNT: CALL    CHKBRK          ; Execution driver - Test break
E7F5: B7       [21]             OR      A               ; Break key hit?
E7F6: C466E8   [31|38]          CALL    NZ,STALL        ; Yes - Pause for a key
E7F9: 22CE10   [47]             LD      (BRKLIN),HL     ; Save code address for break
E7FC: 7E       [54]             LD      A,(HL)          ; Get next byte in code string
E7FD: FE3A     [61]             CP      ":"             ; Multi statement line?
E7FF: CA16E8   [71|71]          JP      Z,EXCUTE        ; Yes - Execute it
E802: B7       [75]             OR      A               ; End of line?
E803: C2ADE3   [85|85]          JP      NZ,SNERR        ; No - Syntax error
E806: 23       [91]             INC     HL              ; Point to address of next line
E807: 7E       [98]             LD      A,(HL)          ; Get LSB of line pointer
E808: 23       [104]            INC     HL
E809: B6       [111]            OR      (HL)            ; Is it zero (End of prog)?
E80A: CA7AE8   [121|121]        JP      Z,ENDPRG        ; Yes - Terminate execution
E80D: 23       [127]            INC     HL              ; Point to line number
E80E: 5E       [134]            LD      E,(HL)          ; Get LSB of line number
E80F: 23       [140]            INC     HL
E810: 56       [147]            LD      D,(HL)          ; Get MSB of line number
E811: EB       [151]            EX      DE,HL           ; Line number to HL
E812: 225C10   [167]            LD      (LINEAT),HL     ; Save as current line number
E815: EB       [171]            EX      DE,HL           ; Line number back to DE
E816: CD36E8   [17]     EXCUTE: CALL    GETCHR          ; Get key word
E819: 11F2E7   [27]             LD      DE,RUNCNT       ; Where to RETurn to
E81C: D5       [38]             PUSH    DE              ; Save for RETurn
E81D: C8       [ 5|11]  IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
E81E: D680     [ 7]     ONJMP:  SUB     ZEND            ; Is it a token?
E820: DA87EA   [17|17]          JP      C,LET           ; No - try to assign it
E823: FE25     [24]             CP      ZNEW+1-ZEND     ; END to NEW ?
E825: D2ADE3   [34|34]          JP      NC,SNERR        ; Not a key word - ?SN Error
E828: 07       [38]             RLCA                    ; Double it
E829: 4F       [42]             LD      C,A             ; BC = Offset into table
E82A: 0600     [49]             LD      B,0
E82C: EB       [53]             EX      DE,HL           ; Save code string address
E82D: 215AE2   [63]             LD      HL,WORDTB       ; Keyword address table
E830: 09       [74]             ADD     HL,BC           ; Point to routine address
E831: 4E       [81]             LD      C,(HL)          ; Get LSB of routine address
E832: 23       [87]             INC     HL
E833: 46       [94]             LD      B,(HL)          ; Get MSB of routine address
E834: C5       [105]            PUSH    BC              ; Save routine address
E835: EB       [109]            EX      DE,HL           ; Restore code string address
                        
E836: 23       [ 6]     GETCHR: INC     HL              ; Point to next character
E837: 7E       [13]             LD      A,(HL)          ; Get next code string byte
E838: FE3A     [20]             CP      ":"             ; Z if ":"
E83A: D0       [25|31]          RET     NC              ; NC if > "9"
E83B: FE20     [32]             CP      " "
E83D: CA36E8   [42|42]          JP      Z,GETCHR        ; Skip over spaces
E840: FE30     [49]             CP      "0"
E842: 3F       [53]             CCF                     ; NC if < "0"
E843: 3C       [57]             INC     A               ; Test for zero - Leave carry
E844: 3D       [61]             DEC     A               ; Z if Null
E845: C9       [71]             RET
                        
E846: EB       [ 4]     RESTOR: EX      DE,HL           ; Save code string address
E847: 2A5E10   [20]             LD      HL,(BASTXT)     ; Point to start of program
E84A: CA5BE8   [30|30]          JP      Z,RESTNL        ; Just RESTORE - reset pointer
E84D: EB       [34]             EX      DE,HL           ; Restore code string address
E84E: CDA5E9   [51]             CALL    ATOH            ; Get line number to DE
E851: E5       [62]             PUSH    HL              ; Save code string address
E852: CD99E4   [79]             CALL    SRCHLN          ; Search for line number in DE
E855: 60       [83]             LD      H,B             ; HL = Address of line
E856: 69       [87]             LD      L,C
E857: D1       [97]             POP     DE              ; Restore code string address
E858: D246EA   [107|107]        JP      NC,ULERR        ; ?UL Error if not found
E85B: 2B       [ 6]     RESTNL: DEC     HL              ; Byte before DATA statement
E85C: 22DC10   [16]     UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
E85F: EB       [20]             EX      DE,HL           ; Restore code string address
E860: C9       [30]             RET
                        
E861: CD40FD   [17]     TSTBRK: CALL    CHKBRK          ; Test for interrupts
E864: B7       [21]             OR      A
E865: C8       [26|32]          RET     Z               ; Return if no key pressed
E866: CDCCE6   [17]     STALL:  CALL    CLOTST          ; Get input and test for ^O
E869: FE13     [24]             CP      CTRLS           ; Is it control "S"
E86B: CCCCE6   [34|41]          CALL    Z,CLOTST        ; Yes - Get another character
E86E: FE03     [41]             CP      CTRLC           ; Return if not control "C"
E870: C0       [ 5|11]  STOP:   RET     NZ              ; Exit if anything else
E871: F6                        DB      0F6H            ; Flag "STOP"
E872: C0       [ 5|11]  PEND:   RET     NZ              ; Exit if anything else
E873: 22CE10   [21]             LD      (BRKLIN),HL     ; Save point of break
E876: 21                        DB      21H             ; Skip "OR 11111111B"
E877: F6FF     [ 7]     INPBRK: OR      11111111B       ; Flag "Break" wanted
E879: C1       [17]             POP     BC              ; Return not needed and more
E87A: 2A5C10   [16]     ENDPRG: LD      HL,(LINEAT)     ; Get current line number
E87D: F5       [27]             PUSH    AF              ; Save STOP / END status
E87E: 7D       [31]             LD      A,L             ; Is it direct break?
E87F: A4       [35]             AND     H
E880: 3C       [39]             INC     A               ; Line is -1 if direct break
E881: CA8DE8   [49|49]          JP      Z,NOLIN         ; Yes - No line number
E884: 22D210   [65]             LD      (ERRLIN),HL     ; Save line of break
E887: 2ACE10   [81]             LD      HL,(BRKLIN)     ; Get point of break
E88A: 22D410   [97]             LD      (CONTAD),HL     ; Save point to CONTinue
E88D: AF       [ 4]     NOLIN:  XOR     A
E88E: 324510   [17]             LD      (CTLOFG),A      ; Enable output
E891: CD74EB   [34]             CALL    STTLIN          ; Start a new line
E894: F1       [44]             POP     AF              ; Restore STOP / END status
E895: 2150E3   [54]             LD      HL,BRKMSG       ; "Break" message
E898: C2E1E3   [64|64]          JP      NZ,ERRIN        ; "in line" wanted?
E89B: C3F8E3   [74]             JP      PRNTOK          ; Go to command mode
                        
E89E: 2AD410   [16]     CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
E8A1: 7C       [20]             LD      A,H             ; Is it zero?
E8A2: B5       [24]             OR      L
E8A3: 1E20     [31]             LD      E,CN            ; ?CN Error
E8A5: CAC1E3   [41|41]          JP      Z,ERROR         ; Yes - output "?CN Error"
E8A8: EB       [45]             EX      DE,HL           ; Save code string address
E8A9: 2AD210   [61]             LD      HL,(ERRLIN)     ; Get line of last break
E8AC: 225C10   [77]             LD      (LINEAT),HL     ; Set up current line number
E8AF: EB       [81]             EX      DE,HL           ; Restore code string address
E8B0: C9       [91]             RET                     ; CONTinue where left off
                        
E8B1: CD84F4   [17]     NULL:   CALL    GETINT          ; Get integer 0-255
E8B4: C0       [22|28]          RET     NZ              ; Return if bad value
E8B5: 324110   [35]             LD      (NULLS),A       ; Set nulls number
E8B8: C9       [45]             RET
                        
E8B9: 06FF     [ 7]     ARRLD1: LD      B,-1            ; Flag array load
E8BB: CD36E8   [17]     ARRSV1: CALL    GETCHR          ; Skip "*"
E8BE: 78       [21]             LD      A,B             ; CLOAD* or CSAVE*
E8BF: 32CE10   [34]             LD      (BRKLIN),A      ; Save it
E8C2: 3E01     [41]             LD      A,1             ; It's an array
E8C4: 32CB10   [54]             LD      (FORFLG),A      ; Flag array name
E8C7: CD2DEF   [71]             CALL    GETVAR          ; Get address of array name
E8CA: E5       [82]             PUSH    HL              ; Save code string address
E8CB: 32CB10   [95]             LD      (FORFLG),A      ; Clear flag
E8CE: 60       [99]             LD      H,B             ; Address of array to HL
E8CF: 69       [103]            LD      L,C
E8D0: 0B       [109]            DEC     BC              ; Back space
E8D1: 0B       [115]            DEC     BC              ;  to point
E8D2: 0B       [121]            DEC     BC              ;  to the
E8D3: 0B       [127]            DEC     BC              ; array name
E8D4: 3ACE10   [140]            LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
E8D7: B7       [144]            OR      A
E8D8: F5       [155]            PUSH    AF              ; Save CLOAD* / CSAVE* status
E8D9: EB       [159]            EX      DE,HL           ; Array data length
E8DA: 19       [170]            ADD     HL,DE           ; End of data
E8DB: EB       [174]            EX      DE,HL           ; To DE
E8DC: 4E       [181]            LD      C,(HL)          ; Get dimension bytes
E8DD: 0600     [188]            LD      B,0
E8DF: 09       [199]            ADD     HL,BC           ; 2 Bytes each dimension
E8E0: 09       [210]            ADD     HL,BC
E8E1: 23       [216]            INC     HL              ; Over number of dimensions
E8E2: E5       [227]            PUSH    HL              ; Address of array data
E8E3: D5       [238]            PUSH    DE              ; End of array data
E8E4: C5       [249]            PUSH    BC              ; Number of dimensions
E8E5: 3ACE10   [262]            LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
E8E8: FEFF     [269]            CP      -1
E8EA: CCD5FC   [279|286]        CALL    Z,CASFF         ; CLOAD* - Cassette on
E8ED: 3ACE10   [292]            LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
E8F0: FEFF     [299]            CP      -1
E8F2: C4C8FC   [309|316]        CALL    NZ,CASFFW       ; CSAVE* - Cassette on and wait
E8F5: 00       [313]            NOP
E8F6: 00       [317]            NOP
E8F7: 00       [321]            NOP
E8F8: 210000   [331]            LD      HL,0
E8FB: 224A10   [347]            LD      (CHKSUM),HL     ; Zero check sum
E8FE: C1       [357]            POP     BC              ; Number of dimensions
E8FF: D1       [367]            POP     DE              ; End of array data
E900: E1       [377]            POP     HL              ; Address of array data
E901: 06D2     [384]            LD      B,11010010B     ; Header byte
E903: C3D6FF   [394]            JP      JPLDSV          ; CSAVE-SNDHDR , CLOAD-GETHDR
                        
E906: 78       [ 4]     SNDHDR: LD      A,B             ; Get header byte
E907: CDB7F4   [21]             CALL    WUART2          ; Send 2 bytes to UART
E90A: CDB7F4   [38]             CALL    WUART2          ; Send 2 bytes to UART
E90D: C31DE9   [48]             JP      SNDARY          ; Send array data
                        
E910: 0E04     [ 7]     GETHDR: LD      C,4             ; 4 Bytes to check
E912: CDB4F4   [17]     HDRLP:  CALL    RUART           ; Read byte from UART
E915: B8       [21]             CP      B               ; Same as header?
E916: C210E9   [31|31]          JP      NZ,GETHDR       ; No - Wait for another
E919: 0D       [35]             DEC     C               ; Count bytes
E91A: C212E9   [45|45]          JP      NZ,HDRLP        ; More needed
E91D: CD44ED   [17]     SNDARY: CALL    TSTNUM          ; Check it's a numerical array
E920: CD8AE6   [17]     ARYLP:  CALL    CPDEHL          ; All array data done
E923: CA37E9   [27|27]          JP      Z,SUMOFF        ; Yes - Do check sum
E926: F1       [37]             POP     AF              ; CLOAD* or CSAVE* ?
E927: F5       [48]             PUSH    AF              ; Re-save flags
E928: 7E       [55]             LD      A,(HL)          ; Get byte
E929: F4BAF4   [65|72]          CALL    P,WUART         ; CSAVE* - Write byte
E92C: FCB4F4   [75|82]          CALL    M,RUART         ; CLOAD* - Read byte
E92F: 77       [82]             LD      (HL),A          ; Save byte in case of CLOAD*
E930: CD40E9   [99]             CALL    ACCSUM          ; Accumulate check sum
E933: 23       [105]            INC     HL              ; Next byte
E934: C320E9   [115]            JP      ARYLP           ; Repeat
                        
E937: CD4DE9   [17]     SUMOFF: CALL    DOSUM           ; Do check sum
E93A: CDD5FC   [34]             CALL    CASFF           ; Cassette off
E93D: F1       [44]             POP     AF              ; Not needed any more
E93E: E1       [54]             POP     HL              ; Restore code string address
E93F: C9       [64]             RET
                        
E940: E5       [11]     ACCSUM: PUSH    HL              ; Save address in array
E941: 2A4A10   [27]             LD      HL,(CHKSUM)     ; Get check sum
E944: 0600     [34]             LD      B,0             ; BC - Value of byte
E946: 4F       [38]             LD      C,A
E947: 09       [49]             ADD     HL,BC           ; Add byte to check sum
E948: 224A10   [65]             LD      (CHKSUM),HL     ; Re-save check sum
E94B: E1       [75]             POP     HL              ; Restore address in array
E94C: C9       [85]             RET
                        
E94D: 3ACE10   [13]     DOSUM:  LD      A,(BRKLIN)      ; CLOAD* or CSAVE* ?
E950: B7       [17]             OR      A
E951: FA60E9   [27|27]          JP      M,CHSUMS        ; CLOAD* - Check if sums match
E954: 3A4A10   [40]             LD      A,(CHKSUM)      ; Get LSB of check sum
E957: CDBAF4   [57]             CALL    WUART           ; Write to UART
E95A: 3A4B10   [70]             LD      A,(CHKSUM+1)    ; Get MSB of check sum
E95D: C3BAF4   [80]             JP      WUART           ; Write to UART and return
                        
E960: CDB4F4   [17]     CHSUMS: CALL    RUART           ; Read LSB of check sum
E963: F5       [28]             PUSH    AF              ; Save it
E964: CDB4F4   [45]             CALL    RUART           ; Read MSB of check sum
E967: C1       [55]             POP     BC              ; LSB to B
E968: 58       [59]             LD      E,B             ; LSB to E
E969: 57       [63]             LD      D,A             ; MSB to D
E96A: 2A4A10   [79]             LD      HL,(CHKSUM)     ; Get accumulated check sum
E96D: CD8AE6   [96]             CALL    CPDEHL          ; Are they the same?
E970: C8       [101|107]        RET     Z               ; Yes - End CLOAD*
E971: CDD5FC   [118]            CALL    CASFF           ; Cassette off
E974: C36BF5   [128]            JP      OUTBAD          ; Different - Output "Bad"
                        
E977: 7E       [ 7]     CHKLTR: LD      A,(HL)          ; Get byte
E978: FE41     [14]             CP      "A"             ; < "A" ?
E97A: D8       [19|25]          RET     C               ; Carry set if not letter
E97B: FE5B     [26]             CP      "Z"+1           ; > "Z" ?
E97D: 3F       [30]             CCF
E97E: C9       [40]             RET                     ; Carry set if not letter
                        
E97F: CD36E8   [17]     FPSINT: CALL    GETCHR          ; Get next character
E982: CD41ED   [17]     POSINT: CALL    GETNUM          ; Get integer 0 to 32767
E985: CD13F8   [17]     DEPINT: CALL    TSTSGN          ; Test sign of FPREG
E988: FAA0E9   [27|27]          JP      M,FCERR         ; Negative - ?FC Error
E98B: 3AE710   [13]     DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
E98E: FE90     [20]             CP      80H+16          ; Exponent in range (16 bits)?
E990: DABBF8   [30|30]          JP      C,FPINT         ; Yes - convert it
E993: 018090   [40]             LD      BC,9080H        ; BCDE = -32768
E996: 110000   [50]             LD      DE,0000
E999: E5       [61]             PUSH    HL              ; Save code string address
E99A: CD8EF8   [78]             CALL    CMPNUM          ; Compare FPREG with BCDE
E99D: E1       [88]             POP     HL              ; Restore code string address
E99E: 51       [92]             LD      D,C             ; MSB to D
E99F: C8       [97|103]         RET     Z               ; Return if in range
E9A0: 1E08     [ 7]     FCERR:  LD      E,FC            ; ?FC Error
E9A2: C3C1E3   [17]             JP      ERROR           ; Output error-
                        
E9A5: 2B       [ 6]     ATOH:   DEC     HL              ; ASCII number to DE binary
E9A6: 110000   [10]     GETLN:  LD      DE,0            ; Get number to DE
E9A9: CD36E8   [17]     GTLNLP: CALL    GETCHR          ; Get next character
E9AC: D0       [22|28]          RET     NC              ; Exit if not a digit
E9AD: E5       [33]             PUSH    HL              ; Save code string address
E9AE: F5       [44]             PUSH    AF              ; Save digit
E9AF: 219819   [54]             LD      HL,65529/10     ; Largest number 65529
E9B2: CD8AE6   [71]             CALL    CPDEHL          ; Number in range?
E9B5: DAADE3   [81|81]          JP      C,SNERR         ; No - ?SN Error
E9B8: 62       [85]             LD      H,D             ; HL = Number
E9B9: 6B       [89]             LD      L,E
E9BA: 19       [100]            ADD     HL,DE           ; Times 2
E9BB: 29       [111]            ADD     HL,HL           ; Times 4
E9BC: 19       [122]            ADD     HL,DE           ; Times 5
E9BD: 29       [133]            ADD     HL,HL           ; Times 10
E9BE: F1       [143]            POP     AF              ; Restore digit
E9BF: D630     [150]            SUB     "0"             ; Make it 0 to 9
E9C1: 5F       [154]            LD      E,A             ; DE = Value of digit
E9C2: 1600     [161]            LD      D,0
E9C4: 19       [172]            ADD     HL,DE           ; Add to number
E9C5: EB       [176]            EX      DE,HL           ; Number to DE
E9C6: E1       [186]            POP     HL              ; Restore code string address
E9C7: C3A9E9   [196]            JP      GTLNLP          ; Go to next character
                        
E9CA: CAC9E4   [10|10]  CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
E9CD: CD82E9   [27]             CALL    POSINT          ; Get integer 0 to 32767 to DE
E9D0: 2B       [33]             DEC     HL              ; Cancel increment
E9D1: CD36E8   [50]             CALL    GETCHR          ; Get next character
E9D4: E5       [61]             PUSH    HL              ; Save code string address
E9D5: 2AAF10   [77]             LD      HL,(LSTRAM)     ; Get end of RAM
E9D8: CAEDE9   [87|87]          JP      Z,STORED        ; No value given - Use stored
E9DB: E1       [97]             POP     HL              ; Restore code string address
E9DC: CD90E6   [114]            CALL    CHKSYN          ; Check for comma
E9DF: 2C                        DB      ","
E9E0: D5       [125]            PUSH    DE              ; Save number
E9E1: CD82E9   [142]            CALL    POSINT          ; Get integer 0 to 32767
E9E4: 2B       [148]            DEC     HL              ; Cancel increment
E9E5: CD36E8   [165]            CALL    GETCHR          ; Get next character
E9E8: C2ADE3   [175|175]        JP      NZ,SNERR        ; ?SN Error if more on line
E9EB: E3       [194]            EX      (SP),HL         ; Save code string address
E9EC: EB       [198]            EX      DE,HL           ; Number to DE
E9ED: 7D       [ 4]     STORED: LD      A,L             ; Get LSB of new RAM top
E9EE: 93       [ 8]             SUB     E               ; Subtract LSB of string space
E9EF: 5F       [12]             LD      E,A             ; Save LSB
E9F0: 7C       [16]             LD      A,H             ; Get MSB of new RAM top
E9F1: 9A       [20]             SBC     A,D             ; Subtract MSB of string space
E9F2: 57       [24]             LD      D,A             ; Save MSB
E9F3: DAA2E3   [34|34]          JP      C,OMERR         ; ?OM Error if not enough mem
E9F6: E5       [45]             PUSH    HL              ; Save RAM top
E9F7: 2AD610   [61]             LD      HL,(PROGND)     ; Get program end
E9FA: 012800   [71]             LD      BC,40           ; 40 Bytes minimum working RAM
E9FD: 09       [82]             ADD     HL,BC           ; Get lowest address
E9FE: CD8AE6   [99]             CALL    CPDEHL          ; Enough memory?
EA01: D2A2E3   [109|109]        JP      NC,OMERR        ; No - ?OM Error
EA04: EB       [113]            EX      DE,HL           ; RAM top to HL
EA05: 225A10   [129]            LD      (STRSPC),HL     ; Set new string space
EA08: E1       [139]            POP     HL              ; End of memory to use
EA09: 22AF10   [155]            LD      (LSTRAM),HL     ; Set new top of RAM
EA0C: E1       [165]            POP     HL              ; Restore code string address
EA0D: C3C9E4   [175]            JP      INTVAR          ; Initialise variables
                        
EA10: CAC5E4   [10|10]  RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
EA13: CDC9E4   [27]             CALL    INTVAR          ; Initialise variables
EA16: 01F2E7   [37]             LD      BC,RUNCNT       ; Execution driver loop
EA19: C32CEA   [47]             JP      RUNLIN          ; RUN from line number
                        
EA1C: 0E03     [ 7]     GOSUB:  LD      C,3             ; 3 Levels of stack needed
EA1E: CD8AE3   [24]             CALL    CHKSTK          ; Check for 3 levels of stack
EA21: C1       [34]             POP     BC              ; Get return address
EA22: E5       [45]             PUSH    HL              ; Save code string for RETURN
EA23: E5       [56]             PUSH    HL              ; And for GOSUB routine
EA24: 2A5C10   [72]             LD      HL,(LINEAT)     ; Get current line
EA27: E3       [91]             EX      (SP),HL         ; Into stack - Code string out
EA28: 3E8C     [98]             LD      A,ZGOSUB        ; "GOSUB" token
EA2A: F5       [109]            PUSH    AF              ; Save token
EA2B: 33       [115]            INC     SP              ; Don't save flags
                        
EA2C: C5       [11]     RUNLIN: PUSH    BC              ; Save return address
EA2D: CDA5E9   [17]     GOTO:   CALL    ATOH            ; ASCII number to DE binary
EA30: CD72EA   [34]             CALL    REM             ; Get end of line
EA33: E5       [45]             PUSH    HL              ; Save end of line
EA34: 2A5C10   [61]             LD      HL,(LINEAT)     ; Get current line
EA37: CD8AE6   [78]             CALL    CPDEHL          ; Line after current?
EA3A: E1       [88]             POP     HL              ; Restore end of line
EA3B: 23       [94]             INC     HL              ; Start of next line
EA3C: DC9CE4   [104|111]        CALL    C,SRCHLP        ; Line is after current line
EA3F: D499E4   [114|121]        CALL    NC,SRCHLN       ; Line is before current line
EA42: 60       [118]            LD      H,B             ; Set up code string address
EA43: 69       [122]            LD      L,C
EA44: 2B       [128]            DEC     HL              ; Incremented after
EA45: D8       [133|139]        RET     C               ; Line found
EA46: 1E0E     [ 7]     ULERR:  LD      E,UL            ; ?UL Error
EA48: C3C1E3   [17]             JP      ERROR           ; Output error message
                        
EA4B: C0       [ 5|11]  RETURN: RET     NZ              ; Return if not just RETURN
EA4C: 16FF     [12]             LD      D,-1            ; Flag "GOSUB" search
EA4E: CD56E3   [29]             CALL    BAKSTK          ; Look "GOSUB" block
EA51: F9       [35]             LD      SP,HL           ; Kill all FORs in subroutine
EA52: FE8C     [42]             CP      ZGOSUB          ; Test for "GOSUB" token
EA54: 1E04     [49]             LD      E,RG            ; ?RG Error
EA56: C2C1E3   [59|59]          JP      NZ,ERROR        ; Error if no "GOSUB" found
EA59: E1       [69]             POP     HL              ; Get RETURN line number
EA5A: 225C10   [85]             LD      (LINEAT),HL     ; Save as current
EA5D: 23       [91]             INC     HL              ; Was it from direct statement?
EA5E: 7C       [95]             LD      A,H
EA5F: B5       [99]             OR      L               ; Return to line
EA60: C26AEA   [109|109]        JP      NZ,RETLIN       ; No - Return to line
EA63: 3ACC10   [122]            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
EA66: B7       [126]            OR      A               ; If so buffer is corrupted
EA67: C2F7E3   [136|136]        JP      NZ,POPNOK       ; Yes - Go to command mode
EA6A: 21F2E7   [10]     RETLIN: LD      HL,RUNCNT       ; Execution driver loop
EA6D: E3       [29]             EX      (SP),HL         ; Into stack - Code string out
EA6E: 3E                        DB      3EH             ; Skip "POP HL"
EA6F: E1       [10]     NXTDTA: POP     HL              ; Restore code string address
                        
EA70: 013A              DATA:   DB      01H,3AH         ; ":" End of statement
EA72: 0E00     [ 7]     REM:    LD      C,0             ; 00  End of statement
EA74: 0600     [14]             LD      B,0
EA76: 79       [ 4]     NXTSTL: LD      A,C             ; Statement and byte
EA77: 48       [ 8]             LD      C,B
EA78: 47       [12]             LD      B,A             ; Statement end byte
EA79: 7E       [ 7]     NXTSTT: LD      A,(HL)          ; Get byte
EA7A: B7       [11]             OR      A               ; End of line?
EA7B: C8       [16|22]          RET     Z               ; Yes - Exit
EA7C: B8       [20]             CP      B               ; End of statement?
EA7D: C8       [25|31]          RET     Z               ; Yes - Exit
EA7E: 23       [31]             INC     HL              ; Next byte
EA7F: FE22     [38]             CP      '"'             ; Literal string?
EA81: CA76EA   [48|48]          JP      Z,NXTSTL        ; Yes - Look for another '"'
EA84: C379EA   [58]             JP      NXTSTT          ; Keep looking
                        
EA87: CD2DEF   [17]     LET:    CALL    GETVAR          ; Get variable name
EA8A: CD90E6   [34]             CALL    CHKSYN          ; Make sure "=" follows
EA8D: B4                        DB      ZEQUAL          ; "=" token
EA8E: D5       [45]             PUSH    DE              ; Save address of variable
EA8F: 3AAD10   [58]             LD      A,(TYPE)        ; Get data type
EA92: F5       [69]             PUSH    AF              ; Save type
EA93: CD5AED   [86]             CALL    EVAL            ; Evaluate expression
EA96: F1       [96]             POP     AF              ; Restore type
EA97: E3       [115]            EX      (SP),HL         ; Save code - Get var addr
EA98: 22CE10   [131]            LD      (BRKLIN),HL     ; Save address of variable
EA9B: 1F       [135]            RRA                     ; Adjust type
EA9C: CD46ED   [152]            CALL    CHKTYP          ; Check types are the same
EA9F: CADAEA   [162|162]        JP      Z,LETNUM        ; Numeric - Move value
EAA2: E5       [11]     LETSTR: PUSH    HL              ; Save address of string var
EAA3: 2AE410   [27]             LD      HL,(FPREG)      ; Pointer to string entry
EAA6: E5       [38]             PUSH    HL              ; Save it on stack
EAA7: 23       [44]             INC     HL              ; Skip over length
EAA8: 23       [50]             INC     HL
EAA9: 5E       [57]             LD      E,(HL)          ; LSB of string address
EAAA: 23       [63]             INC     HL
EAAB: 56       [70]             LD      D,(HL)          ; MSB of string address
EAAC: 2A5E10   [86]             LD      HL,(BASTXT)     ; Point to start of program
EAAF: CD8AE6   [103]            CALL    CPDEHL          ; Is string before program?
EAB2: D2C9EA   [113|113]        JP      NC,CRESTR       ; Yes - Create string entry
EAB5: 2A5A10   [129]            LD      HL,(STRSPC)     ; Point to string space
EAB8: CD8AE6   [146]            CALL    CPDEHL          ; Is string literal in program?
EABB: D1       [156]            POP     DE              ; Restore address of string
EABC: D2D1EA   [166|166]        JP      NC,MVSTPT       ; Yes - Set up pointer
EABF: 21BF10   [176]            LD      HL,TMPSTR       ; Temporary string pool
EAC2: CD8AE6   [193]            CALL    CPDEHL          ; Is string in temporary pool?
EAC5: D2D1EA   [203|203]        JP      NC,MVSTPT       ; No - Set up pointer
EAC8: 3E                        DB      3EH             ; Skip "POP DE"
EAC9: D1       [10]     CRESTR: POP     DE              ; Restore address of string
EACA: CD71F3   [27]             CALL    BAKTMP          ; Back to last tmp-str entry
EACD: EB       [31]             EX      DE,HL           ; Address of string entry
EACE: CDAAF1   [48]             CALL    SAVSTR          ; Save string in string area
EAD1: CD71F3   [17]     MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
EAD4: E1       [27]             POP     HL              ; Get string pointer
EAD5: CD6EF8   [44]             CALL    DETHL4          ; Move string pointer to var
EAD8: E1       [54]             POP     HL              ; Restore code string address
EAD9: C9       [64]             RET
                        
EADA: E5       [11]     LETNUM: PUSH    HL              ; Save address of variable
EADB: CD6BF8   [28]             CALL    FPTHL           ; Move value to variable
EADE: D1       [38]             POP     DE              ; Restore address of variable
EADF: E1       [48]             POP     HL              ; Restore code string address
EAE0: C9       [58]             RET
                        
EAE1: CD84F4   [17]     ON:     CALL    GETINT          ; Get integer 0-255
EAE4: 7E       [24]             LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
EAE5: 47       [28]             LD      B,A             ; Save in B
EAE6: FE8C     [35]             CP      ZGOSUB          ; "GOSUB" token?
EAE8: CAF0EA   [45|45]          JP      Z,ONGO          ; Yes - Find line number
EAEB: CD90E6   [62]             CALL    CHKSYN          ; Make sure it's "GOTO"
EAEE: 88                        DB      ZGOTO           ; "GOTO" token
EAEF: 2B       [68]             DEC     HL              ; Cancel increment
EAF0: 4B       [ 4]     ONGO:   LD      C,E             ; Integer of branch value
EAF1: 0D       [ 4]     ONGOLP: DEC     C               ; Count branches
EAF2: 78       [ 8]             LD      A,B             ; Get "GOTO" or "GOSUB" token
EAF3: CA1EE8   [18|18]          JP      Z,ONJMP         ; Go to that line if right one
EAF6: CDA6E9   [35]             CALL    GETLN           ; Get line number to DE
EAF9: FE2C     [42]             CP      ","             ; Another line number?
EAFB: C0       [47|53]          RET     NZ              ; No - Drop through
EAFC: C3F1EA   [57]             JP      ONGOLP          ; Yes - loop
                        
EAFF: CD5AED   [17]     IF:     CALL    EVAL            ; Evaluate expression
EB02: 7E       [24]             LD      A,(HL)          ; Get token
EB03: FE88     [31]             CP      ZGOTO           ; "GOTO" token?
EB05: CA0DEB   [41|41]          JP      Z,IFGO          ; Yes - Get line
EB08: CD90E6   [58]             CALL    CHKSYN          ; Make sure it's "THEN"
EB0B: A9                        DB      ZTHEN           ; "THEN" token
EB0C: 2B       [64]             DEC     HL              ; Cancel increment
EB0D: CD44ED   [17]     IFGO:   CALL    TSTNUM          ; Make sure it's numeric
EB10: CD13F8   [34]             CALL    TSTSGN          ; Test state of expression
EB13: CA72EA   [44|44]          JP      Z,REM           ; False - Drop through
EB16: CD36E8   [61]             CALL    GETCHR          ; Get next character
EB19: DA2DEA   [71|71]          JP      C,GOTO          ; Number - GOTO that line
EB1C: C31DE8   [81]             JP      IFJMP           ; Otherwise do statement
                        
EB1F: 2B       [ 6]     MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
EB20: CD36E8   [23]             CALL    GETCHR          ; Get next character
EB23: CA81EB   [10|10]  PRINT:  JP      Z,PRNTCR        ; CRLF if just PRINT
EB26: C8       [ 5|11]  PRNTLP: RET     Z               ; End of list - Exit
EB27: FEA5     [12]             CP      ZTAB            ; "TAB(" token?
EB29: CAAFEB   [22|22]          JP      Z,DOTAB         ; Yes - Do TAB routine
EB2C: FEA8     [29]             CP      ZSPC            ; "SPC(" token?
EB2E: CAAFEB   [39|39]          JP      Z,DOTAB         ; Yes - Do SPC routine
EB31: E5       [50]             PUSH    HL              ; Save code string address
EB32: FE2C     [57]             CP      ","             ; Comma?
EB34: CA98EB   [67|67]          JP      Z,DOCOM         ; Yes - Move to next zone
EB37: FE3B     [74]             CP      ";"             ; Semi-colon?
EB39: CAD2EB   [84|84]          JP      Z,NEXITM        ; Do semi-colon routine
EB3C: C1       [94]             POP     BC              ; Code string address to BC
EB3D: CD5AED   [111]            CALL    EVAL            ; Evaluate expression
EB40: E5       [122]            PUSH    HL              ; Save code string address
EB41: 3AAD10   [135]            LD      A,(TYPE)        ; Get variable type
EB44: B7       [139]            OR      A               ; Is it a string variable?
EB45: C26DEB   [149|149]        JP      NZ,PRNTST       ; Yes - Output string contents
EB48: CDB8F9   [166]            CALL    NUMASC          ; Convert number to text
EB4B: CDCEF1   [183]            CALL    CRTST           ; Create temporary string
EB4E: 3620     [193]            LD      (HL)," "        ; Followed by a space
EB50: 2AE410   [209]            LD      HL,(FPREG)      ; Get length of output
EB53: 34       [220]            INC     (HL)            ; Plus 1 for the space
EB54: 2AE410   [236]            LD      HL,(FPREG)      ; < Not needed >
EB57: 3A4210   [249]            LD      A,(LWIDTH)      ; Get width of line
EB5A: 47       [253]            LD      B,A             ; To B
EB5B: 04       [257]            INC     B               ; Width 255 (No limit)?
EB5C: CA69EB   [267|267]        JP      Z,PRNTNB        ; Yes - Output number string
EB5F: 04       [271]            INC     B               ; Adjust it
EB60: 3AAB10   [284]            LD      A,(CURPOS)      ; Get cursor position
EB63: 86       [291]            ADD     A,(HL)          ; Add length of string
EB64: 3D       [295]            DEC     A               ; Adjust it
EB65: B8       [299]            CP      B               ; Will output fit on this line?
EB66: D481EB   [309|316]        CALL    NC,PRNTCR       ; No - CRLF first
EB69: CD13F2   [17]     PRNTNB: CALL    PRS1            ; Output string at (HL)
EB6C: AF       [21]             XOR     A               ; Skip CALL by setting "Z" flag
EB6D: C413F2   [10|17]  PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
EB70: E1       [20]             POP     HL              ; Restore code string address
EB71: C31FEB   [30]             JP      MRPRNT          ; See if more to PRINT
                        
EB74: 3AAB10   [13]     STTLIN: LD      A,(CURPOS)      ; Make sure on new line
EB77: B7       [17]             OR      A               ; Already at start?
EB78: C8       [22|28]          RET     Z               ; Yes - Do nothing
EB79: C381EB   [32]             JP      PRNTCR          ; Start a new line
                        
EB7C: 3600     [10]     ENDINP: LD      (HL),0          ; Mark end of buffer
EB7E: 216010   [20]             LD      HL,BUFFER-1     ; Point to buffer
EB81: 3E0D     [ 7]     PRNTCR: LD      A,CR            ; Load a CR
EB83: CD9BE6   [24]             CALL    OUTC            ; Output character
EB86: AF       [ 4]     DONULL: XOR     A               ; Set to position 0
EB87: 32AB10   [17]             LD      (CURPOS),A      ; Store it
EB8A: 3A4110   [30]             LD      A,(NULLS)       ; Get number of nulls
EB8D: 3D       [ 4]     NULLP:  DEC     A               ; Count them
EB8E: C8       [ 9|15]          RET     Z               ; Return if done
EB8F: F5       [20]             PUSH    AF              ; Save count
EB90: AF       [24]             XOR     A               ; Load a null
EB91: CD9BE6   [41]             CALL    OUTC            ; Output it
EB94: F1       [51]             POP     AF              ; Restore count
EB95: C38DEB   [61]             JP      NULLP           ; Keep counting
                        
EB98: 3A4310   [13]     DOCOM:  LD      A,(COMMAN)      ; Get comma width
EB9B: 47       [17]             LD      B,A             ; Save in B
EB9C: 3AAB10   [30]             LD      A,(CURPOS)      ; Get current position
EB9F: B8       [34]             CP      B               ; Within the limit?
EBA0: D481EB   [44|51]          CALL    NC,PRNTCR       ; No - output CRLF
EBA3: D2D2EB   [54|54]          JP      NC,NEXITM       ; Get next item
EBA6: D60E     [ 7]     ZONELP: SUB     14              ; Next zone of 14 characters
EBA8: D2A6EB   [17|17]          JP      NC,ZONELP       ; Repeat if more zones
EBAB: 2F       [21]             CPL                     ; Number of spaces to output
EBAC: C3C7EB   [31]             JP      ASPCS           ; Output them
                        
EBAF: F5       [11]     DOTAB:  PUSH    AF              ; Save token
EBB0: CD81F4   [28]             CALL    FNDNUM          ; Evaluate expression
EBB3: CD90E6   [45]             CALL    CHKSYN          ; Make sure ")" follows
EBB6: 29                        DB      ")"
EBB7: 2B       [51]             DEC     HL              ; Back space on to ")"
EBB8: F1       [61]             POP     AF              ; Restore token
EBB9: D6A8     [68]             SUB     ZSPC            ; Was it "SPC(" ?
EBBB: E5       [79]             PUSH    HL              ; Save code string address
EBBC: CAC2EB   [89|89]          JP      Z,DOSPC         ; Yes - Do "E" spaces
EBBF: 3AAB10   [102]            LD      A,(CURPOS)      ; Get current position
EBC2: 2F       [ 4]     DOSPC:  CPL                     ; Number of spaces to print to
EBC3: 83       [ 8]             ADD     A,E             ; Total number to print
EBC4: D2D2EB   [18|18]          JP      NC,NEXITM       ; TAB < Current POS(X)
EBC7: 3C       [ 4]     ASPCS:  INC     A               ; Output A spaces
EBC8: 47       [ 8]             LD      B,A             ; Save number to print
EBC9: 3E20     [15]             LD      A," "           ; Space
EBCB: CD9BE6   [17]     SPCLP:  CALL    OUTC            ; Output character in A
EBCE: 05       [21]             DEC     B               ; Count them
EBCF: C2CBEB   [31|31]          JP      NZ,SPCLP        ; Repeat if more
EBD2: E1       [10]     NEXITM: POP     HL              ; Restore code string address
EBD3: CD36E8   [27]             CALL    GETCHR          ; Get next character
EBD6: C326EB   [37]             JP      PRNTLP          ; More to print
                        
EBD9: 3F526564          REDO:   DB      "?Redo from start",CR,LF,0
EBDD: 6F206672          
EBE1: 6F6D2073          
EBE5: 74617274          
EBE9: 0D0A00            
                        
EBEC: 3ACD10   [13]     BADINP: LD      A,(READFG)      ; READ or INPUT?
EBEF: B7       [17]             OR      A
EBF0: C2A7E3   [27|27]          JP      NZ,DATSNR       ; READ - ?SN Error
EBF3: C1       [37]             POP     BC              ; Throw away code string addr
EBF4: 21D9EB   [47]             LD      HL,REDO         ; "Redo from start" message
EBF7: CD10F2   [64]             CALL    PRS             ; Output string
EBFA: C3F8E4   [74]             JP      DOAGN           ; Do last INPUT again
                        
EBFD: CD7BF1   [17]     INPUT:  CALL    IDTEST          ; Test for illegal direct
EC00: 7E       [24]             LD      A,(HL)          ; Get character after "INPUT"
EC01: FE22     [31]             CP      '"'             ; Is there a prompt string?
EC03: 3E00     [38]             LD      A,0             ; Clear A and leave flags
EC05: 324510   [51]             LD      (CTLOFG),A      ; Enable output
EC08: C217EC   [61|61]          JP      NZ,NOPMPT       ; No prompt - get input
EC0B: CDCFF1   [78]             CALL    QTSTR           ; Get string terminated by '"'
EC0E: CD90E6   [95]             CALL    CHKSYN          ; Check for ";" after prompt
EC11: 3B                        DB      ";"
EC12: E5       [106]            PUSH    HL              ; Save code string address
EC13: CD13F2   [123]            CALL    PRS1            ; Output prompt string
EC16: 3E                        DB      3EH             ; Skip "PUSH HL"
EC17: E5       [11]     NOPMPT: PUSH    HL              ; Save code string address
EC18: CDFCE4   [28]             CALL    PROMPT          ; Get input with "? " prompt
EC1B: C1       [38]             POP     BC              ; Restore code string address
EC1C: DA77E8   [48|48]          JP      C,INPBRK        ; Break pressed - Exit
EC1F: 23       [54]             INC     HL              ; Next byte
EC20: 7E       [61]             LD      A,(HL)          ; Get it
EC21: B7       [65]             OR      A               ; End of line?
EC22: 2B       [71]             DEC     HL              ; Back again
EC23: C5       [82]             PUSH    BC              ; Re-save code string address
EC24: CA6FEA   [92|92]          JP      Z,NXTDTA        ; Yes - Find next DATA stmt
EC27: 362C     [102]            LD      (HL),","        ; Store comma as separator
EC29: C331EC   [112]            JP      NXTITM          ; Get next item
                        
EC2C: E5       [11]     READ:   PUSH    HL              ; Save code string address
EC2D: 2ADC10   [27]             LD      HL,(NXTDAT)     ; Next DATA statement
EC30: F6                        DB      0F6H            ; Flag "READ"
EC31: AF       [ 4]     NXTITM: XOR     A               ; Flag "INPUT"
EC32: 32CD10   [17]             LD      (READFG),A      ; Save "READ"/"INPUT" flag
EC35: E3       [36]             EX      (SP),HL         ; Get code str' , Save pointer
EC36: C33DEC   [46]             JP      GTVLUS          ; Get values
                        
EC39: CD90E6   [17]     NEDMOR: CALL    CHKSYN          ; Check for comma between items
EC3C: 2C                        DB      ","
EC3D: CD2DEF   [17]     GTVLUS: CALL    GETVAR          ; Get variable name
EC40: E3       [36]             EX      (SP),HL         ; Save code str" , Get pointer
EC41: D5       [47]             PUSH    DE              ; Save variable address
EC42: 7E       [54]             LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
EC43: FE2C     [61]             CP      ","             ; Comma?
EC45: CA65EC   [71|71]          JP      Z,ANTVLU        ; Yes - Get another value
EC48: 3ACD10   [84]             LD      A,(READFG)      ; Is it READ?
EC4B: B7       [88]             OR      A
EC4C: C2D2EC   [98|98]          JP      NZ,FDTLP        ; Yes - Find next DATA stmt
EC4F: 3E3F     [105]            LD      A,"?"           ; More INPUT needed
EC51: CD9BE6   [122]            CALL    OUTC            ; Output character
EC54: CDFCE4   [139]            CALL    PROMPT          ; Get INPUT with prompt
EC57: D1       [149]            POP     DE              ; Variable address
EC58: C1       [159]            POP     BC              ; Code string address
EC59: DA77E8   [169|169]        JP      C,INPBRK        ; Break pressed
EC5C: 23       [175]            INC     HL              ; Point to next DATA byte
EC5D: 7E       [182]            LD      A,(HL)          ; Get byte
EC5E: B7       [186]            OR      A               ; Is it zero (No input) ?
EC5F: 2B       [192]            DEC     HL              ; Back space INPUT pointer
EC60: C5       [203]            PUSH    BC              ; Save code string address
EC61: CA6FEA   [213|213]        JP      Z,NXTDTA        ; Find end of buffer
EC64: D5       [224]            PUSH    DE              ; Save variable address
EC65: 3AAD10   [13]     ANTVLU: LD      A,(TYPE)        ; Check data type
EC68: B7       [17]             OR      A               ; Is it numeric?
EC69: CA8FEC   [27|27]          JP      Z,INPBIN        ; Yes - Convert to binary
EC6C: CD36E8   [44]             CALL    GETCHR          ; Get next character
EC6F: 57       [48]             LD      D,A             ; Save input character
EC70: 47       [52]             LD      B,A             ; Again
EC71: FE22     [59]             CP      '"'             ; Start of literal sting?
EC73: CA83EC   [69|69]          JP      Z,STRENT        ; Yes - Create string entry
EC76: 3ACD10   [82]             LD      A,(READFG)      ; "READ" or "INPUT" ?
EC79: B7       [86]             OR      A
EC7A: 57       [90]             LD      D,A             ; Save 00 if "INPUT"
EC7B: CA80EC   [100|100]        JP      Z,ITMSEP        ; "INPUT" - End with 00
EC7E: 163A     [107]            LD      D,":"           ; "DATA" - End with 00 or ":"
EC80: 062C     [ 7]     ITMSEP: LD      B,","           ; Item separator
EC82: 2B       [13]             DEC     HL              ; Back space for DTSTR
EC83: CDD2F1   [17]     STRENT: CALL    DTSTR           ; Get string terminated by D
EC86: EB       [21]             EX      DE,HL           ; String address to DE
EC87: 219AEC   [31]             LD      HL,LTSTND       ; Where to go after LETSTR
EC8A: E3       [50]             EX      (SP),HL         ; Save HL , get input pointer
EC8B: D5       [61]             PUSH    DE              ; Save address of string
EC8C: C3A2EA   [71]             JP      LETSTR          ; Assign string to variable
                        
EC8F: CD36E8   [17]     INPBIN: CALL    GETCHR          ; Get next character
EC92: CD1AF9   [34]             CALL    ASCTFP          ; Convert ASCII to FP number
EC95: E3       [53]             EX      (SP),HL         ; Save input ptr, Get var addr
EC96: CD6BF8   [70]             CALL    FPTHL           ; Move FPREG to variable
EC99: E1       [80]             POP     HL              ; Restore input pointer
EC9A: 2B       [ 6]     LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
EC9B: CD36E8   [23]             CALL    GETCHR          ; Get next character
EC9E: CAA6EC   [33|33]          JP      Z,MORDT         ; End of line - More needed?
ECA1: FE2C     [40]             CP      ","             ; Another value?
ECA3: C2ECEB   [50|50]          JP      NZ,BADINP       ; No - Bad input
ECA6: E3       [19]     MORDT:  EX      (SP),HL         ; Get code string address
ECA7: 2B       [25]             DEC     HL              ; DEC 'cos GETCHR INCs
ECA8: CD36E8   [42]             CALL    GETCHR          ; Get next character
ECAB: C239EC   [52|52]          JP      NZ,NEDMOR       ; More needed - Get it
ECAE: D1       [62]             POP     DE              ; Restore DATA pointer
ECAF: 3ACD10   [75]             LD      A,(READFG)      ; "READ" or "INPUT" ?
ECB2: B7       [79]             OR      A
ECB3: EB       [83]             EX      DE,HL           ; DATA pointer to HL
ECB4: C25CE8   [93|93]          JP      NZ,UPDATA       ; Update DATA pointer if "READ"
ECB7: D5       [104]            PUSH    DE              ; Save code string address
ECB8: B6       [111]            OR      (HL)            ; More input given?
ECB9: 21C1EC   [121]            LD      HL,EXTIG        ; "?Extra ignored" message
ECBC: C410F2   [131|138]        CALL    NZ,PRS          ; Output string if extra given
ECBF: E1       [141]            POP     HL              ; Restore code string address
ECC0: C9       [151]            RET
                        
ECC1: 3F457874          EXTIG:  DB      "?Extra ignored",CR,LF,0
ECC5: 72612069          
ECC9: 676E6F72          
ECCD: 65640D0A          
ECD1: 00                
                        
ECD2: CD70EA   [17]     FDTLP:  CALL    DATA            ; Get next statement
ECD5: B7       [21]             OR      A               ; End of line?
ECD6: C2EBEC   [31|31]          JP      NZ,FANDT        ; No - See if DATA statement
ECD9: 23       [37]             INC     HL
ECDA: 7E       [44]             LD      A,(HL)          ; End of program?
ECDB: 23       [50]             INC     HL
ECDC: B6       [57]             OR      (HL)            ; 00 00 Ends program
ECDD: 1E06     [64]             LD      E,OD            ; ?OD Error
ECDF: CAC1E3   [74|74]          JP      Z,ERROR         ; Yes - Out of DATA
ECE2: 23       [80]             INC     HL
ECE3: 5E       [87]             LD      E,(HL)          ; LSB of line number
ECE4: 23       [93]             INC     HL
ECE5: 56       [100]            LD      D,(HL)          ; MSB of line number
ECE6: EB       [104]            EX      DE,HL
ECE7: 22C910   [120]            LD      (DATLIN),HL     ; Set line of current DATA item
ECEA: EB       [124]            EX      DE,HL
ECEB: CD36E8   [17]     FANDT:  CALL    GETCHR          ; Get next character
ECEE: FE83     [24]             CP      ZDATA           ; "DATA" token
ECF0: C2D2EC   [34|34]          JP      NZ,FDTLP        ; No "DATA" - Keep looking
ECF3: C365EC   [44]             JP      ANTVLU          ; Found - Convert input
                        
ECF6: 110000   [10]     NEXT:   LD      DE,0            ; In case no index given
ECF9: C42DEF   [10|17]  NEXT1:  CALL    NZ,GETVAR       ; Get index address
ECFC: 22CE10   [26]             LD      (BRKLIN),HL     ; Save code string address
ECFF: CD56E3   [43]             CALL    BAKSTK          ; Look for "FOR" block
ED02: C2B3E3   [53|53]          JP      NZ,NFERR        ; No "FOR" - ?NF Error
ED05: F9       [59]             LD      SP,HL           ; Clear nested loops
ED06: D5       [70]             PUSH    DE              ; Save index address
ED07: 7E       [77]             LD      A,(HL)          ; Get sign of STEP
ED08: 23       [83]             INC     HL
ED09: F5       [94]             PUSH    AF              ; Save sign of STEP
ED0A: D5       [105]            PUSH    DE              ; Save index address
ED0B: CD51F8   [122]            CALL    PHLTFP          ; Move index value to FPREG
ED0E: E3       [141]            EX      (SP),HL         ; Save address of TO value
ED0F: E5       [152]            PUSH    HL              ; Save address of index
ED10: CDBEF5   [169]            CALL    ADDPHL          ; Add STEP to index value
ED13: E1       [179]            POP     HL              ; Restore address of index
ED14: CD6BF8   [196]            CALL    FPTHL           ; Move value to index variable
ED17: E1       [206]            POP     HL              ; Restore address of TO value
ED18: CD62F8   [223]            CALL    LOADFP          ; Move TO value to BCDE
ED1B: E5       [234]            PUSH    HL              ; Save address of line of FOR
ED1C: CD8EF8   [251]            CALL    CMPNUM          ; Compare index with TO value
ED1F: E1       [261]            POP     HL              ; Restore address of line num
ED20: C1       [271]            POP     BC              ; Address of sign of STEP
ED21: 90       [275]            SUB     B               ; Compare with expected sign
ED22: CD62F8   [292]            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
ED25: CA31ED   [302|302]        JP      Z,KILFOR        ; Loop finished - Terminate it
ED28: EB       [306]            EX      DE,HL           ; Loop statement line number
ED29: 225C10   [322]            LD      (LINEAT),HL     ; Set loop line number
ED2C: 69       [326]            LD      L,C             ; Set code string to loop
ED2D: 60       [330]            LD      H,B
ED2E: C3EEE7   [340]            JP      PUTFID          ; Put back "FOR" and continue
                        
ED31: F9       [ 6]     KILFOR: LD      SP,HL           ; Remove "FOR" block
ED32: 2ACE10   [22]             LD      HL,(BRKLIN)     ; Code string after "NEXT"
ED35: 7E       [29]             LD      A,(HL)          ; Get next byte in code string
ED36: FE2C     [36]             CP      ","             ; More NEXTs ?
ED38: C2F2E7   [46|46]          JP      NZ,RUNCNT       ; No - Do next statement
ED3B: CD36E8   [63]             CALL    GETCHR          ; Position to index name
ED3E: CDF9EC   [80]             CALL    NEXT1           ; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        
ED41: CD5AED   [17]     GETNUM: CALL    EVAL            ; Get a numeric expression
ED44: F6                TSTNUM: DB      0F6H            ; Clear carry (numeric)
ED45: 37       [ 4]     TSTSTR: SCF                     ; Set carry (string)
ED46: 3AAD10   [13]     CHKTYP: LD      A,(TYPE)        ; Check types match
ED49: 8F       [17]             ADC     A,A             ; Expected + actual
ED4A: B7       [21]             OR      A               ; Clear carry , set parity
ED4B: E8       [26|32]          RET     PE              ; Even parity - Types match
ED4C: C3BFE3   [36]             JP      TMERR           ; Different types - Error
                        
                        ; <<< NO REFERENCE TO HERE >>>
                        
ED4F: CD90E6   [53]             CALL    CHKSYN          ; Make sure "=" follows
ED52: B4                        DB      ZEQUAL          ; "="
ED53: C35AED   [63]             JP      EVAL            ; Evaluate expression
                        
ED56: CD90E6   [17]     OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
ED59: 28                        DB      "("
ED5A: 2B       [ 6]     EVAL:   DEC     HL              ; Evaluate expression & save
ED5B: 1600     [13]             LD      D,0             ; Precedence value
ED5D: D5       [11]     EVAL1:  PUSH    DE              ; Save precedence
ED5E: 0E01     [18]             LD      C,1
ED60: CD8AE3   [35]             CALL    CHKSTK          ; Check for 1 level of stack
ED63: CDD1ED   [52]             CALL    OPRND           ; Get next expression value
ED66: 22D010   [16]     EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
ED69: 2AD010   [16]     EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
ED6C: C1       [26]             POP     BC              ; Precedence value and operator
ED6D: 78       [30]             LD      A,B             ; Get precedence value
ED6E: FE78     [37]             CP      78H             ; "AND" or "OR" ?
ED70: D444ED   [47|54]          CALL    NC,TSTNUM       ; No - Make sure it's a number
ED73: 7E       [54]             LD      A,(HL)          ; Get next operator / function
ED74: 1600     [61]             LD      D,0             ; Clear Last relation
ED76: D6B3     [ 7]     RLTLP:  SUB     ZGTR            ; ">" Token
ED78: DA92ED   [17|17]          JP      C,FOPRND        ; + - * / ^ AND OR - Test it
ED7B: FE03     [24]             CP      ZLTH+1-ZGTR     ; < = >
ED7D: D292ED   [34|34]          JP      NC,FOPRND       ; Function - Call it
ED80: FE01     [41]             CP      ZEQUAL-ZGTR     ; "="
ED82: 17       [45]             RLA                     ; <- Test for legal
ED83: AA       [49]             XOR     D               ; <- combinations of < = >
ED84: BA       [53]             CP      D               ; <- by combining last token
ED85: 57       [57]             LD      D,A             ; <- with current one
ED86: DAADE3   [67|67]          JP      C,SNERR         ; Error if "<<" "==" or ">>"
ED89: 22C510   [83]             LD      (CUROPR),HL     ; Save address of current token
ED8C: CD36E8   [100]            CALL    GETCHR          ; Get next character
ED8F: C376ED   [110]            JP      RLTLP           ; Treat the two as one
                        
ED92: 7A       [ 4]     FOPRND: LD      A,D             ; < = > found ?
ED93: B7       [ 8]             OR      A
ED94: C2A8EE   [18|18]          JP      NZ,TSTRED       ; Yes - Test for reduction
ED97: 7E       [25]             LD      A,(HL)          ; Get operator token
ED98: 22C510   [41]             LD      (CUROPR),HL     ; Save operator address
ED9B: D6AC     [48]             SUB     ZPLUS           ; Operator or function?
ED9D: D8       [53|59]          RET     C               ; Neither - Exit
ED9E: FE07     [60]             CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
EDA0: D0       [65|71]          RET     NC              ; No - Exit
EDA1: 5F       [69]             LD      E,A             ; Coded operator
EDA2: 3AAD10   [82]             LD      A,(TYPE)        ; Get data type
EDA5: 3D       [86]             DEC     A               ; FF = numeric , 00 = string
EDA6: B3       [90]             OR      E               ; Combine with coded operator
EDA7: 7B       [94]             LD      A,E             ; Get coded operator
EDA8: CA06F3   [104|104]        JP      Z,CONCAT        ; String concatenation
EDAB: 07       [108]            RLCA                    ; Times 2
EDAC: 83       [112]            ADD     A,E             ; Times 3
EDAD: 5F       [116]            LD      E,A             ; To DE (D is 0)
EDAE: 21A4E2   [126]            LD      HL,PRITAB       ; Precedence table
EDB1: 19       [137]            ADD     HL,DE           ; To the operator concerned
EDB2: 78       [141]            LD      A,B             ; Last operator precedence
EDB3: 56       [148]            LD      D,(HL)          ; Get evaluation precedence
EDB4: BA       [152]            CP      D               ; Compare with eval precedence
EDB5: D0       [157|163]        RET     NC              ; Exit if higher precedence
EDB6: 23       [163]            INC     HL              ; Point to routine address
EDB7: CD44ED   [180]            CALL    TSTNUM          ; Make sure it's a number
                        
EDBA: C5       [11]     STKTHS: PUSH    BC              ; Save last precedence & token
EDBB: 0169ED   [21]             LD      BC,EVAL3        ; Where to go on prec' break
EDBE: C5       [32]             PUSH    BC              ; Save on stack for return
EDBF: 43       [36]             LD      B,E             ; Save operator
EDC0: 4A       [40]             LD      C,D             ; Save precedence
EDC1: CD44F8   [57]             CALL    STAKFP          ; Move value to stack
EDC4: 58       [61]             LD      E,B             ; Restore operator
EDC5: 51       [65]             LD      D,C             ; Restore precedence
EDC6: 4E       [72]             LD      C,(HL)          ; Get LSB of routine address
EDC7: 23       [78]             INC     HL
EDC8: 46       [85]             LD      B,(HL)          ; Get MSB of routine address
EDC9: 23       [91]             INC     HL
EDCA: C5       [102]            PUSH    BC              ; Save routine address
EDCB: 2AC510   [118]            LD      HL,(CUROPR)     ; Address of current operator
EDCE: C35DED   [128]            JP      EVAL1           ; Loop until prec' break
                        
EDD1: AF       [ 4]     OPRND:  XOR     A               ; Get operand routine
EDD2: 32AD10   [17]             LD      (TYPE),A        ; Set numeric expected
EDD5: CD36E8   [34]             CALL    GETCHR          ; Get next character
EDD8: 1E24     [41]             LD      E,MO            ; ?MO Error
EDDA: CAC1E3   [51|51]          JP      Z,ERROR         ; No operand - Error
EDDD: DA1AF9   [61|61]          JP      C,ASCTFP        ; Number - Get value
EDE0: CD77E9   [78]             CALL    CHKLTR          ; See if a letter
EDE3: D222EE   [88|88]          JP      NC,CONVAR       ; Letter - Find variable
EDE6: FEAC     [95]             CP      ZPLUS           ; "+" Token ?
EDE8: CAD1ED   [105|105]        JP      Z,OPRND         ; Yes - Look for operand
EDEB: FE2E     [112]            CP      "."             ; "." ?
EDED: CA1AF9   [122|122]        JP      Z,ASCTFP        ; Yes - Create FP number
EDF0: FEAD     [129]            CP      ZMINUS          ; "-" Token ?
EDF2: CA11EE   [139|139]        JP      Z,MINUS         ; Yes - Do minus
EDF5: FE22     [146]            CP      '"'             ; Literal string ?
EDF7: CACFF1   [156|156]        JP      Z,QTSTR         ; Get string terminated by '"'
EDFA: FEAA     [163]            CP      ZNOT            ; "NOT" Token ?
EDFC: CA08EF   [173|173]        JP      Z,EVNOT         ; Yes - Eval NOT expression
EDFF: FEA7     [180]            CP      ZFN             ; "FN" Token ?
EE01: CA33F1   [190|190]        JP      Z,DOFN          ; Yes - Do FN routine
EE04: D6B6     [197]            SUB     ZSGN            ; Is it a function?
EE06: D233EE   [207|207]        JP      NC,FNOFST       ; Yes - Evaluate function
EE09: CD56ED   [17]     EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
EE0C: CD90E6   [34]             CALL    CHKSYN          ; Make sure ")" follows
EE0F: 29                        DB      ")"
EE10: C9       [44]             RET
                        
EE11: 167D     [ 7]     MINUS:  LD      D,7DH           ; "-" precedence
EE13: CD5DED   [24]             CALL    EVAL1           ; Evaluate until prec' break
EE16: 2AD010   [40]             LD      HL,(NXTOPR)     ; Get next operator address
EE19: E5       [51]             PUSH    HL              ; Save next operator address
EE1A: CD3CF8   [68]             CALL    INVSGN          ; Negate value
EE1D: CD44ED   [17]     RETNUM: CALL    TSTNUM          ; Make sure it's a number
EE20: E1       [27]             POP     HL              ; Restore next operator address
EE21: C9       [37]             RET
                        
EE22: CD2DEF   [17]     CONVAR: CALL    GETVAR          ; Get variable address to DE
EE25: E5       [11]     FRMEVL: PUSH    HL              ; Save code string address
EE26: EB       [15]             EX      DE,HL           ; Variable address to HL
EE27: 22E410   [31]             LD      (FPREG),HL      ; Save address of variable
EE2A: 3AAD10   [44]             LD      A,(TYPE)        ; Get type
EE2D: B7       [48]             OR      A               ; Numeric?
EE2E: CC51F8   [58|65]          CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
EE31: E1       [68]             POP     HL              ; Restore code string address
EE32: C9       [78]             RET
                        
EE33: 0600     [ 7]     FNOFST: LD      B,0             ; Get address of function
EE35: 07       [11]             RLCA                    ; Double function offset
EE36: 4F       [15]             LD      C,A             ; BC = Offset in function table
EE37: C5       [26]             PUSH    BC              ; Save adjusted token value
EE38: CD36E8   [43]             CALL    GETCHR          ; Get next character
EE3B: 79       [47]             LD      A,C             ; Get adjusted token value
EE3C: FE22     [54]             CP      2*(ZPOINT-ZSGN) ; Adjusted "POINT" token?
EE3E: CA79FF   [64|64]          JP      Z,POINTB        ; Yes - Do "POINT" (not POINTB)
EE41: FE2D     [71]             CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
EE43: DA5FEE   [81|81]          JP      C,FNVAL         ; No - Do function
EE46: CD56ED   [98]             CALL    OPNPAR          ; Evaluate expression  (X,...
EE49: CD90E6   [115]            CALL    CHKSYN          ; Make sure "," follows
EE4C: 2C                        DB      ","
EE4D: CD45ED   [132]            CALL    TSTSTR          ; Make sure it's a string
EE50: EB       [136]            EX      DE,HL           ; Save code string address
EE51: 2AE410   [152]            LD      HL,(FPREG)      ; Get address of string
EE54: E3       [171]            EX      (SP),HL         ; Save address of string
EE55: E5       [182]            PUSH    HL              ; Save adjusted token value
EE56: EB       [186]            EX      DE,HL           ; Restore code string address
EE57: CD84F4   [203]            CALL    GETINT          ; Get integer 0-255
EE5A: EB       [207]            EX      DE,HL           ; Save code string address
EE5B: E3       [226]            EX      (SP),HL         ; Save integer,HL = adj' token
EE5C: C367EE   [236]            JP      GOFUNC          ; Jump to string function
                        
EE5F: CD09EE   [17]     FNVAL:  CALL    EVLPAR          ; Evaluate expression
EE62: E3       [36]             EX      (SP),HL         ; HL = Adjusted token value
EE63: 111DEE   [46]             LD      DE,RETNUM       ; Return number from function
EE66: D5       [57]             PUSH    DE              ; Save on stack
EE67: 010FE1   [10]     GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
EE6A: 09       [21]             ADD     HL,BC           ; Point to right address
EE6B: 4E       [28]             LD      C,(HL)          ; Get LSB of address
EE6C: 23       [34]             INC     HL              ;
EE6D: 66       [41]             LD      H,(HL)          ; Get MSB of address
EE6E: 69       [45]             LD      L,C             ; Address to HL
EE6F: E9       [49]             JP      (HL)            ; Jump to function
                        
EE70: 15       [ 4]     SGNEXP: DEC     D               ; Dee to flag negative exponent
EE71: FEAD     [11]             CP      ZMINUS          ; "-" token ?
EE73: C8       [16|22]          RET     Z               ; Yes - Return
EE74: FE2D     [23]             CP      "-"             ; "-" ASCII ?
EE76: C8       [28|34]          RET     Z               ; Yes - Return
EE77: 14       [32]             INC     D               ; Inc to flag positive exponent
EE78: FE2B     [39]             CP      "+"             ; "+" ASCII ?
EE7A: C8       [44|50]          RET     Z               ; Yes - Return
EE7B: FEAC     [51]             CP      ZPLUS           ; "+" token ?
EE7D: C8       [56|62]          RET     Z               ; Yes - Return
EE7E: 2B       [62]             DEC     HL              ; DEC 'cos GETCHR INCs
EE7F: C9       [72]             RET                     ; Return "NZ"
                        
EE80: F6                POR:    DB      0F6H            ; Flag "OR"
EE81: AF       [ 4]     PAND:   XOR     A               ; Flag "AND"
EE82: F5       [15]             PUSH    AF              ; Save "AND" / "OR" flag
EE83: CD44ED   [32]             CALL    TSTNUM          ; Make sure it's a number
EE86: CD8BE9   [49]             CALL    DEINT           ; Get integer -32768 to 32767
EE89: F1       [59]             POP     AF              ; Restore "AND" / "OR" flag
EE8A: EB       [63]             EX      DE,HL           ; <- Get last
EE8B: C1       [73]             POP     BC              ; <-  value
EE8C: E3       [92]             EX      (SP),HL         ; <-  from
EE8D: EB       [96]             EX      DE,HL           ; <-  stack
EE8E: CD54F8   [113]            CALL    FPBCDE          ; Move last value to FPREG
EE91: F5       [124]            PUSH    AF              ; Save "AND" / "OR" flag
EE92: CD8BE9   [141]            CALL    DEINT           ; Get integer -32768 to 32767
EE95: F1       [151]            POP     AF              ; Restore "AND" / "OR" flag
EE96: C1       [161]            POP     BC              ; Get value
EE97: 79       [165]            LD      A,C             ; Get LSB
EE98: 21F1F0   [175]            LD      HL,ACPASS       ; Address of save AC as current
EE9B: C2A3EE   [185|185]        JP      NZ,POR1         ; Jump if OR
EE9E: A3       [189]            AND     E               ; "AND" LSBs
EE9F: 4F       [193]            LD      C,A             ; Save LSB
EEA0: 78       [197]            LD      A,B             ; Get MBS
EEA1: A2       [201]            AND     D               ; "AND" MSBs
EEA2: E9       [205]            JP      (HL)            ; Save AC as current (ACPASS)
                        
EEA3: B3       [ 4]     POR1:   OR      E               ; "OR" LSBs
EEA4: 4F       [ 8]             LD      C,A             ; Save LSB
EEA5: 78       [12]             LD      A,B             ; Get MSB
EEA6: B2       [16]             OR      D               ; "OR" MSBs
EEA7: E9       [20]             JP      (HL)            ; Save AC as current (ACPASS)
                        
EEA8: 21BAEE   [10]     TSTRED: LD      HL,CMPLOG       ; Logical compare routine
EEAB: 3AAD10   [23]             LD      A,(TYPE)        ; Get data type
EEAE: 1F       [27]             RRA                     ; Carry set = string
EEAF: 7A       [31]             LD      A,D             ; Get last precedence value
EEB0: 17       [35]             RLA                     ; Times 2 plus carry
EEB1: 5F       [39]             LD      E,A             ; To E
EEB2: 1664     [46]             LD      D,64H           ; Relational precedence
EEB4: 78       [50]             LD      A,B             ; Get current precedence
EEB5: BA       [54]             CP      D               ; Compare with last
EEB6: D0       [59|65]          RET     NC              ; Eval if last was rel' or log'
EEB7: C3BAED   [69]             JP      STKTHS          ; Stack this one and get next
                        
EEBA: BCEE              CMPLOG: DW      CMPLG1          ; Compare two values / strings
EEBC: 79       [ 4]     CMPLG1: LD      A,C             ; Get data type
EEBD: B7       [ 8]             OR      A
EEBE: 1F       [12]             RRA
EEBF: C1       [22]             POP     BC              ; Get last expression to BCDE
EEC0: D1       [32]             POP     DE
EEC1: F5       [43]             PUSH    AF              ; Save status
EEC2: CD46ED   [60]             CALL    CHKTYP          ; Check that types match
EEC5: 21FEEE   [70]             LD      HL,CMPRES       ; Result to comparison
EEC8: E5       [81]             PUSH    HL              ; Save for RETurn
EEC9: CA8EF8   [91|91]          JP      Z,CMPNUM        ; Compare values if numeric
EECC: AF       [95]             XOR     A               ; Compare two strings
EECD: 32AD10   [108]            LD      (TYPE),A        ; Set type to numeric
EED0: D5       [119]            PUSH    DE              ; Save string name
EED1: CD53F3   [136]            CALL    GSTRCU          ; Get current string
EED4: 7E       [143]            LD      A,(HL)          ; Get length of string
EED5: 23       [149]            INC     HL
EED6: 23       [155]            INC     HL
EED7: 4E       [162]            LD      C,(HL)          ; Get LSB of address
EED8: 23       [168]            INC     HL
EED9: 46       [175]            LD      B,(HL)          ; Get MSB of address
EEDA: D1       [185]            POP     DE              ; Restore string name
EEDB: C5       [196]            PUSH    BC              ; Save address of string
EEDC: F5       [207]            PUSH    AF              ; Save length of string
EEDD: CD57F3   [224]            CALL    GSTRDE          ; Get second string
EEE0: CD62F8   [241]            CALL    LOADFP          ; Get address of second string
EEE3: F1       [251]            POP     AF              ; Restore length of string 1
EEE4: 57       [255]            LD      D,A             ; Length to D
EEE5: E1       [265]            POP     HL              ; Restore address of string 1
EEE6: 7B       [ 4]     CMPSTR: LD      A,E             ; Bytes of string 2 to do
EEE7: B2       [ 8]             OR      D               ; Bytes of string 1 to do
EEE8: C8       [13|19]          RET     Z               ; Exit if all bytes compared
EEE9: 7A       [17]             LD      A,D             ; Get bytes of string 1 to do
EEEA: D601     [24]             SUB     1
EEEC: D8       [29|35]          RET     C               ; Exit if end of string 1
EEED: AF       [33]             XOR     A
EEEE: BB       [37]             CP      E               ; Bytes of string 2 to do
EEEF: 3C       [41]             INC     A
EEF0: D0       [46|52]          RET     NC              ; Exit if end of string 2
EEF1: 15       [50]             DEC     D               ; Count bytes in string 1
EEF2: 1D       [54]             DEC     E               ; Count bytes in string 2
EEF3: 0A       [61]             LD      A,(BC)          ; Byte in string 2
EEF4: BE       [68]             CP      (HL)            ; Compare to byte in string 1
EEF5: 23       [74]             INC     HL              ; Move up string 1
EEF6: 03       [80]             INC     BC              ; Move up string 2
EEF7: CAE6EE   [90|90]          JP      Z,CMPSTR        ; Same - Try next bytes
EEFA: 3F       [94]             CCF                     ; Flag difference (">" or "<")
EEFB: C31EF8   [104]            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
                        
EEFE: 3C       [ 4]     CMPRES: INC     A               ; Increment current value
EEFF: 8F       [ 8]             ADC     A,A             ; Double plus carry
EF00: C1       [18]             POP     BC              ; Get other value
EF01: A0       [22]             AND     B               ; Combine them
EF02: C6FF     [29]             ADD     A,-1            ; Carry set if different
EF04: 9F       [33]             SBC     A,A             ; 00 - Equal , FF - Different
EF05: C325F8   [43]             JP      FLGREL          ; Set current value & continue
                        
EF08: 165A     [ 7]     EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
EF0A: CD5DED   [24]             CALL    EVAL1           ; Eval until precedence break
EF0D: CD44ED   [41]             CALL    TSTNUM          ; Make sure it's a number
EF10: CD8BE9   [58]             CALL    DEINT           ; Get integer -32768 - 32767
EF13: 7B       [62]             LD      A,E             ; Get LSB
EF14: 2F       [66]             CPL                     ; Invert LSB
EF15: 4F       [70]             LD      C,A             ; Save "NOT" of LSB
EF16: 7A       [74]             LD      A,D             ; Get MSB
EF17: 2F       [78]             CPL                     ; Invert MSB
EF18: CDF1F0   [95]             CALL    ACPASS          ; Save AC as current
EF1B: C1       [105]            POP     BC              ; Clean up stack
EF1C: C369ED   [115]            JP      EVAL3           ; Continue evaluation
                        
EF1F: 2B       [ 6]     DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
EF20: CD36E8   [23]             CALL    GETCHR          ; Get next character
EF23: C8       [28|34]          RET     Z               ; End of DIM statement
EF24: CD90E6   [45]             CALL    CHKSYN          ; Make sure "," follows
EF27: 2C                        DB      ","
EF28: 011FEF   [10]     DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
EF2B: C5       [21]             PUSH    BC              ; Save on stack
EF2C: F6                        DB      0F6H            ; Flag "Create" variable
EF2D: AF       [ 4]     GETVAR: XOR     A               ; Find variable address,to DE
EF2E: 32AC10   [17]             LD      (LCRFLG),A      ; Set locate / create flag
EF31: 46       [24]             LD      B,(HL)          ; Get First byte of name
EF32: CD77E9   [17]     GTFNAM: CALL    CHKLTR          ; See if a letter
EF35: DAADE3   [27|27]          JP      C,SNERR         ; ?SN Error if not a letter
EF38: AF       [31]             XOR     A
EF39: 4F       [35]             LD      C,A             ; Clear second byte of name
EF3A: 32AD10   [48]             LD      (TYPE),A        ; Set type to numeric
EF3D: CD36E8   [65]             CALL    GETCHR          ; Get next character
EF40: DA49EF   [75|75]          JP      C,SVNAM2        ; Numeric - Save in name
EF43: CD77E9   [92]             CALL    CHKLTR          ; See if a letter
EF46: DA56EF   [102|102]        JP      C,CHARTY        ; Not a letter - Check type
EF49: 4F       [ 4]     SVNAM2: LD      C,A             ; Save second byte of name
EF4A: CD36E8   [17]     ENDNAM: CALL    GETCHR          ; Get next character
EF4D: DA4AEF   [27|27]          JP      C,ENDNAM        ; Numeric - Get another
EF50: CD77E9   [44]             CALL    CHKLTR          ; See if a letter
EF53: D24AEF   [54|54]          JP      NC,ENDNAM       ; Letter - Get another
EF56: D624     [ 7]     CHARTY: SUB     "$"             ; String variable?
EF58: C265EF   [17|17]          JP      NZ,NOTSTR       ; No - Numeric variable
EF5B: 3C       [21]             INC     A               ; A = 1 (string type)
EF5C: 32AD10   [34]             LD      (TYPE),A        ; Set type to string
EF5F: 0F       [38]             RRCA                    ; A = 80H , Flag for string
EF60: 81       [42]             ADD     A,C             ; 2nd byte of name has bit 7 on
EF61: 4F       [46]             LD      C,A             ; Resave second byte on name
EF62: CD36E8   [63]             CALL    GETCHR          ; Get next character
EF65: 3ACB10   [13]     NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
EF68: 3D       [17]             DEC     A
EF69: CA12F0   [27|27]          JP      Z,ARLDSV        ; Yes - Get array name
EF6C: F275EF   [37|37]          JP      P,NSCFOR        ; No array with "FOR" or "FN"
EF6F: 7E       [44]             LD      A,(HL)          ; Get byte again
EF70: D628     [51]             SUB     "("             ; Subscripted variable?
EF72: CAEAEF   [61|61]          JP      Z,SBSCPT        ; Yes - Sort out subscript
                        
EF75: AF       [ 4]     NSCFOR: XOR     A               ; Simple variable
EF76: 32CB10   [17]             LD      (FORFLG),A      ; Clear "FOR" flag
EF79: E5       [28]             PUSH    HL              ; Save code string address
EF7A: 50       [32]             LD      D,B             ; DE = Variable name to find
EF7B: 59       [36]             LD      E,C
EF7C: 2ADE10   [52]             LD      HL,(FNRGNM)     ; FN argument name
EF7F: CD8AE6   [69]             CALL    CPDEHL          ; Is it the FN argument?
EF82: 11E010   [79]             LD      DE,FNARG        ; Point to argument value
EF85: CA54F7   [89|89]          JP      Z,POPHRT        ; Yes - Return FN argument value
EF88: 2AD810   [105]            LD      HL,(VAREND)     ; End of variables
EF8B: EB       [109]            EX      DE,HL           ; Address of end of search
EF8C: 2AD610   [125]            LD      HL,(PROGND)     ; Start of variables address
EF8F: CD8AE6   [17]     FNDVAR: CALL    CPDEHL          ; End of variable list table?
EF92: CAA8EF   [27|27]          JP      Z,CFEVAL        ; Yes - Called from EVAL?
EF95: 79       [31]             LD      A,C             ; Get second byte of name
EF96: 96       [38]             SUB     (HL)            ; Compare with name in list
EF97: 23       [44]             INC     HL              ; Move on to first byte
EF98: C29DEF   [54|54]          JP      NZ,FNTHR        ; Different - Find another
EF9B: 78       [58]             LD      A,B             ; Get first byte of name
EF9C: 96       [65]             SUB     (HL)            ; Compare with name in list
EF9D: 23       [ 6]     FNTHR:  INC     HL              ; Move on to LSB of value
EF9E: CADCEF   [16|16]          JP      Z,RETADR        ; Found - Return address
EFA1: 23       [22]             INC     HL              ; <- Skip
EFA2: 23       [28]             INC     HL              ; <- over
EFA3: 23       [34]             INC     HL              ; <- F.P.
EFA4: 23       [40]             INC     HL              ; <- value
EFA5: C38FEF   [50]             JP      FNDVAR          ; Keep looking
                        
EFA8: E1       [10]     CFEVAL: POP     HL              ; Restore code string address
EFA9: E3       [29]             EX      (SP),HL         ; Get return address
EFAA: D5       [40]             PUSH    DE              ; Save address of variable
EFAB: 1125EE   [50]             LD      DE,FRMEVL       ; Return address in EVAL
EFAE: CD8AE6   [67]             CALL    CPDEHL          ; Called from EVAL ?
EFB1: D1       [77]             POP     DE              ; Restore address of variable
EFB2: CADFEF   [87|87]          JP      Z,RETNUL        ; Yes - Return null variable
EFB5: E3       [106]            EX      (SP),HL         ; Put back return
EFB6: E5       [117]            PUSH    HL              ; Save code string address
EFB7: C5       [128]            PUSH    BC              ; Save variable name
EFB8: 010600   [138]            LD      BC,6            ; 2 byte name plus 4 byte data
EFBB: 2ADA10   [154]            LD      HL,(ARREND)     ; End of arrays
EFBE: E5       [165]            PUSH    HL              ; Save end of arrays
EFBF: 09       [176]            ADD     HL,BC           ; Move up 6 bytes
EFC0: C1       [186]            POP     BC              ; Source address in BC
EFC1: E5       [197]            PUSH    HL              ; Save new end address
EFC2: CD79E3   [214]            CALL    MOVUP           ; Move arrays up
EFC5: E1       [224]            POP     HL              ; Restore new end address
EFC6: 22DA10   [240]            LD      (ARREND),HL     ; Set new end address
EFC9: 60       [244]            LD      H,B             ; End of variables to HL
EFCA: 69       [248]            LD      L,C
EFCB: 22D810   [264]            LD      (VAREND),HL     ; Set new end address
                        
EFCE: 2B       [ 6]     ZEROLP: DEC     HL              ; Back through to zero variable
EFCF: 3600     [16]             LD      (HL),0          ; Zero byte in variable
EFD1: CD8AE6   [33]             CALL    CPDEHL          ; Done them all?
EFD4: C2CEEF   [43|43]          JP      NZ,ZEROLP       ; No - Keep on going
EFD7: D1       [53]             POP     DE              ; Get variable name
EFD8: 73       [60]             LD      (HL),E          ; Store second character
EFD9: 23       [66]             INC     HL
EFDA: 72       [73]             LD      (HL),D          ; Store first character
EFDB: 23       [79]             INC     HL
EFDC: EB       [ 4]     RETADR: EX      DE,HL           ; Address of variable in DE
EFDD: E1       [14]             POP     HL              ; Restore code string address
EFDE: C9       [24]             RET
                        
EFDF: 32E710   [13]     RETNUL: LD      (FPEXP),A       ; Set result to zero
EFE2: 214AE3   [23]             LD      HL,ZERBYT       ; Also set a null string
EFE5: 22E410   [39]             LD      (FPREG),HL      ; Save for EVAL
EFE8: E1       [49]             POP     HL              ; Restore code string address
EFE9: C9       [59]             RET
                        
EFEA: E5       [11]     SBSCPT: PUSH    HL              ; Save code string address
EFEB: 2AAC10   [27]             LD      HL,(LCRFLG)     ; Locate/Create and Type
EFEE: E3       [46]             EX      (SP),HL         ; Save and get code string
EFEF: 57       [50]             LD      D,A             ; Zero number of dimensions
EFF0: D5       [11]     SCPTLP: PUSH    DE              ; Save number of dimensions
EFF1: C5       [22]             PUSH    BC              ; Save array name
EFF2: CD7FE9   [39]             CALL    FPSINT          ; Get subscript (0-32767)
EFF5: C1       [49]             POP     BC              ; Restore array name
EFF6: F1       [59]             POP     AF              ; Get number of dimensions
EFF7: EB       [63]             EX      DE,HL
EFF8: E3       [82]             EX      (SP),HL         ; Save subscript value
EFF9: E5       [93]             PUSH    HL              ; Save LCRFLG and TYPE
EFFA: EB       [97]             EX      DE,HL
EFFB: 3C       [101]            INC     A               ; Count dimensions
EFFC: 57       [105]            LD      D,A             ; Save in D
EFFD: 7E       [112]            LD      A,(HL)          ; Get next byte in code string
EFFE: FE2C     [119]            CP      ","             ; Comma (more to come)?
F000: CAF0EF   [129|129]        JP      Z,SCPTLP        ; Yes - More subscripts
F003: CD90E6   [146]            CALL    CHKSYN          ; Make sure ")" follows
F006: 29                        DB      ")"
F007: 22D010   [162]            LD      (NXTOPR),HL     ; Save code string address
F00A: E1       [172]            POP     HL              ; Get LCRFLG and TYPE
F00B: 22AC10   [188]            LD      (LCRFLG),HL     ; Restore Locate/create & type
F00E: 1E00     [195]            LD      E,0             ; Flag not CSAVE* or CLOAD*
F010: D5       [206]            PUSH    DE              ; Save number of dimensions (D)
F011: 11                        DB      11H             ; Skip "PUSH HL" and "PUSH AF'
                        
F012: E5       [11]     ARLDSV: PUSH    HL              ; Save code string address
F013: F5       [22]             PUSH    AF              ; A = 00 , Flags set = Z,N
F014: 2AD810   [38]             LD      HL,(VAREND)     ; Start of arrays
F017: 3E                        DB      3EH             ; Skip "ADD HL,DE"
F018: 19       [11]     FNDARY: ADD     HL,DE           ; Move to next array start
F019: EB       [15]             EX      DE,HL
F01A: 2ADA10   [31]             LD      HL,(ARREND)     ; End of arrays
F01D: EB       [35]             EX      DE,HL           ; Current array pointer
F01E: CD8AE6   [52]             CALL    CPDEHL          ; End of arrays found?
F021: CA4AF0   [62|62]          JP      Z,CREARY        ; Yes - Create array
F024: 7E       [69]             LD      A,(HL)          ; Get second byte of name
F025: B9       [73]             CP      C               ; Compare with name given
F026: 23       [79]             INC     HL              ; Move on
F027: C22CF0   [89|89]          JP      NZ,NXTARY       ; Different - Find next array
F02A: 7E       [96]             LD      A,(HL)          ; Get first byte of name
F02B: B8       [100]            CP      B               ; Compare with name given
F02C: 23       [ 6]     NXTARY: INC     HL              ; Move on
F02D: 5E       [13]             LD      E,(HL)          ; Get LSB of next array address
F02E: 23       [19]             INC     HL
F02F: 56       [26]             LD      D,(HL)          ; Get MSB of next array address
F030: 23       [32]             INC     HL
F031: C218F0   [42|42]          JP      NZ,FNDARY       ; Not found - Keep looking
F034: 3AAC10   [55]             LD      A,(LCRFLG)      ; Found Locate or Create it?
F037: B7       [59]             OR      A
F038: C2B6E3   [69|69]          JP      NZ,DDERR        ; Create - ?DD Error
F03B: F1       [79]             POP     AF              ; Locate - Get number of dim'ns
F03C: 44       [83]             LD      B,H             ; BC Points to array dim'ns
F03D: 4D       [87]             LD      C,L
F03E: CA54F7   [97|97]          JP      Z,POPHRT        ; Jump if array load/save
F041: 96       [104]            SUB     (HL)            ; Same number of dimensions?
F042: CAA8F0   [114|114]        JP      Z,FINDEL        ; Yes - Find element
F045: 1E10     [ 7]     BSERR:  LD      E,BS            ; ?BS Error
F047: C3C1E3   [17]             JP      ERROR           ; Output error
                        
F04A: 110400   [10]     CREARY: LD      DE,4            ; 4 Bytes per entry
F04D: F1       [20]             POP     AF              ; Array to save or 0 dim'ns?
F04E: CAA0E9   [30|30]          JP      Z,FCERR         ; Yes - ?FC Error
F051: 71       [37]             LD      (HL),C          ; Save second byte of name
F052: 23       [43]             INC     HL
F053: 70       [50]             LD      (HL),B          ; Save first byte of name
F054: 23       [56]             INC     HL
F055: 4F       [60]             LD      C,A             ; Number of dimensions to C
F056: CD8AE3   [77]             CALL    CHKSTK          ; Check if enough memory
F059: 23       [83]             INC     HL              ; Point to number of dimensions
F05A: 23       [89]             INC     HL
F05B: 22C510   [105]            LD      (CUROPR),HL     ; Save address of pointer
F05E: 71       [112]            LD      (HL),C          ; Set number of dimensions
F05F: 23       [118]            INC     HL
F060: 3AAC10   [131]            LD      A,(LCRFLG)      ; Locate of Create?
F063: 17       [135]            RLA                     ; Carry set = Create
F064: 79       [139]            LD      A,C             ; Get number of dimensions
F065: 010B00   [10]     CRARLP: LD      BC,10+1         ; Default dimension size 10
F068: D26DF0   [20|20]          JP      NC,DEFSIZ       ; Locate - Set default size
F06B: C1       [30]             POP     BC              ; Get specified dimension size
F06C: 03       [36]             INC     BC              ; Include zero element
F06D: 71       [ 7]     DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
F06E: 23       [13]             INC     HL
F06F: 70       [20]             LD      (HL),B          ; Save MSB of dimension size
F070: 23       [26]             INC     HL
F071: F5       [37]             PUSH    AF              ; Save num' of dim'ns an status
F072: E5       [48]             PUSH    HL              ; Save address of dim'n size
F073: CDFFF8   [65]             CALL    MLDEBC          ; Multiply DE by BC to find
F076: EB       [69]             EX      DE,HL           ; amount of mem needed (to DE)
F077: E1       [79]             POP     HL              ; Restore address of dimension
F078: F1       [89]             POP     AF              ; Restore number of dimensions
F079: 3D       [93]             DEC     A               ; Count them
F07A: C265F0   [103|103]        JP      NZ,CRARLP       ; Do next dimension if more
F07D: F5       [114]            PUSH    AF              ; Save locate/create flag
F07E: 42       [118]            LD      B,D             ; MSB of memory needed
F07F: 4B       [122]            LD      C,E             ; LSB of memory needed
F080: EB       [126]            EX      DE,HL
F081: 19       [137]            ADD     HL,DE           ; Add bytes to array start
F082: DAA2E3   [147|147]        JP      C,OMERR         ; Too big - Error
F085: CD93E3   [164]            CALL    ENFMEM          ; See if enough memory
F088: 22DA10   [180]            LD      (ARREND),HL     ; Save new end of array
                        
F08B: 2B       [ 6]     ZERARY: DEC     HL              ; Back through array data
F08C: 3600     [16]             LD      (HL),0          ; Set array element to zero
F08E: CD8AE6   [33]             CALL    CPDEHL          ; All elements zeroed?
F091: C28BF0   [43|43]          JP      NZ,ZERARY       ; No - Keep on going
F094: 03       [49]             INC     BC              ; Number of bytes + 1
F095: 57       [53]             LD      D,A             ; A=0
F096: 2AC510   [69]             LD      HL,(CUROPR)     ; Get address of array
F099: 5E       [76]             LD      E,(HL)          ; Number of dimensions
F09A: EB       [80]             EX      DE,HL           ; To HL
F09B: 29       [91]             ADD     HL,HL           ; Two bytes per dimension size
F09C: 09       [102]            ADD     HL,BC           ; Add number of bytes
F09D: EB       [106]            EX      DE,HL           ; Bytes needed to DE
F09E: 2B       [112]            DEC     HL
F09F: 2B       [118]            DEC     HL
F0A0: 73       [125]            LD      (HL),E          ; Save LSB of bytes needed
F0A1: 23       [131]            INC     HL
F0A2: 72       [138]            LD      (HL),D          ; Save MSB of bytes needed
F0A3: 23       [144]            INC     HL
F0A4: F1       [154]            POP     AF              ; Locate / Create?
F0A5: DACCF0   [164|164]        JP      C,ENDDIM        ; A is 0 , End if create
F0A8: 47       [ 4]     FINDEL: LD      B,A             ; Find array element
F0A9: 4F       [ 8]             LD      C,A
F0AA: 7E       [15]             LD      A,(HL)          ; Number of dimensions
F0AB: 23       [21]             INC     HL
F0AC: 16                        DB      16H             ; Skip "POP HL"
F0AD: E1       [10]     FNDELP: POP     HL              ; Address of next dim' size
F0AE: 5E       [17]             LD      E,(HL)          ; Get LSB of dim'n size
F0AF: 23       [23]             INC     HL
F0B0: 56       [30]             LD      D,(HL)          ; Get MSB of dim'n size
F0B1: 23       [36]             INC     HL
F0B2: E3       [55]             EX      (SP),HL         ; Save address - Get index
F0B3: F5       [66]             PUSH    AF              ; Save number of dim'ns
F0B4: CD8AE6   [83]             CALL    CPDEHL          ; Dimension too large?
F0B7: D245F0   [93|93]          JP      NC,BSERR        ; Yes - ?BS Error
F0BA: E5       [104]            PUSH    HL              ; Save index
F0BB: CDFFF8   [121]            CALL    MLDEBC          ; Multiply previous by size
F0BE: D1       [131]            POP     DE              ; Index supplied to DE
F0BF: 19       [142]            ADD     HL,DE           ; Add index to pointer
F0C0: F1       [152]            POP     AF              ; Number of dimensions
F0C1: 3D       [156]            DEC     A               ; Count them
F0C2: 44       [160]            LD      B,H             ; MSB of pointer
F0C3: 4D       [164]            LD      C,L             ; LSB of pointer
F0C4: C2ADF0   [174|174]        JP      NZ,FNDELP       ; More - Keep going
F0C7: 29       [185]            ADD     HL,HL           ; 4 Bytes per element
F0C8: 29       [196]            ADD     HL,HL
F0C9: C1       [206]            POP     BC              ; Start of array
F0CA: 09       [217]            ADD     HL,BC           ; Point to element
F0CB: EB       [221]            EX      DE,HL           ; Address of element to DE
F0CC: 2AD010   [16]     ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
F0CF: C9       [26]             RET
                        
F0D0: 2ADA10   [16]     FRE:    LD      HL,(ARREND)     ; Start of free memory
F0D3: EB       [20]             EX      DE,HL           ; To DE
F0D4: 210000   [30]             LD      HL,0            ; End of free memory
F0D7: 39       [41]             ADD     HL,SP           ; Current stack value
F0D8: 3AAD10   [54]             LD      A,(TYPE)        ; Dummy argument type
F0DB: B7       [58]             OR      A
F0DC: CAECF0   [68|68]          JP      Z,FRENUM        ; Numeric - Free variable space
F0DF: CD53F3   [85]             CALL    GSTRCU          ; Current string to pool
F0E2: CD53F2   [102]            CALL    GARBGE          ; Garbage collection
F0E5: 2A5A10   [118]            LD      HL,(STRSPC)     ; Bottom of string space in use
F0E8: EB       [122]            EX      DE,HL           ; To DE
F0E9: 2AC310   [138]            LD      HL,(STRBOT)     ; Bottom of string space
F0EC: 7D       [ 4]     FRENUM: LD      A,L             ; Get LSB of end
F0ED: 93       [ 8]             SUB     E               ; Subtract LSB of beginning
F0EE: 4F       [12]             LD      C,A             ; Save difference if C
F0EF: 7C       [16]             LD      A,H             ; Get MSB of end
F0F0: 9A       [20]             SBC     A,D             ; Subtract MSB of beginning
F0F1: 41       [ 4]     ACPASS: LD      B,C             ; Return integer AC
F0F2: 50       [ 4]     ABPASS: LD      D,B             ; Return integer AB
F0F3: 1E00     [11]             LD      E,0
F0F5: 21AD10   [21]             LD      HL,TYPE         ; Point to type
F0F8: 73       [28]             LD      (HL),E          ; Set type to numeric
F0F9: 0690     [35]             LD      B,80H+16        ; 16 bit integer
F0FB: C32AF8   [45]             JP      RETINT          ; Return the integr
                        
F0FE: 3AAB10   [13]     POS:    LD      A,(CURPOS)      ; Get cursor position
F101: 47       [ 4]     PASSA:  LD      B,A             ; Put A into AB
F102: AF       [ 8]             XOR     A               ; Zero A
F103: C3F2F0   [18]             JP      ABPASS          ; Return integer AB
                        
F106: CD89F1   [17]     DEF:    CALL    CHEKFN          ; Get "FN" and name
F109: CD7BF1   [34]             CALL    IDTEST          ; Test for illegal direct
F10C: 0170EA   [44]             LD      BC,DATA         ; To get next statement
F10F: C5       [55]             PUSH    BC              ; Save address for RETurn
F110: D5       [66]             PUSH    DE              ; Save address of function ptr
F111: CD90E6   [83]             CALL    CHKSYN          ; Make sure "(" follows
F114: 28                        DB      "("
F115: CD2DEF   [100]            CALL    GETVAR          ; Get argument variable name
F118: E5       [111]            PUSH    HL              ; Save code string address
F119: EB       [115]            EX      DE,HL           ; Argument address to HL
F11A: 2B       [121]            DEC     HL
F11B: 56       [128]            LD      D,(HL)          ; Get first byte of arg name
F11C: 2B       [134]            DEC     HL
F11D: 5E       [141]            LD      E,(HL)          ; Get second byte of arg name
F11E: E1       [151]            POP     HL              ; Restore code string address
F11F: CD44ED   [168]            CALL    TSTNUM          ; Make sure numeric argument
F122: CD90E6   [185]            CALL    CHKSYN          ; Make sure ")" follows
F125: 29                        DB      ")"
F126: CD90E6   [202]            CALL    CHKSYN          ; Make sure "=" follows
F129: B4                        DB      ZEQUAL          ; "=" token
F12A: 44       [206]            LD      B,H             ; Code string address to BC
F12B: 4D       [210]            LD      C,L
F12C: E3       [229]            EX      (SP),HL         ; Save code str , Get FN ptr
F12D: 71       [236]            LD      (HL),C          ; Save LSB of FN code string
F12E: 23       [242]            INC     HL
F12F: 70       [249]            LD      (HL),B          ; Save MSB of FN code string
F130: C3C8F1   [259]            JP      SVSTAD          ; Save address and do function
                        
F133: CD89F1   [17]     DOFN:   CALL    CHEKFN          ; Make sure FN follows
F136: D5       [28]             PUSH    DE              ; Save function pointer address
F137: CD09EE   [45]             CALL    EVLPAR          ; Evaluate expression in "()"
F13A: CD44ED   [62]             CALL    TSTNUM          ; Make sure numeric result
F13D: E3       [81]             EX      (SP),HL         ; Save code str , Get FN ptr
F13E: 5E       [88]             LD      E,(HL)          ; Get LSB of FN code string
F13F: 23       [94]             INC     HL
F140: 56       [101]            LD      D,(HL)          ; Get MSB of FN code string
F141: 23       [107]            INC     HL
F142: 7A       [111]            LD      A,D             ; And function DEFined?
F143: B3       [115]            OR      E
F144: CAB9E3   [125|125]        JP      Z,UFERR         ; No - ?UF Error
F147: 7E       [132]            LD      A,(HL)          ; Get LSB of argument address
F148: 23       [138]            INC     HL
F149: 66       [145]            LD      H,(HL)          ; Get MSB of argument address
F14A: 6F       [149]            LD      L,A             ; HL = Arg variable address
F14B: E5       [160]            PUSH    HL              ; Save it
F14C: 2ADE10   [176]            LD      HL,(FNRGNM)     ; Get old argument name
F14F: E3       [195]            EX      (SP),HL ;       ; Save old , Get new
F150: 22DE10   [211]            LD      (FNRGNM),HL     ; Set new argument name
F153: 2AE210   [227]            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
F156: E5       [238]            PUSH    HL              ; Save it
F157: 2AE010   [254]            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
F15A: E5       [265]            PUSH    HL              ; Save it
F15B: 21E010   [275]            LD      HL,FNARG        ; HL = Value of argument
F15E: D5       [286]            PUSH    DE              ; Save FN code string address
F15F: CD6BF8   [303]            CALL    FPTHL           ; Move FPREG to argument
F162: E1       [313]            POP     HL              ; Get FN code string address
F163: CD41ED   [330]            CALL    GETNUM          ; Get value from function
F166: 2B       [336]            DEC     HL              ; DEC 'cos GETCHR INCs
F167: CD36E8   [353]            CALL    GETCHR          ; Get next character
F16A: C2ADE3   [363|363]        JP      NZ,SNERR        ; Bad character in FN - Error
F16D: E1       [373]            POP     HL              ; Get MSB,EXP of old arg
F16E: 22E010   [389]            LD      (FNARG),HL      ; Restore it
F171: E1       [399]            POP     HL              ; Get LSB,NLSB of old arg
F172: 22E210   [415]            LD      (FNARG+2),HL    ; Restore it
F175: E1       [425]            POP     HL              ; Get name of old arg
F176: 22DE10   [441]            LD      (FNRGNM),HL     ; Restore it
F179: E1       [451]            POP     HL              ; Restore code string address
F17A: C9       [461]            RET
                        
F17B: E5       [11]     IDTEST: PUSH    HL              ; Save code string address
F17C: 2A5C10   [27]             LD      HL,(LINEAT)     ; Get current line number
F17F: 23       [33]             INC     HL              ; -1 means direct statement
F180: 7C       [37]             LD      A,H
F181: B5       [41]             OR      L
F182: E1       [51]             POP     HL              ; Restore code string address
F183: C0       [56|62]          RET     NZ              ; Return if in program
F184: 1E16     [63]             LD      E,ID            ; ?ID Error
F186: C3C1E3   [73]             JP      ERROR
                        
F189: CD90E6   [17]     CHEKFN: CALL    CHKSYN          ; Make sure FN follows
F18C: A7                        DB      ZFN             ; "FN" token
F18D: 3E80     [24]             LD      A,80H
F18F: 32CB10   [37]             LD      (FORFLG),A      ; Flag FN name to find
F192: B6       [44]             OR      (HL)            ; FN name has bit 7 set
F193: 47       [48]             LD      B,A             ; in first byte of name
F194: CD32EF   [65]             CALL    GTFNAM          ; Get FN name
F197: C344ED   [75]             JP      TSTNUM          ; Make sure numeric function
                        
F19A: CD44ED   [17]     STR:    CALL    TSTNUM          ; Make sure it's a number
F19D: CDB8F9   [34]             CALL    NUMASC          ; Turn number into text
F1A0: CDCEF1   [51]             CALL    CRTST           ; Create string entry for it
F1A3: CD53F3   [68]             CALL    GSTRCU          ; Current string to pool
F1A6: 01AEF3   [78]             LD      BC,TOPOOL       ; Save in string pool
F1A9: C5       [89]             PUSH    BC              ; Save address on stack
                        
F1AA: 7E       [ 7]     SAVSTR: LD      A,(HL)          ; Get string length
F1AB: 23       [13]             INC     HL
F1AC: 23       [19]             INC     HL
F1AD: E5       [30]             PUSH    HL              ; Save pointer to string
F1AE: CD29F2   [47]             CALL    TESTR           ; See if enough string space
F1B1: E1       [57]             POP     HL              ; Restore pointer to string
F1B2: 4E       [64]             LD      C,(HL)          ; Get LSB of address
F1B3: 23       [70]             INC     HL
F1B4: 46       [77]             LD      B,(HL)          ; Get MSB of address
F1B5: CDC2F1   [94]             CALL    CRTMST          ; Create string entry
F1B8: E5       [105]            PUSH    HL              ; Save pointer to MSB of addr
F1B9: 6F       [109]            LD      L,A             ; Length of string
F1BA: CD46F3   [126]            CALL    TOSTRA          ; Move to string area
F1BD: D1       [136]            POP     DE              ; Restore pointer to MSB
F1BE: C9       [146]            RET
                        
F1BF: CD29F2   [17]     MKTMST: CALL    TESTR           ; See if enough string space
F1C2: 21BF10   [10]     CRTMST: LD      HL,TMPSTR       ; Temporary string
F1C5: E5       [21]             PUSH    HL              ; Save it
F1C6: 77       [28]             LD      (HL),A          ; Save length of string
F1C7: 23       [34]             INC     HL
F1C8: 23       [ 6]     SVSTAD: INC     HL
F1C9: 73       [13]             LD      (HL),E          ; Save LSB of address
F1CA: 23       [19]             INC     HL
F1CB: 72       [26]             LD      (HL),D          ; Save MSB of address
F1CC: E1       [36]             POP     HL              ; Restore pointer
F1CD: C9       [46]             RET
                        
F1CE: 2B       [ 6]     CRTST:  DEC     HL              ; DEC - INCed after
F1CF: 0622     [ 7]     QTSTR:  LD      B,'"'           ; Terminating quote
F1D1: 50       [11]             LD      D,B             ; Quote to D
F1D2: E5       [11]     DTSTR:  PUSH    HL              ; Save start
F1D3: 0EFF     [18]             LD      C,-1            ; Set counter to -1
F1D5: 23       [ 6]     QTSTLP: INC     HL              ; Move on
F1D6: 7E       [13]             LD      A,(HL)          ; Get byte
F1D7: 0C       [17]             INC     C               ; Count bytes
F1D8: B7       [21]             OR      A               ; End of line?
F1D9: CAE4F1   [31|31]          JP      Z,CRTSTE        ; Yes - Create string entry
F1DC: BA       [35]             CP      D               ; Terminator D found?
F1DD: CAE4F1   [45|45]          JP      Z,CRTSTE        ; Yes - Create string entry
F1E0: B8       [49]             CP      B               ; Terminator B found?
F1E1: C2D5F1   [59|59]          JP      NZ,QTSTLP       ; No - Keep looking
F1E4: FE22     [ 7]     CRTSTE: CP      '"'             ; End with '"'?
F1E6: CC36E8   [17|24]          CALL    Z,GETCHR        ; Yes - Get next character
F1E9: E3       [36]             EX      (SP),HL         ; Starting quote
F1EA: 23       [42]             INC     HL              ; First byte of string
F1EB: EB       [46]             EX      DE,HL           ; To DE
F1EC: 79       [50]             LD      A,C             ; Get length
F1ED: CDC2F1   [67]             CALL    CRTMST          ; Create string entry
F1F0: 11BF10   [10]     TSTOPL: LD      DE,TMPSTR       ; Temporary string
F1F3: 2AB110   [26]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
F1F6: 22E410   [42]             LD      (FPREG),HL      ; Save address of string ptr
F1F9: 3E01     [49]             LD      A,1
F1FB: 32AD10   [62]             LD      (TYPE),A        ; Set type to string
F1FE: CD6EF8   [79]             CALL    DETHL4          ; Move string to pool
F201: CD8AE6   [96]             CALL    CPDEHL          ; Out of string pool?
F204: 22B110   [112]            LD      (TMSTPT),HL     ; Save new pointer
F207: E1       [122]            POP     HL              ; Restore code string address
F208: 7E       [129]            LD      A,(HL)          ; Get next code byte
F209: C0       [134|140]        RET     NZ              ; Return if pool OK
F20A: 1E1E     [141]            LD      E,ST            ; ?ST Error
F20C: C3C1E3   [151]            JP      ERROR           ; String pool overflow
                        
F20F: 23       [ 6]     PRNUMS: INC     HL              ; Skip leading space
F210: CDCEF1   [17]     PRS:    CALL    CRTST           ; Create string entry for it
F213: CD53F3   [17]     PRS1:   CALL    GSTRCU          ; Current string to pool
F216: CD62F8   [34]             CALL    LOADFP          ; Move string block to BCDE
F219: 1C       [38]             INC     E               ; Length + 1
F21A: 1D       [ 4]     PRSLP:  DEC     E               ; Count characters
F21B: C8       [ 9|15]          RET     Z               ; End of string
F21C: 0A       [16]             LD      A,(BC)          ; Get byte to output
F21D: CD9BE6   [33]             CALL    OUTC            ; Output character in A
F220: FE0D     [40]             CP      CR              ; Return?
F222: CC86EB   [50|57]          CALL    Z,DONULL        ; Yes - Do nulls
F225: 03       [56]             INC     BC              ; Next byte in string
F226: C31AF2   [66]             JP      PRSLP           ; More characters to output
                        
F229: B7       [ 4]     TESTR:  OR      A               ; Test if enough room
F22A: 0E                        DB      0EH             ; No garbage collection done
F22B: F1       [10]     GRBDON: POP     AF              ; Garbage collection done
F22C: F5       [21]             PUSH    AF              ; Save status
F22D: 2A5A10   [37]             LD      HL,(STRSPC)     ; Bottom of string space in use
F230: EB       [41]             EX      DE,HL           ; To DE
F231: 2AC310   [57]             LD      HL,(STRBOT)     ; Bottom of string area
F234: 2F       [61]             CPL                     ; Negate length (Top down)
F235: 4F       [65]             LD      C,A             ; -Length to BC
F236: 06FF     [72]             LD      B,-1            ; BC = -ve length of string
F238: 09       [83]             ADD     HL,BC           ; Add to bottom of space in use
F239: 23       [89]             INC     HL              ; Plus one for 2's complement
F23A: CD8AE6   [106]            CALL    CPDEHL          ; Below string RAM area?
F23D: DA47F2   [116|116]        JP      C,TESTOS        ; Tidy up if not done else err
F240: 22C310   [132]            LD      (STRBOT),HL     ; Save new bottom of area
F243: 23       [138]            INC     HL              ; Point to first byte of string
F244: EB       [142]            EX      DE,HL           ; Address to DE
F245: F1       [10]     POPAF:  POP     AF              ; Throw away status push
F246: C9       [20]             RET
                        
F247: F1       [10]     TESTOS: POP     AF              ; Garbage collect been done?
F248: 1E1A     [17]             LD      E,OS            ; ?OS Error
F24A: CAC1E3   [27|27]          JP      Z,ERROR         ; Yes - Not enough string apace
F24D: BF       [31]             CP      A               ; Flag garbage collect done
F24E: F5       [42]             PUSH    AF              ; Save status
F24F: 012BF2   [52]             LD      BC,GRBDON       ; Garbage collection done
F252: C5       [63]             PUSH    BC              ; Save for RETurn
F253: 2AAF10   [16]     GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
F256: 22C310   [16]     GARBLP: LD      (STRBOT),HL     ; Reset string pointer
F259: 210000   [26]             LD      HL,0
F25C: E5       [37]             PUSH    HL              ; Flag no string found
F25D: 2A5A10   [53]             LD      HL,(STRSPC)     ; Get bottom of string space
F260: E5       [64]             PUSH    HL              ; Save bottom of string space
F261: 21B310   [74]             LD      HL,TMSTPL       ; Temporary string pool
F264: EB       [ 4]     GRBLP:  EX      DE,HL
F265: 2AB110   [20]             LD      HL,(TMSTPT)     ; Temporary string pool pointer
F268: EB       [24]             EX      DE,HL
F269: CD8AE6   [41]             CALL    CPDEHL          ; Temporary string pool done?
F26C: 0164F2   [51]             LD      BC,GRBLP        ; Loop until string pool done
F26F: C2B8F2   [61|61]          JP      NZ,STPOOL       ; No - See if in string area
F272: 2AD610   [77]             LD      HL,(PROGND)     ; Start of simple variables
F275: EB       [ 4]     SMPVAR: EX      DE,HL
F276: 2AD810   [20]             LD      HL,(VAREND)     ; End of simple variables
F279: EB       [24]             EX      DE,HL
F27A: CD8AE6   [41]             CALL    CPDEHL          ; All simple strings done?
F27D: CA8BF2   [51|51]          JP      Z,ARRLP         ; Yes - Do string arrays
F280: 7E       [58]             LD      A,(HL)          ; Get type of variable
F281: 23       [64]             INC     HL
F282: 23       [70]             INC     HL
F283: B7       [74]             OR      A               ; "S" flag set if string
F284: CDBBF2   [91]             CALL    STRADD          ; See if string in string area
F287: C375F2   [101]            JP      SMPVAR          ; Loop until simple ones done
                        
F28A: C1       [10]     GNXARY: POP     BC              ; Scrap address of this array
F28B: EB       [ 4]     ARRLP:  EX      DE,HL
F28C: 2ADA10   [20]             LD      HL,(ARREND)     ; End of string arrays
F28F: EB       [24]             EX      DE,HL
F290: CD8AE6   [41]             CALL    CPDEHL          ; All string arrays done?
F293: CAE1F2   [51|51]          JP      Z,SCNEND        ; Yes - Move string if found
F296: CD62F8   [68]             CALL    LOADFP          ; Get array name to BCDE
F299: 7B       [72]             LD      A,E             ; Get type of array     
F29A: E5       [83]             PUSH    HL              ; Save address of num of dim'ns
F29B: 09       [94]             ADD     HL,BC           ; Start of next array
F29C: B7       [98]             OR      A               ; Test type of array
F29D: F28AF2   [108|108]        JP      P,GNXARY        ; Numeric array - Ignore it
F2A0: 22C510   [124]            LD      (CUROPR),HL     ; Save address of next array
F2A3: E1       [134]            POP     HL              ; Get address of num of dim'ns
F2A4: 4E       [141]            LD      C,(HL)          ; BC = Number of dimensions
F2A5: 0600     [148]            LD      B,0
F2A7: 09       [159]            ADD     HL,BC           ; Two bytes per dimension size
F2A8: 09       [170]            ADD     HL,BC
F2A9: 23       [176]            INC     HL              ; Plus one for number of dim'ns
F2AA: EB       [ 4]     GRBARY: EX      DE,HL
F2AB: 2AC510   [20]             LD      HL,(CUROPR)     ; Get address of next array
F2AE: EB       [24]             EX      DE,HL
F2AF: CD8AE6   [41]             CALL    CPDEHL          ; Is this array finished?
F2B2: CA8BF2   [51|51]          JP      Z,ARRLP         ; Yes - Get next one
F2B5: 01AAF2   [61]             LD      BC,GRBARY       ; Loop until array all done
F2B8: C5       [11]     STPOOL: PUSH    BC              ; Save return address
F2B9: F680     [18]             OR      80H             ; Flag string type
F2BB: 7E       [ 7]     STRADD: LD      A,(HL)          ; Get string length
F2BC: 23       [13]             INC     HL
F2BD: 23       [19]             INC     HL
F2BE: 5E       [26]             LD      E,(HL)          ; Get LSB of string address
F2BF: 23       [32]             INC     HL
F2C0: 56       [39]             LD      D,(HL)          ; Get MSB of string address
F2C1: 23       [45]             INC     HL
F2C2: F0       [50|56]          RET     P               ; Not a string - Return
F2C3: B7       [54]             OR      A               ; Set flags on string length
F2C4: C8       [59|65]          RET     Z               ; Null string - Return
F2C5: 44       [63]             LD      B,H             ; Save variable pointer
F2C6: 4D       [67]             LD      C,L
F2C7: 2AC310   [83]             LD      HL,(STRBOT)     ; Bottom of new area
F2CA: CD8AE6   [100]            CALL    CPDEHL          ; String been done?
F2CD: 60       [104]            LD      H,B             ; Restore variable pointer
F2CE: 69       [108]            LD      L,C
F2CF: D8       [113|119]        RET     C               ; String done - Ignore
F2D0: E1       [123]            POP     HL              ; Return address
F2D1: E3       [142]            EX      (SP),HL         ; Lowest available string area
F2D2: CD8AE6   [159]            CALL    CPDEHL          ; String within string area?
F2D5: E3       [178]            EX      (SP),HL         ; Lowest available string area
F2D6: E5       [189]            PUSH    HL              ; Re-save return address
F2D7: 60       [193]            LD      H,B             ; Restore variable pointer
F2D8: 69       [197]            LD      L,C
F2D9: D0       [202|208]        RET     NC              ; Outside string area - Ignore
F2DA: C1       [212]            POP     BC              ; Get return , Throw 2 away
F2DB: F1       [222]            POP     AF              ; 
F2DC: F1       [232]            POP     AF              ; 
F2DD: E5       [243]            PUSH    HL              ; Save variable pointer
F2DE: D5       [254]            PUSH    DE              ; Save address of current
F2DF: C5       [265]            PUSH    BC              ; Put back return address
F2E0: C9       [275]            RET                     ; Go to it
                        
F2E1: D1       [10]     SCNEND: POP     DE              ; Addresses of strings
F2E2: E1       [20]             POP     HL              ; 
F2E3: 7D       [24]             LD      A,L             ; HL = 0 if no more to do
F2E4: B4       [28]             OR      H
F2E5: C8       [33|39]          RET     Z               ; No more to do - Return
F2E6: 2B       [39]             DEC     HL
F2E7: 46       [46]             LD      B,(HL)          ; MSB of address of string
F2E8: 2B       [52]             DEC     HL
F2E9: 4E       [59]             LD      C,(HL)          ; LSB of address of string
F2EA: E5       [70]             PUSH    HL              ; Save variable address
F2EB: 2B       [76]             DEC     HL
F2EC: 2B       [82]             DEC     HL
F2ED: 6E       [89]             LD      L,(HL)          ; HL = Length of string
F2EE: 2600     [96]             LD      H,0
F2F0: 09       [107]            ADD     HL,BC           ; Address of end of string+1
F2F1: 50       [111]            LD      D,B             ; String address to DE
F2F2: 59       [115]            LD      E,C
F2F3: 2B       [121]            DEC     HL              ; Last byte in string
F2F4: 44       [125]            LD      B,H             ; Address to BC
F2F5: 4D       [129]            LD      C,L
F2F6: 2AC310   [145]            LD      HL,(STRBOT)     ; Current bottom of string area
F2F9: CD7CE3   [162]            CALL    MOVSTR          ; Move string to new address
F2FC: E1       [172]            POP     HL              ; Restore variable address
F2FD: 71       [179]            LD      (HL),C          ; Save new LSB of address
F2FE: 23       [185]            INC     HL
F2FF: 70       [192]            LD      (HL),B          ; Save new MSB of address
F300: 69       [196]            LD      L,C             ; Next string area+1 to HL
F301: 60       [200]            LD      H,B
F302: 2B       [206]            DEC     HL              ; Next string area address
F303: C356F2   [216]            JP      GARBLP          ; Look for more strings
                        
F306: C5       [11]     CONCAT: PUSH    BC              ; Save prec' opr & code string
F307: E5       [22]             PUSH    HL              ; 
F308: 2AE410   [38]             LD      HL,(FPREG)      ; Get first string
F30B: E3       [57]             EX      (SP),HL         ; Save first string
F30C: CDD1ED   [74]             CALL    OPRND           ; Get second string
F30F: E3       [93]             EX      (SP),HL         ; Restore first string
F310: CD45ED   [110]            CALL    TSTSTR          ; Make sure it's a string
F313: 7E       [117]            LD      A,(HL)          ; Get length of second string
F314: E5       [128]            PUSH    HL              ; Save first string
F315: 2AE410   [144]            LD      HL,(FPREG)      ; Get second string
F318: E5       [155]            PUSH    HL              ; Save second string
F319: 86       [162]            ADD     A,(HL)          ; Add length of second string
F31A: 1E1C     [169]            LD      E,LS            ; ?LS Error
F31C: DAC1E3   [179|179]        JP      C,ERROR         ; String too long - Error
F31F: CDBFF1   [196]            CALL    MKTMST          ; Make temporary string
F322: D1       [206]            POP     DE              ; Get second string to DE
F323: CD57F3   [223]            CALL    GSTRDE          ; Move to string pool if needed
F326: E3       [242]            EX      (SP),HL         ; Get first string
F327: CD56F3   [259]            CALL    GSTRHL          ; Move to string pool if needed
F32A: E5       [270]            PUSH    HL              ; Save first string
F32B: 2AC110   [286]            LD      HL,(TMPSTR+2)   ; Temporary string address
F32E: EB       [290]            EX      DE,HL           ; To DE
F32F: CD3DF3   [307]            CALL    SSTSA           ; First string to string area
F332: CD3DF3   [324]            CALL    SSTSA           ; Second string to string area
F335: 2166ED   [334]            LD      HL,EVAL2        ; Return to evaluation loop
F338: E3       [353]            EX      (SP),HL         ; Save return,get code string
F339: E5       [364]            PUSH    HL              ; Save code string address
F33A: C3F0F1   [374]            JP      TSTOPL          ; To temporary string to pool
                        
F33D: E1       [10]     SSTSA:  POP     HL              ; Return address
F33E: E3       [29]             EX      (SP),HL         ; Get string block,save return
F33F: 7E       [36]             LD      A,(HL)          ; Get length of string
F340: 23       [42]             INC     HL
F341: 23       [48]             INC     HL
F342: 4E       [55]             LD      C,(HL)          ; Get LSB of string address
F343: 23       [61]             INC     HL
F344: 46       [68]             LD      B,(HL)          ; Get MSB of string address
F345: 6F       [72]             LD      L,A             ; Length to L
F346: 2C       [ 4]     TOSTRA: INC     L               ; INC - DECed after
F347: 2D       [ 4]     TSALP:  DEC     L               ; Count bytes moved
F348: C8       [ 9|15]          RET     Z               ; End of string - Return
F349: 0A       [16]             LD      A,(BC)          ; Get source
F34A: 12       [23]             LD      (DE),A          ; Save destination
F34B: 03       [29]             INC     BC              ; Next source
F34C: 13       [35]             INC     DE              ; Next destination
F34D: C347F3   [45]             JP      TSALP           ; Loop until string moved
                        
F350: CD45ED   [17]     GETSTR: CALL    TSTSTR          ; Make sure it's a string
F353: 2AE410   [16]     GSTRCU: LD      HL,(FPREG)      ; Get current string
F356: EB       [ 4]     GSTRHL: EX      DE,HL           ; Save DE
F357: CD71F3   [17]     GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
F35A: EB       [21]             EX      DE,HL           ; Restore DE
F35B: C0       [26|32]          RET     NZ              ; No - Return
F35C: D5       [37]             PUSH    DE              ; Save string
F35D: 50       [41]             LD      D,B             ; String block address to DE
F35E: 59       [45]             LD      E,C
F35F: 1B       [51]             DEC     DE              ; Point to length
F360: 4E       [58]             LD      C,(HL)          ; Get string length
F361: 2AC310   [74]             LD      HL,(STRBOT)     ; Current bottom of string area
F364: CD8AE6   [91]             CALL    CPDEHL          ; Last one in string area?
F367: C26FF3   [101|101]        JP      NZ,POPHL        ; No - Return
F36A: 47       [105]            LD      B,A             ; Clear B (A=0)
F36B: 09       [116]            ADD     HL,BC           ; Remove string from str' area
F36C: 22C310   [132]            LD      (STRBOT),HL     ; Save new bottom of str' area
F36F: E1       [10]     POPHL:  POP     HL              ; Restore string
F370: C9       [20]             RET
                        
F371: 2AB110   [16]     BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
F374: 2B       [22]             DEC     HL              ; Back
F375: 46       [29]             LD      B,(HL)          ; Get MSB of address
F376: 2B       [35]             DEC     HL              ; Back
F377: 4E       [42]             LD      C,(HL)          ; Get LSB of address
F378: 2B       [48]             DEC     HL              ; Back
F379: 2B       [54]             DEC     HL              ; Back
F37A: CD8AE6   [71]             CALL    CPDEHL          ; String last in string pool?
F37D: C0       [76|82]          RET     NZ              ; Yes - Leave it
F37E: 22B110   [92]             LD      (TMSTPT),HL     ; Save new string pool top
F381: C9       [102]            RET
                        
F382: 0101F1   [10]     LEN:    LD      BC,PASSA        ; To return integer A
F385: C5       [21]             PUSH    BC              ; Save address
F386: CD50F3   [17]     GETLEN: CALL    GETSTR          ; Get string and its length
F389: AF       [21]             XOR     A
F38A: 57       [25]             LD      D,A             ; Clear D
F38B: 32AD10   [38]             LD      (TYPE),A        ; Set type to numeric
F38E: 7E       [45]             LD      A,(HL)          ; Get length of string
F38F: B7       [49]             OR      A               ; Set status flags
F390: C9       [59]             RET
                        
F391: 0101F1   [10]     ASC:    LD      BC,PASSA        ; To return integer A
F394: C5       [21]             PUSH    BC              ; Save address
F395: CD86F3   [17]     GTFLNM: CALL    GETLEN          ; Get length of string
F398: CAA0E9   [27|27]          JP      Z,FCERR         ; Null string - Error
F39B: 23       [33]             INC     HL
F39C: 23       [39]             INC     HL
F39D: 5E       [46]             LD      E,(HL)          ; Get LSB of address
F39E: 23       [52]             INC     HL
F39F: 56       [59]             LD      D,(HL)          ; Get MSB of address
F3A0: 1A       [66]             LD      A,(DE)          ; Get first byte of string
F3A1: C9       [76]             RET
                        
F3A2: 3E01     [ 7]     CHR:    LD      A,1             ; One character string
F3A4: CDBFF1   [24]             CALL    MKTMST          ; Make a temporary string
F3A7: CD87F4   [41]             CALL    MAKINT          ; Make it integer A
F3AA: 2AC110   [57]             LD      HL,(TMPSTR+2)   ; Get address of string
F3AD: 73       [64]             LD      (HL),E          ; Save character
F3AE: C1       [10]     TOPOOL: POP     BC              ; Clean up stack
F3AF: C3F0F1   [20]             JP      TSTOPL          ; Temporary string to pool
                        
F3B2: CD37F4   [17]     LEFT:   CALL    LFRGNM          ; Get number and ending ")"
F3B5: AF       [21]             XOR     A               ; Start at first byte in string
F3B6: E3       [19]     RIGHT1: EX      (SP),HL         ; Save code string,Get string
F3B7: 4F       [23]             LD      C,A             ; Starting position in string
F3B8: E5       [11]     MID1:   PUSH    HL              ; Save string block address
F3B9: 7E       [18]             LD      A,(HL)          ; Get length of string
F3BA: B8       [22]             CP      B               ; Compare with number given
F3BB: DAC0F3   [32|32]          JP      C,ALLFOL        ; All following bytes required
F3BE: 78       [36]             LD      A,B             ; Get new length
F3BF: 11                        DB      11H             ; Skip "LD C,0"
F3C0: 0E00     [ 7]     ALLFOL: LD      C,0             ; First byte of string
F3C2: C5       [18]             PUSH    BC              ; Save position in string
F3C3: CD29F2   [35]             CALL    TESTR           ; See if enough string space
F3C6: C1       [45]             POP     BC              ; Get position in string
F3C7: E1       [55]             POP     HL              ; Restore string block address
F3C8: E5       [66]             PUSH    HL              ; And re-save it
F3C9: 23       [72]             INC     HL
F3CA: 23       [78]             INC     HL
F3CB: 46       [85]             LD      B,(HL)          ; Get LSB of address
F3CC: 23       [91]             INC     HL
F3CD: 66       [98]             LD      H,(HL)          ; Get MSB of address
F3CE: 68       [102]            LD      L,B             ; HL = address of string
F3CF: 0600     [109]            LD      B,0             ; BC = starting address
F3D1: 09       [120]            ADD     HL,BC           ; Point to that byte
F3D2: 44       [124]            LD      B,H             ; BC = source string
F3D3: 4D       [128]            LD      C,L
F3D4: CDC2F1   [145]            CALL    CRTMST          ; Create a string entry
F3D7: 6F       [149]            LD      L,A             ; Length of new string
F3D8: CD46F3   [166]            CALL    TOSTRA          ; Move string to string area
F3DB: D1       [176]            POP     DE              ; Clear stack
F3DC: CD57F3   [193]            CALL    GSTRDE          ; Move to string pool if needed
F3DF: C3F0F1   [203]            JP      TSTOPL          ; Temporary string to pool
                        
F3E2: CD37F4   [17]     RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
F3E5: D1       [27]             POP     DE              ; Get string length
F3E6: D5       [38]             PUSH    DE              ; And re-save
F3E7: 1A       [45]             LD      A,(DE)          ; Get length
F3E8: 90       [49]             SUB     B               ; Move back N bytes
F3E9: C3B6F3   [59]             JP      RIGHT1          ; Go and get sub-string
                        
F3EC: EB       [ 4]     MID:    EX      DE,HL           ; Get code string address
F3ED: 7E       [11]             LD      A,(HL)          ; Get next byte "," or ")"
F3EE: CD3CF4   [28]             CALL    MIDNUM          ; Get number supplied
F3F1: 04       [32]             INC     B               ; Is it character zero?
F3F2: 05       [36]             DEC     B
F3F3: CAA0E9   [46|46]          JP      Z,FCERR         ; Yes - Error
F3F6: C5       [57]             PUSH    BC              ; Save starting position
F3F7: 1EFF     [64]             LD      E,255           ; All of string
F3F9: FE29     [71]             CP      ")"             ; Any length given?
F3FB: CA05F4   [81|81]          JP      Z,RSTSTR        ; No - Rest of string
F3FE: CD90E6   [98]             CALL    CHKSYN          ; Make sure "," follows
F401: 2C                        DB      ","
F402: CD84F4   [115]            CALL    GETINT          ; Get integer 0-255
F405: CD90E6   [17]     RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
F408: 29                        DB      ")"
F409: F1       [27]             POP     AF              ; Restore starting position
F40A: E3       [46]             EX      (SP),HL         ; Get string,8ave code string
F40B: 01B8F3   [56]             LD      BC,MID1         ; Continuation of MID$ routine
F40E: C5       [67]             PUSH    BC              ; Save for return
F40F: 3D       [71]             DEC     A               ; Starting position-1
F410: BE       [78]             CP      (HL)            ; Compare with length
F411: 0600     [85]             LD      B,0             ; Zero bytes length
F413: D0       [90|96]          RET     NC              ; Null string if start past end
F414: 4F       [94]             LD      C,A             ; Save starting position-1
F415: 7E       [101]            LD      A,(HL)          ; Get length of string
F416: 91       [105]            SUB     C               ; Subtract start
F417: BB       [109]            CP      E               ; Enough string for it?
F418: 47       [113]            LD      B,A             ; Save maximum length available
F419: D8       [118|124]        RET     C               ; Truncate string if needed
F41A: 43       [122]            LD      B,E             ; Set specified length
F41B: C9       [132]            RET                     ; Go and create string
                        
F41C: CD86F3   [17]     VAL:    CALL    GETLEN          ; Get length of string
F41F: CA33F6   [27|27]          JP      Z,RESZER        ; Result zero
F422: 5F       [31]             LD      E,A             ; Save length
F423: 23       [37]             INC     HL
F424: 23       [43]             INC     HL
F425: 7E       [50]             LD      A,(HL)          ; Get LSB of address
F426: 23       [56]             INC     HL
F427: 66       [63]             LD      H,(HL)          ; Get MSB of address
F428: 6F       [67]             LD      L,A             ; HL = String address
F429: E5       [78]             PUSH    HL              ; Save string address
F42A: 19       [89]             ADD     HL,DE
F42B: 46       [96]             LD      B,(HL)          ; Get end of string+1 byte
F42C: 72       [103]            LD      (HL),D          ; Zero it to terminate
F42D: E3       [122]            EX      (SP),HL         ; Save string end,get start
F42E: C5       [133]            PUSH    BC              ; Save end+1 byte
F42F: 7E       [140]            LD      A,(HL)          ; Get starting byte
F430: CD1AF9   [157]            CALL    ASCTFP          ; Convert ASCII string to FP
F433: C1       [167]            POP     BC              ; Restore end+1 byte
F434: E1       [177]            POP     HL              ; Restore end+1 address
F435: 70       [184]            LD      (HL),B          ; Put back original byte
F436: C9       [194]            RET
                        
F437: EB       [ 4]     LFRGNM: EX      DE,HL           ; Code string address to HL
F438: CD90E6   [21]             CALL    CHKSYN          ; Make sure ")" follows
F43B: 29                        DB      ")"
F43C: C1       [10]     MIDNUM: POP     BC              ; Get return address
F43D: D1       [20]             POP     DE              ; Get number supplied
F43E: C5       [31]             PUSH    BC              ; Re-save return address
F43F: 43       [35]             LD      B,E             ; Number to B
F440: C9       [45]             RET
                        
F441: CD87F4   [17]     INP:    CALL    MAKINT          ; Make it integer A
F444: 323F10   [30]             LD      (INPORT),A      ; Set input port
F447: CD3E10   [47]             CALL    INPSUB          ; Get input from port
F44A: C301F1   [57]             JP      PASSA           ; Return integer A
                        
F44D: CD71F4   [17]     POUT:   CALL    SETIO           ; Set up port number
F450: C30610   [27]             JP      OUTSUB          ; Output data and return
                        
F453: CD71F4   [17]     WAIT:   CALL    SETIO           ; Set up port number
F456: F5       [28]             PUSH    AF              ; Save AND mask
F457: 1E00     [35]             LD      E,0             ; Assume zero if none given
F459: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
F45A: CD36E8   [58]             CALL    GETCHR          ; Get next character
F45D: CA67F4   [68|68]          JP      Z,NOXOR         ; No XOR byte given
F460: CD90E6   [85]             CALL    CHKSYN          ; Make sure "," follows
F463: 2C                        DB      ","
F464: CD84F4   [102]            CALL    GETINT          ; Get integer 0-255 to XOR with
F467: C1       [10]     NOXOR:  POP     BC              ; Restore AND mask
F468: CD3E10   [17]     WAITLP: CALL    INPSUB          ; Get input
F46B: AB       [21]             XOR     E               ; Flip selected bits
F46C: A0       [25]             AND     B               ; Result non-zero?
F46D: CA68F4   [35|35]          JP      Z,WAITLP        ; No = keep waiting
F470: C9       [45]             RET
                        
F471: CD84F4   [17]     SETIO:  CALL    GETINT          ; Get integer 0-255
F474: 323F10   [30]             LD      (INPORT),A      ; Set input port
F477: 320710   [43]             LD      (OTPORT),A      ; Set output port
F47A: CD90E6   [60]             CALL    CHKSYN          ; Make sure "," follows
F47D: 2C                        DB      ","
F47E: C384F4   [70]             JP      GETINT          ; Get integer 0-255 and return
                        
F481: CD36E8   [17]     FNDNUM: CALL    GETCHR          ; Get next character
F484: CD41ED   [17]     GETINT: CALL    GETNUM          ; Get a number from 0 to 255
F487: CD85E9   [17]     MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
F48A: 7A       [21]             LD      A,D             ; Get MSB of number
F48B: B7       [25]             OR      A               ; Zero?
F48C: C2A0E9   [35|35]          JP      NZ,FCERR        ; No - Error
F48F: 2B       [41]             DEC     HL              ; DEC 'cos GETCHR INCs
F490: CD36E8   [58]             CALL    GETCHR          ; Get next character
F493: 7B       [62]             LD      A,E             ; Get number to A
F494: C9       [72]             RET
                        
                        ; << NO  REFERENCE  TO  THIS  SECTION  OF  CODE >>
                        ; << Set up another program area (can be in ROM) >>
                        
F495: 2A5E10   [88]             LD      HL,(BASTXT)     ; Get start of program text
F498: 22D610   [104]            LD      (PROGND),HL     ; Set more variable space
F49B: 210080   [114]            LD      HL,8000H        ; Address of new program
F49E: 5E       [121]            LD      E,(HL)          ; Get LSB of new RAM end
F49F: 23       [127]            INC     HL
F4A0: 56       [134]            LD      D,(HL)          ; Get MSB of new RAM end
F4A1: 23       [140]            INC     HL
F4A2: 23       [146]            INC     HL              ; Null at start of program
F4A3: 225E10   [162]            LD      (BASTXT),HL     ; New program text area 8003H
F4A6: EB       [166]            EX      DE,HL           ; New RAM end to HL
F4A7: 22AF10   [182]            LD      (LSTRAM),HL     ; Set new RAM end
F4AA: 225A10   [198]            LD      (STRSPC),HL     ; Clear string space
F4AD: 01F2E7   [208]            LD      BC,RUNCNT       ; Execution driver loop
F4B0: C5       [219]            PUSH    BC              ; Save for return
F4B1: C3C5E4   [229]            JP      RUNFST          ; Clear variables and continue
                        
F4B4: C356FD   [10]     RUART:  JP      GUART           ; Get a byte from UART
                        
F4B7: CDBAF4   [17]     WUART2: CALL    WUART           ; Send 2 Bytes to UART
F4BA: F5       [11]     WUART:  PUSH    AF              ; Save byte
F4BB: C5       [22]             PUSH    BC              ; Save BC
F4BC: 4F       [26]             LD      C,A             ; Byte to C
F4BD: CD68FD   [43]             CALL    SUART           ; Send byte to UART
F4C0: C1       [53]             POP     BC              ; Restore BC
F4C1: F1       [63]             POP     AF              ; Restore byte
F4C2: C9       [73]             RET
                        
F4C3: 0601     [ 7]     CSAVE:  LD      B,1             ; Flag "CSAVE"
F4C5: FEAE     [14]             CP      ZTIMES          ; "*" token? ("CSAVE*")
F4C7: CABBE8   [24|24]          JP      Z,ARRSV1        ; Yes - Array save
F4CA: CD5AED   [41]             CALL    EVAL            ; Evaluate expression
F4CD: E5       [52]             PUSH    HL              ; Save code string address
F4CE: CD95F3   [69]             CALL    GTFLNM          ; Get file name
F4D1: D5       [80]             PUSH    DE              ; Save file name
F4D2: CDC8FC   [97]             CALL    CASFFW          ; Turn on motor and wait
F4D5: D1       [107]            POP     DE              ; Restore file name
F4D6: 3ED3     [114]            LD      A,11010011B     ; Header byte
F4D8: CDBAF4   [131]            CALL    WUART           ; Send byte to UART
F4DB: CDB7F4   [148]            CALL    WUART2          ; Send byte twice more
F4DE: 1A       [155]            LD      A,(DE)          ; Get file name
F4DF: CDBAF4   [172]            CALL    WUART           ; Send it to UART
F4E2: 00       [176]            NOP
F4E3: 00       [180]            NOP
F4E4: 00       [184]            NOP
F4E5: 21D610   [194]            LD      HL,PROGND       ; Start of program information
F4E8: 220C0C   [210]            LD      (ARG1),HL       ; Save for monitor save routine
F4EB: 2AD610   [226]            LD      HL,(PROGND)     ; End of program information
F4EE: 220E0C   [242]            LD      (ARG2),HL       ; Save for monitor save routine
F4F1: CD73FE   [259]            CALL    SAVE            ; Save program to tape
F4F4: CDD8FC   [276]            CALL    ARET            ; Not much there!
F4F7: E1       [286]            POP     HL              ; Restore code string address
F4F8: C9       [296]            RET
                        
F4F9: 7E       [ 7]     CLOAD:  LD      A,(HL)          ; Get byte after "CLOAD"
F4FA: FEAE     [14]             CP      ZTIMES          ; "*" token? ("CLOAD*")
F4FC: CAB9E8   [24|24]          JP      Z,ARRLD1        ; Yes - Array load
F4FF: CDD1FF   [41]             CALL    SMOTOR          ; Start motor and get "?"
F502: D69E     [48]             SUB     ZPRINT          ; "?" ("PRINT" token) Verify?
F504: CA09F5   [58|58]          JP      Z,FLGVER        ; Yes - Flag "verify"
F507: AF       [62]             XOR     A               ; Flag "load"
F508: 01                        DB      01H             ; Skip "CPL" and "INC HL"
F509: 2F       [ 4]     FLGVER: CPL                     ; Flag "verify"
F50A: 23       [10]             INC     HL              ; Skip over "?"
F50B: F5       [21]             PUSH    AF              ; Save verify flag
F50C: 2B       [27]             DEC     HL              ; DEC 'cos GETCHR INCs
F50D: CD36E8   [44]             CALL    GETCHR          ; Get next character
F510: 3E00     [51]             LD      A,0             ; Any file will do
F512: CA1CF5   [61|61]          JP      Z,ANYNAM        ; No name given - Any will do
F515: CD5AED   [78]             CALL    EVAL            ; Evaluate expression
F518: CD95F3   [95]             CALL    GTFLNM          ; Get file name
F51B: 1A       [102]            LD      A,(DE)          ; Get first byte of name
F51C: 6F       [ 4]     ANYNAM: LD      L,A             ; Save name to find
F51D: F1       [14]             POP     AF              ; Get verify flag
F51E: F5       [25]             PUSH    AF              ; And re-save
F51F: B7       [29]             OR      A               ; Verify of load?
F520: 67       [33]             LD      H,A
F521: 22E410   [49]             LD      (FPREG),HL      ; Save nam of file to find
F524: CCBAE4   [59|66]          CALL    Z,CLRPTR        ; Load - Clear pointers
F527: 2AE410   [75]             LD      HL,(FPREG)      ; Get name of program to find
F52A: EB       [79]             EX      DE,HL           ; Name to DE
F52B: 0603     [ 7]     CLOAD1: LD      B,3             ; 3 Header bytes
F52D: CDB4F4   [17]     CLOAD2: CALL    RUART           ; Get a byte from UART
F530: D6D3     [24]             SUB     11010011B       ; Header byte?
F532: C22BF5   [34|34]          JP      NZ,CLOAD1       ; Look for header
F535: 05       [38]             DEC     B               ; Count header bytes
F536: C22DF5   [48|48]          JP      NZ,CLOAD2       ; More to find?
F539: CDB4F4   [65]             CALL    RUART           ; Get name of file
F53C: CD74F5   [82]             CALL    FILFND          ; Display "file X found"
F53F: 1C       [86]             INC     E               ; Any file name given?
F540: 1D       [90]             DEC     E
F541: CA48F5   [100|100]        JP      Z,THSFIL        ; No - This file will do
F544: BB       [104]            CP      E               ; Has file been found?
F545: C22BF5   [114|114]        JP      NZ,CLOAD1       ; No - Look for another
F548: 00       [ 4]     THSFIL: NOP
F549: 00       [ 8]             NOP
F54A: 00       [12]             NOP
F54B: F1       [22]             POP     AF              ; Get verify flag
F54C: B7       [26]             OR      A               ; Load or verify?
F54D: C25CF5   [36|36]          JP      NZ,CLOADV       ; Verify program
F550: CD88FE   [53]             CALL    MONLD           ; Use monitor to load program
F553: 2AD610   [69]             LD      HL,(PROGND)     ; Get end of program
F556: CD93E3   [86]             CALL    ENFMEM          ; See if enough memory
F559: C35FF5   [96]             JP      CLOADE          ; "Ok" and set up pointers
                        
F55C: CDAAFE   [17]     CLOADV: CALL    MONVE           ; Use monitor to verify program
F55F: 214BE3   [10]     CLOADE: LD      HL,OKMSG        ; "Ok" message
F562: CD10F2   [27]             CALL    PRS             ; Output string
F565: CDD8FC   [44]             CALL    ARET            ; Not a lot there!
F568: C37CE4   [54]             JP      SETPTR          ; Set up line pointers
                        
F56B: 219DF5   [10]     OUTBAD: LD      HL,BAD          ; "Bad" message
F56E: CD10F2   [27]             CALL    PRS             ; Output string
F571: C3E1E3   [37]             JP      ERRIN           ; In line message
                        
F574: C5       [11]     FILFND: PUSH    BC              ; <- Save
F575: E5       [22]             PUSH    HL              ; <- all
F576: D5       [33]             PUSH    DE              ; <- the
F577: F5       [44]             PUSH    AF              ; <- registers
F578: 218EF5   [54]             LD      HL,FILE         ; "File" message
F57B: CD10F2   [71]             CALL    PRS             ; Output string
F57E: F1       [81]             POP     AF              ; Get file name
F57F: F5       [92]             PUSH    AF              ; And re-save
F580: CDD9FC   [109]            CALL    CONMON          ; Output file name to screen
F583: 2194F5   [119]            LD      HL,FOUND        ; "Found" message
F586: CD10F2   [136]            CALL    PRS             ; Output string
F589: F1       [146]            POP     AF              ; <- Restore
F58A: D1       [156]            POP     DE              ; <- all
F58B: E1       [166]            POP     HL              ; <- the
F58C: C1       [176]            POP     BC              ; <- registers
F58D: C9       [186]            RET
                        
F58E: 46696C65          FILE:   DB      "File ",0
F592: 2000              
F594: 20466F75          FOUND:  DB      " Found",CR,LF,0
F598: 6E640D0A          
F59C: 00                
F59D: 42616400          BAD:    DB      "Bad",0,0,0
F5A1: 0000              
                        
F5A3: CD8BE9   [17]     PEEK:   CALL    DEINT           ; Get memory address
F5A6: 1A       [24]             LD      A,(DE)          ; Get byte in memory
F5A7: C301F1   [34]             JP      PASSA           ; Return integer A
                        
F5AA: CD41ED   [17]     POKE:   CALL    GETNUM          ; Get memory address
F5AD: CD8BE9   [34]             CALL    DEINT           ; Get integer -32768 to 3276
F5B0: D5       [45]             PUSH    DE              ; Save memory address
F5B1: CD90E6   [62]             CALL    CHKSYN          ; Make sure "," follows
F5B4: 2C                        DB      ","
F5B5: CD84F4   [79]             CALL    GETINT          ; Get integer 0-255
F5B8: D1       [89]             POP     DE              ; Restore memory address
F5B9: 12       [96]             LD      (DE),A          ; Load it into memory
F5BA: C9       [106]            RET
                        
F5BB: 2191FA   [10]     ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
F5BE: CD62F8   [17]     ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
F5C1: C3CDF5   [27]             JP      FPADD           ; Add BCDE to FPREG
                        
F5C4: CD62F8   [17]     SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
F5C7: 21                        DB      21H             ; Skip "POP BC" and "POP DE"
F5C8: C1       [10]     PSUB:   POP     BC              ; Get FP number from stack
F5C9: D1       [20]             POP     DE
F5CA: CD3CF8   [17]     SUBCDE: CALL    INVSGN          ; Negate FPREG
F5CD: 78       [ 4]     FPADD:  LD      A,B             ; Get FP exponent
F5CE: B7       [ 8]             OR      A               ; Is number zero?
F5CF: C8       [13|19]          RET     Z               ; Yes - Nothing to add
F5D0: 3AE710   [26]             LD      A,(FPEXP)       ; Get FPREG exponent
F5D3: B7       [30]             OR      A               ; Is this number zero?
F5D4: CA54F8   [40|40]          JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
F5D7: 90       [44]             SUB     B               ; BCDE number larger?
F5D8: D2E7F5   [54|54]          JP      NC,NOSWAP       ; No - Don't swap them
F5DB: 2F       [58]             CPL                     ; Two's complement
F5DC: 3C       [62]             INC     A               ;  FP exponent
F5DD: EB       [66]             EX      DE,HL
F5DE: CD44F8   [83]             CALL    STAKFP          ; Put FPREG on stack
F5E1: EB       [87]             EX      DE,HL
F5E2: CD54F8   [104]            CALL    FPBCDE          ; Move BCDE to FPREG
F5E5: C1       [114]            POP     BC              ; Restore number from stack
F5E6: D1       [124]            POP     DE
F5E7: FE19     [ 7]     NOSWAP: CP      24+1            ; Second number insignificant?
F5E9: D0       [12|18]          RET     NC              ; Yes - First number is result
F5EA: F5       [23]             PUSH    AF              ; Save number of bits to scale
F5EB: CD79F8   [40]             CALL    SIGNS           ; Set MSBs & sign of result
F5EE: 67       [44]             LD      H,A             ; Save sign of result
F5EF: F1       [54]             POP     AF              ; Restore scaling factor
F5F0: CD92F6   [71]             CALL    SCALE           ; Scale BCDE to same exponent
F5F3: B4       [75]             OR      H               ; Result to be positive?
F5F4: 21E410   [85]             LD      HL,FPREG        ; Point to FPREG
F5F7: F20DF6   [95|95]          JP      P,MINCDE        ; No - Subtract FPREG from CDE
F5FA: CD72F6   [112]            CALL    PLUCDE          ; Add FPREG to CDE
F5FD: D253F6   [122|122]        JP      NC,RONDUP       ; No overflow - Round it up
F600: 23       [128]            INC     HL              ; Point to exponent
F601: 34       [139]            INC     (HL)            ; Increment it
F602: CABCE3   [149|149]        JP      Z,OVERR         ; Number overflowed - Error
F605: 2E01     [156]            LD      L,1             ; 1 bit to shift right
F607: CDA8F6   [173]            CALL    SHRT1           ; Shift result right
F60A: C353F6   [183]            JP      RONDUP          ; Round it up
                        
F60D: AF       [ 4]     MINCDE: XOR     A               ; Clear A and carry
F60E: 90       [ 8]             SUB     B               ; Negate exponent
F60F: 47       [12]             LD      B,A             ; Re-save exponent
F610: 7E       [19]             LD      A,(HL)          ; Get LSB of FPREG
F611: 9B       [23]             SBC     A, E            ; Subtract LSB of BCDE
F612: 5F       [27]             LD      E,A             ; Save LSB of BCDE
F613: 23       [33]             INC     HL
F614: 7E       [40]             LD      A,(HL)          ; Get NMSB of FPREG
F615: 9A       [44]             SBC     A,D             ; Subtract NMSB of BCDE
F616: 57       [48]             LD      D,A             ; Save NMSB of BCDE
F617: 23       [54]             INC     HL
F618: 7E       [61]             LD      A,(HL)          ; Get MSB of FPREG
F619: 99       [65]             SBC     A,C             ; Subtract MSB of BCDE
F61A: 4F       [69]             LD      C,A             ; Save MSB of BCDE
F61B: DC7EF6   [10|17]  CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
                        
F61E: 68       [ 4]     BNORM:  LD      L,B             ; L = Exponent
F61F: 63       [ 8]             LD      H,E             ; H = LSB
F620: AF       [12]             XOR     A
F621: 47       [ 4]     BNRMLP: LD      B,A             ; Save bit count
F622: 79       [ 8]             LD      A,C             ; Get MSB
F623: B7       [12]             OR      A               ; Is it zero?
F624: C240F6   [22|22]          JP      NZ,PNORM        ; No - Do it bit at a time
F627: 4A       [26]             LD      C,D             ; MSB = NMSB
F628: 54       [30]             LD      D,H             ; NMSB= LSB
F629: 65       [34]             LD      H,L             ; LSB = VLSB
F62A: 6F       [38]             LD      L,A             ; VLSB= 0
F62B: 78       [42]             LD      A,B             ; Get exponent
F62C: D608     [49]             SUB     8               ; Count 8 bits
F62E: FEE0     [56]             CP      -24-8           ; Was number zero?
F630: C221F6   [66|66]          JP      NZ,BNRMLP       ; No - Keep normalising
F633: AF       [ 4]     RESZER: XOR     A               ; Result is zero
F634: 32E710   [13]     SAVEXP: LD      (FPEXP),A       ; Save result as zero
F637: C9       [23]             RET
                        
F638: 05       [ 4]     NORMAL: DEC     B               ; Count bits
F639: 29       [15]             ADD     HL,HL           ; Shift HL left
F63A: 7A       [19]             LD      A,D             ; Get NMSB
F63B: 17       [23]             RLA                     ; Shift left with last bit
F63C: 57       [27]             LD      D,A             ; Save NMSB
F63D: 79       [31]             LD      A,C             ; Get MSB
F63E: 8F       [35]             ADC     A,A             ; Shift left with last bit
F63F: 4F       [39]             LD      C,A             ; Save MSB
F640: F238F6   [10|10]  PNORM:  JP      P,NORMAL        ; Not done - Keep going
F643: 78       [14]             LD      A,B             ; Number of bits shifted
F644: 5C       [18]             LD      E,H             ; Save HL in EB
F645: 45       [22]             LD      B,L
F646: B7       [26]             OR      A               ; Any shifting done?
F647: CA53F6   [36|36]          JP      Z,RONDUP        ; No - Round it up
F64A: 21E710   [46]             LD      HL,FPEXP        ; Point to exponent
F64D: 86       [53]             ADD     A,(HL)          ; Add shifted bits
F64E: 77       [60]             LD      (HL),A          ; Re-save exponent
F64F: D233F6   [70|70]          JP      NC,RESZER       ; Underflow - Result is zero
F652: C8       [75|81]          RET     Z               ; Result is zero
F653: 78       [ 4]     RONDUP: LD      A,B             ; Get VLSB of number
F654: 21E710   [10]     RONDB:  LD      HL,FPEXP        ; Point to exponent
F657: B7       [14]             OR      A               ; Any rounding?
F658: FC65F6   [24|31]          CALL    M,FPROND        ; Yes - Round number up
F65B: 46       [31]             LD      B,(HL)          ; B = Exponent
F65C: 23       [37]             INC     HL
F65D: 7E       [44]             LD      A,(HL)          ; Get sign of result
F65E: E680     [51]             AND     10000000B       ; Only bit 7 needed
F660: A9       [55]             XOR     C               ; Set correct sign
F661: 4F       [59]             LD      C,A             ; Save correct sign in number
F662: C354F8   [69]             JP      FPBCDE          ; Move BCDE to FPREG
                        
F665: 1C       [ 4]     FPROND: INC     E               ; Round LSB
F666: C0       [ 9|15]          RET     NZ              ; Return if ok
F667: 14       [13]             INC     D               ; Round NMSB
F668: C0       [18|24]          RET     NZ              ; Return if ok
F669: 0C       [22]             INC     C               ; Round MSB
F66A: C0       [27|33]          RET     NZ              ; Return if ok
F66B: 0E80     [34]             LD      C,80H           ; Set normal value
F66D: 34       [45]             INC     (HL)            ; Increment exponent
F66E: C0       [50|56]          RET     NZ              ; Return if ok
F66F: C3BCE3   [60]             JP      OVERR           ; Overflow error
                        
F672: 7E       [ 7]     PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
F673: 83       [11]             ADD     A,E             ; Add LSB of BCDE
F674: 5F       [15]             LD      E,A             ; Save LSB of BCDE
F675: 23       [21]             INC     HL
F676: 7E       [28]             LD      A,(HL)          ; Get NMSB of FPREG
F677: 8A       [32]             ADC     A,D             ; Add NMSB of BCDE
F678: 57       [36]             LD      D,A             ; Save NMSB of BCDE
F679: 23       [42]             INC     HL
F67A: 7E       [49]             LD      A,(HL)          ; Get MSB of FPREG
F67B: 89       [53]             ADC     A,C             ; Add MSB of BCDE
F67C: 4F       [57]             LD      C,A             ; Save MSB of BCDE
F67D: C9       [67]             RET
                        
F67E: 21E810   [10]     COMPL:  LD      HL,SGNRES       ; Sign of result
F681: 7E       [17]             LD      A,(HL)          ; Get sign of result
F682: 2F       [21]             CPL                     ; Negate it
F683: 77       [28]             LD      (HL),A          ; Put it back
F684: AF       [32]             XOR     A
F685: 6F       [36]             LD      L,A             ; Set L to zero
F686: 90       [40]             SUB     B               ; Negate exponent,set carry
F687: 47       [44]             LD      B,A             ; Re-save exponent
F688: 7D       [48]             LD      A,L             ; Load zero
F689: 9B       [52]             SBC     A,E             ; Negate LSB
F68A: 5F       [56]             LD      E,A             ; Re-save LSB
F68B: 7D       [60]             LD      A,L             ; Load zero
F68C: 9A       [64]             SBC     A,D             ; Negate NMSB
F68D: 57       [68]             LD      D,A             ; Re-save NMSB
F68E: 7D       [72]             LD      A,L             ; Load zero
F68F: 99       [76]             SBC     A,C             ; Negate MSB
F690: 4F       [80]             LD      C,A             ; Re-save MSB
F691: C9       [90]             RET
                        
F692: 0600     [ 7]     SCALE:  LD      B,0             ; Clear underflow
F694: D608     [ 7]     SCALLP: SUB     8               ; 8 bits (a whole byte)?
F696: DAA1F6   [17|17]          JP      C,SHRITE        ; No - Shift right A bits
F699: 43       [21]             LD      B,E             ; <- Shift
F69A: 5A       [25]             LD      E,D             ; <- right
F69B: 51       [29]             LD      D,C             ; <- eight
F69C: 0E00     [36]             LD      C,0             ; <- bits
F69E: C394F6   [46]             JP      SCALLP          ; More bits to shift
                        
F6A1: C609     [ 7]     SHRITE: ADD     A,8+1           ; Adjust count
F6A3: 6F       [11]             LD      L,A             ; Save bits to shift
F6A4: AF       [ 4]     SHRLP:  XOR     A               ; Flag for all done
F6A5: 2D       [ 8]             DEC     L               ; All shifting done?
F6A6: C8       [13|19]          RET     Z               ; Yes - Return
F6A7: 79       [17]             LD      A,C             ; Get MSB
F6A8: 1F       [ 4]     SHRT1:  RRA                     ; Shift it right
F6A9: 4F       [ 8]             LD      C,A             ; Re-save
F6AA: 7A       [12]             LD      A,D             ; Get NMSB
F6AB: 1F       [16]             RRA                     ; Shift right with last bit
F6AC: 57       [20]             LD      D,A             ; Re-save it
F6AD: 7B       [24]             LD      A,E             ; Get LSB
F6AE: 1F       [28]             RRA                     ; Shift right with last bit
F6AF: 5F       [32]             LD      E,A             ; Re-save it
F6B0: 78       [36]             LD      A,B             ; Get underflow
F6B1: 1F       [40]             RRA                     ; Shift right with last bit
F6B2: 47       [44]             LD      B,A             ; Re-save underflow
F6B3: C3A4F6   [54]             JP      SHRLP           ; More bits to do
                        
F6B6: 00000081          UNITY:  DB       000H,000H,000H,081H    ; 1.00000
                        
F6BA: 03                LOGTAB: DB      3                       ; Table used by LOG
F6BB: AA561980                  DB      0AAH,056H,019H,080H     ; 0.59898
F6BF: F1227680                  DB      0F1H,022H,076H,080H     ; 0.96147
F6C3: 45AA3882                  DB      045H,0AAH,038H,082H     ; 2.88539
                        
F6C7: CD13F8   [17]     LOG:    CALL    TSTSGN          ; Test sign of value
F6CA: B7       [21]             OR      A
F6CB: EAA0E9   [31|31]          JP      PE,FCERR        ; ?FC Error if <= zero
F6CE: 21E710   [41]             LD      HL,FPEXP        ; Point to exponent
F6D1: 7E       [48]             LD      A,(HL)          ; Get exponent
F6D2: 013580   [58]             LD      BC,8035H        ; BCDE = SQR(1/2)
F6D5: 11F304   [68]             LD      DE,04F3H
F6D8: 90       [72]             SUB     B               ; Scale value to be < 1
F6D9: F5       [83]             PUSH    AF              ; Save scale factor
F6DA: 70       [90]             LD      (HL),B          ; Save new exponent
F6DB: D5       [101]            PUSH    DE              ; Save SQR(1/2)
F6DC: C5       [112]            PUSH    BC
F6DD: CDCDF5   [129]            CALL    FPADD           ; Add SQR(1/2) to value
F6E0: C1       [139]            POP     BC              ; Restore SQR(1/2)
F6E1: D1       [149]            POP     DE
F6E2: 04       [153]            INC     B               ; Make it SQR(2)
F6E3: CD69F7   [170]            CALL    DVBCDE          ; Divide by SQR(2)
F6E6: 21B6F6   [180]            LD      HL,UNITY        ; Point to 1.
F6E9: CDC4F5   [197]            CALL    SUBPHL          ; Subtract FPREG from 1
F6EC: 21BAF6   [207]            LD      HL,LOGTAB       ; Coefficient table
F6EF: CD5BFB   [224]            CALL    SUMSER          ; Evaluate sum of series
F6F2: 018080   [234]            LD      BC,8080H        ; BCDE = -0.5
F6F5: 110000   [244]            LD      DE,0000H
F6F8: CDCDF5   [261]            CALL    FPADD           ; Subtract 0.5 from FPREG
F6FB: F1       [271]            POP     AF              ; Restore scale factor
F6FC: CD8EF9   [288]            CALL    RSCALE          ; Re-scale number
F6FF: 013180   [10]     MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
F702: 111872   [20]             LD      DE,7218H
F705: 21                        DB      21H             ; Skip "POP BC" and "POP DE"
                        
F706: C1       [10]     MULT:   POP     BC              ; Get number from stack
F707: D1       [20]             POP     DE
F708: CD13F8   [17]     FPMULT: CALL    TSTSGN          ; Test sign of FPREG
F70B: C8       [22|28]          RET     Z               ; Return zero if zero
F70C: 2E00     [29]             LD      L,0             ; Flag add exponents
F70E: CDD1F7   [46]             CALL    ADDEXP          ; Add exponents
F711: 79       [50]             LD      A,C             ; Get MSB of multiplier
F712: 32F610   [63]             LD      (MULVAL),A      ; Save MSB of multiplier
F715: EB       [67]             EX      DE,HL
F716: 22F710   [83]             LD      (MULVAL+1),HL   ; Save rest of multiplier
F719: 010000   [93]             LD      BC,0            ; Partial product (BCDE) = zero
F71C: 50       [97]             LD      D,B
F71D: 58       [101]            LD      E,B
F71E: 211EF6   [111]            LD      HL,BNORM        ; Address of normalise
F721: E5       [122]            PUSH    HL              ; Save for return
F722: 212AF7   [132]            LD      HL,MULT8        ; Address of 8 bit multiply
F725: E5       [143]            PUSH    HL              ; Save for NMSB,MSB
F726: E5       [154]            PUSH    HL              ; 
F727: 21E410   [164]            LD      HL,FPREG        ; Point to number
F72A: 7E       [ 7]     MULT8:  LD      A,(HL)          ; Get LSB of number
F72B: 23       [13]             INC     HL              ; Point to NMSB
F72C: B7       [17]             OR      A               ; Test LSB
F72D: CA56F7   [27|27]          JP      Z,BYTSFT        ; Zero - shift to next byte
F730: E5       [38]             PUSH    HL              ; Save address of number
F731: 2E08     [45]             LD      L,8             ; 8 bits to multiply by
F733: 1F       [ 4]     MUL8LP: RRA                     ; Shift LSB right
F734: 67       [ 8]             LD      H,A             ; Save LSB
F735: 79       [12]             LD      A,C             ; Get MSB
F736: D244F7   [22|22]          JP      NC,NOMADD       ; Bit was zero - Don't add
F739: E5       [33]             PUSH    HL              ; Save LSB and count
F73A: 2AF710   [49]             LD      HL,(MULVAL+1)   ; Get LSB and NMSB
F73D: 19       [60]             ADD     HL,DE           ; Add NMSB and LSB
F73E: EB       [64]             EX      DE,HL           ; Leave sum in DE
F73F: E1       [74]             POP     HL              ; Restore MSB and count
F740: 3AF610   [87]             LD      A,(MULVAL)      ; Get MSB of multiplier
F743: 89       [91]             ADC     A,C             ; Add MSB
F744: 1F       [ 4]     NOMADD: RRA                     ; Shift MSB right
F745: 4F       [ 8]             LD      C,A             ; Re-save MSB
F746: 7A       [12]             LD      A,D             ; Get NMSB
F747: 1F       [16]             RRA                     ; Shift NMSB right
F748: 57       [20]             LD      D,A             ; Re-save NMSB
F749: 7B       [24]             LD      A,E             ; Get LSB
F74A: 1F       [28]             RRA                     ; Shift LSB right
F74B: 5F       [32]             LD      E,A             ; Re-save LSB
F74C: 78       [36]             LD      A,B             ; Get VLSB
F74D: 1F       [40]             RRA                     ; Shift VLSB right
F74E: 47       [44]             LD      B,A             ; Re-save VLSB
F74F: 2D       [48]             DEC     L               ; Count bits multiplied
F750: 7C       [52]             LD      A,H             ; Get LSB of multiplier
F751: C233F7   [62|62]          JP      NZ,MUL8LP       ; More - Do it
F754: E1       [10]     POPHRT: POP     HL              ; Restore address of number
F755: C9       [20]             RET
                        
F756: 43       [ 4]     BYTSFT: LD      B,E             ; Shift partial product left
F757: 5A       [ 8]             LD      E,D
F758: 51       [12]             LD      D,C
F759: 4F       [16]             LD      C,A
F75A: C9       [26]             RET
                        
F75B: CD44F8   [17]     DIV10:  CALL    STAKFP          ; Save FPREG on stack
F75E: 012084   [27]             LD      BC,8420H        ; BCDE = 10.
F761: 110000   [37]             LD      DE,0000H
F764: CD54F8   [54]             CALL    FPBCDE          ; Move 10 to FPREG
                        
F767: C1       [10]     DIV:    POP     BC              ; Get number from stack
F768: D1       [20]             POP     DE
F769: CD13F8   [17]     DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
F76C: CAB0E3   [27|27]          JP      Z,DZERR         ; Error if division by zero
F76F: 2EFF     [34]             LD      L,-1            ; Flag subtract exponents
F771: CDD1F7   [51]             CALL    ADDEXP          ; Subtract exponents
F774: 34       [62]             INC     (HL)            ; Add 2 to exponent to adjust
F775: 34       [73]             INC     (HL)
F776: 2B       [79]             DEC     HL              ; Point to MSB
F777: 7E       [86]             LD      A,(HL)          ; Get MSB of dividend
F778: 321210   [99]             LD      (DIV3),A        ; Save for subtraction
F77B: 2B       [105]            DEC     HL
F77C: 7E       [112]            LD      A,(HL)          ; Get NMSB of dividend
F77D: 320E10   [125]            LD      (DIV2),A        ; Save for subtraction
F780: 2B       [131]            DEC     HL
F781: 7E       [138]            LD      A,(HL)          ; Get MSB of dividend
F782: 320A10   [151]            LD      (DIV1),A        ; Save for subtraction
F785: 41       [155]            LD      B,C             ; Get MSB
F786: EB       [159]            EX      DE,HL           ; NMSB,LSB to HL
F787: AF       [163]            XOR     A
F788: 4F       [167]            LD      C,A             ; Clear MSB of quotient
F789: 57       [171]            LD      D,A             ; Clear NMSB of quotient
F78A: 5F       [175]            LD      E,A             ; Clear LSB of quotient
F78B: 321510   [188]            LD      (DIV4),A        ; Clear overflow count
F78E: E5       [11]     DIVLP:  PUSH    HL              ; Save divisor
F78F: C5       [22]             PUSH    BC
F790: 7D       [26]             LD      A,L             ; Get LSB of number
F791: CD0910   [43]             CALL    DIVSUP          ; Subt' divisor from dividend
F794: DE00     [50]             SBC     A,0             ; Count for overflows
F796: 3F       [54]             CCF
F797: D2A1F7   [64|64]          JP      NC,RESDIV       ; Restore divisor if borrow
F79A: 321510   [77]             LD      (DIV4),A        ; Re-save overflow count
F79D: F1       [87]             POP     AF              ; Scrap divisor
F79E: F1       [97]             POP     AF
F79F: 37       [101]            SCF                     ; Set carry to
F7A0: D2                        DB      0D2H            ; Skip "POP BC" and "POP HL"
                        
F7A1: C1       [10]     RESDIV: POP     BC              ; Restore divisor
F7A2: E1       [20]             POP     HL
F7A3: 79       [24]             LD      A,C             ; Get MSB of quotient
F7A4: 3C       [28]             INC     A
F7A5: 3D       [32]             DEC     A
F7A6: 1F       [36]             RRA                     ; Bit 0 to bit 7
F7A7: FA54F6   [46|46]          JP      M,RONDB         ; Done - Normalise result
F7AA: 17       [50]             RLA                     ; Restore carry
F7AB: 7B       [54]             LD      A,E             ; Get LSB of quotient
F7AC: 17       [58]             RLA                     ; Double it
F7AD: 5F       [62]             LD      E,A             ; Put it back
F7AE: 7A       [66]             LD      A,D             ; Get NMSB of quotient
F7AF: 17       [70]             RLA                     ; Double it
F7B0: 57       [74]             LD      D,A             ; Put it back
F7B1: 79       [78]             LD      A,C             ; Get MSB of quotient
F7B2: 17       [82]             RLA                     ; Double it
F7B3: 4F       [86]             LD      C,A             ; Put it back
F7B4: 29       [97]             ADD     HL,HL           ; Double NMSB,LSB of divisor
F7B5: 78       [101]            LD      A,B             ; Get MSB of divisor
F7B6: 17       [105]            RLA                     ; Double it
F7B7: 47       [109]            LD      B,A             ; Put it back
F7B8: 3A1510   [122]            LD      A,(DIV4)        ; Get VLSB of quotient
F7BB: 17       [126]            RLA                     ; Double it
F7BC: 321510   [139]            LD      (DIV4),A        ; Put it back
F7BF: 79       [143]            LD      A,C             ; Get MSB of quotient
F7C0: B2       [147]            OR      D               ; Merge NMSB
F7C1: B3       [151]            OR      E               ; Merge LSB
F7C2: C28EF7   [161|161]        JP      NZ,DIVLP        ; Not done - Keep dividing
F7C5: E5       [172]            PUSH    HL              ; Save divisor
F7C6: 21E710   [182]            LD      HL,FPEXP        ; Point to exponent
F7C9: 35       [193]            DEC     (HL)            ; Divide by 2
F7CA: E1       [203]            POP     HL              ; Restore divisor
F7CB: C28EF7   [213|213]        JP      NZ,DIVLP        ; Ok - Keep going
F7CE: C3BCE3   [223]            JP      OVERR           ; Overflow error
                        
F7D1: 78       [ 4]     ADDEXP: LD      A,B             ; Get exponent of dividend
F7D2: B7       [ 8]             OR      A               ; Test it
F7D3: CAF5F7   [18|18]          JP      Z,OVTST3        ; Zero - Result zero
F7D6: 7D       [22]             LD      A,L             ; Get add/subtract flag
F7D7: 21E710   [32]             LD      HL,FPEXP        ; Point to exponent
F7DA: AE       [39]             XOR     (HL)            ; Add or subtract it
F7DB: 80       [43]             ADD     A,B             ; Add the other exponent
F7DC: 47       [47]             LD      B,A             ; Save new exponent
F7DD: 1F       [51]             RRA                     ; Test exponent for overflow
F7DE: A8       [55]             XOR     B
F7DF: 78       [59]             LD      A,B             ; Get exponent
F7E0: F2F4F7   [69|69]          JP      P,OVTST2        ; Positive - Test for overflow
F7E3: C680     [76]             ADD     A,80H           ; Add excess 128
F7E5: 77       [83]             LD      (HL),A          ; Save new exponent
F7E6: CA54F7   [93|93]          JP      Z,POPHRT        ; Zero - Result zero
F7E9: CD79F8   [110]            CALL    SIGNS           ; Set MSBs and sign of result
F7EC: 77       [117]            LD      (HL),A          ; Save new exponent
F7ED: 2B       [123]            DEC     HL              ; Point to MSB
F7EE: C9       [133]            RET
                        
F7EF: CD13F8   [17]     OVTST1: CALL    TSTSGN          ; Test sign of FPREG
F7F2: 2F       [21]             CPL                     ; Invert sign
F7F3: E1       [31]             POP     HL              ; Clean up stack
F7F4: B7       [ 4]     OVTST2: OR      A               ; Test if new exponent zero
F7F5: E1       [10]     OVTST3: POP     HL              ; Clear off return address
F7F6: F233F6   [20|20]          JP      P,RESZER        ; Result zero
F7F9: C3BCE3   [30]             JP      OVERR           ; Overflow error
                        
F7FC: CD5FF8   [17]     MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
F7FF: 78       [21]             LD      A,B             ; Get exponent
F800: B7       [25]             OR      A               ; Is it zero?
F801: C8       [30|36]          RET     Z               ; Yes - Result is zero
F802: C602     [37]             ADD     A,2             ; Multiply by 4
F804: DABCE3   [47|47]          JP      C,OVERR         ; Overflow - ?OV Error
F807: 47       [51]             LD      B,A             ; Re-save exponent
F808: CDCDF5   [68]             CALL    FPADD           ; Add BCDE to FPREG (Times 5)
F80B: 21E710   [78]             LD      HL,FPEXP        ; Point to exponent
F80E: 34       [89]             INC     (HL)            ; Double number (Times 10)
F80F: C0       [94|100]         RET     NZ              ; Ok - Return
F810: C3BCE3   [104]            JP      OVERR           ; Overflow error
                        
F813: 3AE710   [13]     TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
F816: B7       [17]             OR      A
F817: C8       [22|28]          RET     Z               ; RETurn if number is zero
F818: 3AE610   [35]             LD      A,(FPREG+2)     ; Get MSB of FPREG
F81B: FE                        DB      0FEH            ; Test sign
F81C: 2F       [ 4]     RETREL: CPL                     ; Invert sign
F81D: 17       [ 8]             RLA                     ; Sign bit to carry
F81E: 9F       [ 4]     FLGDIF: SBC     A,A             ; Carry to all bits of A
F81F: C0       [ 9|15]          RET     NZ              ; Return -1 if negative
F820: 3C       [13]             INC     A               ; Bump to +1
F821: C9       [23]             RET                     ; Positive - Return +1
                        
F822: CD13F8   [17]     SGN:    CALL    TSTSGN          ; Test sign of FPREG
F825: 0688     [ 7]     FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
F827: 110000   [17]             LD      DE,0            ; Zero NMSB and LSB
F82A: 21E710   [10]     RETINT: LD      HL,FPEXP        ; Point to exponent
F82D: 4F       [14]             LD      C,A             ; CDE = MSB,NMSB and LSB
F82E: 70       [21]             LD      (HL),B          ; Save exponent
F82F: 0600     [28]             LD      B,0             ; CDE = integer to normalise
F831: 23       [34]             INC     HL              ; Point to sign of result
F832: 3680     [44]             LD      (HL),80H        ; Set sign of result
F834: 17       [48]             RLA                     ; Carry = sign of integer
F835: C31BF6   [58]             JP      CONPOS          ; Set sign of result
                        
F838: CD13F8   [17]     ABS:    CALL    TSTSGN          ; Test sign of FPREG
F83B: F0       [22|28]          RET     P               ; Return if positive
F83C: 21E610   [10]     INVSGN: LD      HL,FPREG+2      ; Point to MSB
F83F: 7E       [17]             LD      A,(HL)          ; Get sign of mantissa
F840: EE80     [24]             XOR     80H             ; Invert sign of mantissa
F842: 77       [31]             LD      (HL),A          ; Re-save sign of mantissa
F843: C9       [41]             RET
                        
F844: EB       [ 4]     STAKFP: EX      DE,HL           ; Save code string address
F845: 2AE410   [20]             LD      HL,(FPREG)      ; LSB,NLSB of FPREG
F848: E3       [39]             EX      (SP),HL         ; Stack them,get return
F849: E5       [50]             PUSH    HL              ; Re-save return
F84A: 2AE610   [66]             LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
F84D: E3       [85]             EX      (SP),HL         ; Stack them,get return
F84E: E5       [96]             PUSH    HL              ; Re-save return
F84F: EB       [100]            EX      DE,HL           ; Restore code string address
F850: C9       [110]            RET
                        
F851: CD62F8   [17]     PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
F854: EB       [ 4]     FPBCDE: EX      DE,HL           ; Save code string address
F855: 22E410   [20]             LD      (FPREG),HL      ; Save LSB,NLSB of number
F858: 60       [24]             LD      H,B             ; Exponent of number
F859: 69       [28]             LD      L,C             ; MSB of number
F85A: 22E610   [44]             LD      (FPREG+2),HL    ; Save MSB and exponent
F85D: EB       [48]             EX      DE,HL           ; Restore code string address
F85E: C9       [58]             RET
                        
F85F: 21E410   [10]     BCDEFP: LD      HL,FPREG        ; Point to FPREG
F862: 5E       [ 7]     LOADFP: LD      E,(HL)          ; Get LSB of number
F863: 23       [13]             INC     HL
F864: 56       [20]             LD      D,(HL)          ; Get NMSB of number
F865: 23       [26]             INC     HL
F866: 4E       [33]             LD      C,(HL)          ; Get MSB of number
F867: 23       [39]             INC     HL
F868: 46       [46]             LD      B,(HL)          ; Get exponent of number
F869: 23       [ 6]     INCHL:  INC     HL              ; Used for conditional "INC HL"
F86A: C9       [16]             RET
                        
F86B: 11E410   [10]     FPTHL:  LD      DE,FPREG        ; Point to FPREG
F86E: 0604     [ 7]     DETHL4: LD      B,4             ; 4 bytes to move
F870: 1A       [ 7]     DETHLB: LD      A,(DE)          ; Get source
F871: 77       [14]             LD      (HL),A          ; Save destination
F872: 13       [20]             INC     DE              ; Next source
F873: 23       [26]             INC     HL              ; Next destination
F874: 05       [30]             DEC     B               ; Count bytes
F875: C270F8   [40|40]          JP      NZ,DETHLB       ; Loop if more
F878: C9       [50]             RET
                        
F879: 21E610   [10]     SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
F87C: 7E       [17]             LD      A,(HL)          ; Get MSB
F87D: 07       [21]             RLCA                    ; Old sign to carry
F87E: 37       [25]             SCF                     ; Set MSBit
F87F: 1F       [29]             RRA                     ; Set MSBit of MSB
F880: 77       [36]             LD      (HL),A          ; Save new MSB
F881: 3F       [40]             CCF                     ; Complement sign
F882: 1F       [44]             RRA                     ; Old sign to carry
F883: 23       [50]             INC     HL
F884: 23       [56]             INC     HL
F885: 77       [63]             LD      (HL),A          ; Set sign of result
F886: 79       [67]             LD      A,C             ; Get MSB
F887: 07       [71]             RLCA                    ; Old sign to carry
F888: 37       [75]             SCF                     ; Set MSBit
F889: 1F       [79]             RRA                     ; Set MSBit of MSB
F88A: 4F       [83]             LD      C,A             ; Save MSB
F88B: 1F       [87]             RRA
F88C: AE       [94]             XOR     (HL)            ; New sign of result
F88D: C9       [104]            RET
                        
F88E: 78       [ 4]     CMPNUM: LD      A,B             ; Get exponent of number
F88F: B7       [ 8]             OR      A
F890: CA13F8   [18|18]          JP      Z,TSTSGN        ; Zero - Test sign of FPREG
F893: 211CF8   [28]             LD      HL,RETREL       ; Return relation routine
F896: E5       [39]             PUSH    HL              ; Save for return
F897: CD13F8   [56]             CALL    TSTSGN          ; Test sign of FPREG
F89A: 79       [60]             LD      A,C             ; Get MSB of number
F89B: C8       [65|71]          RET     Z               ; FPREG zero - Number's MSB
F89C: 21E610   [75]             LD      HL,FPREG+2      ; MSB of FPREG
F89F: AE       [82]             XOR     (HL)            ; Combine signs
F8A0: 79       [86]             LD      A,C             ; Get MSB of number
F8A1: F8       [91|97]          RET     M               ; Exit if signs different
F8A2: CDA8F8   [108]            CALL    CMPFP           ; Compare FP numbers
F8A5: 1F       [112]            RRA                     ; Get carry to sign
F8A6: A9       [116]            XOR     C               ; Combine with MSB of number
F8A7: C9       [126]            RET
                        
F8A8: 23       [ 6]     CMPFP:  INC     HL              ; Point to exponent
F8A9: 78       [10]             LD      A,B             ; Get exponent
F8AA: BE       [17]             CP      (HL)            ; Compare exponents
F8AB: C0       [22|28]          RET     NZ              ; Different
F8AC: 2B       [28]             DEC     HL              ; Point to MBS
F8AD: 79       [32]             LD      A,C             ; Get MSB
F8AE: BE       [39]             CP      (HL)            ; Compare MSBs
F8AF: C0       [44|50]          RET     NZ              ; Different
F8B0: 2B       [50]             DEC     HL              ; Point to NMSB
F8B1: 7A       [54]             LD      A,D             ; Get NMSB
F8B2: BE       [61]             CP      (HL)            ; Compare NMSBs
F8B3: C0       [66|72]          RET     NZ              ; Different
F8B4: 2B       [72]             DEC     HL              ; Point to LSB
F8B5: 7B       [76]             LD      A,E             ; Get LSB
F8B6: 96       [83]             SUB     (HL)            ; Compare LSBs
F8B7: C0       [88|94]          RET     NZ              ; Different
F8B8: E1       [98]             POP     HL              ; Drop RETurn
F8B9: E1       [108]            POP     HL              ; Drop another RETurn
F8BA: C9       [118]            RET
                        
F8BB: 47       [ 4]     FPINT:  LD      B,A             ; <- Move
F8BC: 4F       [ 8]             LD      C,A             ; <- exponent
F8BD: 57       [12]             LD      D,A             ; <- to all
F8BE: 5F       [16]             LD      E,A             ; <- bits
F8BF: B7       [20]             OR      A               ; Test exponent
F8C0: C8       [25|31]          RET     Z               ; Zero - Return zero
F8C1: E5       [36]             PUSH    HL              ; Save pointer to number
F8C2: CD5FF8   [53]             CALL    BCDEFP          ; Move FPREG to BCDE
F8C5: CD79F8   [70]             CALL    SIGNS           ; Set MSBs & sign of result
F8C8: AE       [77]             XOR     (HL)            ; Combine with sign of FPREG
F8C9: 67       [81]             LD      H,A             ; Save combined signs
F8CA: FCDFF8   [91|98]          CALL    M,DCBCDE        ; Negative - Decrement BCDE
F8CD: 3E98     [98]             LD      A,80H+24        ; 24 bits
F8CF: 90       [102]            SUB     B               ; Bits to shift
F8D0: CD92F6   [119]            CALL    SCALE           ; Shift BCDE
F8D3: 7C       [123]            LD      A,H             ; Get combined sign
F8D4: 17       [127]            RLA                     ; Sign to carry
F8D5: DC65F6   [137|144]        CALL    C,FPROND        ; Negative - Round number up
F8D8: 0600     [144]            LD      B,0             ; Zero exponent
F8DA: DC7EF6   [154|161]        CALL    C,COMPL         ; If negative make positive
F8DD: E1       [164]            POP     HL              ; Restore pointer to number
F8DE: C9       [174]            RET
                        
F8DF: 1B       [ 6]     DCBCDE: DEC     DE              ; Decrement BCDE
F8E0: 7A       [10]             LD      A,D             ; Test LSBs
F8E1: A3       [14]             AND     E
F8E2: 3C       [18]             INC     A
F8E3: C0       [23|29]          RET     NZ              ; Exit if LSBs not FFFF
F8E4: 0B       [29]             DEC     BC              ; Decrement MSBs
F8E5: C9       [39]             RET
                        
F8E6: 21E710   [10]     INT:    LD      HL,FPEXP        ; Point to exponent
F8E9: 7E       [17]             LD      A,(HL)          ; Get exponent
F8EA: FE98     [24]             CP      80H+24          ; Integer accuracy only?
F8EC: 3AE410   [37]             LD      A,(FPREG)       ; Get LSB
F8EF: D0       [42|48]          RET     NC              ; Yes - Already integer
F8F0: 7E       [49]             LD      A,(HL)          ; Get exponent
F8F1: CDBBF8   [66]             CALL    FPINT           ; F.P to integer
F8F4: 3698     [76]             LD      (HL),80H+24     ; Save 24 bit integer
F8F6: 7B       [80]             LD      A,E             ; Get LSB of number
F8F7: F5       [91]             PUSH    AF              ; Save LSB
F8F8: 79       [95]             LD      A,C             ; Get MSB of number
F8F9: 17       [99]             RLA                     ; Sign to carry
F8FA: CD1BF6   [116]            CALL    CONPOS          ; Set sign of result
F8FD: F1       [126]            POP     AF              ; Restore LSB of number
F8FE: C9       [136]            RET
                        
F8FF: 210000   [10]     MLDEBC: LD      HL,0            ; Clear partial product
F902: 78       [14]             LD      A,B             ; Test multiplier
F903: B1       [18]             OR      C
F904: C8       [23|29]          RET     Z               ; Return zero if zero
F905: 3E10     [30]             LD      A,16            ; 16 bits
F907: 29       [11]     MLDBLP: ADD     HL,HL           ; Shift P.P left
F908: DA45F0   [21|21]          JP      C,BSERR         ; ?BS Error if overflow
F90B: EB       [25]             EX      DE,HL
F90C: 29       [36]             ADD     HL,HL           ; Shift multiplier left
F90D: EB       [40]             EX      DE,HL
F90E: D215F9   [50|50]          JP      NC,NOMLAD       ; Bit was zero - No add
F911: 09       [61]             ADD     HL,BC           ; Add multiplicand
F912: DA45F0   [71|71]          JP      C,BSERR         ; ?BS Error if overflow
F915: 3D       [ 4]     NOMLAD: DEC     A               ; Count bits
F916: C207F9   [14|14]          JP      NZ,MLDBLP       ; More
F919: C9       [24]             RET
                        
F91A: FE2D     [ 7]     ASCTFP: CP      "-"             ; Negative?
F91C: F5       [18]             PUSH    AF              ; Save it and flags
F91D: CA26F9   [28|28]          JP      Z,CNVNUM        ; Yes - Convert number
F920: FE2B     [35]             CP      "+"             ; Positive?
F922: CA26F9   [45|45]          JP      Z,CNVNUM        ; Yes - Convert number
F925: 2B       [51]             DEC     HL              ; DEC 'cos GETCHR INCs
F926: CD33F6   [17]     CNVNUM: CALL    RESZER          ; Set result to zero
F929: 47       [21]             LD      B,A             ; Digits after point counter
F92A: 57       [25]             LD      D,A             ; Sign of exponent
F92B: 5F       [29]             LD      E,A             ; Exponent of ten
F92C: 2F       [33]             CPL
F92D: 4F       [37]             LD      C,A             ; Before or after point flag
F92E: CD36E8   [17]     MANLP:  CALL    GETCHR          ; Get next character
F931: DA77F9   [27|27]          JP      C,ADDIG         ; Digit - Add to number
F934: FE2E     [34]             CP      "."
F936: CA52F9   [44|44]          JP      Z,DPOINT        ; "." - Flag point
F939: FE45     [51]             CP      "E"
F93B: C256F9   [61|61]          JP      NZ,CONEXP       ; Not "E" - Scale number
F93E: CD36E8   [78]             CALL    GETCHR          ; Get next character
F941: CD70EE   [95]             CALL    SGNEXP          ; Get sign of exponent
F944: CD36E8   [17]     EXPLP:  CALL    GETCHR          ; Get next character
F947: DA99F9   [27|27]          JP      C,EDIGIT        ; Digit - Add to exponent
F94A: 14       [31]             INC     D               ; Is sign negative?
F94B: C256F9   [41|41]          JP      NZ,CONEXP       ; No - Scale number
F94E: AF       [45]             XOR     A
F94F: 93       [49]             SUB     E               ; Negate exponent
F950: 5F       [53]             LD      E,A             ; And re-save it
F951: 0C       [57]             INC     C               ; Flag end of number
F952: 0C       [ 4]     DPOINT: INC     C               ; Flag point passed
F953: CA2EF9   [14|14]          JP      Z,MANLP         ; Zero - Get another digit
F956: E5       [11]     CONEXP: PUSH    HL              ; Save code string address
F957: 7B       [15]             LD      A,E             ; Get exponent
F958: 90       [19]             SUB     B               ; Subtract digits after point
F959: F46FF9   [10|17]  SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
F95C: F265F9   [20|20]          JP      P,ENDCON        ; Positive - All done
F95F: F5       [31]             PUSH    AF              ; Save number of times to /10
F960: CD5BF7   [48]             CALL    DIV10           ; Divide by 10
F963: F1       [58]             POP     AF              ; Restore count
F964: 3C       [62]             INC     A               ; Count divides
                        
F965: C259F9   [10|10]  ENDCON: JP      NZ,SCALMI       ; More to do
F968: D1       [20]             POP     DE              ; Restore code string address
F969: F1       [30]             POP     AF              ; Restore sign of number
F96A: CC3CF8   [40|47]          CALL    Z,INVSGN        ; Negative - Negate number
F96D: EB       [44]             EX      DE,HL           ; Code string address to HL
F96E: C9       [54]             RET
                        
F96F: C8       [ 5|11]  SCALPL: RET     Z               ; Exit if no scaling needed
F970: F5       [11]     MULTEN: PUSH    AF              ; Save count
F971: CDFCF7   [28]             CALL    MLSP10          ; Multiply number by 10
F974: F1       [38]             POP     AF              ; Restore count
F975: 3D       [42]             DEC     A               ; Count multiplies
F976: C9       [52]             RET
                        
F977: D5       [11]     ADDIG:  PUSH    DE              ; Save sign of exponent
F978: 57       [15]             LD      D,A             ; Save digit
F979: 78       [19]             LD      A,B             ; Get digits after point
F97A: 89       [23]             ADC     A,C             ; Add one if after point
F97B: 47       [27]             LD      B,A             ; Re-save counter
F97C: C5       [38]             PUSH    BC              ; Save point flags
F97D: E5       [49]             PUSH    HL              ; Save code string address
F97E: D5       [60]             PUSH    DE              ; Save digit
F97F: CDFCF7   [77]             CALL    MLSP10          ; Multiply number by 10
F982: F1       [87]             POP     AF              ; Restore digit
F983: D630     [94]             SUB     "0"             ; Make it absolute
F985: CD8EF9   [111]            CALL    RSCALE          ; Re-scale number
F988: E1       [121]            POP     HL              ; Restore code string address
F989: C1       [131]            POP     BC              ; Restore point flags
F98A: D1       [141]            POP     DE              ; Restore sign of exponent
F98B: C32EF9   [151]            JP      MANLP           ; Get another digit
                        
F98E: CD44F8   [17]     RSCALE: CALL    STAKFP          ; Put number on stack
F991: CD25F8   [34]             CALL    FLGREL          ; Digit to add to FPREG
F994: C1       [10]     PADD:   POP     BC              ; Restore number
F995: D1       [20]             POP     DE
F996: C3CDF5   [30]             JP      FPADD           ; Add BCDE to FPREG and return
                        
F999: 7B       [ 4]     EDIGIT: LD      A,E             ; Get digit
F99A: 07       [ 8]             RLCA                    ; Times 2
F99B: 07       [12]             RLCA                    ; Times 4
F99C: 83       [16]             ADD     A,E             ; Times 5
F99D: 07       [20]             RLCA                    ; Times 10
F99E: 86       [27]             ADD     A,(HL)          ; Add next digit
F99F: D630     [34]             SUB     "0"             ; Make it absolute
F9A1: 5F       [38]             LD      E,A             ; Save new digit
F9A2: C344F9   [48]             JP      EXPLP           ; Look for another digit
                        
F9A5: E5       [11]     LINEIN: PUSH    HL              ; Save code string address
F9A6: 2146E3   [21]             LD      HL,INMSG        ; Output " in "
F9A9: CD10F2   [38]             CALL    PRS             ; Output string at HL
F9AC: E1       [48]             POP     HL              ; Restore code string address
F9AD: EB       [ 4]     PRNTHL: EX      DE,HL           ; Code string address to DE
F9AE: AF       [ 8]             XOR     A
F9AF: 0698     [15]             LD      B,80H+24        ; 24 bits
F9B1: CD2AF8   [32]             CALL    RETINT          ; Return the integer
F9B4: 210FF2   [42]             LD      HL,PRNUMS       ; Print number string
F9B7: E5       [53]             PUSH    HL              ; Save for return
F9B8: 21E910   [10]     NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
F9BB: E5       [21]             PUSH    HL              ; Save for return
F9BC: CD13F8   [38]             CALL    TSTSGN          ; Test sign of FPREG
F9BF: 3620     [48]             LD      (HL)," "        ; Space at start
F9C1: F2C6F9   [58|58]          JP      P,SPCFST        ; Positive - Space to start
F9C4: 362D     [68]             LD      (HL),"-"        ; "-" sign at start
F9C6: 23       [ 6]     SPCFST: INC     HL              ; First byte of number
F9C7: 3630     [16]             LD      (HL),"0"        ; "0" if zero
F9C9: CA7CFA   [26|26]          JP      Z,JSTZER        ; Return "0" if zero
F9CC: E5       [37]             PUSH    HL              ; Save buffer address
F9CD: FC3CF8   [47|54]          CALL    M,INVSGN        ; Negate FPREG if negative
F9D0: AF       [51]             XOR     A               ; Zero A
F9D1: F5       [62]             PUSH    AF              ; Save it
F9D2: CD82FA   [79]             CALL    RNGTST          ; Test number is in range
F9D5: 014391   [10]     SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
F9D8: 11F84F   [20]             LD      DE,4FF8H
F9DB: CD8EF8   [37]             CALL    CMPNUM          ; Compare numbers
F9DE: B7       [41]             OR      A
F9DF: E2F3F9   [51|51]          JP      PO,INRNG        ; > 99999.9 - Sort it out
F9E2: F1       [61]             POP     AF              ; Restore count
F9E3: CD70F9   [78]             CALL    MULTEN          ; Multiply by ten
F9E6: F5       [89]             PUSH    AF              ; Re-save count
F9E7: C3D5F9   [99]             JP      SIXDIG          ; Test it again
                        
F9EA: CD5BF7   [17]     GTSIXD: CALL    DIV10           ; Divide by 10
F9ED: F1       [27]             POP     AF              ; Get count
F9EE: 3C       [31]             INC     A               ; Count divides
F9EF: F5       [42]             PUSH    AF              ; Re-save count
F9F0: CD82FA   [59]             CALL    RNGTST          ; Test number is in range
F9F3: CDBBF5   [17]     INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
F9F6: 3C       [21]             INC     A
F9F7: CDBBF8   [38]             CALL    FPINT           ; F.P to integer
F9FA: CD54F8   [55]             CALL    FPBCDE          ; Move BCDE to FPREG
F9FD: 010603   [65]             LD      BC,0306H        ; 1E+06 to 1E-03 range
FA00: F1       [75]             POP     AF              ; Restore count
FA01: 81       [79]             ADD     A,C             ; 6 digits before point
FA02: 3C       [83]             INC     A               ; Add one
FA03: FA0FFA   [93|93]          JP      M,MAKNUM        ; Do it in "E" form if < 1E-02
FA06: FE08     [100]            CP      6+1+1           ; More than 999999 ?
FA08: D20FFA   [110|110]        JP      NC,MAKNUM       ; Yes - Do it in "E" form
FA0B: 3C       [114]            INC     A               ; Adjust for exponent
FA0C: 47       [118]            LD      B,A             ; Exponent of number
FA0D: 3E02     [125]            LD      A,2             ; Make it zero after
                        
FA0F: 3D       [ 4]     MAKNUM: DEC     A               ; Adjust for digits to do
FA10: 3D       [ 8]             DEC     A
FA11: E1       [18]             POP     HL              ; Restore buffer address
FA12: F5       [29]             PUSH    AF              ; Save count
FA13: 1195FA   [39]             LD      DE,POWERS       ; Powers of ten
FA16: 05       [43]             DEC     B               ; Count digits before point
FA17: C220FA   [53|53]          JP      NZ,DIGTXT       ; Not zero - Do number
FA1A: 362E     [63]             LD      (HL),"."        ; Save point
FA1C: 23       [69]             INC     HL              ; Move on
FA1D: 3630     [79]             LD      (HL),"0"        ; Save zero
FA1F: 23       [85]             INC     HL              ; Move on
FA20: 05       [ 4]     DIGTXT: DEC     B               ; Count digits before point
FA21: 362E     [14]             LD      (HL),"."        ; Save point in case
FA23: CC69F8   [24|31]          CALL    Z,INCHL         ; Last digit - move on
FA26: C5       [35]             PUSH    BC              ; Save digits before point
FA27: E5       [46]             PUSH    HL              ; Save buffer address
FA28: D5       [57]             PUSH    DE              ; Save powers of ten
FA29: CD5FF8   [74]             CALL    BCDEFP          ; Move FPREG to BCDE
FA2C: E1       [84]             POP     HL              ; Powers of ten table
FA2D: 062F     [91]             LD      B, "0"-1        ; ASCII "0" - 1
FA2F: 04       [ 4]     TRYAGN: INC     B               ; Count subtractions
FA30: 7B       [ 8]             LD      A,E             ; Get LSB
FA31: 96       [15]             SUB     (HL)            ; Subtract LSB
FA32: 5F       [19]             LD      E,A             ; Save LSB
FA33: 23       [25]             INC     HL
FA34: 7A       [29]             LD      A,D             ; Get NMSB
FA35: 9E       [36]             SBC     A,(HL)          ; Subtract NMSB
FA36: 57       [40]             LD      D,A             ; Save NMSB
FA37: 23       [46]             INC     HL
FA38: 79       [50]             LD      A,C             ; Get MSB
FA39: 9E       [57]             SBC     A,(HL)          ; Subtract MSB
FA3A: 4F       [61]             LD      C,A             ; Save MSB
FA3B: 2B       [67]             DEC     HL              ; Point back to start
FA3C: 2B       [73]             DEC     HL
FA3D: D22FFA   [83|83]          JP      NC,TRYAGN       ; No overflow - Try again
FA40: CD72F6   [100]            CALL    PLUCDE          ; Restore number
FA43: 23       [106]            INC     HL              ; Start of next number
FA44: CD54F8   [123]            CALL    FPBCDE          ; Move BCDE to FPREG
FA47: EB       [127]            EX      DE,HL           ; Save point in table
FA48: E1       [137]            POP     HL              ; Restore buffer address
FA49: 70       [144]            LD      (HL),B          ; Save digit in buffer
FA4A: 23       [150]            INC     HL              ; And move on
FA4B: C1       [160]            POP     BC              ; Restore digit count
FA4C: 0D       [164]            DEC     C               ; Count digits
FA4D: C220FA   [174|174]        JP      NZ,DIGTXT       ; More - Do them
FA50: 05       [178]            DEC     B               ; Any decimal part?
FA51: CA60FA   [188|188]        JP      Z,DOEBIT        ; No - Do "E" bit
FA54: 2B       [ 6]     SUPTLZ: DEC     HL              ; Move back through buffer
FA55: 7E       [13]             LD      A,(HL)          ; Get character
FA56: FE30     [20]             CP      "0"             ; "0" character?
FA58: CA54FA   [30|30]          JP      Z,SUPTLZ        ; Yes - Look back for more
FA5B: FE2E     [37]             CP      "."             ; A decimal point?
FA5D: C469F8   [47|54]          CALL    NZ,INCHL        ; Move back over digit
                        
FA60: F1       [10]     DOEBIT: POP     AF              ; Get "E" flag
FA61: CA7FFA   [20|20]          JP      Z,NOENED        ; No "E" needed - End buffer
FA64: 3645     [30]             LD      (HL),"E"        ; Put "E" in buffer
FA66: 23       [36]             INC     HL              ; And move on
FA67: 362B     [46]             LD      (HL),"+"        ; Put '+' in buffer
FA69: F270FA   [56|56]          JP      P,OUTEXP        ; Positive - Output exponent
FA6C: 362D     [66]             LD      (HL),"-"        ; Put "-" in buffer
FA6E: 2F       [70]             CPL                     ; Negate exponent
FA6F: 3C       [74]             INC     A
FA70: 062F     [ 7]     OUTEXP: LD      B,"0"-1         ; ASCII "0" - 1
FA72: 04       [ 4]     EXPTEN: INC     B               ; Count subtractions
FA73: D60A     [11]             SUB     10              ; Tens digit
FA75: D272FA   [21|21]          JP      NC,EXPTEN       ; More to do
FA78: C63A     [28]             ADD     A,"0"+10        ; Restore and make ASCII
FA7A: 23       [34]             INC     HL              ; Move on
FA7B: 70       [41]             LD      (HL),B          ; Save MSB of exponent
FA7C: 23       [ 6]     JSTZER: INC     HL              ;
FA7D: 77       [13]             LD      (HL),A          ; Save LSB of exponent
FA7E: 23       [19]             INC     HL
FA7F: 71       [ 7]     NOENED: LD      (HL),C          ; Mark end of buffer
FA80: E1       [17]             POP     HL              ; Restore code string address
FA81: C9       [27]             RET
                        
FA82: 017494   [10]     RNGTST: LD      BC,9474H        ; BCDE = 999999.
FA85: 11F723   [20]             LD      DE,23F7H
FA88: CD8EF8   [37]             CALL    CMPNUM          ; Compare numbers
FA8B: B7       [41]             OR      A
FA8C: E1       [51]             POP     HL              ; Return address to HL
FA8D: E2EAF9   [61|61]          JP      PO,GTSIXD       ; Too big - Divide by ten
FA90: E9       [65]             JP      (HL)            ; Otherwise return to caller
                        
FA91: 00000080          HALF:   DB      00H,00H,00H,80H ; 0.5
                        
FA95: A08601            POWERS: DB      0A0H,086H,001H  ; 100000
FA98: 102700                    DB      010H,027H,000H  ;  10000
FA9B: E80300                    DB      0E8H,003H,000H  ;   1000
FA9E: 640000                    DB      064H,000H,000H  ;    100
FAA1: 0A0000                    DB      00AH,000H,000H  ;     10
FAA4: 010000                    DB      001H,000H,000H  ;      1
                        
FAA7: 213CF8   [10]     NEGAFT: LD  HL,INVSGN           ; Negate result
FAAA: E3       [29]             EX      (SP),HL         ; To be done after caller
FAAB: E9       [33]             JP      (HL)            ; Return to caller
                        
FAAC: CD44F8   [17]     SQR:    CALL    STAKFP          ; Put value on stack
FAAF: 2191FA   [27]             LD      HL,HALF         ; Set power to 1/2
FAB2: CD51F8   [44]             CALL    PHLTFP          ; Move 1/2 to FPREG
                        
FAB5: C1       [10]     POWER:  POP     BC              ; Get base
FAB6: D1       [20]             POP     DE
FAB7: CD13F8   [37]             CALL    TSTSGN          ; Test sign of power
FABA: 78       [41]             LD      A,B             ; Get exponent of base
FABB: CAFAFA   [51|51]          JP      Z,EXP           ; Make result 1 if zero
FABE: F2C5FA   [61|61]          JP      P,POWER1        ; Positive base - Ok
FAC1: B7       [65]             OR      A               ; Zero to negative power?
FAC2: CAB0E3   [75|75]          JP      Z,DZERR         ; Yes - ?/0 Error
FAC5: B7       [ 4]     POWER1: OR      A               ; Base zero?
FAC6: CA34F6   [14|14]          JP      Z,SAVEXP        ; Yes - Return zero
FAC9: D5       [25]             PUSH    DE              ; Save base
FACA: C5       [36]             PUSH    BC
FACB: 79       [40]             LD      A,C             ; Get MSB of base
FACC: F67F     [47]             OR      01111111B       ; Get sign status
FACE: CD5FF8   [64]             CALL    BCDEFP          ; Move power to BCDE
FAD1: F2E2FA   [74|74]          JP      P,POWER2        ; Positive base - Ok
FAD4: D5       [85]             PUSH    DE              ; Save power
FAD5: C5       [96]             PUSH    BC
FAD6: CDE6F8   [113]            CALL    INT             ; Get integer of power
FAD9: C1       [123]            POP     BC              ; Restore power
FADA: D1       [133]            POP     DE
FADB: F5       [144]            PUSH    AF              ; MSB of base
FADC: CD8EF8   [161]            CALL    CMPNUM          ; Power an integer?
FADF: E1       [171]            POP     HL              ; Restore MSB of base
FAE0: 7C       [175]            LD      A,H             ; but don't affect flags
FAE1: 1F       [179]            RRA                     ; Exponent odd or even?
FAE2: E1       [10]     POWER2: POP     HL              ; Restore MSB and exponent
FAE3: 22E610   [26]             LD      (FPREG+2),HL    ; Save base in FPREG
FAE6: E1       [36]             POP     HL              ; LSBs of base
FAE7: 22E410   [52]             LD      (FPREG),HL      ; Save in FPREG
FAEA: DCA7FA   [62|69]          CALL    C,NEGAFT        ; Odd power - Negate result
FAED: CC3CF8   [72|79]          CALL    Z,INVSGN        ; Negative base - Negate it
FAF0: D5       [83]             PUSH    DE              ; Save power
FAF1: C5       [94]             PUSH    BC
FAF2: CDC7F6   [111]            CALL    LOG             ; Get LOG of base
FAF5: C1       [121]            POP     BC              ; Restore power
FAF6: D1       [131]            POP     DE
FAF7: CD08F7   [148]            CALL    FPMULT          ; Multiply LOG by power
                        
FAFA: CD44F8   [17]     EXP:    CALL    STAKFP          ; Put value on stack
FAFD: 013881   [27]             LD      BC,08138H       ; BCDE = 1/Ln(2)
FB00: 113BAA   [37]             LD      DE,0AA3BH
FB03: CD08F7   [54]             CALL    FPMULT          ; Multiply value by 1/LN(2)
FB06: 3AE710   [67]             LD      A,(FPEXP)       ; Get exponent
FB09: FE88     [74]             CP      80H+8           ; Is it in range?
FB0B: D2EFF7   [84|84]          JP      NC,OVTST1       ; No - Test for overflow
FB0E: CDE6F8   [101]            CALL    INT             ; Get INT of FPREG
FB11: C680     [108]            ADD     A,80H           ; For excess 128
FB13: C602     [115]            ADD     A,2             ; Exponent > 126?
FB15: DAEFF7   [125|125]        JP      C,OVTST1        ; Yes - Test for overflow
FB18: F5       [136]            PUSH    AF              ; Save scaling factor
FB19: 21B6F6   [146]            LD      HL,UNITY        ; Point to 1.
FB1C: CDBEF5   [163]            CALL    ADDPHL          ; Add 1 to FPREG
FB1F: CDFFF6   [180]            CALL    MULLN2          ; Multiply by LN(2)
FB22: F1       [190]            POP     AF              ; Restore scaling factor
FB23: C1       [200]            POP     BC              ; Restore exponent
FB24: D1       [210]            POP     DE
FB25: F5       [221]            PUSH    AF              ; Save scaling factor
FB26: CDCAF5   [238]            CALL    SUBCDE          ; Subtract exponent from FPREG
FB29: CD3CF8   [255]            CALL    INVSGN          ; Negate result
FB2C: 213AFB   [265]            LD      HL,EXPTAB       ; Coefficient table
FB2F: CD6AFB   [282]            CALL    SMSER1          ; Sum the series
FB32: 110000   [292]            LD      DE,0            ; Zero LSBs
FB35: C1       [302]            POP     BC              ; Scaling factor
FB36: 4A       [306]            LD      C,D             ; Zero MSB
FB37: C308F7   [316]            JP      FPMULT          ; Scale result to correct value
                        
FB3A: 08                EXPTAB: DB      8                       ; Table used by EXP
FB3B: 402E9474                  DB      040H,02EH,094H,074H     ; -1/7! (-1/5040)
FB3F: 704F2E77                  DB      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
FB43: 6E02887A                  DB      06EH,002H,088H,07AH     ; -1/5! (-1/120)
FB47: E6A02A7C                  DB      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
FB4B: 50AAAA7E                  DB      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
FB4F: FFFF7F7F                  DB      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
FB53: 00008081                  DB      000H,000H,080H,081H     ; -1/1! (-1/1)
FB57: 00000081                  DB      000H,000H,000H,081H     ;  1/0! ( 1/1)
                        
FB5B: CD44F8   [17]     SUMSER: CALL    STAKFP          ; Put FPREG on stack
FB5E: 1106F7   [27]             LD      DE,MULT         ; Multiply by "X"
FB61: D5       [38]             PUSH    DE              ; To be done after
FB62: E5       [49]             PUSH    HL              ; Save address of table
FB63: CD5FF8   [66]             CALL    BCDEFP          ; Move FPREG to BCDE
FB66: CD08F7   [83]             CALL    FPMULT          ; Square the value
FB69: E1       [93]             POP     HL              ; Restore address of table
FB6A: CD44F8   [17]     SMSER1: CALL    STAKFP          ; Put value on stack
FB6D: 7E       [24]             LD      A,(HL)          ; Get number of coefficients
FB6E: 23       [30]             INC     HL              ; Point to start of table
FB6F: CD51F8   [47]             CALL    PHLTFP          ; Move coefficient to FPREG
FB72: 06                        DB      06H             ; Skip "POP AF"
FB73: F1       [10]     SUMLP:  POP     AF              ; Restore count
FB74: C1       [20]             POP     BC              ; Restore number
FB75: D1       [30]             POP     DE
FB76: 3D       [34]             DEC     A               ; Cont coefficients
FB77: C8       [39|45]          RET     Z               ; All done
FB78: D5       [50]             PUSH    DE              ; Save number
FB79: C5       [61]             PUSH    BC
FB7A: F5       [72]             PUSH    AF              ; Save count
FB7B: E5       [83]             PUSH    HL              ; Save address in table
FB7C: CD08F7   [100]            CALL    FPMULT          ; Multiply FPREG by BCDE
FB7F: E1       [110]            POP     HL              ; Restore address in table
FB80: CD62F8   [127]            CALL    LOADFP          ; Number at HL to BCDE
FB83: E5       [138]            PUSH    HL              ; Save address in table
FB84: CDCDF5   [155]            CALL    FPADD           ; Add coefficient to FPREG
FB87: E1       [165]            POP     HL              ; Restore address in table
FB88: C373FB   [175]            JP      SUMLP           ; More coefficients
                        
FB8B: CD13F8   [17]     RND:    CALL    TSTSGN          ; Test sign of FPREG
FB8E: 211910   [27]             LD      HL,SEED+2       ; Random number seed
FB91: FAECFB   [37|37]          JP      M,RESEED        ; Negative - Re-seed
FB94: 213A10   [47]             LD      HL,LSTRND       ; Last random number
FB97: CD51F8   [64]             CALL    PHLTFP          ; Move last RND to FPREG
FB9A: 211910   [74]             LD      HL,SEED+2       ; Random number seed
FB9D: C8       [79|85]          RET     Z               ; Return if RND(0)
FB9E: 86       [86]             ADD     A,(HL)          ; Add (SEED)+2)
FB9F: E607     [93]             AND     00000111B       ; 0 to 7
FBA1: 0600     [100]            LD      B,0
FBA3: 77       [107]            LD      (HL),A          ; Re-save seed
FBA4: 23       [113]            INC     HL              ; Move to coefficient table
FBA5: 87       [117]            ADD     A,A             ; 4 bytes
FBA6: 87       [121]            ADD     A,A             ; per entry
FBA7: 4F       [125]            LD      C,A             ; BC = Offset into table
FBA8: 09       [136]            ADD     HL,BC           ; Point to coefficient
FBA9: CD62F8   [153]            CALL    LOADFP          ; Coefficient to BCDE
FBAC: CD08F7   [170]            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
FBAF: 3A1810   [183]            LD      A,(SEED+1)      ; Get (SEED+1)
FBB2: 3C       [187]            INC     A               ; Add 1
FBB3: E603     [194]            AND     00000011B       ; 0 to 3
FBB5: 0600     [201]            LD      B,0
FBB7: FE01     [208]            CP      1               ; Is it zero?
FBB9: 88       [212]            ADC     A,B             ; Yes - Make it 1
FBBA: 321810   [225]            LD      (SEED+1),A      ; Re-save seed
FBBD: 21F0FB   [235]            LD      HL,RNDTAB-4     ; Addition table
FBC0: 87       [239]            ADD     A,A             ; 4 bytes
FBC1: 87       [243]            ADD     A,A             ; per entry
FBC2: 4F       [247]            LD      C,A             ; BC = Offset into table
FBC3: 09       [258]            ADD     HL,BC           ; Point to value
FBC4: CDBEF5   [275]            CALL    ADDPHL          ; Add value to FPREG
FBC7: CD5FF8   [17]     RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
FBCA: 7B       [21]             LD      A,E             ; Get LSB
FBCB: 59       [25]             LD      E,C             ; LSB = MSB
FBCC: EE4F     [32]             XOR     01001111B       ; Fiddle around
FBCE: 4F       [36]             LD      C,A             ; New MSB
FBCF: 3680     [46]             LD      (HL),80H        ; Set exponent
FBD1: 2B       [52]             DEC     HL              ; Point to MSB
FBD2: 46       [59]             LD      B,(HL)          ; Get MSB
FBD3: 3680     [69]             LD      (HL),80H        ; Make value -0.5
FBD5: 211710   [79]             LD      HL,SEED         ; Random number seed
FBD8: 34       [90]             INC     (HL)            ; Count seed
FBD9: 7E       [97]             LD      A,(HL)          ; Get seed
FBDA: D6AB     [104]            SUB     171             ; Do it modulo 171
FBDC: C2E3FB   [114|114]        JP      NZ,RND2         ; Non-zero - Ok
FBDF: 77       [121]            LD      (HL),A          ; Zero seed
FBE0: 0C       [125]            INC     C               ; Fillde about
FBE1: 15       [129]            DEC     D               ; with the
FBE2: 1C       [133]            INC     E               ; number
FBE3: CD1EF6   [17]     RND2:   CALL    BNORM           ; Normalise number
FBE6: 213A10   [27]             LD      HL,LSTRND       ; Save random number
FBE9: C36BF8   [37]             JP      FPTHL           ; Move FPREG to last and return
                        
FBEC: 77       [ 7]     RESEED: LD      (HL),A          ; Re-seed random numbers
FBED: 2B       [13]             DEC     HL
FBEE: 77       [20]             LD      (HL),A
FBEF: 2B       [26]             DEC     HL
FBF0: 77       [33]             LD      (HL),A
FBF1: C3C7FB   [43]             JP      RND1            ; Return RND seed
                        
FBF4: 68B14668          RNDTAB: DB      068H,0B1H,046H,068H     ; Table used by RND
FBF8: 99E99269                  DB      099H,0E9H,092H,069H
FBFC: 10D17568                  DB      010H,0D1H,075H,068H
                        
FC00: 214AFC   [10]     COS:    LD      HL,HALFPI       ; Point to PI/2
FC03: CDBEF5   [27]             CALL    ADDPHL          ; Add it to PPREG
FC06: CD44F8   [17]     SIN:    CALL    STAKFP          ; Put angle on stack
FC09: 014983   [27]             LD      BC,8349H        ; BCDE = 2 PI
FC0C: 11DB0F   [37]             LD      DE,0FDBH
FC0F: CD54F8   [54]             CALL    FPBCDE          ; Move 2 PI to FPREG
FC12: C1       [64]             POP     BC              ; Restore angle
FC13: D1       [74]             POP     DE
FC14: CD69F7   [91]             CALL    DVBCDE          ; Divide angle by 2 PI
FC17: CD44F8   [108]            CALL    STAKFP          ; Put it on stack
FC1A: CDE6F8   [125]            CALL    INT             ; Get INT of result
FC1D: C1       [135]            POP     BC              ; Restore number
FC1E: D1       [145]            POP     DE
FC1F: CDCAF5   [162]            CALL    SUBCDE          ; Make it 0 <= value < 1
FC22: 214EFC   [172]            LD      HL,QUARTR       ; Point to 0.25
FC25: CDC4F5   [189]            CALL    SUBPHL          ; Subtract value from 0.25
FC28: CD13F8   [206]            CALL    TSTSGN          ; Test sign of value
FC2B: 37       [210]            SCF                     ; Flag positive
FC2C: F236FC   [220|220]        JP      P,SIN1          ; Positive - Ok
FC2F: CDBBF5   [237]            CALL    ROUND           ; Add 0.5 to value
FC32: CD13F8   [254]            CALL    TSTSGN          ; Test sign of value
FC35: B7       [258]            OR      A               ; Flag negative
FC36: F5       [11]     SIN1:   PUSH    AF              ; Save sign
FC37: F43CF8   [21|28]          CALL    P,INVSGN        ; Negate value if positive
FC3A: 214EFC   [31]             LD      HL,QUARTR       ; Point to 0.25
FC3D: CDBEF5   [48]             CALL    ADDPHL          ; Add 0.25 to value
FC40: F1       [58]             POP     AF              ; Restore sign
FC41: D43CF8   [68|75]          CALL    NC,INVSGN       ; Negative - Make positive
FC44: 2152FC   [78]             LD      HL,SINTAB       ; Coefficient table
FC47: C35BFB   [88]             JP      SUMSER          ; Evaluate sum of series
                        
FC4A: DB0F4981          HALFPI: DB      0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
                        
FC4E: 0000007F          QUARTR: DB      000H,000H,000H,07FH     ; 0.25
                        
FC52: 05                SINTAB: DB      5                       ; Table used by SIN
FC53: BAD71E86                  DB      0BAH,0D7H,01EH,086H     ; 39.711
FC57: 64269987                  DB      064H,026H,099H,087H     ;-76.575
FC5B: 58342387                  DB      058H,034H,023H,087H     ; 81.602
FC5F: E05DA586                  DB      0E0H,05DH,0A5H,086H     ;-41.342
FC63: DA0F4983                  DB      0DAH,00FH,049H,083H     ;  6.2832
                        
FC67: CD44F8   [17]     TAN:    CALL    STAKFP          ; Put angle on stack
FC6A: CD06FC   [34]             CALL    SIN             ; Get SIN of angle
FC6D: C1       [44]             POP     BC              ; Restore angle
FC6E: E1       [54]             POP     HL
FC6F: CD44F8   [71]             CALL    STAKFP          ; Save SIN of angle
FC72: EB       [75]             EX      DE,HL           ; BCDE = Angle
FC73: CD54F8   [92]             CALL    FPBCDE          ; Angle to FPREG
FC76: CD00FC   [109]            CALL    COS             ; Get COS of angle
FC79: C367F7   [119]            JP      DIV             ; TAN = SIN / COS
                        
FC7C: CD13F8   [17]     ATN:    CALL    TSTSGN          ; Test sign of value
FC7F: FCA7FA   [27|34]          CALL    M,NEGAFT        ; Negate result after if -ve
FC82: FC3CF8   [37|44]          CALL    M,INVSGN        ; Negate value if -ve
FC85: 3AE710   [50]             LD      A,(FPEXP)       ; Get exponent
FC88: FE81     [57]             CP      81H             ; Number less than 1?
FC8A: DA99FC   [67|67]          JP      C,ATN1          ; Yes - Get arc tangnt
FC8D: 010081   [77]             LD      BC,8100H        ; BCDE = 1
FC90: 51       [81]             LD      D,C
FC91: 59       [85]             LD      E,C
FC92: CD69F7   [102]            CALL    DVBCDE          ; Get reciprocal of number
FC95: 21C4F5   [112]            LD      HL,SUBPHL       ; Sub angle from PI/2
FC98: E5       [123]            PUSH    HL              ; Save for angle > 1
FC99: 21A3FC   [10]     ATN1:   LD      HL,ATNTAB       ; Coefficient table
FC9C: CD5BFB   [27]             CALL    SUMSER          ; Evaluate sum of series
FC9F: 214AFC   [37]             LD      HL,HALFPI       ; PI/2 - angle in case > 1
FCA2: C9       [47]             RET                     ; Number > 1 - Sub from PI/2
                        
FCA3: 09                ATNTAB: DB      9                       ; Table used by ATN
FCA4: 4AD73B78                  DB      04AH,0D7H,03BH,078H     ; 1/17
FCA8: 026E847B                  DB      002H,06EH,084H,07BH     ;-1/15
FCAC: FEC12F7C                  DB      0FEH,0C1H,02FH,07CH     ; 1/13
FCB0: 74319A7D                  DB      074H,031H,09AH,07DH     ;-1/11
FCB4: 843D5A7D                  DB      084H,03DH,05AH,07DH     ; 1/9
FCB8: C87F917E                  DB      0C8H,07FH,091H,07EH     ;-1/7
FCBC: E4BB4C7E                  DB      0E4H,0BBH,04CH,07EH     ; 1/5
FCC0: 6CAAAA7F                  DB      06CH,0AAH,0AAH,07FH     ;-1/3
FCC4: 00000081                  DB      000H,000H,000H,081H     ; 1/1
                        
FCC8: CD39FE   [17]     CASFFW: CALL    FLPLED          ; Turn on cassette
FCCB: 0600     [24]             LD      B,0             ; Set 1 second delay
FCCD: CD9BFD   [17]     DELAYB: CALL    DELAY           ; Wait a bit
FCD0: 05       [21]             DEC     B               ; Count
FCD1: C2CDFC   [31|31]          JP      NZ,DELAYB       ; More delay needed
FCD4: C9       [41]             RET
                        
FCD5: C339FE   [10]     CASFF:  JP      FLPLED          ; Flip tape LED
                        
FCD8: C9       [10]     ARET:   RET                     ; A RETurn instruction
                        
FCD9: E5       [11]     CONMON: PUSH    HL              ; Output character to screen
FCDA: C5       [22]             PUSH    BC              ; 
FCDB: D5       [33]             PUSH    DE              ; 
FCDC: F5       [44]             PUSH    AF              ; 
FCDD: CD6DFE   [61]             CALL    MONTST          ; See if NAS-SYS
FCE0: C2FBFC   [71|71]          JP      NZ,NASOUT       ; NAS-SYS - Output ASCII
FCE3: F1       [81]             POP     AF              ; Get character
FCE4: F5       [92]             PUSH    AF              ; And re-save
FCE5: FE0A     [99]             CP      LF              ; ASCII Line feed?
FCE7: CA00FD   [109|109]        JP      Z,IGCHR         ; Yes - Ignore it
FCEA: FE08     [116]            CP      BKSP            ; ASCII back space?
FCEC: C2F1FC   [126|126]        JP      NZ,CONOT1       ; No - Test for CR
FCEF: 3E1D     [133]            LD      A,TBS           ; NASBUG back space
FCF1: FE0D     [ 7]     CONOT1: CP      CR              ; ASCII CR?
FCF3: C2FDFC   [17|17]          JP      NZ,OUTCHR       ; No - Output character
FCF6: 3E1F     [24]             LD      A,TCR           ; NASBUG CR
FCF8: C3FDFC   [34]             JP      OUTCHR          ; Output it
                        
FCFB: F1       [10]     NASOUT: POP     AF              ; Get character
FCFC: F5       [21]             PUSH    AF              ; And re-save
FCFD: CD45FE   [17]     OUTCHR: CALL    MONOUT          ; Output it
FD00: F1       [10]     IGCHR:  POP     AF              ; Restore character
FD01: D1       [20]             POP     DE              ;
FD02: C1       [30]             POP     BC              ;
FD03: E1       [40]             POP     HL              ;
FD04: C9       [50]             RET
                        
FD05: E5       [11]     GETINP: PUSH    HL              ; Get an input character
FD06: C5       [22]             PUSH    BC              ;
FD07: D5       [33]             PUSH    DE              ;
FD08: CD6DFE   [50]             CALL    MONTST          ; See if NAS-SYS
FD0B: CA13FD   [60|60]          JP      Z,GETTIN        ; "T" monitor - Get input
FD0E: DF7B                      DW      _BLNK
FD10: C319FD   [70]             JP      CONVIN          ; Convert to ASCII
                        
FD13: CD4D0C   [17]     GETTIN: CALL    TIN             ; "T" input a character
FD16: D213FD   [27|27]          JP      NC,GETTIN       ; No input - wait
FD19: FE1D     [ 7]     CONVIN: CP      TBS             ; NASBUG back space?
FD1B: C220FD   [17|17]          JP      NZ,CNVIN1       ; No - Test for break
FD1E: 3E08     [24]             LD      A,BKSP          ; ASCII back space
FD20: FE1C     [ 7]     CNVIN1: CP      TBRK            ; NASBUG break?
FD22: C227FD   [17|17]          JP      NZ,CNVIN2       ; No - Test for control Z
FD25: 3E03     [24]             LD      A,CTRLC         ; Control C
FD27: FE1A     [ 7]     CNVIN2: CP      CTRLZ           ; ^Z?
FD29: C22EFD   [17|17]          JP      NZ,CNVIN3       ; No - Test for escape
FD2C: 3E7F     [24]             LD      A,DEL           ; Delete
FD2E: FE1B     [ 7]     CNVIN3: CP      ESC             ; "ESC" ?
FD30: C235FD   [17|17]          JP      NZ,CNVIN4       ; No - Test for CR
FD33: 3E03     [24]             LD      A,CTRLC         ; Control C
FD35: FE1F     [ 7]     CNVIN4: CP      TCR             ; NASBUG CR?
FD37: C23CFD   [17|17]          JP      NZ,CNVIN5       ; No - Return character
FD3A: 3E0D     [24]             LD      A,CR            ; ASCII CR
FD3C: D1       [10]     CNVIN5: POP     DE
FD3D: C1       [20]             POP     BC
FD3E: E1       [30]             POP     HL
FD3F: C9       [40]             RET
                        
FD40: AF       [ 4]     CHKBRK: XOR     A               ; Check for break
FD41: CD70FD   [21]             CALL    SFTENT          ; Test for shift/enter
FD44: CA50FD   [31|31]          JP      Z,TBRK2         ; Yes - Test for second break
FD47: 3A4D10   [44]             LD      A,(BRKFLG)      ; Get break flag
FD4A: B7       [48]             OR      A               ; Break flag set?
FD4B: C250FD   [58|58]          JP      NZ,TBRK2        ; Yes - Test for second break
FD4E: AF       [62]             XOR     A               ; Flag no break
FD4F: C9       [72]             RET
                        
FD50: CD53FE   [17]     TBRK2:  CALL    BREAK2          ; Second break?
FD53: 3EFF     [24]             LD      A,-1            ; Flag break
FD55: C9       [34]             RET
                        
FD56: DB02     [11]     GUART:  IN      A,(UARTS)       ; Get UART status
FD58: 17       [15]             RLA                     ; Any data ready?
FD59: D256FD   [25|25]          JP      NC,GUART        ; No - wait until there is
FD5C: DB01     [36]             IN      A,(UARTD)       ; Get data from UART
FD5E: C9       [46]             RET
                        
FD5F: D301     [11]     UARTOT: OUT     (UARTD),A       ; Send data to UART
FD61: DB02     [11]     URTOLP: IN      A,(UARTS)       ; Get status
FD63: 87       [15]             ADD     A,A             ; Byte sent?
FD64: F8       [20|26]          RET     M               ; Yes - Return
FD65: C361FD   [30]             JP      URTOLP          ; Keep waiting
                        
FD68: F5       [11]     SUART:  PUSH    AF              ; Save A
FD69: CD5FFD   [28]             CALL    UARTOT          ; Send it to UART
FD6C: F1       [38]             POP     AF              ; Restore A
FD6D: C9       [48]             RET
                        
FD6E: 00       [52]             NOP
FD6F: 00       [56]             NOP
                        
FD70: E5       [11]     SFTENT: PUSH    HL              ; Test for Shift Enter from KBD
FD71: 3E02     [18]             LD      A,00000010B     ; Reset KBD counter mask
FD73: 21000C   [28]             LD      HL,PORT0        ; Get old contents
FD76: AE       [35]             XOR     (HL)            ; Toggle bit
FD77: D300     [46]             OUT     (0),A           ; Reset KBD counter
FD79: EE01     [53]             XOR     00000001B       ; Toggle bit
FD7B: D300     [64]             OUT     (0),A           ; Next row
FD7D: EE02     [71]             XOR     00000010B
FD7F: D300     [82]             OUT     (0),A           ; Clear "clear" strobe
FD81: 7E       [89]             LD      A,(HL)          ; Get old value
FD82: D300     [100]            OUT     (0),A           ; Original contents
FD84: 19       [111]            ADD     HL,DE           ; ?? WHAT ??
FD85: E1       [121]            POP     HL              ; Restore HL
FD86: DB00     [132]            IN      A,(0)           ; Read in row
FD88: E612     [139]            AND     00010010B       ; Mask SHIFT and ENTER
FD8A: C9       [149]            RET
                        
FD8B: CD6DFE   [17]     CLS:    CALL    MONTST          ; See if NAS-SYS
FD8E: CA96FD   [27|27]          JP      Z,TCLS          ; "T" CLS
FD91: 3E0C     [34]             LD      A,CS            ; ASCII Clear screen
FD93: C3D9FC   [44]             JP      CONMON          ; Output character
                        
FD96: 3E1E     [ 7]     TCLS:   LD      A,TCS           ; NASBUG Clear screen
FD98: C3D9FC   [17]             JP      CONMON          ; Output character
                        
FD9B: AF       [ 4]     DELAY:  XOR     A               ; Delay routine
FD9C: F5       [11]     DELAY1: PUSH    AF              ; PUSHes and POPs delay
FD9D: F1       [21]             POP     AF
FD9E: F5       [32]             PUSH    AF
FD9F: F1       [42]             POP     AF
FDA0: 3D       [46]             DEC     A               ; Count delays
FDA1: C29CFD   [56|56]          JP      NZ,DELAY1       ; More delay
FDA4: C9       [66]             RET
                        
FDA5: CD84F4   [17]     WIDTH:  CALL    GETINT          ; Get integer 0-255
FDA8: 7B       [21]             LD      A,E             ; Width to A
FDA9: 324210   [34]             LD      (LWIDTH),A      ; Set width
FDAC: C9       [44]             RET
                        
FDAD: CD41ED   [17]     LINES:  CALL    GETNUM          ; Get a number
FDB0: CD8BE9   [34]             CALL    DEINT           ; Get integer -32768 to 32767
FDB3: ED534610 [54]             LD      (LINESC),DE     ; Set lines counter
FDB7: ED534810 [74]             LD      (LINESN),DE     ; Set lines number
FDBB: C9       [84]             RET
                        
FDBC: CD8BE9   [17]     DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
FDBF: D5       [28]             PUSH    DE              ; Save number
FDC0: E1       [38]             POP     HL              ; Number to HL
FDC1: 46       [45]             LD      B,(HL)          ; Get LSB of contents
FDC2: 23       [51]             INC     HL
FDC3: 7E       [58]             LD      A,(HL)          ; Get MSB of contents
FDC4: C3F2F0   [68]             JP      ABPASS          ; Return integer AB
                        
FDC7: CD41ED   [17]     DOKE:   CALL    GETNUM          ; Get a number
FDCA: CD8BE9   [34]             CALL    DEINT           ; Get integer -32768 to 32767
FDCD: D5       [45]             PUSH    DE              ; Save address
FDCE: CD90E6   [62]             CALL    CHKSYN          ; Make sure "," follows
FDD1: 2C                        DB      ","
FDD2: CD41ED   [79]             CALL    GETNUM          ; Get a number
FDD5: CD8BE9   [96]             CALL    DEINT           ; Get integer -32768 to 32767
FDD8: E3       [115]            EX      (SP),HL         ; Save value,get address
FDD9: 73       [122]            LD      (HL),E          ; Save LSB of value
FDDA: 23       [128]            INC     HL
FDDB: 72       [135]            LD      (HL),D          ; Save MSB of value
FDDC: E1       [145]            POP     HL              ; Restore code string address
FDDD: C9       [155]            RET
                        
FDDE: F3       [ 4]     JJUMP1: DI                      ; Disable interrupts
FDDF: DD21FFFF [18]             LD      IX,-1           ; Flag cold start
FDE3: C312E0   [28]             JP      CSTART          ; Go and initialise
                        
FDE6: CD84F4   [17]     SCREEN: CALL    GETINT          ; Get integer 0 to 255
FDE9: F5       [28]             PUSH    AF              ; Save column
FDEA: CD90E6   [45]             CALL    CHKSYN          ; Make sure "," follows
FDED: 2C                        DB      ","
FDEE: CD84F4   [62]             CALL    GETINT          ; Get integer 0 to 255
FDF1: C1       [72]             POP     BC              ; Column to B
FDF2: E5       [83]             PUSH    HL              ; Save code string address
FDF3: C5       [94]             PUSH    BC              ; Save column
FDF4: CD11FE   [111]            CALL    SCRADR          ; Calculate screen address
FDF7: E5       [122]            PUSH    HL              ; Save screen address
FDF8: CD6DFE   [139]            CALL    MONTST          ; See if NAS-SYS
FDFB: CA04FE   [149|149]        JP      Z,TMNCUR        ; "T" monitor - "T" cursor
FDFE: E1       [159]            POP     HL              ; Restore screen address
FDFF: 22290C   [175]            LD      (CURSOR),HL     ; Set new cursor position
FE02: E1       [185]            POP     HL              ; Rstore code string address
FE03: C9       [195]            RET
                        
FE04: 2A180C   [16]     TMNCUR: LD      HL,(TCUR)       ; Get address or cursor
FE07: 3620     [26]             LD      (HL)," "        ; Remove cursor
FE09: E1       [36]             POP     HL              ; Get new cursor address
FE0A: 22180C   [52]             LD      (TCUR),HL       ; Set new cursor
FE0D: 365F     [62]             LD      (HL),"_"        ; Put it on screen
FE0F: E1       [72]             POP     HL              ; Restore code string address
FE10: C9       [82]             RET
                        
FE11: 21C907   [10]     SCRADR: LD      HL,VDU+10-65    ; SCREEN VDU address (0,0)
FE14: 0600     [17]             LD      B,0
FE16: 4F       [21]             LD      C,A             ; Line to BC
FE17: B7       [25]             OR      A               ; Test it
FE18: CAA0E9   [35|35]          JP      Z,FCERR         ; Zero - ?FC Error
FE1B: FE11     [42]             CP      16+1            ; 16 lines
FE1D: F2A0E9   [52|52]          JP      P,FCERR         ; > 16 - ?FC Error
FE20: D1       [62]             POP     DE              ; RETurn address
FE21: F1       [72]             POP     AF              ; Get column
FE22: D5       [83]             PUSH    DE              ; Re-save RETurn
FE23: 1600     [90]             LD      D,0
FE25: 5F       [94]             LD      E,A             ; Column to DE
FE26: B7       [98]             OR      A               ; Test it
FE27: CAA0E9   [108|108]        JP      Z,FCERR         ; Zero - ?FC Error
FE2A: FE31     [115]            CP      48+1            ; 48 characters per line
FE2C: F2A0E9   [125|125]        JP      P,FCERR         ; > 48 - ?FC Error
FE2F: 19       [136]            ADD     HL,DE           ; Add column to address
FE30: 1600     [143]            LD      D,0
FE32: 59       [147]            LD      E,C             ; Line to DE
FE33: 0640     [154]            LD      B,64            ; 64 Bytes per line
FE35: 19       [11]     ADD64X: ADD     HL,DE           ; Add line
FE36: 10FD     [19|24]          DJNZ    ADD64X          ; SIXTY FOUR TIMES!!!
FE38: C9       [29]             RET
                        
FE39: CD6DFE   [17]     FLPLED: CALL    MONTST          ; See if NAS-SYS
FE3C: CA42FE   [27|27]          JP      Z,TMFLP         ; "T" MFLP
FE3F: DF5F                      DW      _MFLP
FE41: C9       [37]             RET
                        
FE42: C35100   [10]     TMFLP:  JP      MFLP            ; Flip drive LED
                        
FE45: F5       [11]     MONOUT: PUSH    AF              ; Save character
FE46: CD6DFE   [28]             CALL    MONTST          ; See if NAS-SYS
FE49: CA4FFE   [38|38]          JP      Z,TMNOUT        ; "T" output
FE4C: F1       [48]             POP     AF              ; Restore character
FE4D: F7                        DB      _ROUT           ; Output it
FE4E: C9       [58]             RET
                        
FE4F: F1       [10]     TMNOUT: POP     AF              ; Restore character
FE50: C34A0C   [20]             JP      TOUT            ; "T" output
                        
FE53: 3A4D10   [13]     BREAK2: LD      A,(BRKFLG)      ; Break flag set?
FE56: C265FE   [23|23]          JP      NZ,RETCTC       ; Yes - Return ^C
FE59: CD6DFE   [40]             CALL    MONTST          ; See if NAS-SYS
FE5C: CA62FE   [50|50]          JP      Z,TCHINP        ; Get "T" character input
FE5F: DF62                      DW      _RIN            ; Scan for a character
FE61: C9       [60]             RET
                        
FE62: C34D0C   [10]     TCHINP: JP      TIN             ; "T" input a character
                        
FE65: 3E00     [ 7]     RETCTC: LD      A,0             ; Clear Break flag
FE67: 324D10   [20]             LD      (BRKFLG),A
FE6A: 3E03     [27]             LD      A,CTRLC         ; Return ^C
FE6C: C9       [37]             RET
                        
FE6D: 3A0100   [13]     MONTST: LD      A,(MONSTT+1)    ; "T" monitor or NAS-SYS?
FE70: FE33     [20]             CP      33H             ; 31 00 10 / 31 33 0C
FE72: C9       [30]             RET
                        
FE73: CD39FE   [17]     SAVE:   CALL    FLPLED          ; Flip tape LED
FE76: CD6DFE   [34]             CALL    MONTST          ; See if NAS-SYS
FE79: CA7FFE   [44|44]          JP      Z,TSAVE         ; "T" save
FE7C: DF57                      DW      _WRIT           ; Save program
FE7E: C9       [54]             RET
                        
FE7F: 3A8D00   [13]     TSAVE:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
FE82: CA0004   [23|23]          JP      Z,T4WR          ; T4 Write
FE85: C3D103   [33]             JP      T2DUMP          ; T2 Dump
                        
FE88: CD39FE   [17]     MONLD:  CALL    FLPLED          ; Flip tape LED
FE8B: CD6DFE   [34]             CALL    MONTST          ; See if NAS-SYS
FE8E: CA99FE   [44|44]          JP      Z,TLOAD         ; "T" load
FE91: 3E52     [51]             LD      A,"R"           ; Set READ
FE93: 322B0C   [64]             LD      (ARGN),A
FE96: DF52                      DW      _READ           ; Load program
FE98: C9       [74]             RET
                        
FE99: 3A8D00   [13]     TLOAD:  LD      A,(MONTYP)      ; "T2" or "T4" (FLAGS!!!)
FE9C: CA0C07   [23|23]          JP      Z,T4READ        ; T4 Read
FE9F: C3D103   [33]             JP      T2DUMP          ; T2 Dump ??????????
                        
FEA2: CD6DFE   [17]     MONITR: CALL    MONTST          ; See if NAS-SYS
FEA5: CA0000   [27|27]          JP      Z,MONSTT        ; Jump to zero if "T"
FEA8: DF5B                      DW      _MRET           ; Return to NAS-SYS
                        
FEAA: CD39FE   [17]     MONVE:  CALL    FLPLED          ; Flip tape LED
FEAD: CD6DFE   [34]             CALL    MONTST          ; See if NAS-SYS
FEB0: CAA0E9   [44|44]          JP      Z,FCERR         ; Verify not available on "T"
FEB3: 3E56     [51]             LD      A,"V"           ; Set VERIFY
FEB5: 322B0C   [64]             LD      (ARGN),A
FEB8: DF56                      DW      _VRFY           ; Verify tape
FEBA: C9       [74]             RET
                        
FEBB: 3E00     [ 7]     INITST: LD      A,0             ; Clear break flag
FEBD: 324D10   [20]             LD      (BRKFLG),A
FEC0: CD6DFE   [37]             CALL    MONTST          ; See if NAS-SYS
FEC3: CA19E0   [47|47]          JP      Z,INIT          ; "T" - No NMI vector
FEC6: 21DEFE   [57]             LD      HL,BREAK        ; Set NMI gives break
FEC9: 227E0C   [73]             LD      (NMI),HL
FECC: DDE5     [88]             PUSH    IX              ; Get start up condition
FECE: F1       [98]             POP     AF              ; "Z" set if cold , Else clear
FECF: B7       [102]            OR      A               ; "Cold" or "Cool" start?
FED0: C219E0   [112|112]        JP      NZ,INIT         ; "Cool" don't init NAS-SYS
FED3: 060F     [119]            LD      B,15            ; Delay for keyboard clear
FED5: CDCDFC   [136]            CALL    DELAYB          ; Allow time for key release
FED8: CD0D00   [153]            CALL    STMON           ; Initialise NAS-SYS
FEDB: C319E0   [163]            JP      INIT            ; Initialise BASIC
                        
FEDE: F5       [11]     BREAK:  PUSH    AF              ; Save character
FEDF: 3EFF     [18]             LD      A,-1
FEE1: 324D10   [31]             LD      (BRKFLG),A      ; Flag break
FEE4: F1       [41]             POP     AF              ; Restore character
FEE5: ED45     [14]     ARETN:  RETN                    ; Return from NMI
                        
FEE7: 00       [18]             NOP
                        
FEE8: DF63              INLINE: DW      _INLN           ; Get an input line
FEEA: D5       [11]             PUSH    DE              ; Save cursor address
FEEB: D5       [22]             PUSH    DE              ; Cursor address to HL
FEEC: E1       [32]             POP     HL
FEED: 112F00   [42]             LD      DE,48-1         ; Length of line-1
FEF0: 19       [53]             ADD     HL,DE           ; Point to end of line
FEF1: 7E       [ 7]     ENDLIN: LD      A,(HL)          ; Get end of line
FEF2: FE20     [14]             CP      " "             ; Space?
FEF4: C202FF   [24|24]          JP      NZ,LINTBF       ; No - Copy to buffer
FEF7: 1D       [28]             DEC     E               ; Back 1 character
FEF8: 3E00     [35]             LD      A,0             ; Wasteful test on E
FEFA: B3       [39]             OR      E
FEFB: CA02FF   [49|49]          JP      Z,LINTBF        ; Start of line - Copy it
FEFE: 2B       [55]             DEC     HL              ; Back 1 character
FEFF: C3F1FE   [65]             JP      ENDLIN          ; Keep looking for end
                        
FF02: D5       [11]     LINTBF: PUSH    DE              ; Line length to BC
FF03: C1       [21]             POP     BC
FF04: 03       [27]             INC     BC              ; Length +1
FF05: 116110   [37]             LD      DE,BUFFER       ; Input buffer
FF08: E1       [47]             POP     HL              ; Line start
FF09: C5       [58]             PUSH    BC              ; Save length
FF0A: EDB0     [74|21]          LDIR                    ; Move line to buffer
FF0C: 3E00     [81]             LD      A,0
FF0E: 12       [88]             LD      (DE),A          ; Mark end of buffer with 00
FF0F: C1       [98]             POP     BC              ; Restore buffer length
FF10: 41       [102]            LD      B,C             ; Length returned in B
FF11: 216010   [112]            LD      HL,BUFFER-1     ; Point to start of buffer-1
FF14: C9       [122]            RET
                        
FF15: CD90E6   [17]     GETXYA: CALL    CHKSYN          ; Make sure "(" follows
FF18: 28                        DB      "("
FF19: CD41ED   [34]             CALL    GETNUM          ; Get a number
FF1C: CD8BE9   [51]             CALL    DEINT           ; Get integer -32768 to 32767
FF1F: D5       [62]             PUSH    DE              ; Save "X"
FF20: CD90E6   [79]             CALL    CHKSYN          ; Make sure "," follows
FF23: 2C                        DB      ","
FF24: CD41ED   [96]             CALL    GETNUM          ; Get a number
FF27: CD90E6   [113]            CALL    CHKSYN          ; Make sure ")" follows
FF2A: 29                        DB      ")"
FF2B: CD8BE9   [130]            CALL    DEINT           ; Get integer -32768 to 32767
FF2E: E5       [141]            PUSH    HL              ; Save code string address
FF2F: FDE1     [155]            POP     IY              ; In IY
FF31: CD96FF   [172]            CALL    XYPOS           ; Address and bit mask
FF34: F5       [183]            PUSH    AF              ; Save mask
FF35: CDC2FF   [200]            CALL    ADJCOL          ; Adjust column
FF38: CD11FE   [217]            CALL    SCRADR          ; Get VDU address
FF3B: F1       [227]            POP     AF              ; Restore bit mask
FF3C: 06C0     [234]            LD      B,11000000B     ; Block graphics base
FF3E: B0       [238]            OR      B               ; Set bits 7 & 6
FF3F: C9       [248]            RET
                        
FF40: CD15FF   [17]     SETB:   CALL    GETXYA          ; Get co-ords and VDU address
FF43: F5       [28]             PUSH    AF              ; Save bit mask
FF44: 7E       [35]             LD      A,(HL)          ; Get character from screen
FF45: FEC0     [42]             CP      11000000B       ; Is it a block graphic?
FF47: D250FF   [52|52]          JP      NC,SETOR        ; Yes - OR new bit
FF4A: F1       [62]             POP     AF              ; Restore bit mask
FF4B: 77       [ 7]     PUTBIT: LD      (HL),A          ; Put character on screen
FF4C: FDE5     [15]     RESCSA: PUSH    IY              ; Restore code string address
FF4E: E1       [25]             POP     HL              ; From IY
FF4F: C9       [35]             RET
                        
FF50: C1       [10]     SETOR:  POP     BC              ; Restore bit mask
FF51: B0       [14]             OR      B               ; Merge the bits
FF52: C34BFF   [24]             JP      PUTBIT          ; Save on screen
                        
FF55: CD15FF   [17]     RESETB: CALL    GETXYA          ; Get co-ords and VDU address
FF58: F5       [28]             PUSH    AF              ; Save bit mask
FF59: 7E       [35]             LD      A,(HL)          ; Get byte from screen
FF5A: FEC0     [42]             CP      11000000B       ; Is it a block graphic?
FF5C: DA75FF   [52|52]          JP      C,NORES         ; No - Leave it
FF5F: 063F     [59]             LD      B,00111111B     ; Six bits per block
FF61: A0       [63]             AND     B               ; Clear bits 7 & 6
FF62: C1       [73]             POP     BC              ; Get bit mask
FF63: A0       [77]             AND     B               ; Test for common bit
FF64: CA4CFF   [87|87]          JP      Z,RESCSA        ; None - Leave it
FF67: 7E       [94]             LD      A,(HL)          ; Get byte from screen
FF68: E63F     [101]            AND     00111111B       ; Isolate bit
FF6A: A8       [105]            XOR     B               ; Clear that bit
FF6B: FEC0     [112]            CP      11000000B       ; Is it a graphic blank?
FF6D: C24BFF   [122|122]        JP      NZ,PUTBIT       ; No - Save character
FF70: 3E20     [129]            LD      A," "           ; Put a space there
FF72: C34BFF   [139]            JP      PUTBIT          ; Save the space
                        
FF75: C1       [10]     NORES:  POP     BC              ; Drop bit mask
FF76: C34CFF   [20]             JP      RESCSA          ; Restore code string address
                        
FF79: CD15FF   [17]     POINTB: CALL    GETXYA          ; Get co-ords and VDU address
FF7C: 46       [24]             LD      B,(HL)          ; Get character from screen
FF7D: CDEDFF   [41]             CALL    TSTBIT          ; Test if bit is set
FF80: C291FF   [51|51]          JP      NZ,POINT0       ; Different - Return zero
FF83: 3E00     [58]             LD      A,0
FF85: 0601     [65]             LD      B,1             ; Integer AB = 1
FF87: E1       [10]     POINTX: POP     HL              ; Drop return
FF88: FDE5     [25]             PUSH    IY              ; PUSH code string address
FF8A: 111DEE   [35]             LD      DE,RETNUM       ; To return a number
FF8D: D5       [46]             PUSH    DE              ; Save for return
FF8E: C3F2F0   [56]             JP      ABPASS          ; Return integer AB
                        
FF91: 0600     [ 7]     POINT0: LD      B,0             ; Set zero
FF93: C387FF   [17]             JP      POINTX          ; Return value
                        
FF96: C1       [10]     XYPOS:  POP     BC              ; Get return address
FF97: E1       [20]             POP     HL              ; Get column
FF98: E5       [31]             PUSH    HL              ; And re-save
FF99: C5       [42]             PUSH    BC              ; Put back return address
FF9A: 7D       [46]             LD      A,L             ; Get column
FF9B: 0601     [53]             LD      B,00000001B     ; 2 bits per character
FF9D: A0       [57]             AND     B               ; Odd or even bit
FF9E: F5       [68]             PUSH    AF              ; Save it
FF9F: D5       [79]             PUSH    DE              ; Get row
FFA0: E1       [89]             POP     HL              ; to HL
FFA1: 110000   [99]             LD      DE,0            ; Zero line count
FFA4: 010300   [109]            LD      BC,3            ; 3 blocks per line
FFA7: 23       [115]            INC     HL
FFA8: ED42     [15]     DIV3LP: SBC     HL,BC           ; Subtract 3
FFAA: 13       [21]             INC     DE              ; Count the subtractions
FFAB: CAB1FF   [31|31]          JP      Z,DIV3EX        ; Exactly - Exit
FFAE: F2A8FF   [41|41]          JP      P,DIV3LP        ; More to do
                        
FFB1: 09       [11]     DIV3EX: ADD     HL,BC           ; Restore number
FFB2: F1       [21]             POP     AF              ; Restore column and odd/even
FFB3: B7       [25]             OR      A               ; Set flags (NZ or Z)
FFB4: 7D       [29]             LD      A,L             ; Get remainder from /3
FFB5: CABAFF   [39|39]          JP      Z,NOREMD        ; No remainder
FFB8: C603     [46]             ADD     A,3             ; Adjust remainder
FFBA: 47       [ 4]     NOREMD: LD      B,A             ; Bit number+1 to B
FFBB: 3E01     [11]             LD      A,00000001B     ; Bit to rotate
FFBD: 07       [ 4]     SHFTBT: RLCA                    ; Shift bit left
FFBE: 10FD     [12|17]          DJNZ    SHFTBT          ; Count shifts
FFC0: 1F       [16]             RRA                     ; Restore correct place
FFC1: C9       [26]             RET
                        
FFC2: C1       [10]     ADJCOL: POP     BC              ; Restore return address
FFC3: F1       [20]             POP     AF              ; Get bit mask
FFC4: E1       [30]             POP     HL              ; Get column
FFC5: F5       [41]             PUSH    AF              ; Re-save but mask
FFC6: 7D       [45]             LD      A,L             ; Get column
FFC7: 1F       [49]             RRA                     ; Divide by 2
FFC8: C601     [56]             ADD     A,1             ; Start at column 1
FFCA: E63F     [63]             AND     00111111B       ; 0 to 63
FFCC: 67       [67]             LD      H,A             ; Save column in H
FFCD: E5       [78]             PUSH    HL              ; Re-save column
FFCE: C5       [89]             PUSH    BC              ; Put back return
FFCF: 7B       [93]             LD      A,E             ; Get row
FFD0: C9       [103]            RET
                        
FFD1: CDD5FC   [17]     SMOTOR: CALL    CASFF           ; Flip tape drive
FFD4: 7E       [24]             LD      A,(HL)          ; Get byte
FFD5: C9       [34]             RET
                        
FFD6: 3ACE10   [13]     JPLDSV: LD      A,(BRKLIN)      ; CLOAD or CSAVE?
FFD9: FEFF     [20]             CP      -1
FFDB: C206E9   [30|30]          JP      NZ,SNDHDR       ; CSAVE - Send header
FFDE: C310E9   [40]             JP      GETHDR          ; CLOAD - Get header
                        
FFE1: CD81EB   [17]     CRLIN1: CALL    PRNTCR          ; Output CRLF
FFE4: C3F2E5   [27]             JP      GETLIN          ; Get an input line
                        
FFE7: CD81EB   [17]     CRLIN:  CALL    PRNTCR          ; Output CRLF
FFEA: C3F2E5   [27]             JP      GETLIN          ; Get an input line
                        
FFED: F5       [11]     TSTBIT: PUSH    AF              ; Save bit mask
FFEE: A0       [15]             AND     B               ; Get common bits
FFEF: C1       [25]             POP     BC              ; Restore bit mask
FFF0: B8       [29]             CP      B               ; Same bit set?
FFF1: 3E00     [36]             LD      A,0             ; Return 0 in A
FFF3: C9       [46]             RET
                        
FFF4: CD9BE6   [17]     OUTNCR: CALL    OUTC            ; Output character in A
FFF7: C381EB   [27]             JP      PRNTCR          ; Output CRLF
                        
FFFA: C3DEFD   [10]     JJUMP:  JP      JJUMP1          ; "Cool" start
                        
FFFD: C3B1E0   [10]     ZJUMP:  JP      BRKRET          ; Warm start
                                END


; +++ segments +++

#CODE          = $E000 = 57344,  size = $2000 =  8192

; +++ global symbols +++

ABPASS  = $F0F2 = 61682          nascom8krombasic.asm:2404
ABS     = $F838 = 63544          nascom8krombasic.asm:3557
ACCSUM  = $E940 = 59712          nascom8krombasic.asm:1289
ACPASS  = $F0F1 = 61681          nascom8krombasic.asm:2403
ADD64X  = $FE35 = 65077          nascom8krombasic.asm:4436
ADDEXP  = $F7D1 = 63441          nascom8krombasic.asm:3492
ADDIG   = $F977 = 63863          nascom8krombasic.asm:3780
ADDPHL  = $F5BE = 62910          nascom8krombasic.asm:3139
ADJCOL  = $FFC2 = 65474          nascom8krombasic.asm:4666
ALLFOL  = $F3C0 = 62400          nascom8krombasic.asm:2851
ANTVLU  = $EC65 = 60517          nascom8krombasic.asm:1714
ANYNAM  = $F51C = 62748          nascom8krombasic.asm:3060
ARET    = $FCD8 = 64728          nascom8krombasic.asm:4228
ARETN   = $FEE5 = 65253          nascom8krombasic.asm:4528
ARG1    = $0C0C =  3084          nascom8k.inc:50
ARG2    = $0C0E =  3086          nascom8k.inc:51
ARGN    = $0C2B =  3115          nascom8k.inc:54
ARLDSV  = $F012 = 61458          nascom8krombasic.asm:2259
ARREND  = $10DA =  4314          nascom8k.inc:115
ARRLD1  = $E8B9 = 59577          nascom8krombasic.asm:1213
ARRLP   = $F28B = 62091          nascom8krombasic.asm:2642
ARRSV1  = $E8BB = 59579          nascom8krombasic.asm:1214
ARYLP   = $E920 = 59680          nascom8krombasic.asm:1271
ASC     = $F391 = 62353          nascom8krombasic.asm:2821
ASCTFP  = $F91A = 63770          nascom8krombasic.asm:3726
ASPCS   = $EBC7 = 60359          nascom8krombasic.asm:1637
ATN     = $FC7C = 64636          nascom8krombasic.asm:4191
ATN1    = $FC99 = 64665          nascom8krombasic.asm:4203
ATNTAB  = $FCA3 = 64675          nascom8krombasic.asm:4208
ATOH    = $E9A5 = 59813          nascom8krombasic.asm:1342
BAD     = $F59D = 62877          nascom8krombasic.asm:3122
BADINP  = $EBEC = 60396          nascom8krombasic.asm:1649
BAKSTK  = $E356 = 58198          nascom8krombasic.asm:412
BAKTMP  = $F371 = 62321          nascom8krombasic.asm:2799
BASTXT  = $105E =  4190          nascom8k.inc:91
BCDEFP  = $F85F = 63583          nascom8krombasic.asm:3584
BFREE   = $E0B7 = 57527          nascom8krombasic.asm:111
BKSP    = $0008 =     8          nascom8k.inc:20
BNORM   = $F61E = 63006          nascom8krombasic.asm:3198
BNRMLP  = $F621 = 63009          nascom8krombasic.asm:3201
BREAK   = $FEDE = 65246          nascom8krombasic.asm:4524
BREAK2  = $FE53 = 65107          nascom8krombasic.asm:4457
BRKFLG  = $104D =  4173          nascom8k.inc:84
BRKLIN  = $10CE =  4302          nascom8k.inc:109
BRKMSG  = $E350 = 58192          nascom8krombasic.asm:410
BRKRET  = $E0B1 = 57521          nascom8krombasic.asm:108
BS      = $0010 =    16          nascom8k.inc:137
BSERR   = $F045 = 61509          nascom8krombasic.asm:2290
BUFFER  = $1061 =  4193          nascom8k.inc:92
BYTSFT  = $F756 = 63318          nascom8krombasic.asm:3409
CASFF   = $FCD5 = 64725          nascom8krombasic.asm:4226
CASFFW  = $FCC8 = 64712          nascom8krombasic.asm:4219
CFEVAL  = $EFA8 = 61352          nascom8krombasic.asm:2190
CHARTY  = $EF56 = 61270          nascom8krombasic.asm:2146
CHEKFN  = $F189 = 61833          nascom8krombasic.asm:2495
CHKBRK  = $FD40 = 64832          nascom8krombasic.asm:4287
CHKLTR  = $E977 = 59767          nascom8krombasic.asm:1318
CHKSTK  = $E38A = 58250          nascom8krombasic.asm:449
CHKSUM  = $104A =  4170          nascom8k.inc:82
CHKSYN  = $E690 = 59024          nascom8krombasic.asm:891
CHKTYP  = $ED46 = 60742          nascom8krombasic.asm:1829
CHR     = $F3A2 = 62370          nascom8krombasic.asm:2833
CHSUMS  = $E960 = 59744          nascom8krombasic.asm:1306
CIN     = $0C75 =  3189          nascom8k.inc:57
CLEAR   = $E9CA = 59850          nascom8krombasic.asm:1366
CLOAD   = $F4F9 = 62713          nascom8krombasic.asm:3042
CLOAD1  = $F52B = 62763          nascom8krombasic.asm:3069
CLOAD2  = $F52D = 62765          nascom8krombasic.asm:3070
CLOADE  = $F55F = 62815          nascom8krombasic.asm:3094
CLOADV  = $F55C = 62812          nascom8krombasic.asm:3093
CLOTST  = $E6CC = 59084          nascom8krombasic.asm:930
CLREG   = $E4DF = 58591          nascom8krombasic.asm:655
CLRPTR  = $E4BA = 58554          nascom8krombasic.asm:635
CLS     = $FD8B = 64907          nascom8krombasic.asm:4337
CMPFP   = $F8A8 = 63656          nascom8krombasic.asm:3642
CMPLG1  = $EEBC = 61116          nascom8krombasic.asm:2052
CMPLOG  = $EEBA = 61114          nascom8krombasic.asm:2051
CMPNUM  = $F88E = 63630          nascom8krombasic.asm:3625
CMPRES  = $EEFE = 61182          nascom8krombasic.asm:2100
CMPSTR  = $EEE6 = 61158          nascom8krombasic.asm:2080
CN      = $0020 =    32          nascom8k.inc:145
CNVIN1  = $FD20 = 64800          nascom8krombasic.asm:4270
CNVIN2  = $FD27 = 64807          nascom8krombasic.asm:4273
CNVIN3  = $FD2E = 64814          nascom8krombasic.asm:4276
CNVIN4  = $FD35 = 64821          nascom8krombasic.asm:4279
CNVIN5  = $FD3C = 64828          nascom8krombasic.asm:4282
CNVNUM  = $F926 = 63782          nascom8krombasic.asm:3732
COMMAN  = $1043 =  4163          nascom8k.inc:77
COMPL   = $F67E = 63102          nascom8krombasic.asm:3272
CONCAT  = $F306 = 62214          nascom8krombasic.asm:2732
CONEXP  = $F956 = 63830          nascom8krombasic.asm:3756
CONMON  = $FCD9 = 64729          nascom8krombasic.asm:4230
CONOT1  = $FCF1 = 64753          nascom8krombasic.asm:4243
CONPOS  = $F61B = 63003          nascom8krombasic.asm:3196
CONT    = $E89E = 59550          nascom8krombasic.asm:1197
CONTAD  = $10D4 =  4308          nascom8k.inc:112
CONVAR  = $EE22 = 60962          nascom8krombasic.asm:1950
CONVIN  = $FD19 = 64793          nascom8krombasic.asm:4267
COPY    = $E021 = 57377          nascom8krombasic.asm:28
COS     = $FC00 = 64512          nascom8krombasic.asm:4139
COUNT   = $E746 = 59206          nascom8krombasic.asm:1002
CPDEHL  = $E68A = 59018          nascom8krombasic.asm:884
CPYLIT  = $E5B1 = 58801          nascom8krombasic.asm:773
CR      = $000D =    13          nascom8k.inc:23
CRARLP  = $F065 = 61541          nascom8krombasic.asm:2310
CREARY  = $F04A = 61514          nascom8krombasic.asm:2293
CRESTR  = $EAC9 = 60105          nascom8krombasic.asm:1505
CRLIN   = $FFE7 = 65511          nascom8krombasic.asm:4692 (unused)
CRLIN1  = $FFE1 = 65505          nascom8krombasic.asm:4689 (unused)
CRNCLP  = $E512 = 58642          nascom8krombasic.asm:681
CRTMST  = $F1C2 = 61890          nascom8krombasic.asm:2528
CRTST   = $F1CE = 61902          nascom8krombasic.asm:2539
CRTSTE  = $F1E4 = 61924          nascom8krombasic.asm:2553
CRUNCH  = $E509 = 58633          nascom8krombasic.asm:677
CS      = $000C =    12          nascom8k.inc:22
CSAVE   = $F4C3 = 62659          nascom8krombasic.asm:3016
CSTART  = $E012 = 57362          nascom8krombasic.asm:21
CTLOFG  = $1045 =  4165          nascom8k.inc:79
CTRLC   = $0003 =     3          nascom8k.inc:18
CTRLG   = $0007 =     7          nascom8k.inc:19
CTRLO   = $000F =    15          nascom8k.inc:24
CTRLR   = $0012 =    18          nascom8k.inc:25
CTRLS   = $0013 =    19          nascom8k.inc:26
CTRLU   = $0015 =    21          nascom8k.inc:27
CTRLZ   = $001A =    26          nascom8k.inc:28
CUROPR  = $10C5 =  4293          nascom8k.inc:103
CURPOS  = $10AB =  4267          nascom8k.inc:94
CURSOR  = $0C29 =  3113          nascom8k.inc:53
DATA    = $EA70 = 60016          nascom8krombasic.asm:1457
DATFLG  = $10AE =  4270          nascom8k.inc:97
DATLIN  = $10C9 =  4297          nascom8k.inc:105
DATSNR  = $E3A7 = 58279          nascom8krombasic.asm:469
DCBCDE  = $F8DF = 63711          nascom8krombasic.asm:3685
DD      = $0012 =    18          nascom8k.inc:138
DDERR   = $E3B6 = 58294          nascom8krombasic.asm:477
DEEK    = $FDBC = 64956          nascom8krombasic.asm:4365
DEF     = $F106 = 61702          nascom8krombasic.asm:2416
DEFSIZ  = $F06D = 61549          nascom8krombasic.asm:2314
DEINT   = $E98B = 59787          nascom8krombasic.asm:1329
DEL     = $007F =   127          nascom8k.inc:34
DELAY   = $FD9B = 64923          nascom8krombasic.asm:4345
DELAY1  = $FD9C = 64924          nascom8krombasic.asm:4346
DELAYB  = $FCCD = 64717          nascom8krombasic.asm:4221
DELCHR  = $E5E1 = 58849          nascom8krombasic.asm:803
DEPINT  = $E985 = 59781          nascom8krombasic.asm:1327
DETHL4  = $F86E = 63598          nascom8krombasic.asm:3596
DETHLB  = $F870 = 63600          nascom8krombasic.asm:3597
DIGTXT  = $FA20 = 64032          nascom8krombasic.asm:3878
DIM     = $EF28 = 61224          nascom8krombasic.asm:2126
DIMRET  = $EF1F = 61215          nascom8krombasic.asm:2121
DINPOS  = $E6BF = 59071          nascom8krombasic.asm:918
DIV     = $F767 = 63335          nascom8krombasic.asm:3420
DIV1    = $100A =  4106          nascom8k.inc:67
DIV10   = $F75B = 63323          nascom8krombasic.asm:3415
DIV2    = $100E =  4110          nascom8k.inc:68
DIV3    = $1012 =  4114          nascom8k.inc:69
DIV3EX  = $FFB1 = 65457          nascom8krombasic.asm:4653
DIV3LP  = $FFA8 = 65448          nascom8krombasic.asm:4648
DIV4    = $1015 =  4117          nascom8k.inc:70
DIVLP   = $F78E = 63374          nascom8krombasic.asm:3444
DIVSUP  = $1009 =  4105          nascom8k.inc:66
DOAGN   = $E4F8 = 58616          nascom8krombasic.asm:668
DOCOM   = $EB98 = 60312          nascom8krombasic.asm:1613
DODEL   = $E5C1 = 58817          nascom8krombasic.asm:787
DOEBIT  = $FA60 = 64096          nascom8krombasic.asm:3921
DOFN    = $F133 = 61747          nascom8krombasic.asm:2444
DOKE    = $FDC7 = 64967          nascom8krombasic.asm:4373
DONULL  = $EB86 = 60294          nascom8krombasic.asm:1602
DOSPC   = $EBC2 = 60354          nascom8krombasic.asm:1634
DOSUM   = $E94D = 59725          nascom8krombasic.asm:1298
DOTAB   = $EBAF = 60335          nascom8krombasic.asm:1624
DPOINT  = $F952 = 63826          nascom8krombasic.asm:3754
DTSTR   = $F1D2 = 61906          nascom8krombasic.asm:2542
DVBCDE  = $F769 = 63337          nascom8krombasic.asm:3422
DZ      = $0014 =    20          nascom8k.inc:139
DZERR   = $E3B0 = 58288          nascom8krombasic.asm:473
ECHDEL  = $E5D5 = 58837          nascom8krombasic.asm:796
EDIGIT  = $F999 = 63897          nascom8krombasic.asm:3803
ENDBUF  = $E5B8 = 58808          nascom8krombasic.asm:779
ENDCON  = $F965 = 63845          nascom8krombasic.asm:3766
ENDDIM  = $F0CC = 61644          nascom8krombasic.asm:2383
ENDINP  = $EB7C = 60284          nascom8krombasic.asm:1598
ENDLIN  = $FEF1 = 65265          nascom8krombasic.asm:4538
ENDNAM  = $EF4A = 61258          nascom8krombasic.asm:2142
ENDPRG  = $E87A = 59514          nascom8krombasic.asm:1180
ENFMEM  = $E393 = 58259          nascom8krombasic.asm:455
ERRIN   = $E3E1 = 58337          nascom8krombasic.asm:498
ERRLIN  = $10D2 =  4306          nascom8k.inc:111
ERRMSG  = $E33F = 58175          nascom8krombasic.asm:406
ERROR   = $E3C1 = 58305          nascom8krombasic.asm:485
ERRORS  = $E2B9 = 58041          nascom8krombasic.asm:329
ESC     = $001B =    27          nascom8k.inc:29
EVAL    = $ED5A = 60762          nascom8krombasic.asm:1843
EVAL1   = $ED5D = 60765          nascom8krombasic.asm:1845
EVAL2   = $ED66 = 60774          nascom8krombasic.asm:1849
EVAL3   = $ED69 = 60777          nascom8krombasic.asm:1850
EVLPAR  = $EE09 = 60937          nascom8krombasic.asm:1936
EVNOT   = $EF08 = 61192          nascom8krombasic.asm:2108
EXCUTE  = $E816 = 59414          nascom8krombasic.asm:1118
EXP     = $FAFA = 64250          nascom8krombasic.asm:4008
EXPLP   = $F944 = 63812          nascom8krombasic.asm:3746
EXPTAB  = $FB3A = 64314          nascom8krombasic.asm:4036
EXPTEN  = $FA72 = 64114          nascom8krombasic.asm:3931
EXTIG   = $ECC1 = 60609          nascom8krombasic.asm:1762
FANDT   = $ECEB = 60651          nascom8krombasic.asm:1780
FC      = $0008 =     8          nascom8k.inc:133
FCERR   = $E9A0 = 59808          nascom8krombasic.asm:1339
FDTLP   = $ECD2 = 60626          nascom8krombasic.asm:1764
FILE    = $F58E = 62862          nascom8krombasic.asm:3120
FILFND  = $F574 = 62836          nascom8krombasic.asm:3103
FINDEL  = $F0A8 = 61608          nascom8krombasic.asm:2355
FLGDIF  = $F81E = 63518          nascom8krombasic.asm:3540
FLGREL  = $F825 = 63525          nascom8krombasic.asm:3546
FLGVER  = $F509 = 62729          nascom8krombasic.asm:3050
FLPLED  = $FE39 = 65081          nascom8krombasic.asm:4440
FNARG   = $10E0 =  4320          nascom8k.inc:118
FNCTAB  = $E10F = 57615          nascom8krombasic.asm:120
FNDARY  = $F018 = 61464          nascom8krombasic.asm:2263
FNDELP  = $F0AD = 61613          nascom8krombasic.asm:2360
FNDEND  = $E48D = 58509          nascom8krombasic.asm:598
FNDNUM  = $F481 = 62593          nascom8krombasic.asm:2975
FNDTOK  = $E71B = 59163          nascom8krombasic.asm:976
FNDVAR  = $EF8F = 61327          nascom8krombasic.asm:2174
FNDWRD  = $E53C = 58684          nascom8krombasic.asm:701
FNOFST  = $EE33 = 60979          nascom8krombasic.asm:1960
FNRGNM  = $10DE =  4318          nascom8k.inc:117
FNTHR   = $EF9D = 61341          nascom8krombasic.asm:2182
FNVAL   = $EE5F = 61023          nascom8krombasic.asm:1984
FOPRND  = $ED92 = 60818          nascom8krombasic.asm:1871
FOR     = $E779 = 59257          nascom8krombasic.asm:1027
FORFLG  = $10CB =  4299          nascom8k.inc:106
FORFND  = $E7A9 = 59305          nascom8krombasic.asm:1055
FORSLP  = $E78D = 59277          nascom8krombasic.asm:1036
FOUND   = $F594 = 62868          nascom8krombasic.asm:3121
FPADD   = $F5CD = 62925          nascom8krombasic.asm:3147
FPBCDE  = $F854 = 63572          nascom8krombasic.asm:3576
FPEXP   = $10E7 =  4327          nascom8k.inc:120
FPINT   = $F8BB = 63675          nascom8krombasic.asm:3662
FPMULT  = $F708 = 63240          nascom8krombasic.asm:3358
FPREG   = $10E4 =  4324          nascom8k.inc:119
FPROND  = $F665 = 63077          nascom8krombasic.asm:3248
FPSINT  = $E97F = 59775          nascom8krombasic.asm:1325
FPTHL   = $F86B = 63595          nascom8krombasic.asm:3595
FRE     = $F0D0 = 61648          nascom8krombasic.asm:2386
FRENUM  = $F0EC = 61676          nascom8krombasic.asm:2398
FRMEVL  = $EE25 = 60965          nascom8krombasic.asm:1951
GARBGE  = $F253 = 62035          nascom8krombasic.asm:2615
GARBLP  = $F256 = 62038          nascom8krombasic.asm:2616
GETCHR  = $E836 = 59446          nascom8krombasic.asm:1138
GETCMD  = $E405 = 58373          nascom8krombasic.asm:515
GETHDR  = $E910 = 59664          nascom8krombasic.asm:1264
GETINP  = $FD05 = 64773          nascom8krombasic.asm:4257
GETINT  = $F484 = 62596          nascom8krombasic.asm:2976
GETLEN  = $F386 = 62342          nascom8krombasic.asm:2813
GETLIN  = $E5F2 = 58866          nascom8krombasic.asm:811
GETLN   = $E9A6 = 59814          nascom8krombasic.asm:1343
GETNUM  = $ED41 = 60737          nascom8krombasic.asm:1826
GETNXT  = $E557 = 58711          nascom8krombasic.asm:716
GETSTR  = $F350 = 62288          nascom8krombasic.asm:2779
GETTIN  = $FD13 = 64787          nascom8krombasic.asm:4265
GETVAR  = $EF2D = 61229          nascom8krombasic.asm:2129
GETXYA  = $FF15 = 65301          nascom8krombasic.asm:4562
GNXARY  = $F28A = 62090          nascom8krombasic.asm:2641
GOFUNC  = $EE67 = 61031          nascom8krombasic.asm:1988
GOSUB   = $EA1C = 59932          nascom8krombasic.asm:1408
GOTO    = $EA2D = 59949          nascom8krombasic.asm:1420
GRBARY  = $F2AA = 62122          nascom8krombasic.asm:2660
GRBDON  = $F22B = 61995          nascom8krombasic.asm:2590
GRBLP   = $F264 = 62052          nascom8krombasic.asm:2622
GSTRCU  = $F353 = 62291          nascom8krombasic.asm:2780
GSTRDE  = $F357 = 62295          nascom8krombasic.asm:2782
GSTRHL  = $F356 = 62294          nascom8krombasic.asm:2781
GTFLNM  = $F395 = 62357          nascom8krombasic.asm:2823
GTFNAM  = $EF32 = 61234          nascom8krombasic.asm:2132
GTLNLP  = $E9A9 = 59817          nascom8krombasic.asm:1344
GTSIXD  = $F9EA = 63978          nascom8krombasic.asm:3847
GTVLUS  = $EC3D = 60477          nascom8krombasic.asm:1692
GUART   = $FD56 = 64854          nascom8krombasic.asm:4300
HALF    = $FA91 = 64145          nascom8krombasic.asm:3952
HALFPI  = $FC4A = 64586          nascom8krombasic.asm:4170
HDRLP   = $E912 = 59666          nascom8krombasic.asm:1265
HIGH    = ***UNDEFINED***
ID      = $0016 =    22          nascom8k.inc:140
IDTEST  = $F17B = 61819          nascom8krombasic.asm:2485
IF      = $EAFF = 60159          nascom8krombasic.asm:1538
IFGO    = $EB0D = 60173          nascom8krombasic.asm:1545
IFJMP   = $E81D = 59421          nascom8krombasic.asm:1121
IGCHR   = $FD00 = 64768          nascom8krombasic.asm:4251
INCHL   = $F869 = 63593          nascom8krombasic.asm:3592
INCLEN  = $E6BB = 59067          nascom8krombasic.asm:916
INDFND  = $E370 = 58224          nascom8krombasic.asm:431
INEWLN  = $E455 = 58453          nascom8krombasic.asm:558
INIT    = $E019 = 57369          nascom8krombasic.asm:25
INITAB  = $E2DF = 58079          nascom8krombasic.asm:351
INITBE  = $E33F = 58175          nascom8krombasic.asm:404
INITST  = $FEBB = 65211          nascom8krombasic.asm:4509
INLINE  = $FEE8 = 65256          nascom8krombasic.asm:4532
INMSG   = $E346 = 58182          nascom8krombasic.asm:407
INP     = $F441 = 62529          nascom8krombasic.asm:2944
INPBIN  = $EC8F = 60559          nascom8krombasic.asm:1736
INPBRK  = $E877 = 59511          nascom8krombasic.asm:1178
INPORT  = $103F =  4159          nascom8k.inc:74
INPSUB  = $103E =  4158          nascom8k.inc:73
INPUT   = $EBFD = 60413          nascom8krombasic.asm:1657
INRNG   = $F9F3 = 63987          nascom8krombasic.asm:3852
INT     = $F8E6 = 63718          nascom8krombasic.asm:3693
INTVAR  = $E4C9 = 58569          nascom8krombasic.asm:646
INVSGN  = $F83C = 63548          nascom8krombasic.asm:3559
ITMSEP  = $EC80 = 60544          nascom8krombasic.asm:1727
JJUMP   = $FFFA = 65530          nascom8krombasic.asm:4705 (unused)
JJUMP1  = $FDDE = 64990          nascom8krombasic.asm:4387
JPLDSV  = $FFD6 = 65494          nascom8krombasic.asm:4684
JSTZER  = $FA7C = 64124          nascom8krombasic.asm:3937
KILFOR  = $ED31 = 60721          nascom8krombasic.asm:1817
KILIN   = $E5EC = 58860          nascom8krombasic.asm:808
LCRFLG  = $10AC =  4268          nascom8k.inc:95
LDNMI1  = $E73C = 59196          nascom8krombasic.asm:996
LEFT    = $F3B2 = 62386          nascom8krombasic.asm:2841
LEN     = $F382 = 62338          nascom8krombasic.asm:2811
LET     = $EA87 = 60039          nascom8krombasic.asm:1473
LETNUM  = $EADA = 60122          nascom8krombasic.asm:1515
LETSTR  = $EAA2 = 60066          nascom8krombasic.asm:1486
LF      = $000A =    10          nascom8k.inc:21
LFRGNM  = $F437 = 62519          nascom8krombasic.asm:2935
LINEAT  = $105C =  4188          nascom8k.inc:90
LINEIN  = $F9A5 = 63909          nascom8krombasic.asm:3813
LINES   = $FDAD = 64941          nascom8krombasic.asm:4359
LINESC  = $1046 =  4166          nascom8k.inc:80
LINESN  = $1048 =  4168          nascom8k.inc:81
LINFND  = $E43E = 58430          nascom8krombasic.asm:544
LINTBF  = $FF02 = 65282          nascom8krombasic.asm:4548
LIST    = $E6DD = 59101          nascom8krombasic.asm:940
LISTLP  = $E6E9 = 59113          nascom8krombasic.asm:946
LOADFP  = $F862 = 63586          nascom8krombasic.asm:3585
LOG     = $F6C7 = 63175          nascom8krombasic.asm:3326
LOGTAB  = $F6BA = 63162          nascom8krombasic.asm:3321
LOKFOR  = $E35A = 58202          nascom8krombasic.asm:414
LOOPST  = $10C7 =  4295          nascom8k.inc:104
LOW     = ***UNDEFINED***
LS      = $001C =    28          nascom8k.inc:143
LSTBIN  = $10CC =  4300          nascom8k.inc:107
LSTLP2  = $E709 = 59145          nascom8krombasic.asm:967
LSTLP3  = $E70C = 59148          nascom8krombasic.asm:968
LSTRAM  = $10AF =  4271          nascom8k.inc:98
LSTRND  = $103A =  4154          nascom8k.inc:72
LTSTND  = $EC9A = 60570          nascom8krombasic.asm:1741
LWIDTH  = $1042 =  4162          nascom8k.inc:76
MAKINT  = $F487 = 62599          nascom8krombasic.asm:2977
MAKNUM  = $FA0F = 64015          nascom8krombasic.asm:3867
MANLP   = $F92E = 63790          nascom8krombasic.asm:3738
MATCH   = $E589 = 58761          nascom8krombasic.asm:748
MEMMSG  = $E103 = 57603          nascom8krombasic.asm:116
MFLP    = $0051 =    81          nascom8k.inc:40
MID     = $F3EC = 62444          nascom8krombasic.asm:2881
MID1    = $F3B8 = 62392          nascom8krombasic.asm:2845
MIDNUM  = $F43C = 62524          nascom8krombasic.asm:2938
MINCDE  = $F60D = 62989          nascom8krombasic.asm:3182
MINUS   = $EE11 = 60945          nascom8krombasic.asm:1941
MKTMST  = $F1BF = 61887          nascom8krombasic.asm:2527
MLDBLP  = $F907 = 63751          nascom8krombasic.asm:3714
MLDEBC  = $F8FF = 63743          nascom8krombasic.asm:3709
MLOOP   = $E049 = 57417          nascom8krombasic.asm:46
MLSP10  = $F7FC = 63484          nascom8krombasic.asm:3520
MO      = $0024 =    36          nascom8k.inc:147
MONITR  = $FEA2 = 65186          nascom8krombasic.asm:4497
MONLD   = $FE88 = 65160          nascom8krombasic.asm:4485
MONOUT  = $FE45 = 65093          nascom8krombasic.asm:4447
MONSTT  = $0000 =     0          nascom8k.inc:38
MONTST  = $FE6D = 65133          nascom8krombasic.asm:4471
MONTYP  = $008D =   141          nascom8k.inc:41
MONVE   = $FEAA = 65194          nascom8krombasic.asm:4501
MORDT   = $ECA6 = 60582          nascom8krombasic.asm:1746
MORINP  = $E610 = 58896          nascom8krombasic.asm:824
MOVBUF  = $E474 = 58484          nascom8krombasic.asm:579
MOVDIR  = $E591 = 58769          nascom8krombasic.asm:756
MOVLP   = $E37F = 58239          nascom8krombasic.asm:441
MOVSTR  = $E37C = 58236          nascom8krombasic.asm:438
MOVUP   = $E379 = 58233          nascom8krombasic.asm:437
MRPRNT  = $EB1F = 60191          nascom8krombasic.asm:1552
MSIZE   = $E036 = 57398          nascom8krombasic.asm:39
MUL8LP  = $F733 = 63283          nascom8krombasic.asm:3381
MULLN2  = $F6FF = 63231          nascom8krombasic.asm:3352
MULT    = $F706 = 63238          nascom8krombasic.asm:3356
MULT8   = $F72A = 63274          nascom8krombasic.asm:3375
MULTEN  = $F970 = 63856          nascom8krombasic.asm:3774
MULVAL  = $10F6 =  4342          nascom8k.inc:123
MVSTPT  = $EAD1 = 60113          nascom8krombasic.asm:1509
NASOUT  = $FCFB = 64763          nascom8krombasic.asm:4248
NEDMOR  = $EC39 = 60473          nascom8krombasic.asm:1690
NEGAFT  = $FAA7 = 64167          nascom8krombasic.asm:3961
NEW     = $E4B9 = 58553          nascom8krombasic.asm:634
NEXITM  = $EBD2 = 60370          nascom8krombasic.asm:1643
NEXT    = $ECF6 = 60662          nascom8krombasic.asm:1785
NEXT1   = $ECF9 = 60665          nascom8krombasic.asm:1786
NF      = $0000 =     0          nascom8k.inc:129
NFERR   = $E3B3 = 58291          nascom8krombasic.asm:475
NMI     = $0C7E =  3198          nascom8k.inc:58
NMIFLG  = $104C =  4172          nascom8k.inc:83
NOCHNG  = $E581 = 58753          nascom8krombasic.asm:743
NOENED  = $FA7F = 64127          nascom8krombasic.asm:3940
NOLIN   = $E88D = 59533          nascom8krombasic.asm:1189
NOMADD  = $F744 = 63300          nascom8krombasic.asm:3392
NOMLAD  = $F915 = 63765          nascom8krombasic.asm:3722
NOPMPT  = $EC17 = 60439          nascom8krombasic.asm:1669
NOREMD  = $FFBA = 65466          nascom8krombasic.asm:4659
NORES   = $FF75 = 65397          nascom8krombasic.asm:4617
NORMAL  = $F638 = 63032          nascom8krombasic.asm:3217
NOSPC   = $E578 = 58744          nascom8krombasic.asm:738
NOSWAP  = $F5E7 = 62951          nascom8krombasic.asm:3163
NOTSTR  = $EF65 = 61285          nascom8krombasic.asm:2154
NOXOR   = $F467 = 62567          nascom8krombasic.asm:2961
NSCFOR  = $EF75 = 61301          nascom8krombasic.asm:2162
NULFLG  = $1044 =  4164          nascom8k.inc:78
NULL    = $E8B1 = 59569          nascom8krombasic.asm:1208
NULLP   = $EB8D = 60301          nascom8krombasic.asm:1605
NULLS   = $1041 =  4161          nascom8k.inc:75
NUMASC  = $F9B8 = 63928          nascom8krombasic.asm:3823
NXTARY  = $F02C = 61484          nascom8krombasic.asm:2275
NXTBYT  = $E567 = 58727          nascom8krombasic.asm:728
NXTCHR  = $E5A8 = 58792          nascom8krombasic.asm:768
NXTDAT  = $10DC =  4316          nascom8k.inc:116
NXTDTA  = $EA6F = 60015          nascom8krombasic.asm:1455
NXTITM  = $EC31 = 60465          nascom8krombasic.asm:1685
NXTOPR  = $10D0 =  4304          nascom8k.inc:110
NXTSTL  = $EA76 = 60022          nascom8krombasic.asm:1460
NXTSTT  = $EA79 = 60025          nascom8krombasic.asm:1463
OD      = $0006 =     6          nascom8k.inc:132
OKMSG   = $E34B = 58187          nascom8krombasic.asm:409
OM      = $000C =    12          nascom8k.inc:135
OMERR   = $E3A2 = 58274          nascom8krombasic.asm:466
ON      = $EAE1 = 60129          nascom8krombasic.asm:1521
ONGO    = $EAF0 = 60144          nascom8krombasic.asm:1529
ONGOLP  = $EAF1 = 60145          nascom8krombasic.asm:1530
ONJMP   = $E81E = 59422          nascom8krombasic.asm:1122
OPNPAR  = $ED56 = 60758          nascom8krombasic.asm:1841
OPRND   = $EDD1 = 60881          nascom8krombasic.asm:1914
OS      = $001A =    26          nascom8k.inc:142
OTKLN   = $E5E9 = 58857          nascom8krombasic.asm:807
OTPORT  = $1007 =  4103          nascom8k.inc:65
OUTBAD  = $F56B = 62827          nascom8krombasic.asm:3099
OUTC    = $E69B = 59035          nascom8krombasic.asm:899
OUTCHR  = $FCFD = 64765          nascom8krombasic.asm:4250
OUTEXP  = $FA70 = 64112          nascom8krombasic.asm:3930
OUTIT   = $E67C = 59004          nascom8krombasic.asm:877
OUTNBS  = $E682 = 59010          nascom8krombasic.asm:880
OUTNCR  = $FFF4 = 65524          nascom8krombasic.asm:4702
OUTSUB  = $1006 =  4102          nascom8k.inc:64
OUTWRD  = $E725 = 59173          nascom8krombasic.asm:982
OV      = $000A =    10          nascom8k.inc:134
OVERR   = $E3BC = 58300          nascom8krombasic.asm:481
OVTST1  = $F7EF = 63471          nascom8krombasic.asm:3512
OVTST2  = $F7F4 = 63476          nascom8krombasic.asm:3515
OVTST3  = $F7F5 = 63477          nascom8krombasic.asm:3516
PADD    = $F994 = 63892          nascom8krombasic.asm:3799
PAND    = $EE81 = 61057          nascom8krombasic.asm:2010
PASSA   = $F101 = 61697          nascom8krombasic.asm:2412
PBUFF   = $10E9 =  4329          nascom8k.inc:122
PEEK    = $F5A3 = 62883          nascom8krombasic.asm:3124
PEND    = $E872 = 59506          nascom8krombasic.asm:1175
PHLTFP  = $F851 = 63569          nascom8krombasic.asm:3575
PLUCDE  = $F672 = 63090          nascom8krombasic.asm:3259
PNORM   = $F640 = 63040          nascom8krombasic.asm:3225
POINT   = $1051 =  4177          nascom8k.inc:86
POINT0  = $FF91 = 65425          nascom8krombasic.asm:4632
POINTB  = $FF79 = 65401          nascom8krombasic.asm:4620
POINTX  = $FF87 = 65415          nascom8krombasic.asm:4626
POKE    = $F5AA = 62890          nascom8krombasic.asm:3128
POPAF   = $F245 = 62021          nascom8krombasic.asm:2605
POPHL   = $F36F = 62319          nascom8krombasic.asm:2796
POPHRT  = $F754 = 63316          nascom8krombasic.asm:3406
POPNOK  = $E3F7 = 58359          nascom8krombasic.asm:508
POR     = $EE80 = 61056          nascom8krombasic.asm:2009
POR1    = $EEA3 = 61091          nascom8krombasic.asm:2033
PORT0   = $0C00 =  3072          nascom8k.inc:49
POS     = $F0FE = 61694          nascom8krombasic.asm:2411
POSINT  = $E982 = 59778          nascom8krombasic.asm:1326
POUT    = $F44D = 62541          nascom8krombasic.asm:2949
POWER   = $FAB5 = 64181          nascom8krombasic.asm:3969
POWER1  = $FAC5 = 64197          nascom8krombasic.asm:3977
POWER2  = $FAE2 = 64226          nascom8krombasic.asm:3995
POWERS  = $FA95 = 64149          nascom8krombasic.asm:3954
PRINT   = $EB23 = 60195          nascom8krombasic.asm:1554
PRITAB  = $E2A4 = 58020          nascom8krombasic.asm:306
PRNTCR  = $EB81 = 60289          nascom8krombasic.asm:1600
PRNTHL  = $F9AD = 63917          nascom8krombasic.asm:3817
PRNTLP  = $EB26 = 60198          nascom8krombasic.asm:1555
PRNTNB  = $EB69 = 60265          nascom8krombasic.asm:1587
PRNTOK  = $E3F8 = 58360          nascom8krombasic.asm:510
PRNTST  = $EB6D = 60269          nascom8krombasic.asm:1589
PRNUMS  = $F20F = 61967          nascom8krombasic.asm:2574
PROCES  = $E629 = 58921          nascom8krombasic.asm:835
PROGND  = $10D6 =  4310          nascom8k.inc:113
PROGST  = $10F9 =  4345          nascom8k.inc:124
PROMPT  = $E4FC = 58620          nascom8krombasic.asm:671
PRS     = $F210 = 61968          nascom8krombasic.asm:2575
PRS1    = $F213 = 61971          nascom8krombasic.asm:2576
PRSLP   = $F21A = 61978          nascom8krombasic.asm:2579
PSET    = $1054 =  4180          nascom8k.inc:87
PSUB    = $F5C8 = 62920          nascom8krombasic.asm:3144
PTRLP   = $E481 = 58497          nascom8krombasic.asm:588
PUTBIT  = $FF4B = 65355          nascom8krombasic.asm:4590
PUTBUF  = $E668 = 58984          nascom8krombasic.asm:866
PUTCTL  = $E66D = 58989          nascom8krombasic.asm:868
PUTFID  = $E7EE = 59374          nascom8krombasic.asm:1093
QTSTLP  = $F1D5 = 61909          nascom8krombasic.asm:2544
QTSTR   = $F1CF = 61903          nascom8krombasic.asm:2540
QUARTR  = $FC4E = 64590          nascom8krombasic.asm:4172
READ    = $EC2C = 60460          nascom8krombasic.asm:1682
READFG  = $10CD =  4301          nascom8k.inc:108
REDO    = $EBD9 = 60377          nascom8krombasic.asm:1647
REM     = $EA72 = 60018          nascom8krombasic.asm:1458
RESCSA  = $FF4C = 65356          nascom8krombasic.asm:4591
RESDIV  = $F7A1 = 63393          nascom8krombasic.asm:3457
RESEED  = $FBEC = 64492          nascom8krombasic.asm:4128
RESET   = $1057 =  4183          nascom8k.inc:88
RESETB  = $FF55 = 65365          nascom8krombasic.asm:4599
RESTNL  = $E85B = 59483          nascom8krombasic.asm:1161
RESTOR  = $E846 = 59462          nascom8krombasic.asm:1150
RESZER  = $F633 = 63027          nascom8krombasic.asm:3213
RETADR  = $EFDC = 61404          nascom8krombasic.asm:2222
RETCTC  = $FE65 = 65125          nascom8krombasic.asm:4466
RETINT  = $F82A = 63530          nascom8krombasic.asm:3548
RETLIN  = $EA6A = 60010          nascom8krombasic.asm:1452
RETNAD  = $E58D = 58765          nascom8krombasic.asm:752
RETNUL  = $EFDF = 61407          nascom8krombasic.asm:2226
RETNUM  = $EE1D = 60957          nascom8krombasic.asm:1946
RETREL  = $F81C = 63516          nascom8krombasic.asm:3538
RETURN  = $EA4B = 59979          nascom8krombasic.asm:1436
RG      = $0004 =     4          nascom8k.inc:131
RIGHT   = $F3E2 = 62434          nascom8krombasic.asm:2874
RIGHT1  = $F3B6 = 62390          nascom8krombasic.asm:2843
RINPUT  = $104E =  4174          nascom8k.inc:85
RLTLP   = $ED76 = 60790          nascom8krombasic.asm:1857
RND     = $FB8B = 64395          nascom8krombasic.asm:4075
RND1    = $FBC7 = 64455          nascom8krombasic.asm:4106
RND2    = $FBE3 = 64483          nascom8krombasic.asm:4124
RNDTAB  = $FBF4 = 64500          nascom8krombasic.asm:4135
RNGTST  = $FA82 = 64130          nascom8krombasic.asm:3944
RONDB   = $F654 = 63060          nascom8krombasic.asm:3237
RONDUP  = $F653 = 63059          nascom8krombasic.asm:3236
ROUND   = $F5BB = 62907          nascom8krombasic.asm:3138
RSCALE  = $F98E = 63886          nascom8krombasic.asm:3797
RSLNBK  = $E770 = 59248          nascom8krombasic.asm:1023
RSTSTR  = $F405 = 62469          nascom8krombasic.asm:2894
RUART   = $F4B4 = 62644          nascom8krombasic.asm:3005
RUN     = $EA10 = 59920          nascom8krombasic.asm:1403
RUNCNT  = $E7F2 = 59378          nascom8krombasic.asm:1097
RUNFST  = $E4C5 = 58565          nascom8krombasic.asm:643
RUNLIN  = $EA2C = 59948          nascom8krombasic.asm:1419
SAVE    = $FE73 = 65139          nascom8krombasic.asm:4475
SAVEXP  = $F634 = 63028          nascom8krombasic.asm:3214
SAVSTP  = $E7E5 = 59365          nascom8krombasic.asm:1086
SAVSTR  = $F1AA = 61866          nascom8krombasic.asm:2511
SBSCPT  = $EFEA = 61418          nascom8krombasic.asm:2232
SCALE   = $F692 = 63122          nascom8krombasic.asm:3291
SCALLP  = $F694 = 63124          nascom8krombasic.asm:3292
SCALMI  = $F959 = 63833          nascom8krombasic.asm:3759
SCALPL  = $F96F = 63855          nascom8krombasic.asm:3773
SCNEND  = $F2E1 = 62177          nascom8krombasic.asm:2701
SCPTLP  = $EFF0 = 61424          nascom8krombasic.asm:2236
SCRADR  = $FE11 = 65041          nascom8krombasic.asm:4416
SCREEN  = $FDE6 = 64998          nascom8krombasic.asm:4391
SEARCH  = $E555 = 58709          nascom8krombasic.asm:714
SEED    = $1017 =  4119          nascom8k.inc:71
SETB    = $FF40 = 65344          nascom8krombasic.asm:4584
SETIO   = $F471 = 62577          nascom8krombasic.asm:2968
SETLIN  = $E733 = 59187          nascom8krombasic.asm:990
SETLIT  = $E59F = 58783          nascom8krombasic.asm:764
SETOR   = $FF50 = 65360          nascom8krombasic.asm:4595
SETPTR  = $E47C = 58492          nascom8krombasic.asm:585
SETTOP  = $E06D = 57453          nascom8krombasic.asm:71
SFTENT  = $FD70 = 64880          nascom8krombasic.asm:4320
SFTPRG  = $E446 = 58438          nascom8krombasic.asm:548
SGN     = $F822 = 63522          nascom8krombasic.asm:3545
SGNEXP  = $EE70 = 61040          nascom8krombasic.asm:1996
SGNRES  = $10E8 =  4328          nascom8k.inc:121
SHFTBT  = $FFBD = 65469          nascom8krombasic.asm:4661
SHRITE  = $F6A1 = 63137          nascom8krombasic.asm:3300
SHRLP   = $F6A4 = 63140          nascom8krombasic.asm:3302
SHRT1   = $F6A8 = 63144          nascom8krombasic.asm:3306
SIGNON  = $E0C5 = 57541          nascom8krombasic.asm:113
SIGNS   = $F879 = 63609          nascom8krombasic.asm:3605
SIN     = $FC06 = 64518          nascom8krombasic.asm:4141
SIN1    = $FC36 = 64566          nascom8krombasic.asm:4161
SINTAB  = $FC52 = 64594          nascom8krombasic.asm:4174
SIXDIG  = $F9D5 = 63957          nascom8krombasic.asm:3837
SMOTOR  = $FFD1 = 65489          nascom8krombasic.asm:4680
SMPVAR  = $F275 = 62069          nascom8krombasic.asm:2629
SMSER1  = $FB6A = 64362          nascom8krombasic.asm:4053
SN      = $0002 =     2          nascom8k.inc:130
SNDARY  = $E91D = 59677          nascom8krombasic.asm:1270
SNDHDR  = $E906 = 59654          nascom8krombasic.asm:1259
SNERR   = $E3AD = 58285          nascom8krombasic.asm:471
SPCFST  = $F9C6 = 63942          nascom8krombasic.asm:3829
SPCLP   = $EBCB = 60363          nascom8krombasic.asm:1640
SQR     = $FAAC = 64172          nascom8krombasic.asm:3965
SRCHLN  = $E499 = 58521          nascom8krombasic.asm:607
SRCHLP  = $E49C = 58524          nascom8krombasic.asm:608
SSTSA   = $F33D = 62269          nascom8krombasic.asm:2761
ST      = $001E =    30          nascom8k.inc:144
STACK   = $1066 =  4198          nascom8k.inc:93
STAKFP  = $F844 = 63556          nascom8krombasic.asm:3565
STALL   = $E866 = 59494          nascom8krombasic.asm:1169
START   = $E000 = 57344          nascom8krombasic.asm:11 (unused)
STARTB  = $E003 = 57347          nascom8krombasic.asm:12
STKTHS  = $EDBA = 60858          nascom8krombasic.asm:1898
STLOOK  = $115D =  4445          nascom8k.inc:125
STMON   = $000D =    13          nascom8k.inc:39
STOP    = $E870 = 59504          nascom8krombasic.asm:1173
STORED  = $E9ED = 59885          nascom8krombasic.asm:1383
STPOOL  = $F2B8 = 62136          nascom8krombasic.asm:2666
STR     = $F19A = 61850          nascom8krombasic.asm:2504
STRADD  = $F2BB = 62139          nascom8krombasic.asm:2668
STRBOT  = $10C3 =  4291          nascom8k.inc:102
STRENT  = $EC83 = 60547          nascom8krombasic.asm:1729
STRSPC  = $105A =  4186          nascom8k.inc:89
STTLIN  = $EB74 = 60276          nascom8krombasic.asm:1593
SUART   = $FD68 = 64872          nascom8krombasic.asm:4312
SUBCDE  = $F5CA = 62922          nascom8krombasic.asm:3146
SUBPHL  = $F5C4 = 62916          nascom8krombasic.asm:3142
SUMLP   = $FB73 = 64371          nascom8krombasic.asm:4058
SUMOFF  = $E937 = 59703          nascom8krombasic.asm:1283
SUMSER  = $FB5B = 64347          nascom8krombasic.asm:4046
SUPTLZ  = $FA54 = 64084          nascom8krombasic.asm:3914
SVNAM2  = $EF49 = 61257          nascom8krombasic.asm:2141
SVSTAD  = $F1C8 = 61896          nascom8krombasic.asm:2532
T2DUMP  = $03D1 =   977          nascom8k.inc:42
T4READ  = $070C =  1804          nascom8k.inc:44
T4WR    = $0400 =  1024          nascom8k.inc:43
TAN     = $FC67 = 64615          nascom8krombasic.asm:4181
TBRK    = $001C =    28          nascom8k.inc:30
TBRK2   = $FD50 = 64848          nascom8krombasic.asm:4296
TBS     = $001D =    29          nascom8k.inc:31
TCHINP  = $FE62 = 65122          nascom8krombasic.asm:4464
TCLS    = $FD96 = 64918          nascom8krombasic.asm:4342
TCR     = $001F =    31          nascom8k.inc:33
TCS     = $001E =    30          nascom8k.inc:32
TCUR    = $0C18 =  3096          nascom8k.inc:52
TESTOS  = $F247 = 62023          nascom8krombasic.asm:2608
TESTR   = $F229 = 61993          nascom8krombasic.asm:2588
THSFIL  = $F548 = 62792          nascom8krombasic.asm:3082
TIN     = $0C4D =  3149          nascom8k.inc:56
TLOAD   = $FE99 = 65177          nascom8krombasic.asm:4493
TM      = $0018 =    24          nascom8k.inc:141
TMERR   = $E3BF = 58303          nascom8krombasic.asm:483
TMFLP   = $FE42 = 65090          nascom8krombasic.asm:4445
TMNCUR  = $FE04 = 65028          nascom8krombasic.asm:4408
TMNOUT  = $FE4F = 65103          nascom8krombasic.asm:4454
TMPSTR  = $10BF =  4287          nascom8k.inc:101
TMSTPL  = $10B3 =  4275          nascom8k.inc:100
TMSTPT  = $10B1 =  4273          nascom8k.inc:99
TOPOOL  = $F3AE = 62382          nascom8krombasic.asm:2838
TOSTRA  = $F346 = 62278          nascom8krombasic.asm:2770
TOUT    = $0C4A =  3146          nascom8k.inc:55
TRYAGN  = $FA2F = 64047          nascom8krombasic.asm:3887
TSALP   = $F347 = 62279          nascom8krombasic.asm:2771
TSAVE   = $FE7F = 65151          nascom8krombasic.asm:4481
TSTBIT  = $FFED = 65517          nascom8krombasic.asm:4695
TSTBRK  = $E861 = 59489          nascom8krombasic.asm:1166
TSTMEM  = $E05B = 57435          nascom8krombasic.asm:59
TSTNUM  = $ED44 = 60740          nascom8krombasic.asm:1827
TSTOPL  = $F1F0 = 61936          nascom8krombasic.asm:2560
TSTRED  = $EEA8 = 61096          nascom8krombasic.asm:2039
TSTREM  = $E5A2 = 58786          nascom8krombasic.asm:765
TSTSGN  = $F813 = 63507          nascom8krombasic.asm:3533
TSTSTR  = $ED45 = 60741          nascom8krombasic.asm:1828
TTYLIN  = $E607 = 58887          nascom8krombasic.asm:820
TYPE    = $10AD =  4269          nascom8k.inc:96
UARTD   = $0001 =     1          nascom8k.inc:16
UARTOT  = $FD5F = 64863          nascom8krombasic.asm:4306
UARTS   = $0002 =     2          nascom8k.inc:17
UF      = $0022 =    34          nascom8k.inc:146
UFERR   = $E3B9 = 58297          nascom8krombasic.asm:479
UL      = $000E =    14          nascom8k.inc:136
ULERR   = $EA46 = 59974          nascom8krombasic.asm:1433
UNITY   = $F6B6 = 63158          nascom8krombasic.asm:3319
UPDATA  = $E85C = 59484          nascom8krombasic.asm:1162
URTOLP  = $FD61 = 64865          nascom8krombasic.asm:4307
USR     = $1003 =  4099          nascom8k.inc:63
VAL     = $F41C = 62492          nascom8krombasic.asm:2913
VAREND  = $10D8 =  4312          nascom8k.inc:114
VDU     = $0800 =  2048          nascom8k.inc:45
WAIT    = $F453 = 62547          nascom8krombasic.asm:2952
WAITLP  = $F468 = 62568          nascom8krombasic.asm:2962
WARMST  = $E0AE = 57518          nascom8krombasic.asm:107
WIDTH   = $FDA5 = 64933          nascom8krombasic.asm:4354
WORDS   = $E143 = 57667          nascom8krombasic.asm:149
WORDTB  = $E25A = 57946          nascom8krombasic.asm:235
WRKSPC  = $1000 =  4096          nascom8k.inc:62
WUART   = $F4BA = 62650          nascom8krombasic.asm:3008
WUART2  = $F4B7 = 62647          nascom8krombasic.asm:3007
XYPOS   = $FF96 = 65430          nascom8krombasic.asm:4635
ZDATA   = $0083 =   131          nascom8krombasic.asm:277
ZDIV    = $00AF =   175          nascom8krombasic.asm:295 (unused)
ZEND    = $0080 =   128          nascom8krombasic.asm:275
ZEQUAL  = $00B4 =   180          nascom8krombasic.asm:298
ZERARY  = $F08B = 61579          nascom8krombasic.asm:2335
ZERBYT  = $E34A = 58186          nascom8krombasic.asm:408
ZEROLP  = $EFCE = 61390          nascom8krombasic.asm:2213
ZFN     = $00A7 =   167          nascom8krombasic.asm:286
ZFOR    = $0081 =   129          nascom8krombasic.asm:276
ZGOSUB  = $008C =   140          nascom8krombasic.asm:279
ZGOTO   = $0088 =   136          nascom8krombasic.asm:278
ZGTR    = $00B3 =   179          nascom8krombasic.asm:297
ZJUMP   = $FFFD = 65533          nascom8krombasic.asm:4707 (unused)
ZLEFT   = $00CD =   205          nascom8krombasic.asm:302
ZLTH    = $00B5 =   181          nascom8krombasic.asm:299
ZMINUS  = $00AD =   173          nascom8krombasic.asm:293
ZNEW    = $00A4 =   164          nascom8krombasic.asm:282
ZNOT    = $00AA =   170          nascom8krombasic.asm:289
ZONELP  = $EBA6 = 60326          nascom8krombasic.asm:1619
ZOR     = $00B2 =   178          nascom8krombasic.asm:296
ZPLUS   = $00AC =   172          nascom8krombasic.asm:292
ZPOINT  = $00C7 =   199          nascom8krombasic.asm:301
ZPRINT  = $009E =   158          nascom8krombasic.asm:281
ZREM    = $008E =   142          nascom8krombasic.asm:280
ZSGN    = $00B6 =   182          nascom8krombasic.asm:300
ZSPC    = $00A8 =   168          nascom8krombasic.asm:287
ZSTEP   = $00AB =   171          nascom8krombasic.asm:290
ZTAB    = $00A5 =   165          nascom8krombasic.asm:284
ZTHEN   = $00A9 =   169          nascom8krombasic.asm:288
ZTIMES  = $00AE =   174          nascom8krombasic.asm:294
ZTO     = $00A6 =   166          nascom8krombasic.asm:285
_BLNK   = $7BDF = 31711          nascom8k.inc:5
_INLN   = $63DF = 25567          nascom8k.inc:6
_MFLP   = $5FDF = 24543          nascom8k.inc:7
_MRET   = $5BDF = 23519          nascom8k.inc:8
_READ   = $52DF = 21215          nascom8k.inc:9
_RIN    = $62DF = 25311          nascom8k.inc:10
_ROUT   = $00F7 =   247          nascom8k.inc:4
_VRFY   = $56DF = 22239          nascom8k.inc:11
_WRIT   = $57DF = 22495          nascom8k.inc:12
_end    = $0000 = 65536          nascom8k.inc:2 (unused)
_size   = $2000 =  8192          nascom8k.inc:2 (unused)


; +++ used but undefined or unresolved labels +++

LOW     = ***undefined***
HIGH    = ***undefined***


total time: 0.0124 sec.
2 errors
