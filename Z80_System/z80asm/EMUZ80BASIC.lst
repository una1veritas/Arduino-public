                        ; --------------------------------------
                        ; zasm: assemble "EMUZ80BASIC.ASM"
                        ; date: 2025-10-03 01:35:33
                        ; --------------------------------------


                        ;	EMUBASIC based on GRANT's BASIC
                        ;	TARGET: EMUZ80
                        ;	ASSEMBLER: ARCPIT XZ80.EXE
                        ;
                        ;	START UP ROUTINE
                        ;	VERSION 1.0, 2022/02/15
                        ;	WRITTEN by TETSUYA SUZUKI
                        ;
                        ;	MEMORY ASIGN
0000:                   ROMTOP	EQU	0000H
                        ;RAMTOP	EQU	8000H
                        ;RAMSIZ	EQU	1000H
F000:                   TSTACK	EQU	0F000H ;80EDH
                        ;
                        ;	UART REGISTER ADDRESS
                        ; UARTDR	EQU	0E000H	; UART DATA REGISTOR  --> out (CONIO), a / out (CONIN), a
                        ; UARTCR	EQU	0E001H	; UART CONTROL REGISTOR. --> in a, (CONST)
                        ;
0000:                   CONSTA	EQU 	$00
0001:                   CONIO	EQU 	$01
                        
                        ;	RESET (RST 00H)
0000:                   	ORG	ROMTOP
0000: F3       [ 4]     	DI
0001: 3100F0   [14]     	LD	SP,TSTACK
0004: C33A00   [24]     	JP	SINIT
                        ;
                        ;	PUT 1CHAR (RST 08H)
                        	ORG	ROMTOP+08H
0008: C33000   [34]     	JP	TXA
                        ;
                        ;	GET 1CHAR (RST 10H)
                        	ORG	ROMTOP+10H
0010: C31B00   [44]     	JP	RXA
                        ;
                        ;	KBHIT (RST 18H)
                        	ORG	ROMTOP+18H
0018: C32B00   [54]     	JP	KBHIT
                        ;
                        ;	UART -> A
001B:                   RXA:
001B: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
                        	; BIT	0,A
001D: A7       [15]     	and a
001E: 28FB     [22|27]  	JR	Z,RXA
0020: DB01     [33]     	in 	a, (CONIO)
                        	;LD	A,(UARTDR)
0022: FE61     [40]     	CP	'a'
0024: D8       [45|51]  	RET	C
0025: FE7B     [52]     	CP	'z'+1
0027: D0       [57|63]  	RET	NC
0028: E6DF     [64]     	AND	0DFH  ; to upper case
002A: C9       [74]     	RET
                        ;
                        ;	CHECK RECEIVE STATUS
002B:                   KBHIT:	
002B: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
002D: CB47     [19]     	BIT	0,A ; --> set Z if the least sig bit is zero
                        	;and a 	; set Z if a == 0
002F: C9       [29]     	RET
                        ;
                        ;	A -> UART
0030: F5       [11]     TXA:	PUSH	AF
0031:                   TXAST1:	
0031: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
                        	; BIT	1,A
0033: A7       [15]     	and a
0034: 28FB     [22|27]  	JR	Z,TXAST1
0036: F1       [32]     	POP	AF
0037: D301     [43]     	out (CONIO), a
                        	;LD	(UARTDR),A
0039: C9       [53]     	RET
                        ;
                        ;
                        ;	SYSTEM INITIALIZE
003A:                   SINIT:
003A: C33D00   [10]     	JP	COLD
                        ;
                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        ;
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        ;
                        ; GENERAL EQUATES
                        ;
0003:                   CTRLC	EQU	03H		; Control "C"
0007:                   CTRLG	EQU	07H		; Control "G"
0008:                   BKSP	EQU	08H		; Back space
000A:                   LF	EQU	0AH		; Line feed
000C:                   CS	EQU	0CH		; Clear screen
000D:                   CR	EQU	0DH		; Carriage return
000F:                   CTRLO	EQU	0FH		; Control "O"
0011:                   CTRLQ	EQU	11H		; Control "Q"
0012:                   CTRLR	EQU	12H		; Control "R"
0013:                   CTRLS	EQU	13H		; Control "S"
0015:                   CTRLU	EQU	15H		; Control "U"
001B:                   ESC	EQU	1BH		; Escape
007F:                   DEL	EQU	7FH		; Delete
                        ;
                        ; BASIC WORK SPACE LOCATIONS
                        ;
8045:                   WRKSPC	EQU	8045H		; BASIC Work space
8048:                   USR	EQU	WRKSPC+3H	; "USR (x)" jump
804B:                   OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
804C:                   OTPORT	EQU	WRKSPC+7H	; Port (p)
804E:                   DIVSUP	EQU	WRKSPC+9H	; Division support routine
804F:                   DIV1	EQU	WRKSPC+0AH	; <- Values
8053:                   DIV2	EQU	WRKSPC+0EH	; <- to
8057:                   DIV3	EQU	WRKSPC+12H	; <- be
805A:                   DIV4	EQU	WRKSPC+15H	; <- inserted
805C:                   SEED	EQU	WRKSPC+17H	; Random number seed
807F:                   LSTRND	EQU	WRKSPC+3AH	; Last random number
8083:                   INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
8084:                   INPORT	EQU	WRKSPC+3FH	; PORT (x)
8086:                   NULLS	EQU	WRKSPC+41H	; Number of nulls
8087:                   LWIDTH	EQU	WRKSPC+42H	; Terminal width
8088:                   COMMAN	EQU	WRKSPC+43H	; Width for commas
8089:                   NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
808A:                   CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
808B:                   LINESC	EQU	WRKSPC+46H	; Lines counter
808D:                   LINESN	EQU	WRKSPC+48H	; Lines number
808F:                   CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
8091:                   NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
8092:                   BRKFLG	EQU	WRKSPC+4DH	; Break flag
8093:                   RINPUT	EQU	WRKSPC+4EH	; Input reflection
8096:                   POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
8099:                   PSET	EQU	WRKSPC+54H	; "SET"	reflection
809C:                   RESET	EQU	WRKSPC+57H	; "RESET" reflection
809F:                   STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
80A1:                   LINEAT	EQU	WRKSPC+5CH	; Current line number
80A3:                   BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
80A6:                   BUFFER	EQU	WRKSPC+61H	; Input buffer
80AB:                   STACK	EQU	WRKSPC+66H	; Initial stack
80F0:                   CURPOS	EQU	WRKSPC+0ABH	; Character position on line
80F1:                   LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
80F2:                   TYPE	EQU	WRKSPC+0ADH	; Data type flag
80F3:                   DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
80F4:                   LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
80F6:                   TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
80F8:                   TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
8104:                   TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
8108:                   STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
810A:                   CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
810C:                   LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
810E:                   DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
8110:                   FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
8111:                   LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
8112:                   READFG	EQU	WRKSPC+0CDH	; Read/Input flag
8113:                   BRKLIN	EQU	WRKSPC+0CEH	; Line of break
8115:                   NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
8117:                   ERRLIN	EQU	WRKSPC+0D2H	; Line of error
8119:                   CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
811B:                   PROGND	EQU	WRKSPC+0D6H	; End of program
811D:                   VAREND	EQU	WRKSPC+0D8H	; End of variables
811F:                   ARREND	EQU	WRKSPC+0DAH	; End of arrays
8121:                   NXTDAT	EQU	WRKSPC+0DCH	; Next data item
8123:                   FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
8125:                   FNARG	EQU	WRKSPC+0E0H	; FN argument value
8129:                   FPREG	EQU	WRKSPC+0E4H	; Floating point register
812C:                   FPEXP	EQU	FPREG+3		; Floating point exponent
812D:                   SGNRES	EQU	WRKSPC+0E8H	; Sign of result
812E:                   PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
813B:                   MULVAL	EQU	WRKSPC+0F6H	; Multiplier
813E:                   PROGST	EQU	WRKSPC+0F9H	; Start of program text area
81A2:                   STLOOK	EQU	WRKSPC+15DH	; Start of memory test
                        ;
                        ; BASIC ERROR CODE VALUES
                        ;
0000:                   NF	EQU	00H		; NEXT without FOR
0002:                   SN	EQU	02H		; Syntax error
0004:                   RG	EQU	04H		; RETURN without GOSUB
0006:                   OD	EQU	06H		; Out of DATA
0008:                   FC	EQU	08H		; Function call error
000A:                   OV	EQU	0AH		; Overflow
000C:                   OM	EQU	0CH		; Out of memory
000E:                   UL	EQU	0EH		; Undefined line number
0010:                   BS	EQU	10H		; Bad subscript
0012:                   RD	EQU	12H		; Re-DIMensioned array
0014:                   DZ	EQU	14H		; Division by zero (/0)
0016:                   ID	EQU	16H		; Illegal direct
0018:                   TM	EQU	18H		; Type miss-match
001A:                   OS	EQU	1AH		; Out of string space
001C:                   LS	EQU	1CH		; String too long
001E:                   ST	EQU	1EH		; String formula too complex
0020:                   CN	EQU	20H		; Can't CONTinue
0022:                   UF	EQU	22H		; UnDEFined FN function
0024:                   MO	EQU	24H		; Missing operand
0026:                   HX	EQU	26H		; HEX error
0028:                   BN	EQU	28H		; BIN error
                        ;
003D: C34300   [10]     COLD:	JP	STARTB		; Jump for cold start
0040: C3B800   [10]     WARM:	JP	WARMST		; Jump for warm start
0043: C34A00   [10]     STARTB: JP	CSTART		; Jump to initialise
                        ;
0046: FB08              	DW	DEINT		; Get integer -32768 to 32767
0048: 7110              	DW	ABPASS		; Return integer in AB
                        ;
004A: 214580   [10]     CSTART: LD	HL,WRKSPC	; Start of workspace RAM
004D: F9       [16]     	LD	SP,HL		; Set up a temporary stack
004E: C38C1C   [26]     	JP	INITST		; Go to initialise
                        ;
0051: 112203   [10]     INIT:	LD	DE,INITAB	; Initialise workspace
0054: 0663     [17]     	LD	B,INITBE-INITAB+3; Bytes to copy
0056: 214580   [27]     	LD	HL,WRKSPC	; Into workspace RAM
0059: 1A       [ 7]     COPY:	LD	A,(DE)		; Get source
005A: 77       [14]     	LD	(HL),A		; To destination
005B: 23       [20]     	INC	HL		; Next destination
005C: 13       [26]     	INC	DE		; Next source
005D: 05       [30]     	DEC	B		; Count bytes
005E: C25900   [40|40]  	JP	NZ,COPY		; More to move
0061: F9       [46]     	LD	SP,HL		; Temporary stack
0062: CD2305   [63]     	CALL	CLREG		; Clear registers and stack
0065: CDF10A   [80]     	CALL	PRCRLF		; Output CRLF
0068: 32EF80   [93]     	LD	(BUFFER+72+1),A	; Mark end of buffer
006B: 323E81   [106]    	LD	(PROGST),A	; Initialise program area
006E: 21A281   [10]     MSIZE:	LD	HL,STLOOK	; Point to start of RAM
0071: 23       [ 6]     MLOOP:	INC	HL		; Next byte
0072: 7C       [10]     	LD	A,H		; Above address FFFF ?
0073: B5       [14]     	OR	L
0074: CA8000   [24|24]  	JP	Z,SETTOP	; Yes - 64K RAM
0077: 7E       [31]     	LD	A,(HL)		; Get contents
0078: 47       [35]     	LD	B,A		; Save it
0079: 2F       [39]     	CPL			; Flip all bits
007A: 77       [46]     	LD	(HL),A		; Put it back
007B: BE       [53]     	CP	(HL)		; RAM there if same
007C: 70       [60]     	LD	(HL),B		; Restore old contents
007D: CA7100   [70|70]  	JP	Z,MLOOP		; If RAM - test next byte
                        ;
0080: 2B       [ 6]     SETTOP: DEC	HL		; Back one byte
0081: 11A181   [16]     	LD	DE,STLOOK-1	; See if enough RAM
0084: CDB906   [33]     	CALL	CPDEHL		; Compare DE with HL
0087: DAC100   [43|43]  	JP	C,NEMEM		; If not enough RAM
008A: 11CEFF   [53]     	LD	DE,0-50		; 50 Bytes string space
008D: 22F480   [69]     	LD	(LSTRAM),HL	; Save last available RAM
0090: 19       [80]     	ADD	HL,DE		; Allocate string space
0091: 229F80   [96]     	LD	(STRSPC),HL	; Save string space
0094: CDFE04   [113]    	CALL	CLRPTR		; Clear program area
0097: 2A9F80   [129]    	LD	HL,(STRSPC)	; Get end of memory
009A: 11EFFF   [139]    	LD	DE,0-17		; Offset for free bytes
009D: 19       [150]    	ADD	HL,DE		; Adjust HL
009E: 113E81   [160]    	LD	DE,PROGST	; Start of program text
00A1: 7D       [164]    	LD	A,L		; Get LSB
00A2: 93       [168]    	SUB	E		; Adjust it
00A3: 6F       [172]    	LD	L,A		; Re-save
00A4: 7C       [176]    	LD	A,H		; Get MSB
00A5: 9A       [180]    	SBC	A,D		; Adjust it
00A6: 67       [184]    	LD	H,A		; Re-save
00A7: E5       [195]    	PUSH	HL		; Save bytes free
00A8: 21D900   [205]    	LD	HL,SIGNON	; Sign-on message
00AB: CD8F11   [222]    	CALL	PRS		; Output string
00AE: E1       [232]    	POP	HL		; Get bytes free back
00AF: CD3218   [249]    	CALL	PRNTHL		; Output amount of free memory
00B2: 21CA00   [259]    	LD	HL,BFREE	; " Bytes free" message
00B5: CD8F11   [276]    	CALL	PRS		; Output string
                        ;
00B8: 31AB80   [10]     WARMST: LD	SP,STACK	; Temporary stack
00BB: CD2305   [17]     BRKRET: CALL	CLREG		; Clear registers and stack
00BE: C33C04   [27]     	JP	PRNTOK		; Go to get command line
                        ;
00C1: 211001   [10]     NEMEM:	LD	HL,MEMMSG	; Memory size not enough
00C4: CD8F11   [27]     	CALL	PRS		; Print it
00C7: C3C700   [10]     XXXXX:	JP	XXXXX		; Stop
                        ;
00CA: 20427974          BFREE:	DB	" Bytes free",CR,LF,0,0
00CE: 65732066          
00D2: 7265650D          
00D6: 0A0000            
                        ;
00D9: 5A383020          SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
00DD: 42415349          
00E1: 43205665          
00E5: 7220342E          
00E9: 37620D0A          
00ED: 436F7079          	DB	"Copyright ",40,"C",41
00F1: 72696768          
00F5: 74202843          
00F9: 29                
00FA: 20313937          	DB	" 1978 by Microsoft",CR,LF,0,0
00FE: 38206279          
0102: 204D6963          
0106: 726F736F          
010A: 66740D0A          
010E: 0000              
                        ;
0110: 4D656D6F          MEMMSG: DB	"Memory size not enough",CR,LF
0114: 72792073          
0118: 697A6520          
011C: 6E6F7420          
0120: 656E6F75          
0124: 67680D0A          
0128: 54686520          	DB	"The system is stopped.",CR,LF,0,0
012C: 73797374          
0130: 656D2069          
0134: 73207374          
0138: 6F707065          
013C: 642E0D0A          
0140: 0000              
                        ;
                        ; FUNCTION ADDRESS TABLE
                        ;
0142: A716              FNCTAB: DW	SGN
0144: 6B17              	DW	INT
0146: BD16              	DW	ABS
0148: 4880              	DW	USR
014A: 4F10              	DW	FRE
014C: D413              	DW	INP
014E: 7D10              	DW	POS
0150: 3119              	DW	SQR
0152: 101A              	DW	RND
0154: 4C15              	DW	LOG
0156: 7F19              	DW	EXP
0158: 851A              	DW	COS
015A: 8B1A              	DW	SIN
015C: EC1A              	DW	TAN
015E: 011B              	DW	ATN
0160: 2814              	DW	PEEK
0162: 6C1B              	DW	DEEK
0164: 9680              	DW	POINT
0166: 0113              	DW	LEN
0168: 1911              	DW	STR
016A: 9B13              	DW	VAL
016C: 1013              	DW	ASC
016E: 2113              	DW	CHR
0170: 8E1B              	DW	HEX
0172: 211C              	DW	BIN
0174: 3113              	DW	LEFT
0176: 6113              	DW	RIGHT
0178: 6B13              	DW	MID
                        ;
                        ; RESERVED WORD LIST
                        ;
017A: C54E44            WORDS:	DB	0C5H,"ND"
017D: C64F52            	DB	0C6H,"OR"
0180: CE455854          	DB	0CEH,"EXT"
0184: C4415441          	DB	0C4H,"ATA"
0188: C94E5055          	DB	0C9H,"NPUT"
018C: 54                
018D: C4494D            	DB	0C4H,"IM"
0190: D2454144          	DB	0D2H,"EAD"
0194: CC4554            	DB	0CCH,"ET"
0197: C74F544F          	DB	0C7H,"OTO"
019B: D2554E            	DB	0D2H,"UN"
019E: C946              	DB	0C9H,"F"
01A0: D2455354          	DB	0D2H,"ESTORE"
01A4: 4F5245            
01A7: C74F5355          	DB	0C7H,"OSUB"
01AB: 42                
01AC: D2455455          	DB	0D2H,"ETURN"
01B0: 524E              
01B2: D2454D            	DB	0D2H,"EM"
01B5: D3544F50          	DB	0D3H,"TOP"
01B9: CF5554            	DB	0CFH,"UT"
01BC: CF4E              	DB	0CFH,"N"
01BE: CE554C4C          	DB	0CEH,"ULL"
01C2: D7414954          	DB	0D7H,"AIT"
01C6: C44546            	DB	0C4H,"EF"
01C9: D04F4B45          	DB	0D0H,"OKE"
01CD: C44F4B45          	DB	0C4H,"OKE"
01D1: D3435245          	DB	0D3H,"CREEN"
01D5: 454E              
01D7: CC494E45          	DB	0CCH,"INES"
01DB: 53                
01DC: C34C53            	DB	0C3H,"LS"
01DF: D7494454          	DB	0D7H,"IDTH"
01E3: 48                
01E4: CD4F4E49          	DB	0CDH,"ONITOR"
01E8: 544F52            
01EB: D34554            	DB	0D3H,"ET"
01EE: D2455345          	DB	0D2H,"ESET"
01F2: 54                
01F3: D052494E          	DB	0D0H,"RINT"
01F7: 54                
01F8: C34F4E54          	DB	0C3H,"ONT"
01FC: CC495354          	DB	0CCH,"IST"
0200: C34C4541          	DB	0C3H,"LEAR"
0204: 52                
0205: C34C4F41          	DB	0C3H,"LOAD"
0209: 44                
020A: C3534156          	DB	0C3H,"SAVE"
020E: 45                
020F: CE4557            	DB	0CEH,"EW"
                        ;
0212: D4414228          	DB	0D4H,"AB("
0216: D44F              	DB	0D4H,"O"
0218: C64E              	DB	0C6H,"N"
021A: D3504328          	DB	0D3H,"PC("
021E: D448454E          	DB	0D4H,"HEN"
0222: CE4F54            	DB	0CEH,"OT"
0225: D3544550          	DB	0D3H,"TEP"
                        ;
0229: AB                	DB	0ABH
022A: AD                	DB	0ADH
022B: AA                	DB	0AAH
022C: AF                	DB	0AFH
022D: DE                	DB	0DEH
022E: C14E44            	DB	0C1H,"ND"
0231: CF52              	DB	0CFH,"R"
0233: BE                	DB	0BEH
0234: BD                	DB	0BDH
0235: BC                	DB	0BCH
                        ;
0236: D3474E            	DB	0D3H,"GN"
0239: C94E54            	DB	0C9H,"NT"
023C: C14253            	DB	0C1H,"BS"
023F: D55352            	DB	0D5H,"SR"
0242: C65245            	DB	0C6H,"RE"
0245: C94E50            	DB	0C9H,"NP"
0248: D04F53            	DB	0D0H,"OS"
024B: D35152            	DB	0D3H,"QR"
024E: D24E44            	DB	0D2H,"ND"
0251: CC4F47            	DB	0CCH,"OG"
0254: C55850            	DB	0C5H,"XP"
0257: C34F53            	DB	0C3H,"OS"
025A: D3494E            	DB	0D3H,"IN"
025D: D4414E            	DB	0D4H,"AN"
0260: C1544E            	DB	0C1H,"TN"
0263: D045454B          	DB	0D0H,"EEK"
0267: C445454B          	DB	0C4H,"EEK"
026B: D04F494E          	DB	0D0H,"OINT"
026F: 54                
0270: CC454E            	DB	0CCH,"EN"
0273: D3545224          	DB	0D3H,"TR$"
0277: D6414C            	DB	0D6H,"AL"
027A: C15343            	DB	0C1H,"SC"
027D: C3485224          	DB	0C3H,"HR$"
0281: C8455824          	DB	0C8H,"EX$"
0285: C2494E24          	DB	0C2H,"IN$"
0289: CC454654          	DB	0CCH,"EFT$"
028D: 24                
028E: D2494748          	DB	0D2H,"IGHT$"
0292: 5424              
0294: CD494424          	DB	0CDH,"ID$"
0298: 80                	DB	80H		; End of list marker
                        ;
                        ; KEYWORD ADDRESS TABLE
                        ;
0299: 9308              WORDTB: DW	PEND
029B: 9007              	DW	FOR
029D: 6B0C              	DW	NEXT
029F: E009              	DW	DATA
02A1: 720B              	DW	INPUT
02A3: A70E              	DW	DIM
02A5: A10B              	DW	READ
02A7: F709              	DW	LET
02A9: 9D09              	DW	GOTO
02AB: 8009              	DW	RUN
02AD: 6F0A              	DW	IF
02AF: 5908              	DW	RESTOR
02B1: 8C09              	DW	GOSUB
02B3: BB09              	DW	RETURN
02B5: E209              	DW	REM
02B7: 9108              	DW	STOP
02B9: E013              	DW	POUT
02BB: 510A              	DW	ON
02BD: D208              	DW	NULL
02BF: E613              	DW	WAIT
02C1: 8510              	DW	DEF
02C3: 2F14              	DW	POKE
02C5: 771B              	DW	DOKE
02C7: E209              	DW	REM
02C9: 5D1B              	DW	LINES
02CB: 501B              	DW	CLS
02CD: 551B              	DW	WIDTH
02CF: 891C              	DW	MONITR
02D1: 9980              	DW	PSET
02D3: 9C80              	DW	RESET
02D5: 930A              	DW	PRINT
02D7: BF08              	DW	CONT
02D9: 0507              	DW	LIST
02DB: 3A09              	DW	CLEAR
02DD: E209              	DW	REM
02DF: E209              	DW	REM
02E1: FD04              	DW	NEW
                        ;
                        ; RESERVED WORD TOKEN VALUES
                        ;
0080:                   ZEND	EQU	080H		; END
0081:                   ZFOR	EQU	081H		; FOR
0083:                   ZDATA	EQU	083H		; DATA
0088:                   ZGOTO	EQU	088H		; GOTO
008C:                   ZGOSUB	EQU	08CH		; GOSUB
008E:                   ZREM	EQU	08EH		; REM
009E:                   ZPRINT	EQU	09EH		; PRINT
00A4:                   ZNEW	EQU	0A4H		; NEW
                        ;
00A5:                   ZTAB	EQU	0A5H		; TAB
00A6:                   ZTO	EQU	0A6H		; TO
00A7:                   ZFN	EQU	0A7H		; FN
00A8:                   ZSPC	EQU	0A8H		; SPC
00A9:                   ZTHEN	EQU	0A9H		; THEN
00AA:                   ZNOT	EQU	0AAH		; NOT
00AB:                   ZSTEP	EQU	0ABH		; STEP
                        ;
00AC:                   ZPLUS	EQU	0ACH		; +
00AD:                   ZMINUS	EQU	0ADH		; -
00AE:                   ZTIMES	EQU	0AEH		; *
00AF:                   ZDIV	EQU	0AFH		; /
00B2:                   ZOR	EQU	0B2H		; OR
00B3:                   ZGTR	EQU	0B3H		; >
00B4:                   ZEQUAL	EQU	0B4H		; M
00B5:                   ZLTH	EQU	0B5H		; <
00B6:                   ZSGN	EQU	0B6H		; SGN
00C7:                   ZPOINT	EQU	0C7H		; POINT
00CF:                   ZLEFT	EQU	0CDH +2		; LEFT$
                        ;
                        ; ARITHMETIC PRECEDENCE TABLE
                        ;
02E3: 79                PRITAB: DB	79H		; Precedence value
02E4: 1918              	DW	PADD		; FPREG = <last> + FPREG
                        ;
02E6: 79                	DB	79H		; Precedence value
02E7: 4D14              	DW	PSUB		; FPREG = <last> - FPREG
                        ;
02E9: 7C                	DB	7CH		; Precedence value
02EA: 8B15              	DW	MULT		; PPREG = <last> * FPREG
                        ;
02EC: 7C                	DB	7CH		; Precedence value
02ED: EC15              	DW	DIV		; FPREG = <last> / FPREG
                        ;
02EF: 7F                	DB	7FH		; Precedence value
02F0: 3A19              	DW	POWER		; FPREG = <last> ^ FPREG
                        ;
02F2: 50                	DB	50H		; Precedence value
02F3: 000E              	DW	PAND		; FPREG = <last> AND FPREG
                        ;
02F5: 46                	DB	46H		; Precedence value
02F6: FF0D              	DW	POR		; FPREG = <last> OR FPREG
                        ;
                        ; BASIC ERROR CODE LIST
                        ;
02F8: 4E46              ERRORS: DB	"NF"		; NEXT without FOR
02FA: 534E              	DB	"SN"		; Syntax error
02FC: 5247              	DB	"RG"		; RETURN without GOSUB
02FE: 4F44              	DB	"OD"		; Out of DATA
0300: 4643              	DB	"FC"		; Illegal function call
0302: 4F56              	DB	"OV"		; Overflow error
0304: 4F4D              	DB	"OM"		; Out of memory
0306: 554C              	DB	"UL"		; Undefined line
0308: 4253              	DB	"BS"		; Bad subscript
030A: 4444              	DB	"DD"		; Re-DIMensioned array
030C: 2F30              	DB	"/0"		; Division by zero
030E: 4944              	DB	"ID"		; Illegal direct
0310: 544D              	DB	"TM"		; Type mis-match
0312: 4F53              	DB	"OS"		; Out of string space
0314: 4C53              	DB	"LS"		; String too long
0316: 5354              	DB	"ST"		; String formula too complex
0318: 434E              	DB	"CN"		; Can't CONTinue
031A: 5546              	DB	"UF"		; Undefined FN function
031C: 4D4F              	DB	"MO"		; Missing operand
031E: 4858              	DB	"HX"		; HEX error
0320: 424E              	DB	"BN"		; BIN error
                        ;
                        ; INITIALISATION TABLE -------------------------------------------------------
                        ;
0322: C3B800   [10]     INITAB: JP	WARMST		; Warm start jump
0325: C31009   [20]     	JP	FCERR		; "USR (X)" jump (Set to Error)
0328: D300     [31]     	OUT	(0),A		; "OUT p,n" skeleton
032A: C9       [41]     	RET
032B: D600     [48]     	SUB	0		; Division support routine
032D: 6F       [52]     	LD	L,A
032E: 7C       [56]     	LD	A,H
032F: DE00     [63]     	SBC	A,0
0331: 67       [67]     	LD	H,A
0332: 78       [71]     	LD	A,B
0333: DE00     [78]     	SBC	A,0
0335: 47       [82]     	LD	B,A
0336: 3E00     [89]     	LD	A,0
0338: C9       [99]     	RET
0339: 000000            	DB	0,0,0			; Random number seed table used by RND
033C: 354ACA99          	DB	035H,04AH,0CAH,099H	;-2.65145E+07
0340: 391C7698          	DB	039H,01CH,076H,098H	; 1.61291E+07
0344: 2295B398          	DB	022H,095H,0B3H,098H	;-1.17691E+07
0348: 0ADD4798          	DB	00AH,0DDH,047H,098H	; 1.30983E+07
034C: 53D19999          	DB	053H,0D1H,099H,099H	;-2-01612E+07
0350: 0A1A9F98          	DB	00AH,01AH,09FH,098H	;-1.04269E+07
0354: 65BCCD98          	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
0358: D6773E98          	DB	0D6H,077H,03EH,098H	; 1.24825E+07
035C: 52C74F80          	DB	052H,0C7H,04FH,080H	; Last random number
0360: DB00     [110]    	IN	A,(0)		; INP (x) skeleton
0362: C9       [120]    	RET
0363: 01                	DB	1		; POS (x) number (1)
0364: FF                	DB	255		; Terminal width (255 = no auto CRLF)
0365: 1C                	DB	28		; Width for commas (3 columns)
0366: 00                	DB	0		; No nulls after input bytes
0367: 00                	DB	0		; Output enabled (^O off)
0368: 1400              	DW	20		; Initial lines counter
036A: 1400              	DW	20		; Initial lines number
036C: 0000              	DW	0		; Array load/save check sum
036E: 00                	DB	0		; Break not by NMI
036F: 00                	DB	0		; Break flag
0370: C33606   [130]    	JP	TTYLIN		; Input reflection (set to TTY)
0373: C30000   [140]    	JP	0000H		; POINT reflection unused
0376: C30000   [150]    	JP	0000H		; SET reflection
0379: C30000   [160]    	JP	0000H			; RESET reflection
037C: A281              	DW	STLOOK		; Temp string space
037E: FEFF              	DW	-2		; Current line number (cold)
0380: 3F81              	DW	PROGST+1	; Start of program text
0382:                   INITBE:			 
                        ;
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        ;
0382: 20457272          ERRMSG: DB	" Error",0
0386: 6F7200            
0389: 20696E20          INMSG:	DB	" in ",0
038D: 00                
038D:                   ZERBYT	EQU	$-1		; A zero byte
038E: 4F6B0D0A          OKMSG:	DB	"Ok",CR,LF,0,0
0392: 0000              
0394: 42726561          BRKMSG: DB	"Break",0
0398: 6B00              
                        ;
039A: 210400   [10]     BAKSTK: LD	HL,4		; Look for "FOR" block with
039D: 39       [21]     	ADD	HL,SP		; same index as specified
039E: 7E       [ 7]     LOKFOR: LD	A,(HL)		; Get block ID
039F: 23       [13]     	INC	HL		; Point to index address
03A0: FE81     [20]     	CP	ZFOR		; Is it a "FOR" token
03A2: C0       [25|31]  	RET	NZ		; No - exit
03A3: 4E       [32]     	LD	C,(HL)		; BC = Address of "FOR" index
03A4: 23       [38]     	INC	HL
03A5: 46       [45]     	LD	B,(HL)
03A6: 23       [51]     	INC	HL		; Point to sign of STEP
03A7: E5       [62]     	PUSH	HL		; Save pointer to sign
03A8: 69       [66]     	LD	L,C		; HL = address of "FOR" index
03A9: 60       [70]     	LD	H,B
03AA: 7A       [74]     	LD	A,D		; See if an index was specified
03AB: B3       [78]     	OR	E		; DE = 0 if no index specified
03AC: EB       [82]     	EX	DE,HL		; Specified index into HL
03AD: CAB403   [92|92]  	JP	Z,INDFND	; Skip if no index given
03B0: EB       [96]     	EX	DE,HL		; Index back into DE
03B1: CDB906   [113]    	CALL	CPDEHL		; Compare index with one given
03B4: 010D00   [10]     INDFND: LD	BC,16-3		; Offset to next block
03B7: E1       [20]     	POP	HL		; Restore pointer to sign
03B8: C8       [25|31]  	RET	Z		; Return if block found
03B9: 09       [36]     	ADD	HL,BC		; Point to next block
03BA: C39E03   [46]     	JP	LOKFOR		; Keep on looking
                        ;
03BD: CDD703   [17]     MOVUP:	CALL	ENFMEM		; See if enough memory
03C0: C5       [11]     MOVSTR: PUSH	BC		; Save end of source
03C1: E3       [30]     	EX	(SP),HL		; Swap source and dest" end
03C2: C1       [40]     	POP	BC		; Get end of destination
03C3: CDB906   [17]     MOVLP:	CALL	CPDEHL		; See if list moved
03C6: 7E       [24]     	LD	A,(HL)		; Get byte
03C7: 02       [31]     	LD	(BC),A		; Move it
03C8: C8       [36|42]  	RET	Z		; Exit if all done
03C9: 0B       [42]     	DEC	BC		; Next byte to move to
03CA: 2B       [48]     	DEC	HL		; Next byte to move
03CB: C3C303   [58]     	JP	MOVLP		; Loop until all bytes moved
                        ;
03CE: E5       [11]     CHKSTK: PUSH	HL		; Save code string address
03CF: 2A1F81   [27]     	LD	HL,(ARREND)	; Lowest free memory
03D2: 0600     [34]     	LD	B,0		; BC = Number of levels to test
03D4: 09       [45]     	ADD	HL,BC		; 2 Bytes for each level
03D5: 09       [56]     	ADD	HL,BC
03D6: 3E                	DB	3EH		; Skip "PUSH HL"
03D7: E5       [11]     ENFMEM: PUSH	HL		; Save code string address
03D8: 3ED0     [18]     	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
03DA: 95       [22]     	SUB	L
03DB: 6F       [26]     	LD	L,A
03DC: 3EFF     [33]     	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
03DE: 9C       [37]     	SBC	A,H
03DF: DAE603   [47|47]  	JP	C,OMERR		; Not enough - ?OM Error
03E2: 67       [51]     	LD	H,A
03E3: 39       [62]     	ADD	HL,SP		; Test if stack is overflowed
03E4: E1       [72]     	POP	HL		; Restore code string address
03E5: D8       [77|83]  	RET	C		; Return if enough mmory
03E6: 1E0C     [ 7]     OMERR:	LD	E,OM		; ?OM Error
03E8: C30504   [17]     	JP	ERROR
                        ;
03EB: 2A0E81   [16]     DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
03EE: 22A180   [32]     	LD	(LINEAT),HL	; Save as current line
03F1: 1E02     [ 7]     SNERR:	LD	E,SN		; ?SN Error
03F3: 01                	DB	01H		; Skip "LD E,DZ"
03F4: 1E14     [ 7]     DZERR:	LD	E,DZ		; ?/0 Error
03F6: 01                	DB	01H		; Skip "LD E,NF"
03F7: 1E00     [ 7]     NFERR:	LD	E,NF		; ?NF Error
03F9: 01                	DB	01H		; Skip "LD E,RD"
03FA: 1E12     [ 7]     DDERR:	LD	E,RD		; ?DD Error
03FC: 01                	DB	01H		; Skip "LD E,UF"
03FD: 1E22     [ 7]     UFERR:	LD	E,UF		; ?UF Error
03FF: 01                	DB	01H		; Skip "LD E,OV
0400: 1E0A     [ 7]     OVERR:	LD	E,OV		; ?OV Error
0402: 01                	DB	01H		; Skip "LD E,TM"
0403: 1E18     [ 7]     TMERR:	LD	E,TM		; ?TM Error
                        ;
0405: CD2305   [17]     ERROR:	CALL	CLREG		; Clear registers and stack
0408: 328A80   [30]     	LD	(CTLOFG),A	; Enable output (A is 0)
040B: CDE40A   [47]     	CALL	STTLIN		; Start new line
040E: 21F802   [57]     	LD	HL,ERRORS	; Point to error codes
0411: 57       [61]     	LD	D,A		; D = 0 (A is 0)
0412: 3E3F     [68]     	LD	A,'?'
0414: CDCA06   [85]     	CALL	OUTC		; Output '?'
0417: 19       [96]     	ADD	HL,DE		; Offset to correct error code
0418: 7E       [103]    	LD	A,(HL)		; First character
0419: CDCA06   [120]    	CALL	OUTC		; Output it
041C: CD4908   [137]    	CALL	GETCHR		; Get next character
041F: CDCA06   [154]    	CALL	OUTC		; Output it
0422: 218203   [164]    	LD	HL,ERRMSG	; "Error" message
0425: CD8F11   [17]     ERRIN:	CALL	PRS		; Output message
0428: 2AA180   [33]     	LD	HL,(LINEAT)	; Get line of error
042B: 11FEFF   [43]     	LD	DE,-2		; Cold start error if -2
042E: CDB906   [60]     	CALL	CPDEHL		; See if cold start error
0431: CA4A00   [70|70]  	JP	Z,CSTART	; Cold start error - Restart
0434: 7C       [74]     	LD	A,H		; Was it a direct error?
0435: A5       [78]     	AND	L		; Line = -1 if direct error
0436: 3C       [82]     	INC	A
0437: C42A18   [92|99]  	CALL	NZ,LINEIN	; No - output line of error
043A: 3E                	DB	3EH		; Skip "POP BC"
043B: C1       [10]     POPNOK: POP	BC		; Drop address in input buffer
                        ;
043C: AF       [ 4]     PRNTOK: XOR	A		; Output "Ok" and get command
043D: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
0440: CDE40A   [34]     	CALL	STTLIN		; Start new line
0443: 218E03   [44]     	LD	HL,OKMSG	; "Ok" message
0446: CD8F11   [61]     	CALL	PRS		; Output "Ok"
0449: 21FFFF   [10]     GETCMD: LD	HL,-1		; Flag direct mode
044C: 22A180   [26]     	LD	(LINEAT),HL	; Save as current line
044F: CD3606   [43]     	CALL	GETLIN		; Get an input line
0452: DA4904   [53|53]  	JP	C,GETCMD	; Get line again if break
0455: CD4908   [70]     	CALL	GETCHR		; Get first character
0458: 3C       [74]     	INC	A		; Test if end of line
0459: 3D       [78]     	DEC	A		; Without affecting Carry
045A: CA4904   [88|88]  	JP	Z,GETCMD	; Nothing entered - Get another
045D: F5       [99]     	PUSH	AF		; Save Carry status
045E: CD1509   [116]    	CALL	ATOH		; Get line number into DE
0461: D5       [127]    	PUSH	DE		; Save line number
0462: CD4D05   [144]    	CALL	CRUNCH		; Tokenise rest of line
0465: 47       [148]    	LD	B,A		; Length of tokenised line
0466: D1       [158]    	POP	DE		; Restore line number
0467: F1       [168]    	POP	AF		; Restore Carry
0468: D22908   [178|178]	JP	NC,EXCUTE	; No line number - Direct mode
046B: D5       [189]    	PUSH	DE		; Save line number
046C: C5       [200]    	PUSH	BC		; Save length of tokenised line
046D: AF       [204]    	XOR	A
046E: 321181   [217]    	LD	(LSTBIN),A	; Clear last byte input
0471: CD4908   [234]    	CALL	GETCHR		; Get next character
0474: B7       [238]    	OR	A		; Set flags
0475: F5       [249]    	PUSH	AF		; And save them
0476: CDDD04   [266]    	CALL	SRCHLN		; Search for line number in DE
0479: DA8204   [276|276]	JP	C,LINFND	; Jump if line found
047C: F1       [286]    	POP	AF		; Get status
047D: F5       [297]    	PUSH	AF		; And re-save
047E: CAB609   [307|307]	JP	Z,ULERR	; Nothing after number - Error
0481: B7       [311]    	OR	A		; Clear Carry
0482: C5       [11]     LINFND: PUSH	BC		; Save address of line in prog
0483: D29904   [21|21]  	JP	NC,INEWLN	; Line not found - Insert new
0486: EB       [25]     	EX	DE,HL		; Next line address in DE
0487: 2A1B81   [41]     	LD	HL,(PROGND)	; End of program
048A: 1A       [ 7]     SFTPRG: LD	A,(DE)		; Shift rest of program down
048B: 02       [14]     	LD	(BC),A
048C: 03       [20]     	INC	BC		; Next destination
048D: 13       [26]     	INC	DE		; Next source
048E: CDB906   [43]     	CALL	CPDEHL		; All done?
0491: C28A04   [53|53]  	JP	NZ,SFTPRG	; More to do
0494: 60       [57]     	LD	H,B		; HL - New end of program
0495: 69       [61]     	LD	L,C
0496: 221B81   [77]     	LD	(PROGND),HL	; Update end of program
                        ;
0499: D1       [10]     INEWLN: POP	DE		; Get address of line,
049A: F1       [20]     	POP	AF		; Get status
049B: CAC004   [30|30]  	JP	Z,SETPTR	; No text - Set up pointers
049E: 2A1B81   [46]     	LD	HL,(PROGND)	; Get end of program
04A1: E3       [65]     	EX	(SP),HL		; Get length of input line
04A2: C1       [75]     	POP	BC		; End of program to BC
04A3: 09       [86]     	ADD	HL,BC		; Find new end
04A4: E5       [97]     	PUSH	HL		; Save new end
04A5: CDBD03   [114]    	CALL	MOVUP		; Make space for line
04A8: E1       [124]    	POP	HL		; Restore new end
04A9: 221B81   [140]    	LD	(PROGND),HL	; Update end of program pointer
04AC: EB       [144]    	EX	DE,HL		; Get line to move up in HL
04AD: 74       [151]    	LD	(HL),H		; Save MSB
04AE: D1       [161]    	POP	DE		; Get new line number
04AF: 23       [167]    	INC	HL		; Skip pointer
04B0: 23       [173]    	INC	HL
04B1: 73       [180]    	LD	(HL),E		; Save LSB of line number
04B2: 23       [186]    	INC	HL
04B3: 72       [193]    	LD	(HL),D		; Save MSB of line number
04B4: 23       [199]    	INC	HL		; To first byte in line
04B5: 11A680   [209]    	LD	DE,BUFFER	; Copy buffer to program
04B8: 1A       [ 7]     MOVBUF: LD	A,(DE)		; Get source
04B9: 77       [14]     	LD	(HL),A		; Save destinations
04BA: 23       [20]     	INC	HL		; Next source
04BB: 13       [26]     	INC	DE		; Next destination
04BC: B7       [30]     	OR	A		; Done?
04BD: C2B804   [40|40]  	JP	NZ,MOVBUF	; No - Repeat
04C0: CD0905   [17]     SETPTR: CALL	RUNFST		; Set line pointers
04C3: 23       [23]     	INC	HL		; To LSB of pointer
04C4: EB       [27]     	EX	DE,HL		; Address to DE
04C5: 62       [ 4]     PTRLP:	LD	H,D		; Address to HL
04C6: 6B       [ 8]     	LD	L,E
04C7: 7E       [15]     	LD	A,(HL)		; Get LSB of pointer
04C8: 23       [21]     	INC	HL		; To MSB of pointer
04C9: B6       [28]     	OR	(HL)		; Compare with MSB pointer
04CA: CA4904   [38|38]  	JP	Z,GETCMD	; Get command line if end
04CD: 23       [44]     	INC	HL		; To LSB of line number
04CE: 23       [50]     	INC	HL		; Skip line number
04CF: 23       [56]     	INC	HL		; Point to first byte in line
04D0: AF       [60]     	XOR	A		; Looking for 00 byte
04D1: BE       [ 7]     FNDEND: CP	(HL)		; Found end of line?
04D2: 23       [13]     	INC	HL		; Move to next byte
04D3: C2D104   [23|23]  	JP	NZ,FNDEND	; No - Keep looking
04D6: EB       [27]     	EX	DE,HL		; Next line address to HL
04D7: 73       [34]     	LD	(HL),E		; Save LSB of pointer
04D8: 23       [40]     	INC	HL
04D9: 72       [47]     	LD	(HL),D		; Save MSB of pointer
04DA: C3C504   [57]     	JP	PTRLP		; Do next line
                        ;
04DD: 2AA380   [16]     SRCHLN: LD	HL,(BASTXT)	; Start of program text
04E0: 44       [ 4]     SRCHLP: LD	B,H		; BC = Address to look at
04E1: 4D       [ 8]     	LD	C,L
04E2: 7E       [15]     	LD	A,(HL)		; Get address of next line
04E3: 23       [21]     	INC	HL
04E4: B6       [28]     	OR	(HL)		; End of program found?
04E5: 2B       [34]     	DEC	HL
04E6: C8       [39|45]  	RET	Z		; Yes - Line not found
04E7: 23       [45]     	INC	HL
04E8: 23       [51]     	INC	HL
04E9: 7E       [58]     	LD	A,(HL)		; Get LSB of line number
04EA: 23       [64]     	INC	HL
04EB: 66       [71]     	LD	H,(HL)		; Get MSB of line number
04EC: 6F       [75]     	LD	L,A
04ED: CDB906   [92]     	CALL	CPDEHL		; Compare with line in DE
04F0: 60       [96]     	LD	H,B		; HL = Start of this line
04F1: 69       [100]    	LD	L,C
04F2: 7E       [107]    	LD	A,(HL)		; Get LSB of next line address
04F3: 23       [113]    	INC	HL
04F4: 66       [120]    	LD	H,(HL)		; Get MSB of next line address
04F5: 6F       [124]    	LD	L,A		; Next line to HL
04F6: 3F       [128]    	CCF
04F7: C8       [133|139]	RET	Z		; Lines found - Exit
04F8: 3F       [137]    	CCF
04F9: D0       [142|148]	RET	NC		; Line not found,at line after
04FA: C3E004   [152]    	JP	SRCHLP		; Keep looking
                        ;
04FD: C0       [ 5|11]  NEW:	RET	NZ		; Return if any more on line
04FE: 2AA380   [16]     CLRPTR: LD	HL,(BASTXT)	; Point to start of program
0501: AF       [20]     	XOR	A		; Set program area to empty
0502: 77       [27]     	LD	(HL),A		; Save LSB = 00
0503: 23       [33]     	INC	HL
0504: 77       [40]     	LD	(HL),A		; Save MSB = 00
0505: 23       [46]     	INC	HL
0506: 221B81   [62]     	LD	(PROGND),HL	; Set program end
                        ;
0509: 2AA380   [16]     RUNFST: LD	HL,(BASTXT)	; Clear all variables
050C: 2B       [22]     	DEC	HL
                        ;
050D: 221381   [16]     INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
0510: 2AF480   [32]     	LD	HL,(LSTRAM)	; Get end of RAM
0513: 220881   [48]     	LD	(STRBOT),HL	; Clear string space
0516: AF       [52]     	XOR	A
0517: CD5908   [69]     	CALL	RESTOR		; Reset DATA pointers
051A: 2A1B81   [85]     	LD	HL,(PROGND)	; Get end of program
051D: 221D81   [101]    	LD	(VAREND),HL	; Clear variables
0520: 221F81   [117]    	LD	(ARREND),HL	; Clear arrays
                        ;
0523: C1       [10]     CLREG:	POP	BC		; Save return address
0524: 2A9F80   [26]     	LD	HL,(STRSPC)	; Get end of working RAN
0527: F9       [32]     	LD	SP,HL		; Set stack
0528: 21F880   [42]     	LD	HL,TMSTPL	; Temporary string pool
052B: 22F680   [58]     	LD	(TMSTPT),HL	; Reset temporary string ptr
052E: AF       [62]     	XOR	A		; A = 00
052F: 6F       [66]     	LD	L,A		; HL = 0000
0530: 67       [70]     	LD	H,A
0531: 221981   [86]     	LD	(CONTAD),HL	; No CONTinue
0534: 321081   [99]     	LD	(FORFLG),A	; Clear FOR flag
0537: 222381   [115]    	LD	(FNRGNM),HL	; Clear FN argument
053A: E5       [126]    	PUSH	HL		; HL = 0000
053B: C5       [137]    	PUSH	BC		; Put back return
053C: 2A1381   [16]     DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
053F: C9       [26]     	RET			; Return to execution driver
                        ;
0540: 3E3F     [ 7]     PROMPT: LD	A,'?'		; '?'
0542: CDCA06   [24]     	CALL	OUTC		; Output character
0545: 3E20     [31]     	LD	A,' '		; Space
0547: CDCA06   [48]     	CALL	OUTC		; Output character
054A: C39380   [58]     	JP	RINPUT		; Get input line
                        ;
054D: AF       [ 4]     CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
054E: 32F380   [17]     	LD	(DATFLG),A	; Reset literal flag
0551: 0E05     [24]     	LD	C,2+3		; 2 byte number and 3 nulls
0553: 11A680   [34]     	LD	DE,BUFFER	; Start of input buffer
0556: 7E       [ 7]     CRNCLP: LD	A,(HL)		; Get byte
0557: FE20     [14]     	CP	' '		; Is it a space?
0559: CAD505   [24|24]  	JP	Z,MOVDIR	; Yes - Copy direct
055C: 47       [28]     	LD	B,A		; Save character
055D: FE22     [35]     	CP	'"'		; Is it a quote?
055F: CAF505   [45|45]  	JP	Z,CPYLIT	; Yes - Copy literal string
0562: B7       [49]     	OR	A		; Is it end of buffer?
0563: CAFC05   [59|59]  	JP	Z,ENDBUF	; Yes - End buffer
0566: 3AF380   [72]     	LD	A,(DATFLG)	; Get data type
0569: B7       [76]     	OR	A		; Literal?
056A: 7E       [83]     	LD	A,(HL)		; Get byte to copy
056B: C2D505   [93|93]  	JP	NZ,MOVDIR	; Literal - Copy direct
056E: FE3F     [100]    	CP	'?'		; Is it '?' short for PRINT
0570: 3E9E     [107]    	LD	A,ZPRINT	; "PRINT" token
0572: CAD505   [117|117]	JP	Z,MOVDIR	; Yes - replace it
0575: 7E       [124]    	LD	A,(HL)		; Get byte again
0576: FE30     [131]    	CP	'0'		; Is it less than '0'
0578: DA8005   [141|141]	JP	C,FNDWRD	; Yes - Look for reserved words
057B: FE3C     [148]    	CP	60		; ";"+1; Is it "0123456789:;" ?
057D: DAD505   [158|158]	JP	C,MOVDIR	; Yes - copy it direct
0580: D5       [11]     FNDWRD: PUSH	DE		; Look for reserved words
0581: 117901   [21]     	LD	DE,WORDS-1	; Point to table
0584: C5       [32]     	PUSH	BC		; Save count
0585: 01D105   [42]     	LD	BC,RETNAD	; Where to return to
0588: C5       [53]     	PUSH	BC		; Save return address
0589: 067F     [60]     	LD	B,ZEND-1	; First token value -1
058B: 7E       [67]     	LD	A,(HL)		; Get byte
058C: FE61     [74]     	CP	'a'		; Less than 'a' ?
058E: DA9905   [84|84]  	JP	C,SEARCH	; Yes - search for words
0591: FE7B     [91]     	CP	'z'+1		; Greater than 'z' ?
0593: D29905   [101|101]	JP	NC,SEARCH	; Yes - search for words
0596: E65F     [108]    	AND	01011111B	; Force upper case
0598: 77       [115]    	LD	(HL),A		; Replace byte
0599: 4E       [ 7]     SEARCH: LD	C,(HL)		; Search for a word
059A: EB       [11]     	EX	DE,HL
059B: 23       [ 6]     GETNXT: INC	HL		; Get next reserved word
059C: B6       [13]     	OR	(HL)		; Start of word?
059D: F29B05   [23|23]  	JP	P,GETNXT	; No - move on
05A0: 04       [27]     	INC	B		; Increment token value
05A1: 7E       [34]     	LD	A, (HL)		; Get byte from table
05A2: E67F     [41]     	AND	01111111B	; Strip bit 7
05A4: C8       [46|52]  	RET	Z		; Return if end of list
05A5: B9       [50]     	CP	C		; Same character as in buffer?
05A6: C29B05   [60|60]  	JP	NZ,GETNXT	; No - get next word
05A9: EB       [64]     	EX	DE,HL
05AA: E5       [75]     	PUSH	HL		; Save start of word
                        ;
05AB: 13       [ 6]     NXTBYT: INC	DE		; Look through rest of word
05AC: 1A       [13]     	LD	A,(DE)		; Get byte from table
05AD: B7       [17]     	OR	A		; End of word ?
05AE: FACD05   [27|27]  	JP	M,MATCH		; Yes - Match found
05B1: 4F       [31]     	LD	C,A		; Save it
05B2: 78       [35]     	LD	A,B		; Get token value
05B3: FE88     [42]     	CP	ZGOTO		; Is it "GOTO" token ?
05B5: C2BC05   [52|52]  	JP	NZ,NOSPC	; No - Don't allow spaces
05B8: CD4908   [69]     	CALL	GETCHR		; Get next character
05BB: 2B       [75]     	DEC	HL		; Cancel increment from GETCHR
05BC: 23       [ 6]     NOSPC:	INC	HL		; Next byte
05BD: 7E       [13]     	LD	A,(HL)		; Get byte
05BE: FE61     [20]     	CP	'a'		; Less than 'a' ?
05C0: DAC505   [30|30]  	JP	C,NOCHNG	; Yes - don't change
05C3: E65F     [37]     	AND	01011111B	; Make upper case
05C5: B9       [ 4]     NOCHNG: CP	C		; Same as in buffer ?
05C6: CAAB05   [14|14]  	JP	Z,NXTBYT	; Yes - keep testing
05C9: E1       [24]     	POP	HL		; Get back start of word
05CA: C39905   [34]     	JP	SEARCH		; Look at next word
                        ;
05CD: 48       [ 4]     MATCH:	LD	C,B		; Word found - Save token value
05CE: F1       [14]     	POP	AF		; Throw away return
05CF: EB       [18]     	EX	DE,HL
05D0: C9       [28]     	RET			; Return to "RETNAD"
05D1: EB       [ 4]     RETNAD: EX	DE,HL		; Get address in string
05D2: 79       [ 8]     	LD	A,C		; Get token value
05D3: C1       [18]     	POP	BC		; Restore buffer length
05D4: D1       [28]     	POP	DE		; Get destination address
05D5: 23       [ 6]     MOVDIR: INC	HL		; Next source in buffer
05D6: 12       [13]     	LD	(DE),A		; Put byte in buffer
05D7: 13       [19]     	INC	DE		; Move up buffer
05D8: 0C       [23]     	INC	C		; Increment length of buffer
05D9: D63A     [30]     	SUB	':'		; End of statement?
05DB: CAE305   [40|40]  	JP	Z,SETLIT	; Jump if multi-statement line
05DE: FE49     [47]     	CP	ZDATA-3AH	; Is it DATA statement ?
05E0: C2E605   [57|57]  	JP	NZ,TSTREM	; No - see if REM
05E3: 32F380   [13]     SETLIT: LD	(DATFLG),A	; Set literal flag
05E6: D654     [ 7]     TSTREM: SUB	ZREM-3AH	; Is it REM?
05E8: C25605   [17|17]  	JP	NZ,CRNCLP	; No - Leave flag
05EB: 47       [21]     	LD	B,A		; Copy rest of buffer
05EC: 7E       [ 7]     NXTCHR: LD	A,(HL)		; Get byte
05ED: B7       [11]     	OR	A		; End of line ?
05EE: CAFC05   [21|21]  	JP	Z,ENDBUF	; Yes - Terminate buffer
05F1: B8       [25]     	CP	B		; End of statement ?
05F2: CAD505   [35|35]  	JP	Z,MOVDIR	; Yes - Get next one
05F5: 23       [ 6]     CPYLIT: INC	HL		; Move up source string
05F6: 12       [13]     	LD	(DE),A		; Save in destination
05F7: 0C       [17]     	INC	C		; Increment length
05F8: 13       [23]     	INC	DE		; Move up destination
05F9: C3EC05   [33]     	JP	NXTCHR		; Repeat
                        ;
05FC: 21A580   [10]     ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
05FF: 12       [17]     	LD	(DE),A		; Mark end of buffer (A = 00)
0600: 13       [23]     	INC	DE
0601: 12       [30]     	LD	(DE),A		; A = 00
0602: 13       [36]     	INC	DE
0603: 12       [43]     	LD	(DE),A		; A = 00
0604: C9       [53]     	RET
                        ;
0605: 3A8980   [13]     DODEL:	LD	A,(NULFLG)	; Get null flag status
0608: B7       [17]     	OR	A		; Is it zero?
0609: 3E00     [24]     	LD	A,0		; Zero A - Leave flags
060B: 328980   [37]     	LD	(NULFLG),A	; Zero null flag
060E: C21906   [47|47]  	JP	NZ,ECHDEL	; Set - Echo it
0611: 05       [51]     	DEC	B		; Decrement length
0612: CA3606   [61|61]  	JP	Z,GETLIN	; Get line again if empty
0615: CDCA06   [78]     	CALL	OUTC		; Output null character
0618: 3E                	DB	3EH		; Skip "DEC B"
0619: 05       [ 4]     ECHDEL: DEC	B		; Count bytes in buffer
061A: 2B       [10]     	DEC	HL		; Back space buffer
061B: CA2D06   [20|20]  	JP	Z,OTKLN		; No buffer - Try again
061E: 7E       [27]     	LD	A,(HL)		; Get deleted byte
061F: CDCA06   [44]     	CALL	OUTC		; Echo it
0622: C33F06   [54]     	JP	MORINP		; Get more input
                        ;
0625: 05       [ 4]     DELCHR: DEC	B		; Count bytes in buffer
0626: 2B       [10]     	DEC	HL		; Back space buffer
0627: CDCA06   [27]     	CALL	OUTC		; Output character in A
062A: C23F06   [37|37]  	JP	NZ,MORINP	; Not end - Get more
062D: CDCA06   [17]     OTKLN:	CALL	OUTC		; Output character in A
0630: CDF10A   [17]     KILIN:	CALL	PRCRLF		; Output CRLF
0633: C33606   [27]     	JP	TTYLIN		; Get line again
                        ;
0636:                   GETLIN:
0636: 21A680   [10]     TTYLIN: LD	HL,BUFFER	; Get a line by character
0639: 0601     [17]     	LD	B,1		; Set buffer as empty
063B: AF       [21]     	XOR	A
063C: 328980   [34]     	LD	(NULFLG),A	; Clear null flag
063F: CDF406   [17]     MORINP: CALL	CLOTST		; Get character and test ^O
0642: 4F       [21]     	LD	C,A		; Save character in C
0643: FE7F     [28]     	CP	DEL		; Delete character?
0645: CA0506   [38|38]  	JP	Z,DODEL	; Yes - Process it
0648: 3A8980   [51]     	LD	A,(NULFLG)	; Get null flag
064B: B7       [55]     	OR	A		; Test null flag status
064C: CA5806   [65|65]  	JP	Z,PROCES	; Reset - Process character
064F: 3E00     [72]     	LD	A,0		; Set a null
0651: CDCA06   [89]     	CALL	OUTC		; Output null
0654: AF       [93]     	XOR	A		; Clear A
0655: 328980   [106]    	LD	(NULFLG),A	; Reset null flag
0658: 79       [ 4]     PROCES: LD	A,C		; Get character
0659: FE07     [11]     	CP	CTRLG		; Bell?
065B: CA9C06   [21|21]  	JP	Z,PUTCTL	; Yes - Save it
065E: FE03     [28]     	CP	CTRLC		; Is it control "C"?
0660: CCF10A   [38|45]  	CALL	Z,PRCRLF	; Yes - Output CRLF
0663: 37       [42]     	SCF			; Flag break
0664: C8       [47|53]  	RET	Z		; Return if control "C"
0665: FE0D     [54]     	CP	CR		; Is it enter?
0667: CAEC0A   [64|64]  	JP	Z,ENDINP	; Yes - Terminate input
066A: FE15     [71]     	CP	CTRLU		; Is it control "U"?
066C: CA3006   [81|81]  	JP	Z,KILIN		; Yes - Get another line
066F: FE40     [88]     	CP	'@'		; Is it "kill line"?
0671: CA2D06   [98|98]  	JP	Z,OTKLN		; Yes - Kill line
0674: FE5F     [105]    	CP	'_'		; Is it delete?
0676: CA2506   [115|115]	JP	Z,DELCHR	; Yes - Delete character
0679: FE08     [122]    	CP	BKSP		; Is it backspace?
067B: CA2506   [132|132]	JP	Z,DELCHR	; Yes - Delete character
067E: FE12     [139]    	CP	CTRLR		; Is it control "R"?
0680: C29706   [149|149]	JP	NZ,PUTBUF	; No - Put in buffer
0683: C5       [160]    	PUSH	BC		; Save buffer length
0684: D5       [171]    	PUSH	DE		; Save DE
0685: E5       [182]    	PUSH	HL		; Save buffer address
0686: 3600     [192]    	LD	(HL),0		; Mark end of buffer
0688: CD9B1C   [209]    	CALL	OUTNCR		; Output and do CRLF
068B: 21A680   [219]    	LD	HL,BUFFER	; Point to buffer start
068E: CD8F11   [236]    	CALL	PRS		; Output buffer
0691: E1       [246]    	POP	HL		; Restore buffer address
0692: D1       [256]    	POP	DE		; Restore DE
0693: C1       [266]    	POP	BC		; Restore buffer length
0694: C33F06   [276]    	JP	MORINP		; Get another character
                        ;
0697: FE20     [ 7]     PUTBUF: CP	' '		; Is it a control code?
0699: DA3F06   [17|17]  	JP	C,MORINP	; Yes - Ignore
069C: 78       [ 4]     PUTCTL: LD	A,B		; Get number of bytes in buffer
069D: FE49     [11]     	CP	72+1		; Test for line overflow
069F: 3E07     [18]     	LD	A,CTRLG		; Set a bell
06A1: D2B106   [28|28]  	JP	NC,OUTNBS	; Ring bell if buffer full
06A4: 79       [32]     	LD	A,C		; Get character
06A5: 71       [39]     	LD	(HL),C		; Save in buffer
06A6: 321181   [52]     	LD	(LSTBIN),A	; Save last input byte
06A9: 23       [58]     	INC	HL		; Move up buffer
06AA: 04       [62]     	INC	B		; Increment length
06AB: CDCA06   [17]     OUTIT:	CALL	OUTC		; Output the character entered
06AE: C33F06   [27]     	JP	MORINP		; Get another character
                        ;
06B1: CDCA06   [17]     OUTNBS: CALL	OUTC		; Output bell and back over it
06B4: 3E08     [24]     	LD	A,BKSP		; Set back space
06B6: C3AB06   [34]     	JP	OUTIT		; Output it and get more
                        ;
06B9: 7C       [ 4]     CPDEHL: LD	A,H		; Get H
06BA: 92       [ 8]     	SUB	D		; Compare with D
06BB: C0       [13|19]  	RET	NZ		; Different - Exit
06BC: 7D       [17]     	LD	A,L		; Get L
06BD: 93       [21]     	SUB	E		; Compare with E
06BE: C9       [31]     	RET			; Return status
                        ;
06BF: 7E       [ 7]     CHKSYN: LD	A,(HL)		; Check syntax of character
06C0: E3       [26]     	EX	(SP),HL		; Address of test byte
06C1: BE       [33]     	CP	(HL)		; Same as in code string?
06C2: 23       [39]     	INC	HL		; Return address
06C3: E3       [58]     	EX	(SP),HL		; Put it back
06C4: CA4908   [68|68]  	JP	Z,GETCHR	; Yes - Get next character
06C7: C3F103   [78]     	JP	SNERR		; Different - ?SN Error
                        ;
06CA: F5       [11]     OUTC:	PUSH	AF		; Save character
06CB: 3A8A80   [24]     	LD	A,(CTLOFG)	; Get control "O" flag
06CE: B7       [28]     	OR	A		; Is it set?
06CF: C2C411   [38|38]  	JP	NZ,POPAF	; Yes - don't output
06D2: F1       [48]     	POP	AF		; Restore character
06D3: C5       [59]     	PUSH	BC		; Save buffer length
06D4: F5       [70]     	PUSH	AF		; Save character
06D5: FE20     [77]     	CP	' '		; Is it a control code?
06D7: DAEE06   [87|87]  	JP	C,DINPOS	; Yes - Don't INC POS(X)
06DA: 3A8780   [100]    	LD	A,(LWIDTH)	; Get line width
06DD: 47       [104]    	LD	B,A		; To B
06DE: 3AF080   [117]    	LD	A,(CURPOS)	; Get cursor position
06E1: 04       [121]    	INC	B		; Width 255?
06E2: CAEA06   [131|131]	JP	Z,INCLEN	; Yes - No width limit
06E5: 05       [135]    	DEC	B		; Restore width
06E6: B8       [139]    	CP	B		; At end of line?
06E7: CCF10A   [149|156]	CALL	Z,PRCRLF	; Yes - output CRLF
06EA: 3C       [ 4]     INCLEN: INC	A		; Move on one character
06EB: 32F080   [17]     	LD	(CURPOS),A	; Save new position
06EE: F1       [10]     DINPOS: POP	AF		; Restore character
06EF: C1       [20]     	POP	BC		; Restore buffer length
06F0: CD861C   [37]     	CALL	MONOUT		; Send it
06F3: C9       [47]     	RET
                        ;
06F4: CD4E1B   [17]     CLOTST: CALL	GETINP		; Get input character
06F7: E67F     [24]     	AND	01111111B	; Strip bit 7
06F9: FE0F     [31]     	CP	CTRLO		; Is it control "O"?
06FB: C0       [36|42]  	RET	NZ		; No don't flip flag
06FC: 3A8A80   [49]     	LD	A,(CTLOFG)	; Get flag
06FF: 2F       [53]     	CPL			; Flip it
0700: 328A80   [66]     	LD	(CTLOFG),A	; Put it back
0703: AF       [70]     	XOR	A		; Null character
0704: C9       [80]     	RET
                        ;
0705: CD1509   [17]     LIST:	CALL	ATOH		; ASCII number to DE
0708: C0       [22|28]  	RET	NZ		; Return if anything extra
0709: C1       [32]     	POP	BC		; Rubbish - Not needed
070A: CDDD04   [49]     	CALL	SRCHLN		; Search for line number in DE
070D: C5       [60]     	PUSH	BC		; Save address of line
070E: CD5B07   [77]     	CALL	SETLIN		; Set up lines counter
0711: E1       [10]     LISTLP: POP	HL		; Restore address of line
0712: 4E       [17]     	LD	C,(HL)		; Get LSB of next line
0713: 23       [23]     	INC	HL
0714: 46       [30]     	LD	B,(HL)		; Get MSB of next line
0715: 23       [36]     	INC	HL
0716: 78       [40]     	LD	A,B		; BC = 0 (End of program)?
0717: B1       [44]     	OR	C
0718: CA3C04   [54|54]  	JP	Z,PRNTOK	; Yes - Go to command mode
071B: CD6407   [71]     	CALL	COUNT		; Count lines
071E: CD7408   [88]     	CALL	TSTBRK		; Test for break key
0721: C5       [99]     	PUSH	BC		; Save address of next line
0722: CDF10A   [116]    	CALL	PRCRLF		; Output CRLF
0725: 5E       [123]    	LD	E,(HL)		; Get LSB of line number
0726: 23       [129]    	INC	HL
0727: 56       [136]    	LD	D,(HL)		; Get MSB of line number
0728: 23       [142]    	INC	HL
0729: E5       [153]    	PUSH	HL		; Save address of line start
072A: EB       [157]    	EX	DE,HL		; Line number to HL
072B: CD3218   [174]    	CALL	PRNTHL		; Output line number in decimal
072E: 3E20     [181]    	LD	A,' '		; Space after line number
0730: E1       [191]    	POP	HL		; Restore start of line address
0731: CDCA06   [17]     LSTLP2: CALL	OUTC		; Output character in A
0734: 7E       [ 7]     LSTLP3: LD	A,(HL)		; Get next byte in line
0735: B7       [11]     	OR	A		; End of line?
0736: 23       [17]     	INC	HL		; To next byte in line
0737: CA1107   [27|27]  	JP	Z,LISTLP	; Yes - get next line
073A: F23107   [37|37]  	JP	P,LSTLP2	; No token - output it
073D: D67F     [44]     	SUB	ZEND-1		; Find and output word
073F: 4F       [48]     	LD	C,A		; Token offset+1 to C
0740: 117A01   [58]     	LD	DE,WORDS	; Reserved word list
0743: 1A       [ 7]     FNDTOK: LD	A,(DE)		; Get character in list
0744: 13       [13]     	INC	DE		; Move on to next
0745: B7       [17]     	OR	A		; Is it start of word?
0746: F24307   [27|27]  	JP	P,FNDTOK	; No - Keep looking for word
0749: 0D       [31]     	DEC	C		; Count words
074A: C24307   [41|41]  	JP	NZ,FNDTOK	; Not there - keep looking
074D: E67F     [ 7]     OUTWRD: AND	01111111B	; Strip bit 7
074F: CDCA06   [24]     	CALL	OUTC		; Output first character
0752: 1A       [31]     	LD	A,(DE)		; Get next character
0753: 13       [37]     	INC	DE		; Move on to next
0754: B7       [41]     	OR	A		; Is it end of word?
0755: F24D07   [51|51]  	JP	P,OUTWRD	; No - output the rest
0758: C33407   [61]     	JP	LSTLP3		; Next byte in line
                        ;
075B: E5       [11]     SETLIN: PUSH	HL		; Set up LINES counter
075C: 2A8D80   [27]     	LD	HL,(LINESN)	; Get LINES number
075F: 228B80   [43]     	LD	(LINESC),HL	; Save in LINES counter
0762: E1       [53]     	POP	HL
0763: C9       [63]     	RET
                        ;
0764: E5       [11]     COUNT:	PUSH	HL		; Save code string address
0765: D5       [22]     	PUSH	DE
0766: 2A8B80   [38]     	LD	HL,(LINESC)	; Get LINES counter
0769: 11FFFF   [48]     	LD	DE,-1
076C: ED5A     [63]     	ADC	HL,DE		; Decrement
076E: 228B80   [79]     	LD	(LINESC),HL	; Put it back
0771: D1       [89]     	POP	DE
0772: E1       [99]     	POP	HL		; Restore code string address
0773: F0       [104|110]	RET	P		; Return if more lines to go
0774: E5       [115]    	PUSH	HL		; Save code string address
0775: 2A8D80   [131]    	LD	HL,(LINESN)	; Get LINES number
0778: 228B80   [147]    	LD	(LINESC),HL	; Reset LINES counter
077B: CD4E1B   [164]    	CALL	GETINP		; Get input character
077E: FE03     [171]    	CP	CTRLC		; Is it control "C"?
0780: CA8707   [181|181]	JP	Z,RSLNBK	; Yes - Reset LINES and break
0783: E1       [191]    	POP	HL		; Restore code string address
0784: C36407   [201]    	JP	COUNT		; Keep on counting
                        ;
0787: 2A8D80   [16]     RSLNBK: LD	HL,(LINESN)	; Get LINES number
078A: 228B80   [32]     	LD	(LINESC),HL	; Reset LINES counter
078D: C3BB00   [42]     	JP	BRKRET		; Go and output "Break"
                        ;
0790: 3E64     [ 7]     FOR:	LD	A,64H		; Flag "FOR" assignment
0792: 321081   [20]     	LD	(FORFLG),A	; Save "FOR" flag
0795: CDF709   [37]     	CALL	LET		; Set up initial index
0798: C1       [47]     	POP	BC		; Drop RETurn address
0799: E5       [58]     	PUSH	HL		; Save code string address
079A: CDE009   [75]     	CALL	DATA		; Get next statement address
079D: 220C81   [91]     	LD	(LOOPST),HL	; Save it for start of loop
07A0: 210200   [101]    	LD	HL,2		; Offset for "FOR" block
07A3: 39       [112]    	ADD	HL,SP		; Point to it
07A4: CD9E03   [17]     FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
07A7: D1       [27]     	POP	DE		; Get code string address
07A8: C2C007   [37|37]  	JP	NZ,FORFND	; No nesting found
07AB: 09       [48]     	ADD	HL,BC		; Move into "FOR" block
07AC: D5       [59]     	PUSH	DE		; Save code string address
07AD: 2B       [65]     	DEC	HL
07AE: 56       [72]     	LD	D,(HL)		; Get MSB of loop statement
07AF: 2B       [78]     	DEC	HL
07B0: 5E       [85]     	LD	E,(HL)		; Get LSB of loop statement
07B1: 23       [91]     	INC	HL
07B2: 23       [97]     	INC	HL
07B3: E5       [108]    	PUSH	HL		; Save block address
07B4: 2A0C81   [124]    	LD	HL,(LOOPST)	; Get address of loop statement
07B7: CDB906   [141]    	CALL	CPDEHL		; Compare the FOR loops
07BA: E1       [151]    	POP	HL		; Restore block address
07BB: C2A407   [161|161]	JP	NZ,FORSLP	; Different FORs - Find another
07BE: D1       [171]    	POP	DE		; Restore code string address
07BF: F9       [177]    	LD	SP,HL		; Remove all nested loops
                        ;
07C0: EB       [ 4]     FORFND: EX	DE,HL		; Code string address to HL
07C1: 0E08     [11]     	LD	C,8
07C3: CDCE03   [28]     	CALL	CHKSTK		; Check for 8 levels of stack
07C6: E5       [39]     	PUSH	HL		; Save code string address
07C7: 2A0C81   [55]     	LD	HL,(LOOPST)	; Get first statement of loop
07CA: E3       [74]     	EX	(SP),HL		; Save and restore code string
07CB: E5       [85]     	PUSH	HL		; Re-save code string address
07CC: 2AA180   [101]    	LD	HL,(LINEAT)	; Get current line number
07CF: E3       [120]    	EX	(SP),HL		; Save and restore code string
07D0: CDB90C   [137]    	CALL	TSTNUM		; Make sure it's a number
07D3: CDBF06   [154]    	CALL	CHKSYN		; Make sure "TO" is next
07D6: A6                	DB	ZTO		; "TO" token
07D7: CDB60C   [171]    	CALL	GETNUM		; Get "TO" expression value
07DA: E5       [182]    	PUSH	HL		; Save code string address
07DB: CDE416   [199]    	CALL	BCDEFP		; Move "TO" value to BCDE
07DE: E1       [209]    	POP	HL		; Restore code string address
07DF: C5       [220]    	PUSH	BC		; Save "TO" value in block
07E0: D5       [231]    	PUSH	DE
07E1: 010081   [241]    	LD	BC,8100H	; BCDE - 1 (default STEP)
07E4: 51       [245]    	LD	D,C		; C=0
07E5: 5A       [249]    	LD	E,D		; D=0
07E6: 7E       [256]    	LD	A,(HL)		; Get next byte in code string
07E7: FEAB     [263]    	CP	ZSTEP		; See if "STEP" is stated
07E9: 3E01     [270]    	LD	A,1		; Sign of step = 1
07EB: C2FC07   [280|280]	JP	NZ,SAVSTP	; No STEP given - Default to 1
07EE: CD4908   [297]    	CALL	GETCHR		; Jump over "STEP" token
07F1: CDB60C   [314]    	CALL	GETNUM		; Get step value
07F4: E5       [325]    	PUSH	HL		; Save code string address
07F5: CDE416   [342]    	CALL	BCDEFP		; Move STEP to BCDE
07F8: CD9816   [359]    	CALL	TSTSGN		; Test sign of FPREG
07FB: E1       [369]    	POP	HL		; Restore code string address
07FC: C5       [11]     SAVSTP: PUSH	BC		; Save the STEP value in block
07FD: D5       [22]     	PUSH	DE
07FE: F5       [33]     	PUSH	AF		; Save sign of STEP
07FF: 33       [39]     	INC	SP		; Don't save flags
0800: E5       [50]     	PUSH	HL		; Save code string address
0801: 2A1381   [66]     	LD	HL,(BRKLIN)	; Get address of index variable
0804: E3       [85]     	EX	(SP),HL		; Save and restore code string
0805: 0681     [ 7]     PUTFID: LD	B,ZFOR		; "FOR" block marker
0807: C5       [18]     	PUSH	BC		; Save it
0808: 33       [24]     	INC	SP		; Don't save C
                        ;
0809: CD7408   [17]     RUNCNT: CALL	TSTBRK		; Execution driver - Test break
080C: 221381   [33]     	LD	(BRKLIN),HL	; Save code address for break
080F: 7E       [40]     	LD	A,(HL)		; Get next byte in code string
0810: FE3A     [47]     	CP	':'		; Multi statement line?
0812: CA2908   [57|57]  	JP	Z,EXCUTE	; Yes - Execute it
0815: B7       [61]     	OR	A		; End of line?
0816: C2F103   [71|71]  	JP	NZ,SNERR	; No - Syntax error
0819: 23       [77]     	INC	HL		; Point to address of next line
081A: 7E       [84]     	LD	A,(HL)		; Get LSB of line pointer
081B: 23       [90]     	INC	HL
081C: B6       [97]     	OR	(HL)		; Is it zero (End of prog)?
081D: CA9B08   [107|107]	JP	Z,ENDPRG	; Yes - Terminate execution
0820: 23       [113]    	INC	HL		; Point to line number
0821: 5E       [120]    	LD	E,(HL)		; Get LSB of line number
0822: 23       [126]    	INC	HL
0823: 56       [133]    	LD	D,(HL)		; Get MSB of line number
0824: EB       [137]    	EX	DE,HL		; Line number to HL
0825: 22A180   [153]    	LD	(LINEAT),HL	; Save as current line number
0828: EB       [157]    	EX	DE,HL		; Line number back to DE
0829: CD4908   [17]     EXCUTE: CALL	GETCHR		; Get key word
082C: 110908   [27]     	LD	DE,RUNCNT	; Where to RETurn to
082F: D5       [38]     	PUSH	DE		; Save for RETurn
0830: C8       [ 5|11]  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
0831: D680     [ 7]     ONJMP:	SUB	ZEND		; Is it a token?
0833: DAF709   [17|17]  	JP	C,LET		; No - try to assign it
0836: FE25     [24]     	CP	ZNEW+1-ZEND	; END to NEW ?
0838: D2F103   [34|34]  	JP	NC,SNERR	; Not a key word - ?SN Error
083B: 07       [38]     	RLCA			; Double it
083C: 4F       [42]     	LD	C,A		; BC = Offset into table
083D: 0600     [49]     	LD	B,0
083F: EB       [53]     	EX	DE,HL		; Save code string address
0840: 219902   [63]     	LD	HL,WORDTB	; Keyword address table
0843: 09       [74]     	ADD	HL,BC		; Point to routine address
0844: 4E       [81]     	LD	C,(HL)		; Get LSB of routine address
0845: 23       [87]     	INC	HL
0846: 46       [94]     	LD	B,(HL)		; Get MSB of routine address
0847: C5       [105]    	PUSH	BC		; Save routine address
0848: EB       [109]    	EX	DE,HL		; Restore code string address
                        ;
0849: 23       [ 6]     GETCHR: INC	HL		; Point to next character
084A: 7E       [13]     	LD	A,(HL)		; Get next code string byte
084B: FE3A     [20]     	CP	':'		; Z if ':'
084D: D0       [25|31]  	RET	NC		; NC if > "9"
084E: FE20     [32]     	CP	' '
0850: CA4908   [42|42]  	JP	Z,GETCHR	; Skip over spaces
0853: FE30     [49]     	CP	'0'
0855: 3F       [53]     	CCF			; NC if < '0'
0856: 3C       [57]     	INC	A		; Test for zero - Leave carry
0857: 3D       [61]     	DEC	A		; Z if Null
0858: C9       [71]     	RET
                        ;
0859: EB       [ 4]     RESTOR: EX	DE,HL		; Save code string address
085A: 2AA380   [20]     	LD	HL,(BASTXT)	; Point to start of program
085D: CA6E08   [30|30]  	JP	Z,RESTNL	; Just RESTORE - reset pointer
0860: EB       [34]     	EX	DE,HL		; Restore code string address
0861: CD1509   [51]     	CALL	ATOH		; Get line number to DE
0864: E5       [62]     	PUSH	HL		; Save code string address
0865: CDDD04   [79]     	CALL	SRCHLN		; Search for line number in DE
0868: 60       [83]     	LD	H,B		; HL = Address of line
0869: 69       [87]     	LD	L,C
086A: D1       [97]     	POP	DE		; Restore code string address
086B: D2B609   [107|107]	JP	NC,ULERR	; ?UL Error if not found
086E: 2B       [ 6]     RESTNL: DEC	HL		; Byte before DATA statement
086F: 222181   [16]     UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
0872: EB       [20]     	EX	DE,HL		; Restore code string address
0873: C9       [30]     	RET
                        ;
                        
0874: DF       [11]     TSTBRK: RST	18H		; Check input status
0875: C8       [16|22]  	RET	Z		; No key, go back
0876: D7       [27]     	RST	10H		; Get the key into A
0877: FE1B     [34]     	CP	ESC		; Escape key?
0879: 2811     [41|46]  	JR	Z,BRK		; Yes, break
087B: FE03     [48]     	CP	CTRLC		; <Ctrl-C>
087D: 280D     [55|60]  	JR	Z,BRK		; Yes, break
087F: FE13     [62]     	CP	CTRLS		; Stop scrolling?
0881: C0       [67|73]  	RET	NZ		; Other key, ignore
                        ;
                        
0882: D7       [11]     STALL:	RST	10H		; Wait for key
0883: FE11     [18]     	CP	CTRLQ		; Resume scrolling?
0885: C8       [23|29]  	RET	Z		; Release the chokehold
0886: FE03     [30]     	CP	CTRLC		; Second break?
0888: 2807     [37|42]  	JR	Z,STOP		; Break during hold exits prog
088A: 18F6     [49]     	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                        ;
088C: 3EFF     [ 7]     BRK	LD	A,0FFH		; Set BRKFLG
088E: 329280   [20]     	LD	(BRKFLG),A	; Store it
                        ;
                        
0891: C0       [ 5|11]  STOP:	RET	NZ		; Exit if anything else
0892: F6                	DB	0F6H		; Flag "STOP"
0893: C0       [ 5|11]  PEND:	RET	NZ		; Exit if anything else
0894: 221381   [21]     	LD	(BRKLIN),HL	; Save point of break
0897: 21                	DB	21H		; Skip "OR 11111111B"
0898: F6FF     [ 7]     INPBRK: OR	11111111B	; Flag "Break" wanted
089A: C1       [17]     	POP	BC		; Return not needed and more
089B: 2AA180   [16]     ENDPRG: LD	HL,(LINEAT)	; Get current line number
089E: F5       [27]     	PUSH	AF		; Save STOP / END status
089F: 7D       [31]     	LD	A,L		; Is it direct break?
08A0: A4       [35]     	AND	H
08A1: 3C       [39]     	INC	A		; Line is -1 if direct break
08A2: CAAE08   [49|49]  	JP	Z,NOLIN		; Yes - No line number
08A5: 221781   [65]     	LD	(ERRLIN),HL	; Save line of break
08A8: 2A1381   [81]     	LD	HL,(BRKLIN)	; Get point of break
08AB: 221981   [97]     	LD	(CONTAD),HL	; Save point to CONTinue
08AE: AF       [ 4]     NOLIN:	XOR	A
08AF: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
08B2: CDE40A   [34]     	CALL	STTLIN		; Start a new line
08B5: F1       [44]     	POP	AF		; Restore STOP / END status
08B6: 219403   [54]     	LD	HL,BRKMSG	; "Break" message
08B9: C22504   [64|64]  	JP	NZ,ERRIN	; "in line" wanted?
08BC: C33C04   [74]     	JP	PRNTOK		; Go to command mode
                        ;
08BF: 2A1981   [16]     CONT:	LD	HL,(CONTAD)	; Get CONTinue address
08C2: 7C       [20]     	LD	A,H		; Is it zero?
08C3: B5       [24]     	OR	L
08C4: 1E20     [31]     	LD	E,CN		; ?CN Error
08C6: CA0504   [41|41]  	JP	Z,ERROR		; Yes - output "?CN Error"
08C9: EB       [45]     	EX	DE,HL		; Save code string address
08CA: 2A1781   [61]     	LD	HL,(ERRLIN)	; Get line of last break
08CD: 22A180   [77]     	LD	(LINEAT),HL	; Set up current line number
08D0: EB       [81]     	EX	DE,HL		; Restore code string address
08D1: C9       [91]     	RET			; CONTinue where left off
                        ;
08D2: CD1714   [17]     NULL:	CALL	GETINT		; Get integer 0-255
08D5: C0       [22|28]  	RET	NZ		; Return if bad value
08D6: 328680   [35]     	LD	(NULLS),A	; Set nulls number
08D9: C9       [45]     	RET
                        ;
                        
08DA: E5       [11]     ACCSUM: PUSH	HL		; Save address in array
08DB: 2A8F80   [27]     	LD	HL,(CHKSUM)	; Get check sum
08DE: 0600     [34]     	LD	B,0		; BC - Value of byte
08E0: 4F       [38]     	LD	C,A
08E1: 09       [49]     	ADD	HL,BC		; Add byte to check sum
08E2: 228F80   [65]     	LD	(CHKSUM),HL	; Re-save check sum
08E5: E1       [75]     	POP	HL		; Restore address in array
08E6: C9       [85]     	RET
                        ;
08E7: 7E       [ 7]     CHKLTR: LD	A,(HL)		; Get byte
08E8: FE41     [14]     	CP	'A'		; < 'a' ?
08EA: D8       [19|25]  	RET	C		; Carry set if not letter
08EB: FE5B     [26]     	CP	'Z'+1		; > 'z' ?
08ED: 3F       [30]     	CCF
08EE: C9       [40]     	RET			; Carry set if not letter
                        ;
08EF: CD4908   [17]     FPSINT: CALL	GETCHR		; Get next character
08F2: CDB60C   [17]     POSINT: CALL	GETNUM		; Get integer 0 to 32767
08F5: CD9816   [17]     DEPINT: CALL	TSTSGN		; Test sign of FPREG
08F8: FA1009   [27|27]  	JP	M,FCERR		; Negative - ?FC Error
08FB: 3A2C81   [13]     DEINT:	LD	A,(FPEXP)	; Get integer value to DE
08FE: FE90     [20]     	CP	80H+16		; Exponent in range (16 bits)?
0900: DA4017   [30|30]  	JP	C,FPINT		; Yes - convert it
0903: 018090   [40]     	LD	BC,9080H	; BCDE = -32768
0906: 110000   [50]     	LD	DE,0000
0909: E5       [61]     	PUSH	HL		; Save code string address
090A: CD1317   [78]     	CALL	CMPNUM		; Compare FPREG with BCDE
090D: E1       [88]     	POP	HL		; Restore code string address
090E: 51       [92]     	LD	D,C		; MSB to D
090F: C8       [97|103] 	RET	Z		; Return if in range
0910: 1E08     [ 7]     FCERR:	LD	E,FC		; ?FC Error
0912: C30504   [17]     	JP	ERROR		; Output error-
                        ;
0915: 2B       [ 6]     ATOH:	DEC	HL		; ASCII number to DE binary
0916: 110000   [10]     GETLN:	LD	DE,0		; Get number to DE
0919: CD4908   [17]     GTLNLP: CALL	GETCHR		; Get next character
091C: D0       [22|28]  	RET	NC		; Exit if not a digit
091D: E5       [33]     	PUSH	HL		; Save code string address
091E: F5       [44]     	PUSH	AF		; Save digit
091F: 219819   [54]     	LD	HL,65529/10	; Largest number 65529
0922: CDB906   [71]     	CALL	CPDEHL		; Number in range?
0925: DAF103   [81|81]  	JP	C,SNERR		; No - ?SN Error
0928: 62       [85]     	LD	H,D		; HL = Number
0929: 6B       [89]     	LD	L,E
092A: 19       [100]    	ADD	HL,DE		; Times 2
092B: 29       [111]    	ADD	HL,HL		; Times 4
092C: 19       [122]    	ADD	HL,DE		; Times 5
092D: 29       [133]    	ADD	HL,HL		; Times 10
092E: F1       [143]    	POP	AF		; Restore digit
092F: D630     [150]    	SUB	'0'		; Make it 0 to 9
0931: 5F       [154]    	LD	E,A		; DE = Value of digit
0932: 1600     [161]    	LD	D,0
0934: 19       [172]    	ADD	HL,DE		; Add to number
0935: EB       [176]    	EX	DE,HL		; Number to DE
0936: E1       [186]    	POP	HL		; Restore code string address
0937: C31909   [196]    	JP	GTLNLP		; Go to next character
                        ;
093A: CA0D05   [10|10]  CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
093D: CDF208   [27]     	CALL	POSINT		; Get integer 0 to 32767 to DE
0940: 2B       [33]     	DEC	HL		; Cancel increment
0941: CD4908   [50]     	CALL	GETCHR		; Get next character
0944: E5       [61]     	PUSH	HL		; Save code string address
0945: 2AF480   [77]     	LD	HL,(LSTRAM)	; Get end of RAM
0948: CA5D09   [87|87]  	JP	Z,STORED	; No value given - Use stored
094B: E1       [97]     	POP	HL		; Restore code string address
094C: CDBF06   [114]    	CALL	CHKSYN		; Check for comma
094F: 2C                	DB	','
0950: D5       [125]    	PUSH	DE		; Save number
0951: CDF208   [142]    	CALL	POSINT		; Get integer 0 to 32767
0954: 2B       [148]    	DEC	HL		; Cancel increment
0955: CD4908   [165]    	CALL	GETCHR		; Get next character
0958: C2F103   [175|175]	JP	NZ,SNERR	; ?SN Error if more on line
095B: E3       [194]    	EX	(SP),HL		; Save code string address
095C: EB       [198]    	EX	DE,HL		; Number to DE
095D: 7D       [ 4]     STORED: LD	A,L		; Get LSB of new RAM top
095E: 93       [ 8]     	SUB	E		; Subtract LSB of string space
095F: 5F       [12]     	LD	E,A		; Save LSB
0960: 7C       [16]     	LD	A,H		; Get MSB of new RAM top
0961: 9A       [20]     	SBC	A,D		; Subtract MSB of string space
0962: 57       [24]     	LD	D,A		; Save MSB
0963: DAE603   [34|34]  	JP	C,OMERR		; ?OM Error if not enough mem
0966: E5       [45]     	PUSH	HL		; Save RAM top
0967: 2A1B81   [61]     	LD	HL,(PROGND)	; Get program end
096A: 012800   [71]     	LD	BC,40		; 40 Bytes minimum working RAM
096D: 09       [82]     	ADD	HL,BC		; Get lowest address
096E: CDB906   [99]     	CALL	CPDEHL		; Enough memory?
0971: D2E603   [109|109]	JP	NC,OMERR	; No - ?OM Error
0974: EB       [113]    	EX	DE,HL		; RAM top to HL
0975: 229F80   [129]    	LD	(STRSPC),HL	; Set new string space
0978: E1       [139]    	POP	HL		; End of memory to use
0979: 22F480   [155]    	LD	(LSTRAM),HL	; Set new top of RAM
097C: E1       [165]    	POP	HL		; Restore code string address
097D: C30D05   [175]    	JP	INTVAR		; Initialise variables
                        ;
0980: CA0905   [10|10]  RUN:	JP	Z,RUNFST	; RUN from start if just RUN
0983: CD0D05   [27]     	CALL	INTVAR		; Initialise variables
0986: 010908   [37]     	LD	BC,RUNCNT	; Execution driver loop
0989: C39C09   [47]     	JP	RUNLIN		; RUN from line number
                        ;
098C: 0E03     [ 7]     GOSUB:	LD	C,3		; 3 Levels of stack needed
098E: CDCE03   [24]     	CALL	CHKSTK		; Check for 3 levels of stack
0991: C1       [34]     	POP	BC		; Get return address
0992: E5       [45]     	PUSH	HL		; Save code string for RETURN
0993: E5       [56]     	PUSH	HL		; And for GOSUB routine
0994: 2AA180   [72]     	LD	HL,(LINEAT)	; Get current line
0997: E3       [91]     	EX	(SP),HL		; Into stack - Code string out
0998: 3E8C     [98]     	LD	A,ZGOSUB	; "GOSUB" token
099A: F5       [109]    	PUSH	AF		; Save token
099B: 33       [115]    	INC	SP		; Don't save flags
                        ;
099C: C5       [11]     RUNLIN: PUSH	BC		; Save return address
099D: CD1509   [17]     GOTO:	CALL	ATOH		; ASCII number to DE binary
09A0: CDE209   [34]     	CALL	REM		; Get end of line
09A3: E5       [45]     	PUSH	HL		; Save end of line
09A4: 2AA180   [61]     	LD	HL,(LINEAT)	; Get current line
09A7: CDB906   [78]     	CALL	CPDEHL		; Line after current?
09AA: E1       [88]     	POP	HL		; Restore end of line
09AB: 23       [94]     	INC	HL		; Start of next line
09AC: DCE004   [104|111]	CALL	C,SRCHLP	; Line is after current line
09AF: D4DD04   [114|121]	CALL	NC,SRCHLN	; Line is before current line
09B2: 60       [118]    	LD	H,B		; Set up code string address
09B3: 69       [122]    	LD	L,C
09B4: 2B       [128]    	DEC	HL		; Incremented after
09B5: D8       [133|139]	RET	C		; Line found
09B6: 1E0E     [ 7]     ULERR:	LD	E,UL		; ?UL Error
09B8: C30504   [17]     	JP	ERROR		; Output error message
                        ;
09BB: C0       [ 5|11]  RETURN: RET	NZ		; Return if not just RETURN
09BC: 16FF     [12]     	LD	D,-1		; Flag "GOSUB" search
09BE: CD9A03   [29]     	CALL	BAKSTK		; Look "GOSUB" block
09C1: F9       [35]     	LD	SP,HL		; Kill all FORs in subroutine
09C2: FE8C     [42]     	CP	ZGOSUB		; Test for "GOSUB" token
09C4: 1E04     [49]     	LD	E,RG		; ?RG Error
09C6: C20504   [59|59]  	JP	NZ,ERROR	; Error if no "GOSUB" found
09C9: E1       [69]     	POP	HL		; Get RETURN line number
09CA: 22A180   [85]     	LD	(LINEAT),HL	; Save as current
09CD: 23       [91]     	INC	HL		; Was it from direct statement?
09CE: 7C       [95]     	LD	A,H
09CF: B5       [99]     	OR	L		; Return to line
09D0: C2DA09   [109|109]	JP	NZ,RETLIN	; No - Return to line
09D3: 3A1181   [122]    	LD	A,(LSTBIN)	; Any INPUT in subroutine?
09D6: B7       [126]    	OR	A		; If so buffer is corrupted
09D7: C23B04   [136|136]	JP	NZ,POPNOK	; Yes - Go to command mode
09DA: 210908   [10]     RETLIN: LD	HL,RUNCNT	; Execution driver loop
09DD: E3       [29]     	EX	(SP),HL		; Into stack - Code string out
09DE: 3E                	DB	3EH		; Skip "POP HL"
09DF: E1       [10]     NXTDTA: POP	HL		; Restore code string address
                        ;
09E0: 013A              DATA:	DB	01H,3AH		; ':' End of statement
09E2: 0E00     [ 7]     REM:	LD	C,0		; 00	End of statement
09E4: 0600     [14]     	LD	B,0
09E6: 79       [ 4]     NXTSTL: LD	A,C		; Statement and byte
09E7: 48       [ 8]     	LD	C,B
09E8: 47       [12]     	LD	B,A		; Statement end byte
09E9: 7E       [ 7]     NXTSTT: LD	A,(HL)		; Get byte
09EA: B7       [11]     	OR	A		; End of line?
09EB: C8       [16|22]  	RET	Z		; Yes - Exit
09EC: B8       [20]     	CP	B		; End of statement?
09ED: C8       [25|31]  	RET	Z		; Yes - Exit
09EE: 23       [31]     	INC	HL		; Next byte
09EF: FE22     [38]     	CP	'"'		; Literal string?
09F1: CAE609   [48|48]  	JP	Z,NXTSTL	; Yes - Look for another '"'
09F4: C3E909   [58]     	JP	NXTSTT		; Keep looking
                        ;
09F7: CDAC0E   [17]     LET:	CALL	GETVAR		; Get variable name
09FA: CDBF06   [34]     	CALL	CHKSYN		; Make sure "=" follows
09FD: B4                	DB	ZEQUAL		; "=" token
09FE: D5       [45]     	PUSH	DE		; Save address of variable
09FF: 3AF280   [58]     	LD	A,(TYPE)	; Get data type
0A02: F5       [69]     	PUSH	AF		; Save type
0A03: CDC80C   [86]     	CALL	EVAL		; Evaluate expression
0A06: F1       [96]     	POP	AF		; Restore type
0A07: E3       [115]    	EX	(SP),HL		; Save code - Get var addr
0A08: 221381   [131]    	LD	(BRKLIN),HL	; Save address of variable
0A0B: 1F       [135]    	RRA			; Adjust type
0A0C: CDBB0C   [152]    	CALL	CHKTYP		; Check types are the same
0A0F: CA4A0A   [162|162]	JP	Z,LETNUM	; Numeric - Move value
0A12: E5       [11]     LETSTR: PUSH	HL		; Save address of string var
0A13: 2A2981   [27]     	LD	HL,(FPREG)	; Pointer to string entry
0A16: E5       [38]     	PUSH	HL		; Save it on stack
0A17: 23       [44]     	INC	HL		; Skip over length
0A18: 23       [50]     	INC	HL
0A19: 5E       [57]     	LD	E,(HL)		; LSB of string address
0A1A: 23       [63]     	INC	HL
0A1B: 56       [70]     	LD	D,(HL)		; MSB of string address
0A1C: 2AA380   [86]     	LD	HL,(BASTXT)	; Point to start of program
0A1F: CDB906   [103]    	CALL	CPDEHL		; Is string before program?
0A22: D2390A   [113|113]	JP	NC,CRESTR	; Yes - Create string entry
0A25: 2A9F80   [129]    	LD	HL,(STRSPC)	; Point to string space
0A28: CDB906   [146]    	CALL	CPDEHL		; Is string literal in program?
0A2B: D1       [156]    	POP	DE		; Restore address of string
0A2C: D2410A   [166|166]	JP	NC,MVSTPT	; Yes - Set up pointer
0A2F: 210481   [176]    	LD	HL,TMPSTR	; Temporary string pool
0A32: CDB906   [193]    	CALL	CPDEHL		; Is string in temporary pool?
0A35: D2410A   [203|203]	JP	NC,MVSTPT	; No - Set up pointer
0A38: 3E                	DB	3EH		; Skip "POP DE"
0A39: D1       [10]     CRESTR: POP	DE		; Restore address of string
0A3A: CDF012   [27]     	CALL	BAKTMP		; Back to last tmp-str entry
0A3D: EB       [31]     	EX	DE,HL		; Address of string entry
0A3E: CD2911   [48]     	CALL	SAVSTR		; Save string in string area
0A41: CDF012   [17]     MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
0A44: E1       [27]     	POP	HL		; Get string pointer
0A45: CDF316   [44]     	CALL	DETHL4		; Move string pointer to var
0A48: E1       [54]     	POP	HL		; Restore code string address
0A49: C9       [64]     	RET
                        ;
0A4A: E5       [11]     LETNUM: PUSH	HL		; Save address of variable
0A4B: CDF016   [28]     	CALL	FPTHL		; Move value to variable
0A4E: D1       [38]     	POP	DE		; Restore address of variable
0A4F: E1       [48]     	POP	HL		; Restore code string address
0A50: C9       [58]     	RET
                        ;
0A51: CD1714   [17]     ON:	CALL	GETINT		; Get integer 0-255
0A54: 7E       [24]     	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
0A55: 47       [28]     	LD	B,A		; Save in B
0A56: FE8C     [35]     	CP	ZGOSUB		; "GOSUB" token?
0A58: CA600A   [45|45]  	JP	Z,ONGO		; Yes - Find line number
0A5B: CDBF06   [62]     	CALL	CHKSYN		; Make sure it's "GOTO"
0A5E: 88                	DB	ZGOTO		; "GOTO" token
0A5F: 2B       [68]     	DEC	HL		; Cancel increment
0A60: 4B       [ 4]     ONGO:	LD	C,E		; Integer of branch value
0A61: 0D       [ 4]     ONGOLP: DEC	C		; Count branches
0A62: 78       [ 8]     	LD	A,B		; Get "GOTO" or "GOSUB" token
0A63: CA3108   [18|18]  	JP	Z,ONJMP		; Go to that line if right one
0A66: CD1609   [35]     	CALL	GETLN		; Get line number to DE
0A69: FE2C     [42]     	CP	','		; Another line number?
0A6B: C0       [47|53]  	RET	NZ		; No - Drop through
0A6C: C3610A   [57]     	JP	ONGOLP		; Yes - loop
                        ;
0A6F: CDC80C   [17]     IF:	CALL	EVAL		; Evaluate expression
0A72: 7E       [24]     	LD	A,(HL)		; Get token
0A73: FE88     [31]     	CP	ZGOTO		; "GOTO" token?
0A75: CA7D0A   [41|41]  	JP	Z,IFGO		; Yes - Get line
0A78: CDBF06   [58]     	CALL	CHKSYN		; Make sure it's "THEN"
0A7B: A9                	DB	ZTHEN		; "THEN" token
0A7C: 2B       [64]     	DEC	HL		; Cancel increment
0A7D: CDB90C   [17]     IFGO:	CALL	TSTNUM		; Make sure it's numeric
0A80: CD9816   [34]     	CALL	TSTSGN		; Test state of expression
0A83: CAE209   [44|44]  	JP	Z,REM		; False - Drop through
0A86: CD4908   [61]     	CALL	GETCHR		; Get next character
0A89: DA9D09   [71|71]  	JP	C,GOTO		; Number - GOTO that line
0A8C: C33008   [81]     	JP	IFJMP		; Otherwise do statement
                        ;
0A8F: 2B       [ 6]     MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
0A90: CD4908   [23]     	CALL	GETCHR		; Get next character
0A93: CAF10A   [10|10]  PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
0A96: C8       [ 5|11]  PRNTLP: RET	Z		; End of list - Exit
0A97: FEA5     [12]     	CP	ZTAB		; "TAB(" token?
0A99: CA240B   [22|22]  	JP	Z,DOTAB		; Yes - Do TAB routine
0A9C: FEA8     [29]     	CP	ZSPC		; "SPC(" token?
0A9E: CA240B   [39|39]  	JP	Z,DOTAB		; Yes - Do SPC routine
0AA1: E5       [50]     	PUSH	HL		; Save code string address
0AA2: FE2C     [57]     	CP	','		; Comma?
0AA4: CA0D0B   [67|67]  	JP	Z,DOCOM		; Yes - Move to next zone
0AA7: FE3B     [74]     	CP	59;";"		; Semi-colon?
0AA9: CA470B   [84|84]  	JP	Z,NEXITM	; Do semi-colon routine
0AAC: C1       [94]     	POP	BC		; Code string address to BC
0AAD: CDC80C   [111]    	CALL	EVAL		; Evaluate expression
0AB0: E5       [122]    	PUSH	HL		; Save code string address
0AB1: 3AF280   [135]    	LD	A,(TYPE)	; Get variable type
0AB4: B7       [139]    	OR	A		; Is it a string variable?
0AB5: C2DD0A   [149|149]	JP	NZ,PRNTST	; Yes - Output string contents
0AB8: CD3D18   [166]    	CALL	NUMASC		; Convert number to text
0ABB: CD4D11   [183]    	CALL	CRTST		; Create temporary string
0ABE: 3620     [193]    	LD	(HL),' '	; Followed by a space
0AC0: 2A2981   [209]    	LD	HL,(FPREG)	; Get length of output
0AC3: 34       [220]    	INC	(HL)		; Plus 1 for the space
0AC4: 2A2981   [236]    	LD	HL,(FPREG)	; < Not needed >
0AC7: 3A8780   [249]    	LD	A,(LWIDTH)	; Get width of line
0ACA: 47       [253]    	LD	B,A		; To B
0ACB: 04       [257]    	INC	B		; Width 255 (No limit)?
0ACC: CAD90A   [267|267]	JP	Z,PRNTNB	; Yes - Output number string
0ACF: 04       [271]    	INC	B		; Adjust it
0AD0: 3AF080   [284]    	LD	A,(CURPOS)	; Get cursor position
0AD3: 86       [291]    	ADD	A,(HL)		; Add length of string
0AD4: 3D       [295]    	DEC	A		; Adjust it
0AD5: B8       [299]    	CP	B		; Will output fit on this line?
0AD6: D4F10A   [309|316]	CALL	NC,PRCRLF	; No - CRLF first
0AD9: CD9211   [17]     PRNTNB: CALL	PRS1		; Output string at (HL)
0ADC: AF       [21]     	XOR	A		; Skip CALL by setting 'z' flag
0ADD: C49211   [10|17]  PRNTST: CALL	NZ,PRS1		; Output string at (HL)
0AE0: E1       [20]     	POP	HL		; Restore code string address
0AE1: C38F0A   [30]     	JP	MRPRNT		; See if more to PRINT
                        ;
0AE4: 3AF080   [13]     STTLIN: LD	A,(CURPOS)	; Make sure on new line
0AE7: B7       [17]     	OR	A		; Already at start?
0AE8: C8       [22|28]  	RET	Z		; Yes - Do nothing
0AE9: C3F10A   [32]     	JP	PRCRLF		; Start a new line
                        ;
0AEC: 3600     [10]     ENDINP: LD	(HL),0		; Mark end of buffer
0AEE: 21A580   [20]     	LD	HL,BUFFER-1	; Point to buffer
0AF1: 3E0D     [ 7]     PRCRLF: LD	A,CR		; Load a CR
0AF3: CDCA06   [24]     	CALL	OUTC		; Output character
0AF6: 3E0A     [31]     	LD	A,LF		; Load a LF
0AF8: CDCA06   [48]     	CALL	OUTC		; Output character
0AFB: AF       [ 4]     DONULL: XOR	A		; Set to position 0
0AFC: 32F080   [17]     	LD	(CURPOS),A	; Store it
0AFF: 3A8680   [30]     	LD	A,(NULLS)	; Get number of nulls
0B02: 3D       [ 4]     NULLP:	DEC	A		; Count them
0B03: C8       [ 9|15]  	RET	Z		; Return if done
0B04: F5       [20]     	PUSH	AF		; Save count
0B05: AF       [24]     	XOR	A		; Load a null
0B06: CDCA06   [41]     	CALL	OUTC		; Output it
0B09: F1       [51]     	POP	AF		; Restore count
0B0A: C3020B   [61]     	JP	NULLP		; Keep counting
                        ;
0B0D: 3A8880   [13]     DOCOM:	LD	A,(COMMAN)	; Get comma width
0B10: 47       [17]     	LD	B,A		; Save in B
0B11: 3AF080   [30]     	LD	A,(CURPOS)	; Get current position
0B14: B8       [34]     	CP	B		; Within the limit?
0B15: D4F10A   [44|51]  	CALL	NC,PRCRLF	; No - output CRLF
0B18: D2470B   [54|54]  	JP	NC,NEXITM	; Get next item
0B1B: D60E     [ 7]     ZONELP: SUB	14		; Next zone of 14 characters
0B1D: D21B0B   [17|17]  	JP	NC,ZONELP	; Repeat if more zones
0B20: 2F       [21]     	CPL			; Number of spaces to output
0B21: C33C0B   [31]     	JP	ASPCS		; Output them
                        ;
0B24: F5       [11]     DOTAB:	PUSH	AF		; Save token
0B25: CD1414   [28]     	CALL	FNDNUM		; Evaluate expression
0B28: CDBF06   [45]     	CALL	CHKSYN		; Make sure ")" follows
0B2B: 29                	DB	")"
0B2C: 2B       [51]     	DEC	HL		; Back space on to ")"
0B2D: F1       [61]     	POP	AF		; Restore token
0B2E: D6A8     [68]     	SUB	ZSPC		; Was it "SPC(" ?
0B30: E5       [79]     	PUSH	HL		; Save code string address
0B31: CA370B   [89|89]  	JP	Z,DOSPC	; Yes - Do 'E' spaces
0B34: 3AF080   [102]    	LD	A,(CURPOS)	; Get current position
0B37: 2F       [ 4]     DOSPC:	CPL			; Number of spaces to print to
0B38: 83       [ 8]     	ADD	A,E		; Total number to print
0B39: D2470B   [18|18]  	JP	NC,NEXITM	; TAB < Current POS(X)
0B3C: 3C       [ 4]     ASPCS:	INC	A		; Output A spaces
0B3D: 47       [ 8]     	LD	B,A		; Save number to print
0B3E: 3E20     [15]     	LD	A,' '		; Space
0B40: CDCA06   [17]     SPCLP:	CALL	OUTC		; Output character in A
0B43: 05       [21]     	DEC	B		; Count them
0B44: C2400B   [31|31]  	JP	NZ,SPCLP	; Repeat if more
0B47: E1       [10]     NEXITM: POP	HL		; Restore code string address
0B48: CD4908   [27]     	CALL	GETCHR		; Get next character
0B4B: C3960A   [37]     	JP	PRNTLP		; More to print
                        ;
0B4E: 3F526564          REDO:	DB	"?Redo from start",CR,LF,0
0B52: 6F206672          
0B56: 6F6D2073          
0B5A: 74617274          
0B5E: 0D0A00            
                        ;
0B61: 3A1281   [13]     BADINP: LD	A,(READFG)	; READ or INPUT?
0B64: B7       [17]     	OR	A
0B65: C2EB03   [27|27]  	JP	NZ,DATSNR	; READ - ?SN Error
0B68: C1       [37]     	POP	BC		; Throw away code string addr
0B69: 214E0B   [47]     	LD	HL,REDO		; "Redo from start" message
0B6C: CD8F11   [64]     	CALL	PRS		; Output string
0B6F: C33C05   [74]     	JP	DOAGN		; Do last INPUT again
                        ;
0B72: CDFA10   [17]     INPUT:	CALL	IDTEST		; Test for illegal direct
0B75: 7E       [24]     	LD	A,(HL)		; Get character after "INPUT"
0B76: FE22     [31]     	CP	'"'		; Is there a prompt string?
0B78: 3E00     [38]     	LD	A,0		; Clear A and leave flags
0B7A: 328A80   [51]     	LD	(CTLOFG),A	; Enable output
0B7D: C28C0B   [61|61]  	JP	NZ,NOPMPT	; No prompt - get input
0B80: CD4E11   [78]     	CALL	QTSTR		; Get string terminated by '"'
0B83: CDBF06   [95]     	CALL	CHKSYN		; Check for ';' after prompt
0B86: 3B                	DB	';'
0B87: E5       [106]    	PUSH	HL		; Save code string address
0B88: CD9211   [123]    	CALL	PRS1		; Output prompt string
0B8B: 3E                	DB	3EH		; Skip "PUSH HL"
0B8C: E5       [11]     NOPMPT: PUSH	HL		; Save code string address
0B8D: CD4005   [28]     	CALL	PROMPT		; Get input with "? " prompt
0B90: C1       [38]     	POP	BC		; Restore code string address
0B91: DA9808   [48|48]  	JP	C,INPBRK	; Break pressed - Exit
0B94: 23       [54]     	INC	HL		; Next byte
0B95: 7E       [61]     	LD	A,(HL)		; Get it
0B96: B7       [65]     	OR	A		; End of line?
0B97: 2B       [71]     	DEC	HL		; Back again
0B98: C5       [82]     	PUSH	BC		; Re-save code string address
0B99: CADF09   [92|92]  	JP	Z,NXTDTA	; Yes - Find next DATA stmt
0B9C: 362C     [102]    	LD	(HL),','	; Store comma as separator
0B9E: C3A60B   [112]    	JP	NXTITM		; Get next item
                        ;
0BA1: E5       [11]     READ:	PUSH	HL		; Save code string address
0BA2: 2A2181   [27]     	LD	HL,(NXTDAT)	; Next DATA statement
0BA5: F6                	DB	0F6H		; Flag "READ"
0BA6: AF       [ 4]     NXTITM: XOR	A		; Flag "INPUT"
0BA7: 321281   [17]     	LD	(READFG),A	; Save "READ"/"INPUT" flag
0BAA: E3       [36]     	EX	(SP),HL		; Get code str' , Save pointer
0BAB: C3B20B   [46]     	JP	GTVLUS		; Get values
                        ;
0BAE: CDBF06   [17]     NEDMOR: CALL	CHKSYN		; Check for comma between items
0BB1: 2C                	DB	','
0BB2: CDAC0E   [17]     GTVLUS: CALL	GETVAR		; Get variable name
0BB5: E3       [36]     	EX	(SP),HL		; Save code str" , Get pointer
0BB6: D5       [47]     	PUSH	DE		; Save variable address
0BB7: 7E       [54]     	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
0BB8: FE2C     [61]     	CP	','		; Comma?
0BBA: CADA0B   [71|71]  	JP	Z,ANTVLU	; Yes - Get another value
0BBD: 3A1281   [84]     	LD	A,(READFG)	; Is it READ?
0BC0: B7       [88]     	OR	A
0BC1: C2470C   [98|98]  	JP	NZ,FDTLP	; Yes - Find next DATA stmt
0BC4: 3E3F     [105]    	LD	A,'?'		; More INPUT needed
0BC6: CDCA06   [122]    	CALL	OUTC		; Output character
0BC9: CD4005   [139]    	CALL	PROMPT		; Get INPUT with prompt
0BCC: D1       [149]    	POP	DE		; Variable address
0BCD: C1       [159]    	POP	BC		; Code string address
0BCE: DA9808   [169|169]	JP	C,INPBRK	; Break pressed
0BD1: 23       [175]    	INC	HL		; Point to next DATA byte
0BD2: 7E       [182]    	LD	A,(HL)		; Get byte
0BD3: B7       [186]    	OR	A		; Is it zero (No input) ?
0BD4: 2B       [192]    	DEC	HL		; Back space INPUT pointer
0BD5: C5       [203]    	PUSH	BC		; Save code string address
0BD6: CADF09   [213|213]	JP	Z,NXTDTA	; Find end of buffer
0BD9: D5       [224]    	PUSH	DE		; Save variable address
0BDA: 3AF280   [13]     ANTVLU: LD	A,(TYPE)	; Check data type
0BDD: B7       [17]     	OR	A		; Is it numeric?
0BDE: CA040C   [27|27]  	JP	Z,INPBIN	; Yes - Convert to binary
0BE1: CD4908   [44]     	CALL	GETCHR		; Get next character
0BE4: 57       [48]     	LD	D,A		; Save input character
0BE5: 47       [52]     	LD	B,A		; Again
0BE6: FE22     [59]     	CP	'"'		; Start of literal sting?
0BE8: CAF80B   [69|69]  	JP	Z,STRENT	; Yes - Create string entry
0BEB: 3A1281   [82]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0BEE: B7       [86]     	OR	A
0BEF: 57       [90]     	LD	D,A		; Save 00 if "INPUT"
0BF0: CAF50B   [100|100]	JP	Z,ITMSEP	; "INPUT" - End with 00
0BF3: 163A     [107]    	LD	D,':'		; "DATA" - End with 00 or ':'
0BF5: 062C     [ 7]     ITMSEP: LD	B,','		; Item separator
0BF7: 2B       [13]     	DEC	HL		; Back space for DTSTR
0BF8: CD5111   [17]     STRENT: CALL	DTSTR		; Get string terminated by D
0BFB: EB       [21]     	EX	DE,HL		; String address to DE
0BFC: 210F0C   [31]     	LD	HL,LTSTND	; Where to go after LETSTR
0BFF: E3       [50]     	EX	(SP),HL		; Save HL , get input pointer
0C00: D5       [61]     	PUSH	DE		; Save address of string
0C01: C3120A   [71]     	JP	LETSTR		; Assign string to variable
                        ;
0C04: CD4908   [17]     INPBIN: CALL	GETCHR		; Get next character
0C07: CD9F17   [34]     	CALL	ASCTFP		; Convert ASCII to FP number
0C0A: E3       [53]     	EX	(SP),HL		; Save input ptr, Get var addr
0C0B: CDF016   [70]     	CALL	FPTHL		; Move FPREG to variable
0C0E: E1       [80]     	POP	HL		; Restore input pointer
0C0F: 2B       [ 6]     LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
0C10: CD4908   [23]     	CALL	GETCHR		; Get next character
0C13: CA1B0C   [33|33]  	JP	Z,MORDT		; End of line - More needed?
0C16: FE2C     [40]     	CP	','		; Another value?
0C18: C2610B   [50|50]  	JP	NZ,BADINP	; No - Bad input
0C1B: E3       [19]     MORDT:	EX	(SP),HL		; Get code string address
0C1C: 2B       [25]     	DEC	HL		; DEC 'cos GETCHR INCs
0C1D: CD4908   [42]     	CALL	GETCHR		; Get next character
0C20: C2AE0B   [52|52]  	JP	NZ,NEDMOR	; More needed - Get it
0C23: D1       [62]     	POP	DE		; Restore DATA pointer
0C24: 3A1281   [75]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0C27: B7       [79]     	OR	A
0C28: EB       [83]     	EX	DE,HL		; DATA pointer to HL
0C29: C26F08   [93|93]  	JP	NZ,UPDATA	; Update DATA pointer if "READ"
0C2C: D5       [104]    	PUSH	DE		; Save code string address
0C2D: B6       [111]    	OR	(HL)		; More input given?
0C2E: 21360C   [121]    	LD	HL,EXTIG	; "?Extra ignored" message
0C31: C48F11   [131|138]	CALL	NZ,PRS		; Output string if extra given
0C34: E1       [141]    	POP	HL		; Restore code string address
0C35: C9       [151]    	RET
                        ;
0C36: 3F457874          EXTIG:	DB	"?Extra ignored",CR,LF,0
0C3A: 72612069          
0C3E: 676E6F72          
0C42: 65640D0A          
0C46: 00                
                        ;
0C47: CDE009   [17]     FDTLP:	CALL	DATA		; Get next statement
0C4A: B7       [21]     	OR	A		; End of line?
0C4B: C2600C   [31|31]  	JP	NZ,FANDT	; No - See if DATA statement
0C4E: 23       [37]     	INC	HL
0C4F: 7E       [44]     	LD	A,(HL)		; End of program?
0C50: 23       [50]     	INC	HL
0C51: B6       [57]     	OR	(HL)		; 00 00 Ends program
0C52: 1E06     [64]     	LD	E,OD		; ?OD Error
0C54: CA0504   [74|74]  	JP	Z,ERROR		; Yes - Out of DATA
0C57: 23       [80]     	INC	HL
0C58: 5E       [87]     	LD	E,(HL)		; LSB of line number
0C59: 23       [93]     	INC	HL
0C5A: 56       [100]    	LD	D,(HL)		; MSB of line number
0C5B: EB       [104]    	EX	DE,HL
0C5C: 220E81   [120]    	LD	(DATLIN),HL	; Set line of current DATA item
0C5F: EB       [124]    	EX	DE,HL
0C60: CD4908   [17]     FANDT:	CALL	GETCHR		; Get next character
0C63: FE83     [24]     	CP	ZDATA		; "DATA" token
0C65: C2470C   [34|34]  	JP	NZ,FDTLP	; No "DATA" - Keep looking
0C68: C3DA0B   [44]     	JP	ANTVLU		; Found - Convert input
                        ;
0C6B: 110000   [10]     NEXT:	LD	DE,0		; In case no index given
0C6E: C4AC0E   [10|17]  NEXT1:	CALL	NZ,GETVAR	; Get index address
0C71: 221381   [26]     	LD	(BRKLIN),HL	; Save code string address
0C74: CD9A03   [43]     	CALL	BAKSTK		; Look for "FOR" block
0C77: C2F703   [53|53]  	JP	NZ,NFERR	; No "FOR" - ?NF Error
0C7A: F9       [59]     	LD	SP,HL		; Clear nested loops
0C7B: D5       [70]     	PUSH	DE		; Save index address
0C7C: 7E       [77]     	LD	A,(HL)		; Get sign of STEP
0C7D: 23       [83]     	INC	HL
0C7E: F5       [94]     	PUSH	AF		; Save sign of STEP
0C7F: D5       [105]    	PUSH	DE		; Save index address
0C80: CDD616   [122]    	CALL	PHLTFP		; Move index value to FPREG
0C83: E3       [141]    	EX	(SP),HL		; Save address of TO value
0C84: E5       [152]    	PUSH	HL		; Save address of index
0C85: CD4314   [169]    	CALL	ADDPHL		; Add STEP to index value
0C88: E1       [179]    	POP	HL		; Restore address of index
0C89: CDF016   [196]    	CALL	FPTHL		; Move value to index variable
0C8C: E1       [206]    	POP	HL		; Restore address of TO value
0C8D: CDE716   [223]    	CALL	LOADFP		; Move TO value to BCDE
0C90: E5       [234]    	PUSH	HL		; Save address of line of FOR
0C91: CD1317   [251]    	CALL	CMPNUM		; Compare index with TO value
0C94: E1       [261]    	POP	HL		; Restore address of line num
0C95: C1       [271]    	POP	BC		; Address of sign of STEP
0C96: 90       [275]    	SUB	B		; Compare with expected sign
0C97: CDE716   [292]    	CALL	LOADFP		; BC = Loop stmt,DE = Line num
0C9A: CAA60C   [302|302]	JP	Z,KILFOR	; Loop finished - Terminate it
0C9D: EB       [306]    	EX	DE,HL		; Loop statement line number
0C9E: 22A180   [322]    	LD	(LINEAT),HL	; Set loop line number
0CA1: 69       [326]    	LD	L,C		; Set code string to loop
0CA2: 60       [330]    	LD	H,B
0CA3: C30508   [340]    	JP	PUTFID		; Put back "FOR" and continue
                        ;
0CA6: F9       [ 6]     KILFOR: LD	SP,HL		; Remove "FOR" block
0CA7: 2A1381   [22]     	LD	HL,(BRKLIN)	; Code string after "NEXT"
0CAA: 7E       [29]     	LD	A,(HL)		; Get next byte in code string
0CAB: FE2C     [36]     	CP	','		; More NEXTs ?
0CAD: C20908   [46|46]  	JP	NZ,RUNCNT	; No - Do next statement
0CB0: CD4908   [63]     	CALL	GETCHR		; Position to index name
0CB3: CD6E0C   [80]     	CALL	NEXT1		; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        ;
0CB6: CDC80C   [17]     GETNUM: CALL	EVAL		; Get a numeric expression
0CB9: F6                TSTNUM: DB	0F6H		; Clear carry (numeric)
0CBA: 37       [ 4]     TSTSTR: SCF			; Set carry (string)
0CBB: 3AF280   [13]     CHKTYP: LD	A,(TYPE)	; Check types match
0CBE: 8F       [17]     	ADC	A,A		; Expected + actual
0CBF: B7       [21]     	OR	A		; Clear carry , set parity
0CC0: E8       [26|32]  	RET	PE		; Even parity - Types match
0CC1: C30304   [36]     	JP	TMERR		; Different types - Error
                        ;
0CC4: CDBF06   [17]     OPNPAR: CALL	CHKSYN		; Make sure "(" follows
0CC7: 28                	DB	"("
0CC8: 2B       [ 6]     EVAL:	DEC	HL		; Evaluate expression & save
0CC9: 1600     [13]     	LD	D,0		; Precedence value
0CCB: D5       [11]     EVAL1:	PUSH	DE		; Save precedence
0CCC: 0E01     [18]     	LD	C,1
0CCE: CDCE03   [35]     	CALL	CHKSTK		; Check for 1 level of stack
0CD1: CD3F0D   [52]     	CALL	OPRND		; Get next expression value
0CD4: 221581   [16]     EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
0CD7: 2A1581   [16]     EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
0CDA: C1       [26]     	POP	BC		; Precedence value and operator
0CDB: 78       [30]     	LD	A,B		; Get precedence value
0CDC: FE78     [37]     	CP	78H		; "AND" or "OR" ?
0CDE: D4B90C   [47|54]  	CALL	NC,TSTNUM	; No - Make sure it's a number
0CE1: 7E       [54]     	LD	A,(HL)		; Get next operator / function
0CE2: 1600     [61]     	LD	D,0		; Clear Last relation
0CE4: D6B3     [ 7]     RLTLP:	SUB	ZGTR		; ">" Token
0CE6: DA000D   [17|17]  	JP	C,FOPRND	; + - * / ^ AND OR - Test it
0CE9: FE03     [24]     	CP	ZLTH+1-ZGTR	; < = >
0CEB: D2000D   [34|34]  	JP	NC,FOPRND	; Function - Call it
0CEE: FE01     [41]     	CP	ZEQUAL-ZGTR	; "="
0CF0: 17       [45]     	RLA			; <- Test for legal
0CF1: AA       [49]     	XOR	D		; <- combinations of < = >
0CF2: BA       [53]     	CP	D		; <- by combining last token
0CF3: 57       [57]     	LD	D,A		; <- with current one
0CF4: DAF103   [67|67]  	JP	C,SNERR		; Error if "<<' '==" or ">>"
0CF7: 220A81   [83]     	LD	(CUROPR),HL	; Save address of current token
0CFA: CD4908   [100]    	CALL	GETCHR		; Get next character
0CFD: C3E40C   [110]    	JP	RLTLP		; Treat the two as one
                        ;
0D00: 7A       [ 4]     FOPRND: LD	A,D		; < = > found ?
0D01: B7       [ 8]     	OR	A
0D02: C2270E   [18|18]  	JP	NZ,TSTRED	; Yes - Test for reduction
0D05: 7E       [25]     	LD	A,(HL)		; Get operator token
0D06: 220A81   [41]     	LD	(CUROPR),HL	; Save operator address
0D09: D6AC     [48]     	SUB	ZPLUS		; Operator or function?
0D0B: D8       [53|59]  	RET	C		; Neither - Exit
0D0C: FE07     [60]     	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
0D0E: D0       [65|71]  	RET	NC		; No - Exit
0D0F: 5F       [69]     	LD	E,A		; Coded operator
0D10: 3AF280   [82]     	LD	A,(TYPE)	; Get data type
0D13: 3D       [86]     	DEC	A		; FF = numeric , 00 = string
0D14: B3       [90]     	OR	E		; Combine with coded operator
0D15: 7B       [94]     	LD	A,E		; Get coded operator
0D16: CA8512   [104|104]	JP	Z,CONCAT	; String concatenation
0D19: 07       [108]    	RLCA			; Times 2
0D1A: 83       [112]    	ADD	A,E		; Times 3
0D1B: 5F       [116]    	LD	E,A		; To DE (D is 0)
0D1C: 21E302   [126]    	LD	HL,PRITAB	; Precedence table
0D1F: 19       [137]    	ADD	HL,DE		; To the operator concerned
0D20: 78       [141]    	LD	A,B		; Last operator precedence
0D21: 56       [148]    	LD	D,(HL)		; Get evaluation precedence
0D22: BA       [152]    	CP	D		; Compare with eval precedence
0D23: D0       [157|163]	RET	NC		; Exit if higher precedence
0D24: 23       [163]    	INC	HL		; Point to routine address
0D25: CDB90C   [180]    	CALL	TSTNUM		; Make sure it's a number
                        ;
0D28: C5       [11]     STKTHS: PUSH	BC		; Save last precedence & token
0D29: 01D70C   [21]     	LD	BC,EVAL3	; Where to go on prec' break
0D2C: C5       [32]     	PUSH	BC		; Save on stack for return
0D2D: 43       [36]     	LD	B,E		; Save operator
0D2E: 4A       [40]     	LD	C,D		; Save precedence
0D2F: CDC916   [57]     	CALL	STAKFP		; Move value to stack
0D32: 58       [61]     	LD	E,B		; Restore operator
0D33: 51       [65]     	LD	D,C		; Restore precedence
0D34: 4E       [72]     	LD	C,(HL)		; Get LSB of routine address
0D35: 23       [78]     	INC	HL
0D36: 46       [85]     	LD	B,(HL)		; Get MSB of routine address
0D37: 23       [91]     	INC	HL
0D38: C5       [102]    	PUSH	BC		; Save routine address
0D39: 2A0A81   [118]    	LD	HL,(CUROPR)	; Address of current operator
0D3C: C3CB0C   [128]    	JP	EVAL1		; Loop until prec' break
                        ;
0D3F: AF       [ 4]     OPRND:	XOR	A		; Get operand routine
0D40: 32F280   [17]     	LD	(TYPE),A	; Set numeric expected
0D43: CD4908   [34]     	CALL	GETCHR		; Get next character
0D46: 1E24     [41]     	LD	E,MO		; ?MO Error
0D48: CA0504   [51|51]  	JP	Z,ERROR		; No operand - Error
0D4B: DA9F17   [61|61]  	JP	C,ASCTFP	; Number - Get value
0D4E: CDE708   [78]     	CALL	CHKLTR		; See if a letter
0D51: D2A60D   [88|88]  	JP	NC,CONVAR	; Letter - Find variable
0D54: FE26     [95]     	CP	'&'		; &H = HEX, &B = BINARY
0D56: 2012     [102|107]	JR	NZ, NOTAMP
0D58: CD4908   [119]    	CALL	GETCHR		; Get next character
0D5B: FE48     [126]    	CP	'H'		; Hex number indicated? [function added]
0D5D: CAE31B   [136|136]	JP	Z,HEXTFP	; Convert Hex to FPREG
0D60: FE42     [143]    	CP	'B'		; Binary number indicated? [function added]
0D62: CA531C   [153|153]	JP	Z,BINTFP	; Convert Bin to FPREG
0D65: 1E02     [160]    	LD	E,SN		; If neither then a ?SN Error
0D67: CA0504   [170|170]	JP	Z,ERROR
0D6A: FEAC     [ 7]     NOTAMP: CP	ZPLUS		; '+' Token ?
0D6C: CA3F0D   [17|17]  	JP	Z,OPRND		; Yes - Look for operand
0D6F: FE2E     [24]     	CP	'.'		; '.' ?
0D71: CA9F17   [34|34]  	JP	Z,ASCTFP	; Yes - Create FP number
0D74: FEAD     [41]     	CP	ZMINUS		; '-' Token ?
0D76: CA950D   [51|51]  	JP	Z,MINUS		; Yes - Do minus
0D79: FE22     [58]     	CP	'"'		; Literal string ?
0D7B: CA4E11   [68|68]  	JP	Z,QTSTR		; Get string terminated by '"'
0D7E: FEAA     [75]     	CP	ZNOT		; "NOT" Token ?
0D80: CA870E   [85|85]  	JP	Z,EVNOT		; Yes - Eval NOT expression
0D83: FEA7     [92]     	CP	ZFN		; "FN" Token ?
0D85: CAB210   [102|102]	JP	Z,DOFN		; Yes - Do FN routine
0D88: D6B6     [109]    	SUB	ZSGN		; Is it a function?
0D8A: D2B70D   [119|119]	JP	NC,FNOFST	; Yes - Evaluate function
0D8D: CDC40C   [17]     EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
0D90: CDBF06   [34]     	CALL	CHKSYN		; Make sure ")" follows
0D93: 29                	DB	")"
0D94: C9       [44]     	RET
                        ;
0D95: 167D     [ 7]     MINUS:	LD	D,7DH		; '-' precedence
0D97: CDCB0C   [24]     	CALL	EVAL1		; Evaluate until prec' break
0D9A: 2A1581   [40]     	LD	HL,(NXTOPR)	; Get next operator address
0D9D: E5       [51]     	PUSH	HL		; Save next operator address
0D9E: CDC116   [68]     	CALL	INVSGN		; Negate value
0DA1: CDB90C   [17]     RETNUM: CALL	TSTNUM		; Make sure it's a number
0DA4: E1       [27]     	POP	HL		; Restore next operator address
0DA5: C9       [37]     	RET
                        ;
0DA6: CDAC0E   [17]     CONVAR: CALL	GETVAR		; Get variable address to DE
0DA9: E5       [11]     FRMEVL: PUSH	HL		; Save code string address
0DAA: EB       [15]     	EX	DE,HL		; Variable address to HL
0DAB: 222981   [31]     	LD	(FPREG),HL	; Save address of variable
0DAE: 3AF280   [44]     	LD	A,(TYPE)	; Get type
0DB1: B7       [48]     	OR	A		; Numeric?
0DB2: CCD616   [58|65]  	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
0DB5: E1       [68]     	POP	HL		; Restore code string address
0DB6: C9       [78]     	RET
                        ;
0DB7: 0600     [ 7]     FNOFST: LD	B,0		; Get address of function
0DB9: 07       [11]     	RLCA			; Double function offset
0DBA: 4F       [15]     	LD	C,A		; BC = Offset in function table
0DBB: C5       [26]     	PUSH	BC		; Save adjusted token value
0DBC: CD4908   [43]     	CALL	GETCHR		; Get next character
0DBF: 79       [47]     	LD	A,C		; Get adjusted token value
0DC0: FE31     [54]     	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
0DC2: DADE0D   [64|64]  	JP	C,FNVAL		; No - Do function
0DC5: CDC40C   [81]     	CALL	OPNPAR		; Evaluate expression	(X,...
0DC8: CDBF06   [98]     	CALL	CHKSYN		; Make sure ',' follows
0DCB: 2C                	DB	','
0DCC: CDBA0C   [115]    	CALL	TSTSTR		; Make sure it's a string
0DCF: EB       [119]    	EX	DE,HL		; Save code string address
0DD0: 2A2981   [135]    	LD	HL,(FPREG)	; Get address of string
0DD3: E3       [154]    	EX	(SP),HL		; Save address of string
0DD4: E5       [165]    	PUSH	HL		; Save adjusted token value
0DD5: EB       [169]    	EX	DE,HL		; Restore code string address
0DD6: CD1714   [186]    	CALL	GETINT		; Get integer 0-255
0DD9: EB       [190]    	EX	DE,HL		; Save code string address
0DDA: E3       [209]    	EX	(SP),HL		; Save integer,HL = adj' token
0DDB: C3E60D   [219]    	JP	GOFUNC		; Jump to string function
                        ;
0DDE: CD8D0D   [17]     FNVAL:	CALL	EVLPAR		; Evaluate expression
0DE1: E3       [36]     	EX	(SP),HL		; HL = Adjusted token value
0DE2: 11A10D   [46]     	LD	DE,RETNUM	; Return number from function
0DE5: D5       [57]     	PUSH	DE		; Save on stack
0DE6: 014201   [10]     GOFUNC: LD	BC,FNCTAB	; Function routine addresses
0DE9: 09       [21]     	ADD	HL,BC		; Point to right address
0DEA: 4E       [28]     	LD	C,(HL)		; Get LSB of address
0DEB: 23       [34]     	INC	HL		;
0DEC: 66       [41]     	LD	H,(HL)		; Get MSB of address
0DED: 69       [45]     	LD	L,C		; Address to HL
0DEE: E9       [49]     	JP	(HL)		; Jump to function
                        ;
0DEF: 15       [ 4]     SGNEXP: DEC	D		; Dee to flag negative exponent
0DF0: FEAD     [11]     	CP	ZMINUS		; '-' token ?
0DF2: C8       [16|22]  	RET	Z		; Yes - Return
0DF3: FE2D     [23]     	CP	'-'		; '-' ASCII ?
0DF5: C8       [28|34]  	RET	Z		; Yes - Return
0DF6: 14       [32]     	INC	D		; Inc to flag positive exponent
0DF7: FE2B     [39]     	CP	'+'		; '+' ASCII ?
0DF9: C8       [44|50]  	RET	Z		; Yes - Return
0DFA: FEAC     [51]     	CP	ZPLUS		; '+' token ?
0DFC: C8       [56|62]  	RET	Z		; Yes - Return
0DFD: 2B       [62]     	DEC	HL		; DEC 'cos GETCHR INCs
0DFE: C9       [72]     	RET			; Return "NZ"
                        ;
0DFF: F6                POR:	DB	0F6H		; Flag "OR"
0E00: AF       [ 4]     PAND:	XOR	A		; Flag "AND"
0E01: F5       [15]     	PUSH	AF		; Save "AND" / "OR" flag
0E02: CDB90C   [32]     	CALL	TSTNUM		; Make sure it's a number
0E05: CDFB08   [49]     	CALL	DEINT		; Get integer -32768 to 32767
0E08: F1       [59]     	POP	AF		; Restore "AND" / "OR" flag
0E09: EB       [63]     	EX	DE,HL		; <- Get last
0E0A: C1       [73]     	POP	BC		; <- value
0E0B: E3       [92]     	EX	(SP),HL		; <- from
0E0C: EB       [96]     	EX	DE,HL		; <- stack
0E0D: CDD916   [113]    	CALL	FPBCDE		; Move last value to FPREG
0E10: F5       [124]    	PUSH	AF		; Save "AND" / "OR" flag
0E11: CDFB08   [141]    	CALL	DEINT		; Get integer -32768 to 32767
0E14: F1       [151]    	POP	AF		; Restore "AND" / "OR" flag
0E15: C1       [161]    	POP	BC		; Get value
0E16: 79       [165]    	LD	A,C		; Get LSB
0E17: 217010   [175]    	LD	HL,ACPASS	; Address of save AC as current
0E1A: C2220E   [185|185]	JP	NZ,POR1		; Jump if OR
0E1D: A3       [189]    	AND	E		; "AND" LSBs
0E1E: 4F       [193]    	LD	C,A		; Save LSB
0E1F: 78       [197]    	LD	A,B		; Get MBS
0E20: A2       [201]    	AND	D		; "AND" MSBs
0E21: E9       [205]    	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E22: B3       [ 4]     POR1:	OR	E		; "OR" LSBs
0E23: 4F       [ 8]     	LD	C,A		; Save LSB
0E24: 78       [12]     	LD	A,B		; Get MSB
0E25: B2       [16]     	OR	D		; "OR" MSBs
0E26: E9       [20]     	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E27: 21390E   [10]     TSTRED: LD	HL,CMPLOG	; Logical compare routine
0E2A: 3AF280   [23]     	LD	A,(TYPE)	; Get data type
0E2D: 1F       [27]     	RRA			; Carry set = string
0E2E: 7A       [31]     	LD	A,D		; Get last precedence value
0E2F: 17       [35]     	RLA			; Times 2 plus carry
0E30: 5F       [39]     	LD	E,A		; To E
0E31: 1664     [46]     	LD	D,64H		; Relational precedence
0E33: 78       [50]     	LD	A,B		; Get current precedence
0E34: BA       [54]     	CP	D		; Compare with last
0E35: D0       [59|65]  	RET	NC		; Eval if last was rel' or log'
0E36: C3280D   [69]     	JP	STKTHS		; Stack this one and get next
                        ;
0E39: 3B0E              CMPLOG: DW	CMPLG1		; Compare two values / strings
0E3B: 79       [ 4]     CMPLG1: LD	A,C		; Get data type
0E3C: B7       [ 8]     	OR	A
0E3D: 1F       [12]     	RRA
0E3E: C1       [22]     	POP	BC		; Get last expression to BCDE
0E3F: D1       [32]     	POP	DE
0E40: F5       [43]     	PUSH	AF		; Save status
0E41: CDBB0C   [60]     	CALL	CHKTYP		; Check that types match
0E44: 217D0E   [70]     	LD	HL,CMPRES	; Result to comparison
0E47: E5       [81]     	PUSH	HL		; Save for RETurn
0E48: CA1317   [91|91]  	JP	Z,CMPNUM	; Compare values if numeric
0E4B: AF       [95]     	XOR	A		; Compare two strings
0E4C: 32F280   [108]    	LD	(TYPE),A	; Set type to numeric
0E4F: D5       [119]    	PUSH	DE		; Save string name
0E50: CDD212   [136]    	CALL	GSTRCU		; Get current string
0E53: 7E       [143]    	LD	A,(HL)		; Get length of string
0E54: 23       [149]    	INC	HL
0E55: 23       [155]    	INC	HL
0E56: 4E       [162]    	LD	C,(HL)		; Get LSB of address
0E57: 23       [168]    	INC	HL
0E58: 46       [175]    	LD	B,(HL)		; Get MSB of address
0E59: D1       [185]    	POP	DE		; Restore string name
0E5A: C5       [196]    	PUSH	BC		; Save address of string
0E5B: F5       [207]    	PUSH	AF		; Save length of string
0E5C: CDD612   [224]    	CALL	GSTRDE		; Get second string
0E5F: CDE716   [241]    	CALL	LOADFP		; Get address of second string
0E62: F1       [251]    	POP	AF		; Restore length of string 1
0E63: 57       [255]    	LD	D,A		; Length to D
0E64: E1       [265]    	POP	HL		; Restore address of string 1
0E65: 7B       [ 4]     CMPSTR: LD	A,E		; Bytes of string 2 to do
0E66: B2       [ 8]     	OR	D		; Bytes of string 1 to do
0E67: C8       [13|19]  	RET	Z		; Exit if all bytes compared
0E68: 7A       [17]     	LD	A,D		; Get bytes of string 1 to do
0E69: D601     [24]     	SUB	1
0E6B: D8       [29|35]  	RET	C		; Exit if end of string 1
0E6C: AF       [33]     	XOR	A
0E6D: BB       [37]     	CP	E		; Bytes of string 2 to do
0E6E: 3C       [41]     	INC	A
0E6F: D0       [46|52]  	RET	NC		; Exit if end of string 2
0E70: 15       [50]     	DEC	D		; Count bytes in string 1
0E71: 1D       [54]     	DEC	E		; Count bytes in string 2
0E72: 0A       [61]     	LD	A,(BC)		; Byte in string 2
0E73: BE       [68]     	CP	(HL)		; Compare to byte in string 1
0E74: 23       [74]     	INC	HL		; Move up string 1
0E75: 03       [80]     	INC	BC		; Move up string 2
0E76: CA650E   [90|90]  	JP	Z,CMPSTR	; Same - Try next bytes
0E79: 3F       [94]     	CCF			; Flag difference (">" or "<")
0E7A: C3A316   [104]    	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                        ;
0E7D: 3C       [ 4]     CMPRES: INC	A		; Increment current value
0E7E: 8F       [ 8]     	ADC	A,A		; Double plus carry
0E7F: C1       [18]     	POP	BC		; Get other value
0E80: A0       [22]     	AND	B		; Combine them
0E81: C6FF     [29]     	ADD	A,-1		; Carry set if different
0E83: 9F       [33]     	SBC	A,A		; 00 - Equal , FF - Different
0E84: C3AA16   [43]     	JP	FLGREL		; Set current value & continue
                        ;
0E87: 165A     [ 7]     EVNOT:	LD	D,5AH		; Precedence value for "NOT"
0E89: CDCB0C   [24]     	CALL	EVAL1		; Eval until precedence break
0E8C: CDB90C   [41]     	CALL	TSTNUM		; Make sure it's a number
0E8F: CDFB08   [58]     	CALL	DEINT		; Get integer -32768 - 32767
0E92: 7B       [62]     	LD	A,E		; Get LSB
0E93: 2F       [66]     	CPL			; Invert LSB
0E94: 4F       [70]     	LD	C,A		; Save "NOT" of LSB
0E95: 7A       [74]     	LD	A,D		; Get MSB
0E96: 2F       [78]     	CPL			; Invert MSB
0E97: CD7010   [95]     	CALL	ACPASS		; Save AC as current
0E9A: C1       [105]    	POP	BC		; Clean up stack
0E9B: C3D70C   [115]    	JP	EVAL3		; Continue evaluation
                        ;
0E9E: 2B       [ 6]     DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
0E9F: CD4908   [23]     	CALL	GETCHR		; Get next character
0EA2: C8       [28|34]  	RET	Z		; End of DIM statement
0EA3: CDBF06   [45]     	CALL	CHKSYN		; Make sure ',' follows
0EA6: 2C                	DB	','
0EA7: 019E0E   [10]     DIM:	LD	BC,DIMRET	; Return to "DIMRET"
0EAA: C5       [21]     	PUSH	BC		; Save on stack
0EAB: F6                	DB	0F6H		; Flag "Create" variable
0EAC: AF       [ 4]     GETVAR: XOR	A		; Find variable address,to DE
0EAD: 32F180   [17]     	LD	(LCRFLG),A	; Set locate / create flag
0EB0: 46       [24]     	LD	B,(HL)		; Get First byte of name
0EB1: CDE708   [17]     GTFNAM: CALL	CHKLTR		; See if a letter
0EB4: DAF103   [27|27]  	JP	C,SNERR		; ?SN Error if not a letter
0EB7: AF       [31]     	XOR	A
0EB8: 4F       [35]     	LD	C,A		; Clear second byte of name
0EB9: 32F280   [48]     	LD	(TYPE),A	; Set type to numeric
0EBC: CD4908   [65]     	CALL	GETCHR		; Get next character
0EBF: DAC80E   [75|75]  	JP	C,SVNAM2	; Numeric - Save in name
0EC2: CDE708   [92]     	CALL	CHKLTR		; See if a letter
0EC5: DAD50E   [102|102]	JP	C,CHARTY	; Not a letter - Check type
0EC8: 4F       [ 4]     SVNAM2: LD	C,A		; Save second byte of name
0EC9: CD4908   [17]     ENDNAM: CALL	GETCHR		; Get next character
0ECC: DAC90E   [27|27]  	JP	C,ENDNAM	; Numeric - Get another
0ECF: CDE708   [44]     	CALL	CHKLTR		; See if a letter
0ED2: D2C90E   [54|54]  	JP	NC,ENDNAM	; Letter - Get another
0ED5: D624     [ 7]     CHARTY: SUB	'$'		; String variable?
0ED7: C2E40E   [17|17]  	JP	NZ,NOTSTR	; No - Numeric variable
0EDA: 3C       [21]     	INC	A		; A = 1 (string type)
0EDB: 32F280   [34]     	LD	(TYPE),A	; Set type to string
0EDE: 0F       [38]     	RRCA			; A = 80H , Flag for string
0EDF: 81       [42]     	ADD	A,C		; 2nd byte of name has bit 7 on
0EE0: 4F       [46]     	LD	C,A		; Resave second byte on name
0EE1: CD4908   [63]     	CALL	GETCHR		; Get next character
0EE4: 3A1081   [13]     NOTSTR: LD	A,(FORFLG)	; Array name needed ?
0EE7: 3D       [17]     	DEC	A
0EE8: CA910F   [27|27]  	JP	Z,ARLDSV	; Yes - Get array name
0EEB: F2F40E   [37|37]  	JP	P,NSCFOR	; No array with "FOR" or "FN"
0EEE: 7E       [44]     	LD	A,(HL)		; Get byte again
0EEF: D628     [51]     	SUB	'('		; Subscripted variable?
0EF1: CA690F   [61|61]  	JP	Z,SBSCPT	; Yes - Sort out subscript
                        ;
0EF4: AF       [ 4]     NSCFOR: XOR	A		; Simple variable
0EF5: 321081   [17]     	LD	(FORFLG),A	; Clear "FOR" flag
0EF8: E5       [28]     	PUSH	HL		; Save code string address
0EF9: 50       [32]     	LD	D,B		; DE = Variable name to find
0EFA: 59       [36]     	LD	E,C
0EFB: 2A2381   [52]     	LD	HL,(FNRGNM)	; FN argument name
0EFE: CDB906   [69]     	CALL	CPDEHL		; Is it the FN argument?
0F01: 112581   [79]     	LD	DE,FNARG	; Point to argument value
0F04: CAD915   [89|89]  	JP	Z,POPHRT	; Yes - Return FN argument value
0F07: 2A1D81   [105]    	LD	HL,(VAREND)	; End of variables
0F0A: EB       [109]    	EX	DE,HL		; Address of end of search
0F0B: 2A1B81   [125]    	LD	HL,(PROGND)	; Start of variables address
0F0E: CDB906   [17]     FNDVAR: CALL	CPDEHL		; End of variable list table?
0F11: CA270F   [27|27]  	JP	Z,CFEVAL	; Yes - Called from EVAL?
0F14: 79       [31]     	LD	A,C		; Get second byte of name
0F15: 96       [38]     	SUB	(HL)		; Compare with name in list
0F16: 23       [44]     	INC	HL		; Move on to first byte
0F17: C21C0F   [54|54]  	JP	NZ,FNTHR	; Different - Find another
0F1A: 78       [58]     	LD	A,B		; Get first byte of name
0F1B: 96       [65]     	SUB	(HL)		; Compare with name in list
0F1C: 23       [ 6]     FNTHR:	INC	HL		; Move on to LSB of value
0F1D: CA5B0F   [16|16]  	JP	Z,RETADR	; Found - Return address
0F20: 23       [22]     	INC	HL		; <- Skip
0F21: 23       [28]     	INC	HL		; <- over
0F22: 23       [34]     	INC	HL		; <- F.P.
0F23: 23       [40]     	INC	HL		; <- value
0F24: C30E0F   [50]     	JP	FNDVAR		; Keep looking
                        ;
0F27: E1       [10]     CFEVAL: POP	HL		; Restore code string address
0F28: E3       [29]     	EX	(SP),HL		; Get return address
0F29: D5       [40]     	PUSH	DE		; Save address of variable
0F2A: 11A90D   [50]     	LD	DE,FRMEVL	; Return address in EVAL
0F2D: CDB906   [67]     	CALL	CPDEHL		; Called from EVAL ?
0F30: D1       [77]     	POP	DE		; Restore address of variable
0F31: CA5E0F   [87|87]  	JP	Z,RETNUL	; Yes - Return null variable
0F34: E3       [106]    	EX	(SP),HL		; Put back return
0F35: E5       [117]    	PUSH	HL		; Save code string address
0F36: C5       [128]    	PUSH	BC		; Save variable name
0F37: 010600   [138]    	LD	BC,6		; 2 byte name plus 4 byte data
0F3A: 2A1F81   [154]    	LD	HL,(ARREND)	; End of arrays
0F3D: E5       [165]    	PUSH	HL		; Save end of arrays
0F3E: 09       [176]    	ADD	HL,BC		; Move up 6 bytes
0F3F: C1       [186]    	POP	BC		; Source address in BC
0F40: E5       [197]    	PUSH	HL		; Save new end address
0F41: CDBD03   [214]    	CALL	MOVUP		; Move arrays up
0F44: E1       [224]    	POP	HL		; Restore new end address
0F45: 221F81   [240]    	LD	(ARREND),HL	; Set new end address
0F48: 60       [244]    	LD	H,B		; End of variables to HL
0F49: 69       [248]    	LD	L,C
0F4A: 221D81   [264]    	LD	(VAREND),HL	; Set new end address
                        ;
0F4D: 2B       [ 6]     ZEROLP: DEC	HL		; Back through to zero variable
0F4E: 3600     [16]     	LD	(HL),0		; Zero byte in variable
0F50: CDB906   [33]     	CALL	CPDEHL		; Done them all?
0F53: C24D0F   [43|43]  	JP	NZ,ZEROLP	; No - Keep on going
0F56: D1       [53]     	POP	DE		; Get variable name
0F57: 73       [60]     	LD	(HL),E		; Store second character
0F58: 23       [66]     	INC	HL
0F59: 72       [73]     	LD	(HL),D		; Store first character
0F5A: 23       [79]     	INC	HL
0F5B: EB       [ 4]     RETADR: EX	DE,HL		; Address of variable in DE
0F5C: E1       [14]     	POP	HL		; Restore code string address
0F5D: C9       [24]     	RET
                        ;
0F5E: 322C81   [13]     RETNUL: LD	(FPEXP),A	; Set result to zero
0F61: 218D03   [23]     	LD	HL,ZERBYT	; Also set a null string
0F64: 222981   [39]     	LD	(FPREG),HL	; Save for EVAL
0F67: E1       [49]     	POP	HL		; Restore code string address
0F68: C9       [59]     	RET
                        ;
0F69: E5       [11]     SBSCPT: PUSH	HL		; Save code string address
0F6A: 2AF180   [27]     	LD	HL,(LCRFLG)	; Locate/Create and Type
0F6D: E3       [46]     	EX	(SP),HL		; Save and get code string
0F6E: 57       [50]     	LD	D,A		; Zero number of dimensions
0F6F: D5       [11]     SCPTLP: PUSH	DE		; Save number of dimensions
0F70: C5       [22]     	PUSH	BC		; Save array name
0F71: CDEF08   [39]     	CALL	FPSINT		; Get subscript (0-32767)
0F74: C1       [49]     	POP	BC		; Restore array name
0F75: F1       [59]     	POP	AF		; Get number of dimensions
0F76: EB       [63]     	EX	DE,HL
0F77: E3       [82]     	EX	(SP),HL		; Save subscript value
0F78: E5       [93]     	PUSH	HL		; Save LCRFLG and TYPE
0F79: EB       [97]     	EX	DE,HL
0F7A: 3C       [101]    	INC	A		; Count dimensions
0F7B: 57       [105]    	LD	D,A		; Save in D
0F7C: 7E       [112]    	LD	A,(HL)		; Get next byte in code string
0F7D: FE2C     [119]    	CP	','		; Comma (more to come)?
0F7F: CA6F0F   [129|129]	JP	Z,SCPTLP	; Yes - More subscripts
0F82: CDBF06   [146]    	CALL	CHKSYN		; Make sure ")" follows
0F85: 29                	DB	")"
0F86: 221581   [162]    	LD	(NXTOPR),HL	; Save code string address
0F89: E1       [172]    	POP	HL		; Get LCRFLG and TYPE
0F8A: 22F180   [188]    	LD	(LCRFLG),HL	; Restore Locate/create & type
0F8D: 1E00     [195]    	LD	E,0		; Flag not CSAVE* or CLOAD*
0F8F: D5       [206]    	PUSH	DE		; Save number of dimensions (D)
0F90: 11                	DB	11H		; Skip "PUSH HL" and "PUSH AF'
                        ;
0F91: E5       [11]     ARLDSV: PUSH	HL		; Save code string address
0F92: F5       [22]     	PUSH	AF		; A = 00 , Flags set = Z,N
0F93: 2A1D81   [38]     	LD	HL,(VAREND)	; Start of arrays
0F96: 3E                	DB	3EH		; Skip "ADD HL,DE"
0F97: 19       [11]     FNDARY: ADD	HL,DE		; Move to next array start
0F98: EB       [15]     	EX	DE,HL
0F99: 2A1F81   [31]     	LD	HL,(ARREND)	; End of arrays
0F9C: EB       [35]     	EX	DE,HL		; Current array pointer
0F9D: CDB906   [52]     	CALL	CPDEHL		; End of arrays found?
0FA0: CAC90F   [62|62]  	JP	Z,CREARY	; Yes - Create array
0FA3: 7E       [69]     	LD	A,(HL)		; Get second byte of name
0FA4: B9       [73]     	CP	C		; Compare with name given
0FA5: 23       [79]     	INC	HL		; Move on
0FA6: C2AB0F   [89|89]  	JP	NZ,NXTARY	; Different - Find next array
0FA9: 7E       [96]     	LD	A,(HL)		; Get first byte of name
0FAA: B8       [100]    	CP	B		; Compare with name given
0FAB: 23       [ 6]     NXTARY: INC	HL		; Move on
0FAC: 5E       [13]     	LD	E,(HL)		; Get LSB of next array address
0FAD: 23       [19]     	INC	HL
0FAE: 56       [26]     	LD	D,(HL)		; Get MSB of next array address
0FAF: 23       [32]     	INC	HL
0FB0: C2970F   [42|42]  	JP	NZ,FNDARY	; Not found - Keep looking
0FB3: 3AF180   [55]     	LD	A,(LCRFLG)	; Found Locate or Create it?
0FB6: B7       [59]     	OR	A
0FB7: C2FA03   [69|69]  	JP	NZ,DDERR	; Create - ?DD Error
0FBA: F1       [79]     	POP	AF		; Locate - Get number of dim'ns
0FBB: 44       [83]     	LD	B,H		; BC Points to array dim'ns
0FBC: 4D       [87]     	LD	C,L
0FBD: CAD915   [97|97]  	JP	Z,POPHRT	; Jump if array load/save
0FC0: 96       [104]    	SUB	(HL)		; Same number of dimensions?
0FC1: CA2710   [114|114]	JP	Z,FINDEL	; Yes - Find element
0FC4: 1E10     [ 7]     BSERR:	LD	E,BS		; ?BS Error
0FC6: C30504   [17]     	JP	ERROR		; Output error
                        ;
0FC9: 110400   [10]     CREARY: LD	DE,4		; 4 Bytes per entry
0FCC: F1       [20]     	POP	AF		; Array to save or 0 dim'ns?
0FCD: CA1009   [30|30]  	JP	Z,FCERR		; Yes - ?FC Error
0FD0: 71       [37]     	LD	(HL),C		; Save second byte of name
0FD1: 23       [43]     	INC	HL
0FD2: 70       [50]     	LD	(HL),B		; Save first byte of name
0FD3: 23       [56]     	INC	HL
0FD4: 4F       [60]     	LD	C,A		; Number of dimensions to C
0FD5: CDCE03   [77]     	CALL	CHKSTK		; Check if enough memory
0FD8: 23       [83]     	INC	HL		; Point to number of dimensions
0FD9: 23       [89]     	INC	HL
0FDA: 220A81   [105]    	LD	(CUROPR),HL	; Save address of pointer
0FDD: 71       [112]    	LD	(HL),C		; Set number of dimensions
0FDE: 23       [118]    	INC	HL
0FDF: 3AF180   [131]    	LD	A,(LCRFLG)	; Locate of Create?
0FE2: 17       [135]    	RLA			; Carry set = Create
0FE3: 79       [139]    	LD	A,C		; Get number of dimensions
0FE4: 010B00   [10]     CRARLP: LD	BC,10+1		; Default dimension size 10
0FE7: D2EC0F   [20|20]  	JP	NC,DEFSIZ	; Locate - Set default size
0FEA: C1       [30]     	POP	BC		; Get specified dimension size
0FEB: 03       [36]     	INC	BC		; Include zero element
0FEC: 71       [ 7]     DEFSIZ: LD	(HL),C		; Save LSB of dimension size
0FED: 23       [13]     	INC	HL
0FEE: 70       [20]     	LD	(HL),B		; Save MSB of dimension size
0FEF: 23       [26]     	INC	HL
0FF0: F5       [37]     	PUSH	AF		; Save num' of dim'ns an status
0FF1: E5       [48]     	PUSH	HL		; Save address of dim'n size
0FF2: CD8417   [65]     	CALL	MLDEBC		; Multiply DE by BC to find
0FF5: EB       [69]     	EX	DE,HL		; amount of mem needed (to DE)
0FF6: E1       [79]     	POP	HL		; Restore address of dimension
0FF7: F1       [89]     	POP	AF		; Restore number of dimensions
0FF8: 3D       [93]     	DEC	A		; Count them
0FF9: C2E40F   [103|103]	JP	NZ,CRARLP	; Do next dimension if more
0FFC: F5       [114]    	PUSH	AF		; Save locate/create flag
0FFD: 42       [118]    	LD	B,D		; MSB of memory needed
0FFE: 4B       [122]    	LD	C,E		; LSB of memory needed
0FFF: EB       [126]    	EX	DE,HL
1000: 19       [137]    	ADD	HL,DE		; Add bytes to array start
1001: DAE603   [147|147]	JP	C,OMERR		; Too big - Error
1004: CDD703   [164]    	CALL	ENFMEM		; See if enough memory
1007: 221F81   [180]    	LD	(ARREND),HL	; Save new end of array
                        ;
100A: 2B       [ 6]     ZERARY: DEC	HL		; Back through array data
100B: 3600     [16]     	LD	(HL),0		; Set array element to zero
100D: CDB906   [33]     	CALL	CPDEHL		; All elements zeroed?
1010: C20A10   [43|43]  	JP	NZ,ZERARY	; No - Keep on going
1013: 03       [49]     	INC	BC		; Number of bytes + 1
1014: 57       [53]     	LD	D,A		; A=0
1015: 2A0A81   [69]     	LD	HL,(CUROPR)	; Get address of array
1018: 5E       [76]     	LD	E,(HL)		; Number of dimensions
1019: EB       [80]     	EX	DE,HL		; To HL
101A: 29       [91]     	ADD	HL,HL		; Two bytes per dimension size
101B: 09       [102]    	ADD	HL,BC		; Add number of bytes
101C: EB       [106]    	EX	DE,HL		; Bytes needed to DE
101D: 2B       [112]    	DEC	HL
101E: 2B       [118]    	DEC	HL
101F: 73       [125]    	LD	(HL),E		; Save LSB of bytes needed
1020: 23       [131]    	INC	HL
1021: 72       [138]    	LD	(HL),D		; Save MSB of bytes needed
1022: 23       [144]    	INC	HL
1023: F1       [154]    	POP	AF		; Locate / Create?
1024: DA4B10   [164|164]	JP	C,ENDDIM	; A is 0 , End if create
1027: 47       [ 4]     FINDEL: LD	B,A		; Find array element
1028: 4F       [ 8]     	LD	C,A
1029: 7E       [15]     	LD	A,(HL)		; Number of dimensions
102A: 23       [21]     	INC	HL
102B: 16                	DB	16H		; Skip "POP HL"
102C: E1       [10]     FNDELP: POP	HL		; Address of next dim' size
102D: 5E       [17]     	LD	E,(HL)		; Get LSB of dim'n size
102E: 23       [23]     	INC	HL
102F: 56       [30]     	LD	D,(HL)		; Get MSB of dim'n size
1030: 23       [36]     	INC	HL
1031: E3       [55]     	EX	(SP),HL		; Save address - Get index
1032: F5       [66]     	PUSH	AF		; Save number of dim'ns
1033: CDB906   [83]     	CALL	CPDEHL		; Dimension too large?
1036: D2C40F   [93|93]  	JP	NC,BSERR	; Yes - ?BS Error
1039: E5       [104]    	PUSH	HL		; Save index
103A: CD8417   [121]    	CALL	MLDEBC		; Multiply previous by size
103D: D1       [131]    	POP	DE		; Index supplied to DE
103E: 19       [142]    	ADD	HL,DE		; Add index to pointer
103F: F1       [152]    	POP	AF		; Number of dimensions
1040: 3D       [156]    	DEC	A		; Count them
1041: 44       [160]    	LD	B,H		; MSB of pointer
1042: 4D       [164]    	LD	C,L		; LSB of pointer
1043: C22C10   [174|174]	JP	NZ,FNDELP	; More - Keep going
1046: 29       [185]    	ADD	HL,HL		; 4 Bytes per element
1047: 29       [196]    	ADD	HL,HL
1048: C1       [206]    	POP	BC		; Start of array
1049: 09       [217]    	ADD	HL,BC		; Point to element
104A: EB       [221]    	EX	DE,HL		; Address of element to DE
104B: 2A1581   [16]     ENDDIM: LD	HL,(NXTOPR)	; Got code string address
104E: C9       [26]     	RET
                        ;
104F: 2A1F81   [16]     FRE:	LD	HL,(ARREND)	; Start of free memory
1052: EB       [20]     	EX	DE,HL		; To DE
1053: 210000   [30]     	LD	HL,0		; End of free memory
1056: 39       [41]     	ADD	HL,SP		; Current stack value
1057: 3AF280   [54]     	LD	A,(TYPE)	; Dummy argument type
105A: B7       [58]     	OR	A
105B: CA6B10   [68|68]  	JP	Z,FRENUM	; Numeric - Free variable space
105E: CDD212   [85]     	CALL	GSTRCU		; Current string to pool
1061: CDD211   [102]    	CALL	GARBGE		; Garbage collection
1064: 2A9F80   [118]    	LD	HL,(STRSPC)	; Bottom of string space in use
1067: EB       [122]    	EX	DE,HL		; To DE
1068: 2A0881   [138]    	LD	HL,(STRBOT)	; Bottom of string space
106B: 7D       [ 4]     FRENUM: LD	A,L		; Get LSB of end
106C: 93       [ 8]     	SUB	E		; Subtract LSB of beginning
106D: 4F       [12]     	LD	C,A		; Save difference if C
106E: 7C       [16]     	LD	A,H		; Get MSB of end
106F: 9A       [20]     	SBC	A,D		; Subtract MSB of beginning
1070: 41       [ 4]     ACPASS: LD	B,C		; Return integer AC
1071: 50       [ 4]     ABPASS: LD	D,B		; Return integer AB
1072: 1E00     [11]     	LD	E,0
1074: 21F280   [21]     	LD	HL,TYPE		; Point to type
1077: 73       [28]     	LD	(HL),E		; Set type to numeric
1078: 0690     [35]     	LD	B,80H+16	; 16 bit integer
107A: C3AF16   [45]     	JP	RETINT		; Return the integr
                        ;
107D: 3AF080   [13]     POS:	LD	A,(CURPOS)	; Get cursor position
1080: 47       [ 4]     PASSA:	LD	B,A		; Put A into AB
1081: AF       [ 8]     	XOR	A		; Zero A
1082: C37110   [18]     	JP	ABPASS		; Return integer AB
                        ;
1085: CD0811   [17]     DEF:	CALL	CHEKFN		; Get "FN" and name
1088: CDFA10   [34]     	CALL	IDTEST		; Test for illegal direct
108B: 01E009   [44]     	LD	BC,DATA		; To get next statement
108E: C5       [55]     	PUSH	BC		; Save address for RETurn
108F: D5       [66]     	PUSH	DE		; Save address of function ptr
1090: CDBF06   [83]     	CALL	CHKSYN		; Make sure "(" follows
1093: 28                	DB	"("
1094: CDAC0E   [100]    	CALL	GETVAR		; Get argument variable name
1097: E5       [111]    	PUSH	HL		; Save code string address
1098: EB       [115]    	EX	DE,HL		; Argument address to HL
1099: 2B       [121]    	DEC	HL
109A: 56       [128]    	LD	D,(HL)		; Get first byte of arg name
109B: 2B       [134]    	DEC	HL
109C: 5E       [141]    	LD	E,(HL)		; Get second byte of arg name
109D: E1       [151]    	POP	HL		; Restore code string address
109E: CDB90C   [168]    	CALL	TSTNUM		; Make sure numeric argument
10A1: CDBF06   [185]    	CALL	CHKSYN		; Make sure ")" follows
10A4: 29                	DB	")"
10A5: CDBF06   [202]    	CALL	CHKSYN		; Make sure "=" follows
10A8: B4                	DB	ZEQUAL		; "=" token
10A9: 44       [206]    	LD	B,H		; Code string address to BC
10AA: 4D       [210]    	LD	C,L
10AB: E3       [229]    	EX	(SP),HL		; Save code str , Get FN ptr
10AC: 71       [236]    	LD	(HL),C		; Save LSB of FN code string
10AD: 23       [242]    	INC	HL
10AE: 70       [249]    	LD	(HL),B		; Save MSB of FN code string
10AF: C34711   [259]    	JP	SVSTAD		; Save address and do function
                        ;
10B2: CD0811   [17]     DOFN:	CALL	CHEKFN		; Make sure FN follows
10B5: D5       [28]     	PUSH	DE		; Save function pointer address
10B6: CD8D0D   [45]     	CALL	EVLPAR		; Evaluate expression in "()"
10B9: CDB90C   [62]     	CALL	TSTNUM		; Make sure numeric result
10BC: E3       [81]     	EX	(SP),HL		; Save code str , Get FN ptr
10BD: 5E       [88]     	LD	E,(HL)		; Get LSB of FN code string
10BE: 23       [94]     	INC	HL
10BF: 56       [101]    	LD	D,(HL)		; Get MSB of FN code string
10C0: 23       [107]    	INC	HL
10C1: 7A       [111]    	LD	A,D		; And function DEFined?
10C2: B3       [115]    	OR	E
10C3: CAFD03   [125|125]	JP	Z,UFERR		; No - ?UF Error
10C6: 7E       [132]    	LD	A,(HL)		; Get LSB of argument address
10C7: 23       [138]    	INC	HL
10C8: 66       [145]    	LD	H,(HL)		; Get MSB of argument address
10C9: 6F       [149]    	LD	L,A		; HL = Arg variable address
10CA: E5       [160]    	PUSH	HL		; Save it
10CB: 2A2381   [176]    	LD	HL,(FNRGNM)	; Get old argument name
10CE: E3       [195]    	EX	(SP),HL;	; Save old , Get new
10CF: 222381   [211]    	LD	(FNRGNM),HL	; Set new argument name
10D2: 2A2781   [227]    	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
10D5: E5       [238]    	PUSH	HL		; Save it
10D6: 2A2581   [254]    	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
10D9: E5       [265]    	PUSH	HL		; Save it
10DA: 212581   [275]    	LD	HL,FNARG	; HL = Value of argument
10DD: D5       [286]    	PUSH	DE		; Save FN code string address
10DE: CDF016   [303]    	CALL	FPTHL		; Move FPREG to argument
10E1: E1       [313]    	POP	HL		; Get FN code string address
10E2: CDB60C   [330]    	CALL	GETNUM		; Get value from function
10E5: 2B       [336]    	DEC	HL		; DEC 'cos GETCHR INCs
10E6: CD4908   [353]    	CALL	GETCHR		; Get next character
10E9: C2F103   [363|363]	JP	NZ,SNERR	; Bad character in FN - Error
10EC: E1       [373]    	POP	HL		; Get MSB,EXP of old arg
10ED: 222581   [389]    	LD	(FNARG),HL	; Restore it
10F0: E1       [399]    	POP	HL		; Get LSB,NLSB of old arg
10F1: 222781   [415]    	LD	(FNARG+2),HL	; Restore it
10F4: E1       [425]    	POP	HL		; Get name of old arg
10F5: 222381   [441]    	LD	(FNRGNM),HL	; Restore it
10F8: E1       [451]    	POP	HL		; Restore code string address
10F9: C9       [461]    	RET
                        ;
10FA: E5       [11]     IDTEST: PUSH	HL		; Save code string address
10FB: 2AA180   [27]     	LD	HL,(LINEAT)	; Get current line number
10FE: 23       [33]     	INC	HL		; -1 means direct statement
10FF: 7C       [37]     	LD	A,H
1100: B5       [41]     	OR	L
1101: E1       [51]     	POP	HL		; Restore code string address
1102: C0       [56|62]  	RET	NZ		; Return if in program
1103: 1E16     [63]     	LD	E,ID		; ?ID Error
1105: C30504   [73]     	JP	ERROR
                        ;
1108: CDBF06   [17]     CHEKFN: CALL	CHKSYN		; Make sure FN follows
110B: A7                	DB	ZFN		; "FN" token
110C: 3E80     [24]     	LD	A,80H
110E: 321081   [37]     	LD	(FORFLG),A	; Flag FN name to find
1111: B6       [44]     	OR	(HL)		; FN name has bit 7 set
1112: 47       [48]     	LD	B,A		; in first byte of name
1113: CDB10E   [65]     	CALL	GTFNAM		; Get FN name
1116: C3B90C   [75]     	JP	TSTNUM		; Make sure numeric function
                        ;
1119: CDB90C   [17]     STR:	CALL	TSTNUM		; Make sure it's a number
111C: CD3D18   [34]     	CALL	NUMASC		; Turn number into text
111F: CD4D11   [17]     STR1:	CALL	CRTST		; Create string entry for it
1122: CDD212   [34]     	CALL	GSTRCU		; Current string to pool
1125: 012D13   [44]     	LD	BC,TOPOOL	; Save in string pool
1128: C5       [55]     	PUSH	BC		; Save address on stack
                        ;
1129: 7E       [ 7]     SAVSTR: LD	A,(HL)		; Get string length
112A: 23       [13]     	INC	HL
112B: 23       [19]     	INC	HL
112C: E5       [30]     	PUSH	HL		; Save pointer to string
112D: CDA811   [47]     	CALL	TESTR		; See if enough string space
1130: E1       [57]     	POP	HL		; Restore pointer to string
1131: 4E       [64]     	LD	C,(HL)		; Get LSB of address
1132: 23       [70]     	INC	HL
1133: 46       [77]     	LD	B,(HL)		; Get MSB of address
1134: CD4111   [94]     	CALL	CRTMST		; Create string entry
1137: E5       [105]    	PUSH	HL		; Save pointer to MSB of addr
1138: 6F       [109]    	LD	L,A		; Length of string
1139: CDC512   [126]    	CALL	TOSTRA		; Move to string area
113C: D1       [136]    	POP	DE		; Restore pointer to MSB
113D: C9       [146]    	RET
                        ;
113E: CDA811   [17]     MKTMST: CALL	TESTR		; See if enough string space
1141: 210481   [10]     CRTMST: LD	HL,TMPSTR	; Temporary string
1144: E5       [21]     	PUSH	HL		; Save it
1145: 77       [28]     	LD	(HL),A		; Save length of string
1146: 23       [34]     	INC	HL
1147: 23       [ 6]     SVSTAD: INC	HL
1148: 73       [13]     	LD	(HL),E		; Save LSB of address
1149: 23       [19]     	INC	HL
114A: 72       [26]     	LD	(HL),D		; Save MSB of address
114B: E1       [36]     	POP	HL		; Restore pointer
114C: C9       [46]     	RET
                        ;
114D: 2B       [ 6]     CRTST:	DEC	HL		; DEC - INCed after
114E: 0622     [ 7]     QTSTR:	LD	B,'"'		; Terminating quote
1150: 50       [11]     	LD	D,B		; Quote to D
1151: E5       [11]     DTSTR:	PUSH	HL		; Save start
1152: 0EFF     [18]     	LD	C,-1		; Set counter to -1
1154: 23       [ 6]     QTSTLP: INC	HL		; Move on
1155: 7E       [13]     	LD	A,(HL)		; Get byte
1156: 0C       [17]     	INC	C		; Count bytes
1157: B7       [21]     	OR	A		; End of line?
1158: CA6311   [31|31]  	JP	Z,CRTSTE	; Yes - Create string entry
115B: BA       [35]     	CP	D		; Terminator D found?
115C: CA6311   [45|45]  	JP	Z,CRTSTE	; Yes - Create string entry
115F: B8       [49]     	CP	B		; Terminator B found?
1160: C25411   [59|59]  	JP	NZ,QTSTLP	; No - Keep looking
1163: FE22     [ 7]     CRTSTE: CP	'"'		; End with '"'?
1165: CC4908   [17|24]  	CALL	Z,GETCHR	; Yes - Get next character
1168: E3       [36]     	EX	(SP),HL		; Starting quote
1169: 23       [42]     	INC	HL		; First byte of string
116A: EB       [46]     	EX	DE,HL		; To DE
116B: 79       [50]     	LD	A,C		; Get length
116C: CD4111   [67]     	CALL	CRTMST		; Create string entry
116F: 110481   [10]     TSTOPL: LD	DE,TMPSTR	; Temporary string
1172: 2AF680   [26]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
1175: 222981   [42]     	LD	(FPREG),HL	; Save address of string ptr
1178: 3E01     [49]     	LD	A,1
117A: 32F280   [62]     	LD	(TYPE),A	; Set type to string
117D: CDF316   [79]     	CALL	DETHL4		; Move string to pool
1180: CDB906   [96]     	CALL	CPDEHL		; Out of string pool?
1183: 22F680   [112]    	LD	(TMSTPT),HL	; Save new pointer
1186: E1       [122]    	POP	HL		; Restore code string address
1187: 7E       [129]    	LD	A,(HL)		; Get next code byte
1188: C0       [134|140]	RET	NZ		; Return if pool OK
1189: 1E1E     [141]    	LD	E,ST		; ?ST Error
118B: C30504   [151]    	JP	ERROR		; String pool overflow
                        ;
118E: 23       [ 6]     PRNUMS: INC	HL		; Skip leading space
118F: CD4D11   [17]     PRS:	CALL	CRTST		; Create string entry for it
1192: CDD212   [17]     PRS1:	CALL	GSTRCU		; Current string to pool
1195: CDE716   [34]     	CALL	LOADFP		; Move string block to BCDE
1198: 1C       [38]     	INC	E		; Length + 1
1199: 1D       [ 4]     PRSLP:	DEC	E		; Count characters
119A: C8       [ 9|15]  	RET	Z		; End of string
119B: 0A       [16]     	LD	A,(BC)		; Get byte to output
119C: CDCA06   [33]     	CALL	OUTC		; Output character in A
119F: FE0D     [40]     	CP	CR		; Return?
11A1: CCFB0A   [50|57]  	CALL	Z,DONULL	; Yes - Do nulls
11A4: 03       [56]     	INC	BC		; Next byte in string
11A5: C39911   [66]     	JP	PRSLP		; More characters to output
                        ;
11A8: B7       [ 4]     TESTR:	OR	A		; Test if enough room
11A9: 0E                	DB	0EH		; No garbage collection done
11AA: F1       [10]     GRBDON: POP	AF		; Garbage collection done
11AB: F5       [21]     	PUSH	AF		; Save status
11AC: 2A9F80   [37]     	LD	HL,(STRSPC)	; Bottom of string space in use
11AF: EB       [41]     	EX	DE,HL		; To DE
11B0: 2A0881   [57]     	LD	HL,(STRBOT)	; Bottom of string area
11B3: 2F       [61]     	CPL			; Negate length (Top down)
11B4: 4F       [65]     	LD	C,A		; -Length to BC
11B5: 06FF     [72]     	LD	B,-1		; BC = -ve length of string
11B7: 09       [83]     	ADD	HL,BC		; Add to bottom of space in use
11B8: 23       [89]     	INC	HL		; Plus one for 2's complement
11B9: CDB906   [106]    	CALL	CPDEHL		; Below string RAM area?
11BC: DAC611   [116|116]	JP	C,TESTOS	; Tidy up if not done else err
11BF: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of area
11C2: 23       [138]    	INC	HL		; Point to first byte of string
11C3: EB       [142]    	EX	DE,HL		; Address to DE
11C4: F1       [10]     POPAF:	POP	AF		; Throw away status push
11C5: C9       [20]     	RET
                        ;
11C6: F1       [10]     TESTOS: POP	AF		; Garbage collect been done?
11C7: 1E1A     [17]     	LD	E,OS		; ?OS Error
11C9: CA0504   [27|27]  	JP	Z,ERROR		; Yes - Not enough string apace
11CC: BF       [31]     	CP	A		; Flag garbage collect done
11CD: F5       [42]     	PUSH	AF		; Save status
11CE: 01AA11   [52]     	LD	BC,GRBDON	; Garbage collection done
11D1: C5       [63]     	PUSH	BC		; Save for RETurn
11D2: 2AF480   [16]     GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
11D5: 220881   [16]     GARBLP: LD	(STRBOT),HL	; Reset string pointer
11D8: 210000   [26]     	LD	HL,0
11DB: E5       [37]     	PUSH	HL		; Flag no string found
11DC: 2A9F80   [53]     	LD	HL,(STRSPC)	; Get bottom of string space
11DF: E5       [64]     	PUSH	HL		; Save bottom of string space
11E0: 21F880   [74]     	LD	HL,TMSTPL	; Temporary string pool
11E3: EB       [ 4]     GRBLP:	EX	DE,HL
11E4: 2AF680   [20]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
11E7: EB       [24]     	EX	DE,HL
11E8: CDB906   [41]     	CALL	CPDEHL		; Temporary string pool done?
11EB: 01E311   [51]     	LD	BC,GRBLP	; Loop until string pool done
11EE: C23712   [61|61]  	JP	NZ,STPOOL	; No - See if in string area
11F1: 2A1B81   [77]     	LD	HL,(PROGND)	; Start of simple variables
11F4: EB       [ 4]     SMPVAR: EX	DE,HL
11F5: 2A1D81   [20]     	LD	HL,(VAREND)	; End of simple variables
11F8: EB       [24]     	EX	DE,HL
11F9: CDB906   [41]     	CALL	CPDEHL		; All simple strings done?
11FC: CA0A12   [51|51]  	JP	Z,ARRLP		; Yes - Do string arrays
11FF: 7E       [58]     	LD	A,(HL)		; Get type of variable
1200: 23       [64]     	INC	HL
1201: 23       [70]     	INC	HL
1202: B7       [74]     	OR	A		; "S" flag set if string
1203: CD3A12   [91]     	CALL	STRADD		; See if string in string area
1206: C3F411   [101]    	JP	SMPVAR		; Loop until simple ones done
                        ;
1209: C1       [10]     GNXARY: POP	BC		; Scrap address of this array
120A: EB       [ 4]     ARRLP:	EX	DE,HL
120B: 2A1F81   [20]     	LD	HL,(ARREND)	; End of string arrays
120E: EB       [24]     	EX	DE,HL
120F: CDB906   [41]     	CALL	CPDEHL		; All string arrays done?
1212: CA6012   [51|51]  	JP	Z,SCNEND	; Yes - Move string if found
1215: CDE716   [68]     	CALL	LOADFP		; Get array name to BCDE
1218: 7B       [72]     	LD	A,E		; Get type of array	
1219: E5       [83]     	PUSH	HL		; Save address of num of dim'ns
121A: 09       [94]     	ADD	HL,BC		; Start of next array
121B: B7       [98]     	OR	A		; Test type of array
121C: F20912   [108|108]	JP	P,GNXARY	; Numeric array - Ignore it
121F: 220A81   [124]    	LD	(CUROPR),HL	; Save address of next array
1222: E1       [134]    	POP	HL		; Get address of num of dim'ns
1223: 4E       [141]    	LD	C,(HL)		; BC = Number of dimensions
1224: 0600     [148]    	LD	B,0
1226: 09       [159]    	ADD	HL,BC		; Two bytes per dimension size
1227: 09       [170]    	ADD	HL,BC
1228: 23       [176]    	INC	HL		; Plus one for number of dim'ns
1229: EB       [ 4]     GRBARY: EX	DE,HL
122A: 2A0A81   [20]     	LD	HL,(CUROPR)	; Get address of next array
122D: EB       [24]     	EX	DE,HL
122E: CDB906   [41]     	CALL	CPDEHL		; Is this array finished?
1231: CA0A12   [51|51]  	JP	Z,ARRLP		; Yes - Get next one
1234: 012912   [61]     	LD	BC,GRBARY	; Loop until array all done
1237: C5       [11]     STPOOL: PUSH	BC		; Save return address
1238: F680     [18]     	OR	80H		; Flag string type
123A: 7E       [ 7]     STRADD: LD	A,(HL)		; Get string length
123B: 23       [13]     	INC	HL
123C: 23       [19]     	INC	HL
123D: 5E       [26]     	LD	E,(HL)		; Get LSB of string address
123E: 23       [32]     	INC	HL
123F: 56       [39]     	LD	D,(HL)		; Get MSB of string address
1240: 23       [45]     	INC	HL
1241: F0       [50|56]  	RET	P		; Not a string - Return
1242: B7       [54]     	OR	A		; Set flags on string length
1243: C8       [59|65]  	RET	Z		; Null string - Return
1244: 44       [63]     	LD	B,H		; Save variable pointer
1245: 4D       [67]     	LD	C,L
1246: 2A0881   [83]     	LD	HL,(STRBOT)	; Bottom of new area
1249: CDB906   [100]    	CALL	CPDEHL		; String been done?
124C: 60       [104]    	LD	H,B		; Restore variable pointer
124D: 69       [108]    	LD	L,C
124E: D8       [113|119]	RET	C		; String done - Ignore
124F: E1       [123]    	POP	HL		; Return address
1250: E3       [142]    	EX	(SP),HL		; Lowest available string area
1251: CDB906   [159]    	CALL	CPDEHL		; String within string area?
1254: E3       [178]    	EX	(SP),HL		; Lowest available string area
1255: E5       [189]    	PUSH	HL		; Re-save return address
1256: 60       [193]    	LD	H,B		; Restore variable pointer
1257: 69       [197]    	LD	L,C
1258: D0       [202|208]	RET	NC		; Outside string area - Ignore
1259: C1       [212]    	POP	BC		; Get return , Throw 2 away
125A: F1       [222]    	POP	AF		; 
125B: F1       [232]    	POP	AF		; 
125C: E5       [243]    	PUSH	HL		; Save variable pointer
125D: D5       [254]    	PUSH	DE		; Save address of current
125E: C5       [265]    	PUSH	BC		; Put back return address
125F: C9       [275]    	RET			; Go to it
                        ;
1260: D1       [10]     SCNEND: POP	DE		; Addresses of strings
1261: E1       [20]     	POP	HL		; 
1262: 7D       [24]     	LD	A,L		; HL = 0 if no more to do
1263: B4       [28]     	OR	H
1264: C8       [33|39]  	RET	Z		; No more to do - Return
1265: 2B       [39]     	DEC	HL
1266: 46       [46]     	LD	B,(HL)		; MSB of address of string
1267: 2B       [52]     	DEC	HL
1268: 4E       [59]     	LD	C,(HL)		; LSB of address of string
1269: E5       [70]     	PUSH	HL		; Save variable address
126A: 2B       [76]     	DEC	HL
126B: 2B       [82]     	DEC	HL
126C: 6E       [89]     	LD	L,(HL)		; HL = Length of string
126D: 2600     [96]     	LD	H,0
126F: 09       [107]    	ADD	HL,BC		; Address of end of string+1
1270: 50       [111]    	LD	D,B		; String address to DE
1271: 59       [115]    	LD	E,C
1272: 2B       [121]    	DEC	HL		; Last byte in string
1273: 44       [125]    	LD	B,H		; Address to BC
1274: 4D       [129]    	LD	C,L
1275: 2A0881   [145]    	LD	HL,(STRBOT)	; Current bottom of string area
1278: CDC003   [162]    	CALL	MOVSTR		; Move string to new address
127B: E1       [172]    	POP	HL		; Restore variable address
127C: 71       [179]    	LD	(HL),C		; Save new LSB of address
127D: 23       [185]    	INC	HL
127E: 70       [192]    	LD	(HL),B		; Save new MSB of address
127F: 69       [196]    	LD	L,C		; Next string area+1 to HL
1280: 60       [200]    	LD	H,B
1281: 2B       [206]    	DEC	HL		; Next string area address
1282: C3D511   [216]    	JP	GARBLP		; Look for more strings
                        ;
1285: C5       [11]     CONCAT: PUSH	BC		; Save prec' opr & code string
1286: E5       [22]     	PUSH	HL		; 
1287: 2A2981   [38]     	LD	HL,(FPREG)	; Get first string
128A: E3       [57]     	EX	(SP),HL		; Save first string
128B: CD3F0D   [74]     	CALL	OPRND		; Get second string
128E: E3       [93]     	EX	(SP),HL		; Restore first string
128F: CDBA0C   [110]    	CALL	TSTSTR		; Make sure it's a string
1292: 7E       [117]    	LD	A,(HL)		; Get length of second string
1293: E5       [128]    	PUSH	HL		; Save first string
1294: 2A2981   [144]    	LD	HL,(FPREG)	; Get second string
1297: E5       [155]    	PUSH	HL		; Save second string
1298: 86       [162]    	ADD	A,(HL)		; Add length of second string
1299: 1E1C     [169]    	LD	E,LS		; ?LS Error
129B: DA0504   [179|179]	JP	C,ERROR		; String too long - Error
129E: CD3E11   [196]    	CALL	MKTMST		; Make temporary string
12A1: D1       [206]    	POP	DE		; Get second string to DE
12A2: CDD612   [223]    	CALL	GSTRDE		; Move to string pool if needed
12A5: E3       [242]    	EX	(SP),HL		; Get first string
12A6: CDD512   [259]    	CALL	GSTRHL		; Move to string pool if needed
12A9: E5       [270]    	PUSH	HL		; Save first string
12AA: 2A0681   [286]    	LD	HL,(TMPSTR+2)	; Temporary string address
12AD: EB       [290]    	EX	DE,HL		; To DE
12AE: CDBC12   [307]    	CALL	SSTSA		; First string to string area
12B1: CDBC12   [324]    	CALL	SSTSA		; Second string to string area
12B4: 21D40C   [334]    	LD	HL,EVAL2	; Return to evaluation loop
12B7: E3       [353]    	EX	(SP),HL		; Save return,get code string
12B8: E5       [364]    	PUSH	HL		; Save code string address
12B9: C36F11   [374]    	JP	TSTOPL		; To temporary string to pool
                        ;
12BC: E1       [10]     SSTSA:	POP	HL		; Return address
12BD: E3       [29]     	EX	(SP),HL		; Get string block,save return
12BE: 7E       [36]     	LD	A,(HL)		; Get length of string
12BF: 23       [42]     	INC	HL
12C0: 23       [48]     	INC	HL
12C1: 4E       [55]     	LD	C,(HL)		; Get LSB of string address
12C2: 23       [61]     	INC	HL
12C3: 46       [68]     	LD	B,(HL)		; Get MSB of string address
12C4: 6F       [72]     	LD	L,A		; Length to L
12C5: 2C       [ 4]     TOSTRA: INC	L		; INC - DECed after
12C6: 2D       [ 4]     TSALP:	DEC	L		; Count bytes moved
12C7: C8       [ 9|15]  	RET	Z		; End of string - Return
12C8: 0A       [16]     	LD	A,(BC)		; Get source
12C9: 12       [23]     	LD	(DE),A		; Save destination
12CA: 03       [29]     	INC	BC		; Next source
12CB: 13       [35]     	INC	DE		; Next destination
12CC: C3C612   [45]     	JP	TSALP		; Loop until string moved
                        ;
12CF: CDBA0C   [17]     GETSTR: CALL	TSTSTR		; Make sure it's a string
12D2: 2A2981   [16]     GSTRCU: LD	HL,(FPREG)	; Get current string
12D5: EB       [ 4]     GSTRHL: EX	DE,HL		; Save DE
12D6: CDF012   [17]     GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
12D9: EB       [21]     	EX	DE,HL		; Restore DE
12DA: C0       [26|32]  	RET	NZ		; No - Return
12DB: D5       [37]     	PUSH	DE		; Save string
12DC: 50       [41]     	LD	D,B		; String block address to DE
12DD: 59       [45]     	LD	E,C
12DE: 1B       [51]     	DEC	DE		; Point to length
12DF: 4E       [58]     	LD	C,(HL)		; Get string length
12E0: 2A0881   [74]     	LD	HL,(STRBOT)	; Current bottom of string area
12E3: CDB906   [91]     	CALL	CPDEHL		; Last one in string area?
12E6: C2EE12   [101|101]	JP	NZ,POPHL	; No - Return
12E9: 47       [105]    	LD	B,A		; Clear B (A=0)
12EA: 09       [116]    	ADD	HL,BC		; Remove string from str' area
12EB: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of str' area
12EE: E1       [10]     POPHL:	POP	HL		; Restore string
12EF: C9       [20]     	RET
                        ;
12F0: 2AF680   [16]     BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
12F3: 2B       [22]     	DEC	HL		; Back
12F4: 46       [29]     	LD	B,(HL)		; Get MSB of address
12F5: 2B       [35]     	DEC	HL		; Back
12F6: 4E       [42]     	LD	C,(HL)		; Get LSB of address
12F7: 2B       [48]     	DEC	HL		; Back
12F8: 2B       [54]     	DEC	HL		; Back
12F9: CDB906   [71]     	CALL	CPDEHL		; String last in string pool?
12FC: C0       [76|82]  	RET	NZ		; Yes - Leave it
12FD: 22F680   [92]     	LD	(TMSTPT),HL	; Save new string pool top
1300: C9       [102]    	RET
                        ;
1301: 018010   [10]     LEN:	LD	BC,PASSA	; To return integer A
1304: C5       [21]     	PUSH	BC		; Save address
1305: CDCF12   [17]     GETLEN: CALL	GETSTR		; Get string and its length
1308: AF       [21]     	XOR	A
1309: 57       [25]     	LD	D,A		; Clear D
130A: 32F280   [38]     	LD	(TYPE),A	; Set type to numeric
130D: 7E       [45]     	LD	A,(HL)		; Get length of string
130E: B7       [49]     	OR	A		; Set status flags
130F: C9       [59]     	RET
                        ;
1310: 018010   [10]     ASC:	LD	BC,PASSA	; To return integer A
1313: C5       [21]     	PUSH	BC		; Save address
1314: CD0513   [17]     GTFLNM: CALL	GETLEN		; Get length of string
1317: CA1009   [27|27]  	JP	Z,FCERR		; Null string - Error
131A: 23       [33]     	INC	HL
131B: 23       [39]     	INC	HL
131C: 5E       [46]     	LD	E,(HL)		; Get LSB of address
131D: 23       [52]     	INC	HL
131E: 56       [59]     	LD	D,(HL)		; Get MSB of address
131F: 1A       [66]     	LD	A,(DE)		; Get first byte of string
1320: C9       [76]     	RET
                        ;
1321: 3E01     [ 7]     CHR:	LD	A,1		; One character string
1323: CD3E11   [24]     	CALL	MKTMST		; Make a temporary string
1326: CD1A14   [41]     	CALL	MAKINT		; Make it integer A
1329: 2A0681   [57]     	LD	HL,(TMPSTR+2)	; Get address of string
132C: 73       [64]     	LD	(HL),E		; Save character
132D: C1       [10]     TOPOOL: POP	BC		; Clean up stack
132E: C36F11   [20]     	JP	TSTOPL		; Temporary string to pool
                        ;
1331: CDCA13   [17]     LEFT:	CALL	LFRGNM		; Get number and ending ")"
1334: AF       [21]     	XOR	A		; Start at first byte in string
1335: E3       [19]     RIGHT1: EX	(SP),HL		; Save code string,Get string
1336: 4F       [23]     	LD	C,A		; Starting position in string
1337: E5       [11]     MID1:	PUSH	HL		; Save string block address
1338: 7E       [18]     	LD	A,(HL)		; Get length of string
1339: B8       [22]     	CP	B		; Compare with number given
133A: DA3F13   [32|32]  	JP	C,ALLFOL	; All following bytes required
133D: 78       [36]     	LD	A,B		; Get new length
133E: 11                	DB	11H		; Skip "LD C,0"
133F: 0E00     [ 7]     ALLFOL: LD	C,0		; First byte of string
1341: C5       [18]     	PUSH	BC		; Save position in string
1342: CDA811   [35]     	CALL	TESTR		; See if enough string space
1345: C1       [45]     	POP	BC		; Get position in string
1346: E1       [55]     	POP	HL		; Restore string block address
1347: E5       [66]     	PUSH	HL		; And re-save it
1348: 23       [72]     	INC	HL
1349: 23       [78]     	INC	HL
134A: 46       [85]     	LD	B,(HL)		; Get LSB of address
134B: 23       [91]     	INC	HL
134C: 66       [98]     	LD	H,(HL)		; Get MSB of address
134D: 68       [102]    	LD	L,B		; HL = address of string
134E: 0600     [109]    	LD	B,0		; BC = starting address
1350: 09       [120]    	ADD	HL,BC		; Point to that byte
1351: 44       [124]    	LD	B,H		; BC = source string
1352: 4D       [128]    	LD	C,L
1353: CD4111   [145]    	CALL	CRTMST		; Create a string entry
1356: 6F       [149]    	LD	L,A		; Length of new string
1357: CDC512   [166]    	CALL	TOSTRA		; Move string to string area
135A: D1       [176]    	POP	DE		; Clear stack
135B: CDD612   [193]    	CALL	GSTRDE		; Move to string pool if needed
135E: C36F11   [203]    	JP	TSTOPL		; Temporary string to pool
                        ;
1361: CDCA13   [17]     RIGHT:	CALL	LFRGNM		; Get number and ending ")"
1364: D1       [27]     	POP	DE		; Get string length
1365: D5       [38]     	PUSH	DE		; And re-save
1366: 1A       [45]     	LD	A,(DE)		; Get length
1367: 90       [49]     	SUB	B		; Move back N bytes
1368: C33513   [59]     	JP	RIGHT1		; Go and get sub-string
                        ;
136B: EB       [ 4]     MID:	EX	DE,HL		; Get code string address
136C: 7E       [11]     	LD	A,(HL)		; Get next byte ',' or ")"
136D: CDCF13   [28]     	CALL	MIDNUM		; Get number supplied
1370: 04       [32]     	INC	B		; Is it character zero?
1371: 05       [36]     	DEC	B
1372: CA1009   [46|46]  	JP	Z,FCERR		; Yes - Error
1375: C5       [57]     	PUSH	BC		; Save starting position
1376: 1EFF     [64]     	LD	E,255		; All of string
1378: FE29     [71]     	CP	')'		; Any length given?
137A: CA8413   [81|81]  	JP	Z,RSTSTR	; No - Rest of string
137D: CDBF06   [98]     	CALL	CHKSYN		; Make sure ',' follows
1380: 2C                	DB	','
1381: CD1714   [115]    	CALL	GETINT		; Get integer 0-255
1384: CDBF06   [17]     RSTSTR: CALL	CHKSYN		; Make sure ")" follows
1387: 29                	DB	")"
1388: F1       [27]     	POP	AF		; Restore starting position
1389: E3       [46]     	EX	(SP),HL		; Get string,8ave code string
138A: 013713   [56]     	LD	BC,MID1		; Continuation of MID$ routine
138D: C5       [67]     	PUSH	BC		; Save for return
138E: 3D       [71]     	DEC	A		; Starting position-1
138F: BE       [78]     	CP	(HL)		; Compare with length
1390: 0600     [85]     	LD	B,0		; Zero bytes length
1392: D0       [90|96]  	RET	NC		; Null string if start past end
1393: 4F       [94]     	LD	C,A		; Save starting position-1
1394: 7E       [101]    	LD	A,(HL)		; Get length of string
1395: 91       [105]    	SUB	C		; Subtract start
1396: BB       [109]    	CP	E		; Enough string for it?
1397: 47       [113]    	LD	B,A		; Save maximum length available
1398: D8       [118|124]	RET	C		; Truncate string if needed
1399: 43       [122]    	LD	B,E		; Set specified length
139A: C9       [132]    	RET			; Go and create string
                        ;
139B: CD0513   [17]     VAL:	CALL	GETLEN		; Get length of string
139E: CAB814   [27|27]  	JP	Z,RESZER	; Result zero
13A1: 5F       [31]     	LD	E,A		; Save length
13A2: 23       [37]     	INC	HL
13A3: 23       [43]     	INC	HL
13A4: 7E       [50]     	LD	A,(HL)		; Get LSB of address
13A5: 23       [56]     	INC	HL
13A6: 66       [63]     	LD	H,(HL)		; Get MSB of address
13A7: 6F       [67]     	LD	L,A		; HL = String address
13A8: E5       [78]     	PUSH	HL		; Save string address
13A9: 19       [89]     	ADD	HL,DE
13AA: 46       [96]     	LD	B,(HL)		; Get end of string+1 byte
13AB: 72       [103]    	LD	(HL),D		; Zero it to terminate
13AC: E3       [122]    	EX	(SP),HL		; Save string end,get start
13AD: C5       [133]    	PUSH	BC		; Save end+1 byte
13AE: 7E       [140]    	LD	A,(HL)		; Get starting byte
13AF: FE24     [147]    	CP	'$'		; Hex number indicated? [function added]
13B1: C2B913   [157|157]	JP	NZ,VAL1
13B4: CDE31B   [174]    	CALL	HEXTFP		; Convert Hex to FPREG
13B7: 180D     [186]    	JR	VAL3
13B9: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
13BB: C2C313   [17|17]  	JP	NZ,VAL2
13BE: CD531C   [34]     	CALL	BINTFP		; Convert Bin to FPREG
13C1: 1803     [46]     	JR	VAL3
13C3: CD9F17   [17]     VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
13C6: C1       [10]     VAL3:	POP	BC		; Restore end+1 byte
13C7: E1       [20]     	POP	HL		; Restore end+1 address
13C8: 70       [27]     	LD	(HL),B		; Put back original byte
13C9: C9       [37]     	RET
                        ;
13CA: EB       [ 4]     LFRGNM: EX	DE,HL		; Code string address to HL
13CB: CDBF06   [21]     	CALL	CHKSYN		; Make sure ")" follows
13CE: 29                	DB	")"
13CF: C1       [10]     MIDNUM: POP	BC		; Get return address
13D0: D1       [20]     	POP	DE		; Get number supplied
13D1: C5       [31]     	PUSH	BC		; Re-save return address
13D2: 43       [35]     	LD	B,E		; Number to B
13D3: C9       [45]     	RET
                        ;
13D4: CD1A14   [17]     INP:	CALL	MAKINT		; Make it integer A
13D7: 328480   [30]     	LD	(INPORT),A	; Set input port
13DA: CD8380   [47]     	CALL	INPSUB		; Get input from port
13DD: C38010   [57]     	JP	PASSA		; Return integer A
                        ;
13E0: CD0414   [17]     POUT:	CALL	SETIO		; Set up port number
13E3: C34B80   [27]     	JP	OUTSUB		; Output data and return
                        ;
13E6: CD0414   [17]     WAIT:	CALL	SETIO		; Set up port number
13E9: F5       [28]     	PUSH	AF		; Save AND mask
13EA: 1E00     [35]     	LD	E,0		; Assume zero if none given
13EC: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
13ED: CD4908   [58]     	CALL	GETCHR		; Get next character
13F0: CAFA13   [68|68]  	JP	Z,NOXOR		; No XOR byte given
13F3: CDBF06   [85]     	CALL	CHKSYN		; Make sure ',' follows
13F6: 2C                	DB	','
13F7: CD1714   [102]    	CALL	GETINT		; Get integer 0-255 to XOR with
13FA: C1       [10]     NOXOR:	POP	BC		; Restore AND mask
13FB: CD8380   [17]     WAITLP: CALL	INPSUB		; Get input
13FE: AB       [21]     	XOR	E		; Flip selected bits
13FF: A0       [25]     	AND	B		; Result non-zero?
1400: CAFB13   [35|35]  	JP	Z,WAITLP	; No = keep waiting
1403: C9       [45]     	RET
                        ;
1404: CD1714   [17]     SETIO:	CALL	GETINT		; Get integer 0-255
1407: 328480   [30]     	LD	(INPORT),A	; Set input port
140A: 324C80   [43]     	LD	(OTPORT),A	; Set output port
140D: CDBF06   [60]     	CALL	CHKSYN		; Make sure ',' follows
1410: 2C                	DB	','
1411: C31714   [70]     	JP	GETINT		; Get integer 0-255 and return
                        ;
1414: CD4908   [17]     FNDNUM: CALL	GETCHR		; Get next character
1417: CDB60C   [17]     GETINT: CALL	GETNUM		; Get a number from 0 to 255
141A: CDF508   [17]     MAKINT: CALL	DEPINT		; Make sure value 0 - 255
141D: 7A       [21]     	LD	A,D		; Get MSB of number
141E: B7       [25]     	OR	A		; Zero?
141F: C21009   [35|35]  	JP	NZ,FCERR	; No - Error
1422: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
1423: CD4908   [58]     	CALL	GETCHR		; Get next character
1426: 7B       [62]     	LD	A,E		; Get number to A
1427: C9       [72]     	RET
                        ;
1428: CDFB08   [17]     PEEK:	CALL	DEINT		; Get memory address
142B: 1A       [24]     	LD	A,(DE)		; Get byte in memory
142C: C38010   [34]     	JP	PASSA		; Return integer A
                        ;
142F: CDB60C   [17]     POKE:	CALL	GETNUM		; Get memory address
1432: CDFB08   [34]     	CALL	DEINT		; Get integer -32768 to 3276
1435: D5       [45]     	PUSH	DE		; Save memory address
1436: CDBF06   [62]     	CALL	CHKSYN		; Make sure ',' follows
1439: 2C                	DB	','
143A: CD1714   [79]     	CALL	GETINT		; Get integer 0-255
143D: D1       [89]     	POP	DE		; Restore memory address
143E: 12       [96]     	LD	(DE),A		; Load it into memory
143F: C9       [106]    	RET
                        ;
1440: 211619   [10]     ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
1443: CDE716   [17]     ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
1446: C35214   [27]     	JP	FPADD		; Add BCDE to FPREG
                        ;
1449: CDE716   [17]     SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
144C: 21                	DB	21H		; Skip "POP BC" and "POP DE"
144D: C1       [10]     PSUB:	POP	BC		; Get FP number from stack
144E: D1       [20]     	POP	DE
144F: CDC116   [17]     SUBCDE: CALL	INVSGN		; Negate FPREG
1452: 78       [ 4]     FPADD:	LD	A,B		; Get FP exponent
1453: B7       [ 8]     	OR	A		; Is number zero?
1454: C8       [13|19]  	RET	Z		; Yes - Nothing to add
1455: 3A2C81   [26]     	LD	A,(FPEXP)	; Get FPREG exponent
1458: B7       [30]     	OR	A		; Is this number zero?
1459: CAD916   [40|40]  	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
145C: 90       [44]     	SUB	B		; BCDE number larger?
145D: D26C14   [54|54]  	JP	NC,NOSWAP	; No - Don't swap them
1460: 2F       [58]     	CPL			; Two's complement
1461: 3C       [62]     	INC	A		;	FP exponent
1462: EB       [66]     	EX	DE,HL
1463: CDC916   [83]     	CALL	STAKFP		; Put FPREG on stack
1466: EB       [87]     	EX	DE,HL
1467: CDD916   [104]    	CALL	FPBCDE		; Move BCDE to FPREG
146A: C1       [114]    	POP	BC		; Restore number from stack
146B: D1       [124]    	POP	DE
146C: FE19     [ 7]     NOSWAP: CP	24+1		; Second number insignificant?
146E: D0       [12|18]  	RET	NC		; Yes - First number is result
146F: F5       [23]     	PUSH	AF		; Save number of bits to scale
1470: CDFE16   [40]     	CALL	SIGNS		; Set MSBs & sign of result
1473: 67       [44]     	LD	H,A		; Save sign of result
1474: F1       [54]     	POP	AF		; Restore scaling factor
1475: CD1715   [71]     	CALL	SCALE		; Scale BCDE to same exponent
1478: B4       [75]     	OR	H		; Result to be positive?
1479: 212981   [85]     	LD	HL,FPREG	; Point to FPREG
147C: F29214   [95|95]  	JP	P,MINCDE	; No - Subtract FPREG from CDE
147F: CDF714   [112]    	CALL	PLUCDE		; Add FPREG to CDE
1482: D2D814   [122|122]	JP	NC,RONDUP	; No overflow - Round it up
1485: 23       [128]    	INC	HL		; Point to exponent
1486: 34       [139]    	INC	(HL)		; Increment it
1487: CA0004   [149|149]	JP	Z,OVERR		; Number overflowed - Error
148A: 2E01     [156]    	LD	L,1		; 1 bit to shift right
148C: CD2D15   [173]    	CALL	SHRT1		; Shift result right
148F: C3D814   [183]    	JP	RONDUP		; Round it up
                        ;
1492: AF       [ 4]     MINCDE: XOR	A		; Clear A and carry
1493: 90       [ 8]     	SUB	B		; Negate exponent
1494: 47       [12]     	LD	B,A		; Re-save exponent
1495: 7E       [19]     	LD	A,(HL)		; Get LSB of FPREG
1496: 9B       [23]     	SBC	A, E		; Subtract LSB of BCDE
1497: 5F       [27]     	LD	E,A		; Save LSB of BCDE
1498: 23       [33]     	INC	HL
1499: 7E       [40]     	LD	A,(HL)		; Get NMSB of FPREG
149A: 9A       [44]     	SBC	A,D		; Subtract NMSB of BCDE
149B: 57       [48]     	LD	D,A		; Save NMSB of BCDE
149C: 23       [54]     	INC	HL
149D: 7E       [61]     	LD	A,(HL)		; Get MSB of FPREG
149E: 99       [65]     	SBC	A,C		; Subtract MSB of BCDE
149F: 4F       [69]     	LD	C,A		; Save MSB of BCDE
14A0: DC0315   [10|17]  CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                        ;
14A3: 68       [ 4]     BNORM:	LD	L,B		; L = Exponent
14A4: 63       [ 8]     	LD	H,E		; H = LSB
14A5: AF       [12]     	XOR	A
14A6: 47       [ 4]     BNRMLP: LD	B,A		; Save bit count
14A7: 79       [ 8]     	LD	A,C		; Get MSB
14A8: B7       [12]     	OR	A		; Is it zero?
14A9: C2C514   [22|22]  	JP	NZ,PNORM	; No - Do it bit at a time
14AC: 4A       [26]     	LD	C,D		; MSB = NMSB
14AD: 54       [30]     	LD	D,H		; NMSB= LSB
14AE: 65       [34]     	LD	H,L		; LSB = VLSB
14AF: 6F       [38]     	LD	L,A		; VLSB= 0
14B0: 78       [42]     	LD	A,B		; Get exponent
14B1: D608     [49]     	SUB	8		; Count 8 bits
14B3: FEE0     [56]     	CP	0E0H		; -24-8 Was number zero?
14B5: C2A614   [66|66]  	JP	NZ,BNRMLP	; No - Keep normalising
14B8: AF       [ 4]     RESZER: XOR	A		; Result is zero
14B9: 322C81   [13]     SAVEXP: LD	(FPEXP),A	; Save result as zero
14BC: C9       [23]     	RET
                        ;
14BD: 05       [ 4]     NORMAL: DEC	B		; Count bits
14BE: 29       [15]     	ADD	HL,HL		; Shift HL left
14BF: 7A       [19]     	LD	A,D		; Get NMSB
14C0: 17       [23]     	RLA			; Shift left with last bit
14C1: 57       [27]     	LD	D,A		; Save NMSB
14C2: 79       [31]     	LD	A,C		; Get MSB
14C3: 8F       [35]     	ADC	A,A		; Shift left with last bit
14C4: 4F       [39]     	LD	C,A		; Save MSB
14C5: F2BD14   [10|10]  PNORM:	JP	P,NORMAL	; Not done - Keep going
14C8: 78       [14]     	LD	A,B		; Number of bits shifted
14C9: 5C       [18]     	LD	E,H		; Save HL in EB
14CA: 45       [22]     	LD	B,L
14CB: B7       [26]     	OR	A		; Any shifting done?
14CC: CAD814   [36|36]  	JP	Z,RONDUP	; No - Round it up
14CF: 212C81   [46]     	LD	HL,FPEXP	; Point to exponent
14D2: 86       [53]     	ADD	A,(HL)		; Add shifted bits
14D3: 77       [60]     	LD	(HL),A		; Re-save exponent
14D4: D2B814   [70|70]  	JP	NC,RESZER	; Underflow - Result is zero
14D7: C8       [75|81]  	RET	Z		; Result is zero
14D8: 78       [ 4]     RONDUP: LD	A,B		; Get VLSB of number
14D9: 212C81   [10]     RONDB:	LD	HL,FPEXP	; Point to exponent
14DC: B7       [14]     	OR	A		; Any rounding?
14DD: FCEA14   [24|31]  	CALL	M,FPROND	; Yes - Round number up
14E0: 46       [31]     	LD	B,(HL)		; B = Exponent
14E1: 23       [37]     	INC	HL
14E2: 7E       [44]     	LD	A,(HL)		; Get sign of result
14E3: E680     [51]     	AND	10000000B	; Only bit 7 needed
14E5: A9       [55]     	XOR	C		; Set correct sign
14E6: 4F       [59]     	LD	C,A		; Save correct sign in number
14E7: C3D916   [69]     	JP	FPBCDE		; Move BCDE to FPREG
                        ;
14EA: 1C       [ 4]     FPROND: INC	E		; Round LSB
14EB: C0       [ 9|15]  	RET	NZ		; Return if ok
14EC: 14       [13]     	INC	D		; Round NMSB
14ED: C0       [18|24]  	RET	NZ		; Return if ok
14EE: 0C       [22]     	INC	C		; Round MSB
14EF: C0       [27|33]  	RET	NZ		; Return if ok
14F0: 0E80     [34]     	LD	C,80H		; Set normal value
14F2: 34       [45]     	INC	(HL)		; Increment exponent
14F3: C0       [50|56]  	RET	NZ		; Return if ok
14F4: C30004   [60]     	JP	OVERR		; Overflow error
                        ;
14F7: 7E       [ 7]     PLUCDE: LD	A,(HL)		; Get LSB of FPREG
14F8: 83       [11]     	ADD	A,E		; Add LSB of BCDE
14F9: 5F       [15]     	LD	E,A		; Save LSB of BCDE
14FA: 23       [21]     	INC	HL
14FB: 7E       [28]     	LD	A,(HL)		; Get NMSB of FPREG
14FC: 8A       [32]     	ADC	A,D		; Add NMSB of BCDE
14FD: 57       [36]     	LD	D,A		; Save NMSB of BCDE
14FE: 23       [42]     	INC	HL
14FF: 7E       [49]     	LD	A,(HL)		; Get MSB of FPREG
1500: 89       [53]     	ADC	A,C		; Add MSB of BCDE
1501: 4F       [57]     	LD	C,A		; Save MSB of BCDE
1502: C9       [67]     	RET
                        ;
1503: 212D81   [10]     COMPL:	LD	HL,SGNRES	; Sign of result
1506: 7E       [17]     	LD	A,(HL)		; Get sign of result
1507: 2F       [21]     	CPL			; Negate it
1508: 77       [28]     	LD	(HL),A		; Put it back
1509: AF       [32]     	XOR	A
150A: 6F       [36]     	LD	L,A		; Set L to zero
150B: 90       [40]     	SUB	B		; Negate exponent,set carry
150C: 47       [44]     	LD	B,A		; Re-save exponent
150D: 7D       [48]     	LD	A,L		; Load zero
150E: 9B       [52]     	SBC	A,E		; Negate LSB
150F: 5F       [56]     	LD	E,A		; Re-save LSB
1510: 7D       [60]     	LD	A,L		; Load zero
1511: 9A       [64]     	SBC	A,D		; Negate NMSB
1512: 57       [68]     	LD	D,A		; Re-save NMSB
1513: 7D       [72]     	LD	A,L		; Load zero
1514: 99       [76]     	SBC	A,C		; Negate MSB
1515: 4F       [80]     	LD	C,A		; Re-save MSB
1516: C9       [90]     	RET
                        ;
1517: 0600     [ 7]     SCALE:	LD	B,0		; Clear underflow
1519: D608     [ 7]     SCALLP: SUB	8		; 8 bits (a whole byte)?
151B: DA2615   [17|17]  	JP	C,SHRITE	; No - Shift right A bits
151E: 43       [21]     	LD	B,E		; <- Shift
151F: 5A       [25]     	LD	E,D		; <- right
1520: 51       [29]     	LD	D,C		; <- eight
1521: 0E00     [36]     	LD	C,0		; <- bits
1523: C31915   [46]     	JP	SCALLP		; More bits to shift
                        ;
1526: C609     [ 7]     SHRITE: ADD	A,8+1		; Adjust count
1528: 6F       [11]     	LD	L,A		; Save bits to shift
1529: AF       [ 4]     SHRLP:	XOR	A		; Flag for all done
152A: 2D       [ 8]     	DEC	L		; All shifting done?
152B: C8       [13|19]  	RET	Z		; Yes - Return
152C: 79       [17]     	LD	A,C		; Get MSB
152D: 1F       [ 4]     SHRT1:	RRA			; Shift it right
152E: 4F       [ 8]     	LD	C,A		; Re-save
152F: 7A       [12]     	LD	A,D		; Get NMSB
1530: 1F       [16]     	RRA			; Shift right with last bit
1531: 57       [20]     	LD	D,A		; Re-save it
1532: 7B       [24]     	LD	A,E		; Get LSB
1533: 1F       [28]     	RRA			; Shift right with last bit
1534: 5F       [32]     	LD	E,A		; Re-save it
1535: 78       [36]     	LD	A,B		; Get underflow
1536: 1F       [40]     	RRA			; Shift right with last bit
1537: 47       [44]     	LD	B,A		; Re-save underflow
1538: C32915   [54]     	JP	SHRLP		; More bits to do
                        ;
153B: 00000081          UNITY:	DB	 000H,000H,000H,081H	; 1.00000
                        ;
153F: 03                LOGTAB: DB	3			; Table used by LOG
1540: AA561980          	DB	0AAH,056H,019H,080H	; 0.59898
1544: F1227680          	DB	0F1H,022H,076H,080H	; 0.96147
1548: 45AA3882          	DB	045H,0AAH,038H,082H	; 2.88539
                        ;
154C: CD9816   [17]     LOG:	CALL	TSTSGN		; Test sign of value
154F: B7       [21]     	OR	A
1550: EA1009   [31|31]  	JP	PE,FCERR	; ?FC Error if <= zero
1553: 212C81   [41]     	LD	HL,FPEXP	; Point to exponent
1556: 7E       [48]     	LD	A,(HL)		; Get exponent
1557: 013580   [58]     	LD	BC,8035H	; BCDE = SQR(1/2)
155A: 11F304   [68]     	LD	DE,04F3H
155D: 90       [72]     	SUB	B		; Scale value to be < 1
155E: F5       [83]     	PUSH	AF		; Save scale factor
155F: 70       [90]     	LD	(HL),B		; Save new exponent
1560: D5       [101]    	PUSH	DE		; Save SQR(1/2)
1561: C5       [112]    	PUSH	BC
1562: CD5214   [129]    	CALL	FPADD		; Add SQR(1/2) to value
1565: C1       [139]    	POP	BC		; Restore SQR(1/2)
1566: D1       [149]    	POP	DE
1567: 04       [153]    	INC	B		; Make it SQR(2)
1568: CDEE15   [170]    	CALL	DVBCDE		; Divide by SQR(2)
156B: 213B15   [180]    	LD	HL,UNITY	; Point to 1.
156E: CD4914   [197]    	CALL	SUBPHL		; Subtract FPREG from 1
1571: 213F15   [207]    	LD	HL,LOGTAB	; Coefficient table
1574: CDE019   [224]    	CALL	SUMSER		; Evaluate sum of series
1577: 018080   [234]    	LD	BC,8080H	; BCDE = -0.5
157A: 110000   [244]    	LD	DE,0000H
157D: CD5214   [261]    	CALL	FPADD		; Subtract 0.5 from FPREG
1580: F1       [271]    	POP	AF		; Restore scale factor
1581: CD1318   [288]    	CALL	RSCALE		; Re-scale number
1584: 013180   [10]     MULLN2: LD	BC,8031H	; BCDE = Ln(2)
1587: 111872   [20]     	LD	DE,7218H
158A: 21                	DB	21H		; Skip "POP BC" and "POP DE"
                        ;
158B: C1       [10]     MULT:	POP	BC		; Get number from stack
158C: D1       [20]     	POP	DE
158D: CD9816   [17]     FPMULT: CALL	TSTSGN		; Test sign of FPREG
1590: C8       [22|28]  	RET	Z		; Return zero if zero
1591: 2E00     [29]     	LD	L,0		; Flag add exponents
1593: CD5616   [46]     	CALL	ADDEXP		; Add exponents
1596: 79       [50]     	LD	A,C		; Get MSB of multiplier
1597: 323B81   [63]     	LD	(MULVAL),A	; Save MSB of multiplier
159A: EB       [67]     	EX	DE,HL
159B: 223C81   [83]     	LD	(MULVAL+1),HL	; Save rest of multiplier
159E: 010000   [93]     	LD	BC,0		; Partial product (BCDE) = zero
15A1: 50       [97]     	LD	D,B
15A2: 58       [101]    	LD	E,B
15A3: 21A314   [111]    	LD	HL,BNORM	; Address of normalise
15A6: E5       [122]    	PUSH	HL		; Save for return
15A7: 21AF15   [132]    	LD	HL,MULT8	; Address of 8 bit multiply
15AA: E5       [143]    	PUSH	HL		; Save for NMSB,MSB
15AB: E5       [154]    	PUSH	HL		; 
15AC: 212981   [164]    	LD	HL,FPREG	; Point to number
15AF: 7E       [ 7]     MULT8:	LD	A,(HL)		; Get LSB of number
15B0: 23       [13]     	INC	HL		; Point to NMSB
15B1: B7       [17]     	OR	A		; Test LSB
15B2: CADB15   [27|27]  	JP	Z,BYTSFT	; Zero - shift to next byte
15B5: E5       [38]     	PUSH	HL		; Save address of number
15B6: 2E08     [45]     	LD	L,8		; 8 bits to multiply by
15B8: 1F       [ 4]     MUL8LP: RRA			; Shift LSB right
15B9: 67       [ 8]     	LD	H,A		; Save LSB
15BA: 79       [12]     	LD	A,C		; Get MSB
15BB: D2C915   [22|22]  	JP	NC,NOMADD	; Bit was zero - Don't add
15BE: E5       [33]     	PUSH	HL		; Save LSB and count
15BF: 2A3C81   [49]     	LD	HL,(MULVAL+1)	; Get LSB and NMSB
15C2: 19       [60]     	ADD	HL,DE		; Add NMSB and LSB
15C3: EB       [64]     	EX	DE,HL		; Leave sum in DE
15C4: E1       [74]     	POP	HL		; Restore MSB and count
15C5: 3A3B81   [87]     	LD	A,(MULVAL)	; Get MSB of multiplier
15C8: 89       [91]     	ADC	A,C		; Add MSB
15C9: 1F       [ 4]     NOMADD: RRA			; Shift MSB right
15CA: 4F       [ 8]     	LD	C,A		; Re-save MSB
15CB: 7A       [12]     	LD	A,D		; Get NMSB
15CC: 1F       [16]     	RRA			; Shift NMSB right
15CD: 57       [20]     	LD	D,A		; Re-save NMSB
15CE: 7B       [24]     	LD	A,E		; Get LSB
15CF: 1F       [28]     	RRA			; Shift LSB right
15D0: 5F       [32]     	LD	E,A		; Re-save LSB
15D1: 78       [36]     	LD	A,B		; Get VLSB
15D2: 1F       [40]     	RRA			; Shift VLSB right
15D3: 47       [44]     	LD	B,A		; Re-save VLSB
15D4: 2D       [48]     	DEC	L		; Count bits multiplied
15D5: 7C       [52]     	LD	A,H		; Get LSB of multiplier
15D6: C2B815   [62|62]  	JP	NZ,MUL8LP	; More - Do it
15D9: E1       [10]     POPHRT: POP	HL		; Restore address of number
15DA: C9       [20]     	RET
                        ;
15DB: 43       [ 4]     BYTSFT: LD	B,E		; Shift partial product left
15DC: 5A       [ 8]     	LD	E,D
15DD: 51       [12]     	LD	D,C
15DE: 4F       [16]     	LD	C,A
15DF: C9       [26]     	RET
                        ;
15E0: CDC916   [17]     DIV10:	CALL	STAKFP		; Save FPREG on stack
15E3: 012084   [27]     	LD	BC,8420H	; BCDE = 10.
15E6: 110000   [37]     	LD	DE,0000H
15E9: CDD916   [54]     	CALL	FPBCDE		; Move 10 to FPREG
                        ;
15EC: C1       [10]     DIV:	POP	BC		; Get number from stack
15ED: D1       [20]     	POP	DE
15EE: CD9816   [17]     DVBCDE: CALL	TSTSGN		; Test sign of FPREG
15F1: CAF403   [27|27]  	JP	Z,DZERR		; Error if division by zero
15F4: 2EFF     [34]     	LD	L,-1		; Flag subtract exponents
15F6: CD5616   [51]     	CALL	ADDEXP		; Subtract exponents
15F9: 34       [62]     	INC	(HL)		; Add 2 to exponent to adjust
15FA: 34       [73]     	INC	(HL)
15FB: 2B       [79]     	DEC	HL		; Point to MSB
15FC: 7E       [86]     	LD	A,(HL)		; Get MSB of dividend
15FD: 325780   [99]     	LD	(DIV3),A	; Save for subtraction
1600: 2B       [105]    	DEC	HL
1601: 7E       [112]    	LD	A,(HL)		; Get NMSB of dividend
1602: 325380   [125]    	LD	(DIV2),A	; Save for subtraction
1605: 2B       [131]    	DEC	HL
1606: 7E       [138]    	LD	A,(HL)		; Get MSB of dividend
1607: 324F80   [151]    	LD	(DIV1),A	; Save for subtraction
160A: 41       [155]    	LD	B,C		; Get MSB
160B: EB       [159]    	EX	DE,HL		; NMSB,LSB to HL
160C: AF       [163]    	XOR	A
160D: 4F       [167]    	LD	C,A		; Clear MSB of quotient
160E: 57       [171]    	LD	D,A		; Clear NMSB of quotient
160F: 5F       [175]    	LD	E,A		; Clear LSB of quotient
1610: 325A80   [188]    	LD	(DIV4),A	; Clear overflow count
1613: E5       [11]     DIVLP:	PUSH	HL		; Save divisor
1614: C5       [22]     	PUSH	BC
1615: 7D       [26]     	LD	A,L		; Get LSB of number
1616: CD4E80   [43]     	CALL	DIVSUP		; Subt' divisor from dividend
1619: DE00     [50]     	SBC	A,0		; Count for overflows
161B: 3F       [54]     	CCF
161C: D22616   [64|64]  	JP	NC,RESDIV	; Restore divisor if borrow
161F: 325A80   [77]     	LD	(DIV4),A	; Re-save overflow count
1622: F1       [87]     	POP	AF		; Scrap divisor
1623: F1       [97]     	POP	AF
1624: 37       [101]    	SCF			; Set carry to
1625: D2                	DB	0D2H		; Skip "POP BC" and "POP HL"
                        ;
1626: C1       [10]     RESDIV: POP	BC		; Restore divisor
1627: E1       [20]     	POP	HL
1628: 79       [24]     	LD	A,C		; Get MSB of quotient
1629: 3C       [28]     	INC	A
162A: 3D       [32]     	DEC	A
162B: 1F       [36]     	RRA			; Bit 0 to bit 7
162C: FAD914   [46|46]  	JP	M,RONDB		; Done - Normalise result
162F: 17       [50]     	RLA			; Restore carry
1630: 7B       [54]     	LD	A,E		; Get LSB of quotient
1631: 17       [58]     	RLA			; Double it
1632: 5F       [62]     	LD	E,A		; Put it back
1633: 7A       [66]     	LD	A,D		; Get NMSB of quotient
1634: 17       [70]     	RLA			; Double it
1635: 57       [74]     	LD	D,A		; Put it back
1636: 79       [78]     	LD	A,C		; Get MSB of quotient
1637: 17       [82]     	RLA			; Double it
1638: 4F       [86]     	LD	C,A		; Put it back
1639: 29       [97]     	ADD	HL,HL		; Double NMSB,LSB of divisor
163A: 78       [101]    	LD	A,B		; Get MSB of divisor
163B: 17       [105]    	RLA			; Double it
163C: 47       [109]    	LD	B,A		; Put it back
163D: 3A5A80   [122]    	LD	A,(DIV4)	; Get VLSB of quotient
1640: 17       [126]    	RLA			; Double it
1641: 325A80   [139]    	LD	(DIV4),A	; Put it back
1644: 79       [143]    	LD	A,C		; Get MSB of quotient
1645: B2       [147]    	OR	D		; Merge NMSB
1646: B3       [151]    	OR	E		; Merge LSB
1647: C21316   [161|161]	JP	NZ,DIVLP	; Not done - Keep dividing
164A: E5       [172]    	PUSH	HL		; Save divisor
164B: 212C81   [182]    	LD	HL,FPEXP	; Point to exponent
164E: 35       [193]    	DEC	(HL)		; Divide by 2
164F: E1       [203]    	POP	HL		; Restore divisor
1650: C21316   [213|213]	JP	NZ,DIVLP	; Ok - Keep going
1653: C30004   [223]    	JP	OVERR		; Overflow error
                        ;
1656: 78       [ 4]     ADDEXP: LD	A,B		; Get exponent of dividend
1657: B7       [ 8]     	OR	A		; Test it
1658: CA7A16   [18|18]  	JP	Z,OVTST3	; Zero - Result zero
165B: 7D       [22]     	LD	A,L		; Get add/subtract flag
165C: 212C81   [32]     	LD	HL,FPEXP	; Point to exponent
165F: AE       [39]     	XOR	(HL)		; Add or subtract it
1660: 80       [43]     	ADD	A,B		; Add the other exponent
1661: 47       [47]     	LD	B,A		; Save new exponent
1662: 1F       [51]     	RRA			; Test exponent for overflow
1663: A8       [55]     	XOR	B
1664: 78       [59]     	LD	A,B		; Get exponent
1665: F27916   [69|69]  	JP	P,OVTST2	; Positive - Test for overflow
1668: C680     [76]     	ADD	A,80H		; Add excess 128
166A: 77       [83]     	LD	(HL),A		; Save new exponent
166B: CAD915   [93|93]  	JP	Z,POPHRT	; Zero - Result zero
166E: CDFE16   [110]    	CALL	SIGNS		; Set MSBs and sign of result
1671: 77       [117]    	LD	(HL),A		; Save new exponent
1672: 2B       [123]    	DEC	HL		; Point to MSB
1673: C9       [133]    	RET
                        ;
1674: CD9816   [17]     OVTST1: CALL	TSTSGN		; Test sign of FPREG
1677: 2F       [21]     	CPL			; Invert sign
1678: E1       [31]     	POP	HL		; Clean up stack
1679: B7       [ 4]     OVTST2: OR	A		; Test if new exponent zero
167A: E1       [10]     OVTST3: POP	HL		; Clear off return address
167B: F2B814   [20|20]  	JP	P,RESZER	; Result zero
167E: C30004   [30]     	JP	OVERR		; Overflow error
                        ;
1681: CDE416   [17]     MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
1684: 78       [21]     	LD	A,B		; Get exponent
1685: B7       [25]     	OR	A		; Is it zero?
1686: C8       [30|36]  	RET	Z		; Yes - Result is zero
1687: C602     [37]     	ADD	A,2		; Multiply by 4
1689: DA0004   [47|47]  	JP	C,OVERR		; Overflow - ?OV Error
168C: 47       [51]     	LD	B,A		; Re-save exponent
168D: CD5214   [68]     	CALL	FPADD		; Add BCDE to FPREG (Times 5)
1690: 212C81   [78]     	LD	HL,FPEXP	; Point to exponent
1693: 34       [89]     	INC	(HL)		; Double number (Times 10)
1694: C0       [94|100] 	RET	NZ		; Ok - Return
1695: C30004   [104]    	JP	OVERR		; Overflow error
                        ;
1698: 3A2C81   [13]     TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
169B: B7       [17]     	OR	A
169C: C8       [22|28]  	RET	Z		; RETurn if number is zero
169D: 3A2B81   [35]     	LD	A,(FPREG+2)	; Get MSB of FPREG
16A0: FE                	DB	0FEH		; Test sign
16A1: 2F       [ 4]     RETREL: CPL			; Invert sign
16A2: 17       [ 8]     	RLA			; Sign bit to carry
16A3: 9F       [ 4]     FLGDIF: SBC	A,A		; Carry to all bits of A
16A4: C0       [ 9|15]  	RET	NZ		; Return -1 if negative
16A5: 3C       [13]     	INC	A		; Bump to +1
16A6: C9       [23]     	RET			; Positive - Return +1
                        ;
16A7: CD9816   [17]     SGN:	CALL	TSTSGN		; Test sign of FPREG
16AA: 0688     [ 7]     FLGREL: LD	B,80H+8		; 8 bit integer in exponent
16AC: 110000   [17]     	LD	DE,0		; Zero NMSB and LSB
16AF: 212C81   [10]     RETINT: LD	HL,FPEXP	; Point to exponent
16B2: 4F       [14]     	LD	C,A		; CDE = MSB,NMSB and LSB
16B3: 70       [21]     	LD	(HL),B		; Save exponent
16B4: 0600     [28]     	LD	B,0		; CDE = integer to normalise
16B6: 23       [34]     	INC	HL		; Point to sign of result
16B7: 3680     [44]     	LD	(HL),80H	; Set sign of result
16B9: 17       [48]     	RLA			; Carry = sign of integer
16BA: C3A014   [58]     	JP	CONPOS		; Set sign of result
                        ;
16BD: CD9816   [17]     ABS:	CALL	TSTSGN		; Test sign of FPREG
16C0: F0       [22|28]  	RET	P		; Return if positive
16C1: 212B81   [10]     INVSGN: LD	HL,FPREG+2	; Point to MSB
16C4: 7E       [17]     	LD	A,(HL)		; Get sign of mantissa
16C5: EE80     [24]     	XOR	80H		; Invert sign of mantissa
16C7: 77       [31]     	LD	(HL),A		; Re-save sign of mantissa
16C8: C9       [41]     	RET
                        ;
16C9: EB       [ 4]     STAKFP: EX	DE,HL		; Save code string address
16CA: 2A2981   [20]     	LD	HL,(FPREG)	; LSB,NLSB of FPREG
16CD: E3       [39]     	EX	(SP),HL		; Stack them,get return
16CE: E5       [50]     	PUSH	HL		; Re-save return
16CF: 2A2B81   [66]     	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
16D2: E3       [85]     	EX	(SP),HL		; Stack them,get return
16D3: E5       [96]     	PUSH	HL		; Re-save return
16D4: EB       [100]    	EX	DE,HL		; Restore code string address
16D5: C9       [110]    	RET
                        ;
16D6: CDE716   [17]     PHLTFP: CALL	LOADFP		; Number at HL to BCDE
16D9: EB       [ 4]     FPBCDE: EX	DE,HL		; Save code string address
16DA: 222981   [20]     	LD	(FPREG),HL	; Save LSB,NLSB of number
16DD: 60       [24]     	LD	H,B		; Exponent of number
16DE: 69       [28]     	LD	L,C		; MSB of number
16DF: 222B81   [44]     	LD	(FPREG+2),HL	; Save MSB and exponent
16E2: EB       [48]     	EX	DE,HL		; Restore code string address
16E3: C9       [58]     	RET
                        ;
16E4: 212981   [10]     BCDEFP: LD	HL,FPREG	; Point to FPREG
16E7: 5E       [ 7]     LOADFP: LD	E,(HL)		; Get LSB of number
16E8: 23       [13]     	INC	HL
16E9: 56       [20]     	LD	D,(HL)		; Get NMSB of number
16EA: 23       [26]     	INC	HL
16EB: 4E       [33]     	LD	C,(HL)		; Get MSB of number
16EC: 23       [39]     	INC	HL
16ED: 46       [46]     	LD	B,(HL)		; Get exponent of number
16EE: 23       [ 6]     INCHL:	INC	HL		; Used for conditional "INC HL"
16EF: C9       [16]     	RET
                        ;
16F0: 112981   [10]     FPTHL:	LD	DE,FPREG	; Point to FPREG
16F3: 0604     [ 7]     DETHL4: LD	B,4		; 4 bytes to move
16F5: 1A       [ 7]     DETHLB: LD	A,(DE)		; Get source
16F6: 77       [14]     	LD	(HL),A		; Save destination
16F7: 13       [20]     	INC	DE		; Next source
16F8: 23       [26]     	INC	HL		; Next destination
16F9: 05       [30]     	DEC	B		; Count bytes
16FA: C2F516   [40|40]  	JP	NZ,DETHLB	; Loop if more
16FD: C9       [50]     	RET
                        ;
16FE: 212B81   [10]     SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
1701: 7E       [17]     	LD	A,(HL)		; Get MSB
1702: 07       [21]     	RLCA			; Old sign to carry
1703: 37       [25]     	SCF			; Set MSBit
1704: 1F       [29]     	RRA			; Set MSBit of MSB
1705: 77       [36]     	LD	(HL),A		; Save new MSB
1706: 3F       [40]     	CCF			; Complement sign
1707: 1F       [44]     	RRA			; Old sign to carry
1708: 23       [50]     	INC	HL
1709: 23       [56]     	INC	HL
170A: 77       [63]     	LD	(HL),A		; Set sign of result
170B: 79       [67]     	LD	A,C		; Get MSB
170C: 07       [71]     	RLCA			; Old sign to carry
170D: 37       [75]     	SCF			; Set MSBit
170E: 1F       [79]     	RRA			; Set MSBit of MSB
170F: 4F       [83]     	LD	C,A		; Save MSB
1710: 1F       [87]     	RRA
1711: AE       [94]     	XOR	(HL)		; New sign of result
1712: C9       [104]    	RET
                        ;
1713: 78       [ 4]     CMPNUM: LD	A,B		; Get exponent of number
1714: B7       [ 8]     	OR	A
1715: CA9816   [18|18]  	JP	Z,TSTSGN	; Zero - Test sign of FPREG
1718: 21A116   [28]     	LD	HL,RETREL	; Return relation routine
171B: E5       [39]     	PUSH	HL		; Save for return
171C: CD9816   [56]     	CALL	TSTSGN		; Test sign of FPREG
171F: 79       [60]     	LD	A,C		; Get MSB of number
1720: C8       [65|71]  	RET	Z		; FPREG zero - Number's MSB
1721: 212B81   [75]     	LD	HL,FPREG+2	; MSB of FPREG
1724: AE       [82]     	XOR	(HL)		; Combine signs
1725: 79       [86]     	LD	A,C		; Get MSB of number
1726: F8       [91|97]  	RET	M		; Exit if signs different
1727: CD2D17   [108]    	CALL	CMPFP		; Compare FP numbers
172A: 1F       [112]    	RRA			; Get carry to sign
172B: A9       [116]    	XOR	C		; Combine with MSB of number
172C: C9       [126]    	RET
                        ;
172D: 23       [ 6]     CMPFP:	INC	HL		; Point to exponent
172E: 78       [10]     	LD	A,B		; Get exponent
172F: BE       [17]     	CP	(HL)		; Compare exponents
1730: C0       [22|28]  	RET	NZ		; Different
1731: 2B       [28]     	DEC	HL		; Point to MBS
1732: 79       [32]     	LD	A,C		; Get MSB
1733: BE       [39]     	CP	(HL)		; Compare MSBs
1734: C0       [44|50]  	RET	NZ		; Different
1735: 2B       [50]     	DEC	HL		; Point to NMSB
1736: 7A       [54]     	LD	A,D		; Get NMSB
1737: BE       [61]     	CP	(HL)		; Compare NMSBs
1738: C0       [66|72]  	RET	NZ		; Different
1739: 2B       [72]     	DEC	HL		; Point to LSB
173A: 7B       [76]     	LD	A,E		; Get LSB
173B: 96       [83]     	SUB	(HL)		; Compare LSBs
173C: C0       [88|94]  	RET	NZ		; Different
173D: E1       [98]     	POP	HL		; Drop RETurn
173E: E1       [108]    	POP	HL		; Drop another RETurn
173F: C9       [118]    	RET
                        ;
1740: 47       [ 4]     FPINT:	LD	B,A		; <- Move
1741: 4F       [ 8]     	LD	C,A		; <- exponent
1742: 57       [12]     	LD	D,A		; <- to all
1743: 5F       [16]     	LD	E,A		; <- bits
1744: B7       [20]     	OR	A		; Test exponent
1745: C8       [25|31]  	RET	Z		; Zero - Return zero
1746: E5       [36]     	PUSH	HL		; Save pointer to number
1747: CDE416   [53]     	CALL	BCDEFP		; Move FPREG to BCDE
174A: CDFE16   [70]     	CALL	SIGNS		; Set MSBs & sign of result
174D: AE       [77]     	XOR	(HL)		; Combine with sign of FPREG
174E: 67       [81]     	LD	H,A		; Save combined signs
174F: FC6417   [91|98]  	CALL	M,DCBCDE	; Negative - Decrement BCDE
1752: 3E98     [98]     	LD	A,80H+24	; 24 bits
1754: 90       [102]    	SUB	B		; Bits to shift
1755: CD1715   [119]    	CALL	SCALE		; Shift BCDE
1758: 7C       [123]    	LD	A,H		; Get combined sign
1759: 17       [127]    	RLA			; Sign to carry
175A: DCEA14   [137|144]	CALL	C,FPROND	; Negative - Round number up
175D: 0600     [144]    	LD	B,0		; Zero exponent
175F: DC0315   [154|161]	CALL	C,COMPL		; If negative make positive
1762: E1       [164]    	POP	HL		; Restore pointer to number
1763: C9       [174]    	RET
                        ;
1764: 1B       [ 6]     DCBCDE: DEC	DE		; Decrement BCDE
1765: 7A       [10]     	LD	A,D		; Test LSBs
1766: A3       [14]     	AND	E
1767: 3C       [18]     	INC	A
1768: C0       [23|29]  	RET	NZ		; Exit if LSBs not FFFF
1769: 0B       [29]     	DEC	BC		; Decrement MSBs
176A: C9       [39]     	RET
                        ;
176B: 212C81   [10]     INT:	LD	HL,FPEXP	; Point to exponent
176E: 7E       [17]     	LD	A,(HL)		; Get exponent
176F: FE98     [24]     	CP	80H+24		; Integer accuracy only?
1771: 3A2981   [37]     	LD	A,(FPREG)	; Get LSB
1774: D0       [42|48]  	RET	NC		; Yes - Already integer
1775: 7E       [49]     	LD	A,(HL)		; Get exponent
1776: CD4017   [66]     	CALL	FPINT		; F.P to integer
1779: 3698     [76]     	LD	(HL),80H+24	; Save 24 bit integer
177B: 7B       [80]     	LD	A,E		; Get LSB of number
177C: F5       [91]     	PUSH	AF		; Save LSB
177D: 79       [95]     	LD	A,C		; Get MSB of number
177E: 17       [99]     	RLA			; Sign to carry
177F: CDA014   [116]    	CALL	CONPOS		; Set sign of result
1782: F1       [126]    	POP	AF		; Restore LSB of number
1783: C9       [136]    	RET
                        ;
1784: 210000   [10]     MLDEBC: LD	HL,0		; Clear partial product
1787: 78       [14]     	LD	A,B		; Test multiplier
1788: B1       [18]     	OR	C
1789: C8       [23|29]  	RET	Z		; Return zero if zero
178A: 3E10     [30]     	LD	A,16		; 16 bits
178C: 29       [11]     MLDBLP: ADD	HL,HL		; Shift P.P left
178D: DAC40F   [21|21]  	JP	C,BSERR		; ?BS Error if overflow
1790: EB       [25]     	EX	DE,HL
1791: 29       [36]     	ADD	HL,HL		; Shift multiplier left
1792: EB       [40]     	EX	DE,HL
1793: D29A17   [50|50]  	JP	NC,NOMLAD	; Bit was zero - No add
1796: 09       [61]     	ADD	HL,BC		; Add multiplicand
1797: DAC40F   [71|71]  	JP	C,BSERR		; ?BS Error if overflow
179A: 3D       [ 4]     NOMLAD: DEC	A		; Count bits
179B: C28C17   [14|14]  	JP	NZ,MLDBLP	; More
179E: C9       [24]     	RET
                        ;
179F: FE2D     [ 7]     ASCTFP: CP	'-'		; Negative?
17A1: F5       [18]     	PUSH	AF		; Save it and flags
17A2: CAAB17   [28|28]  	JP	Z,CNVNUM	; Yes - Convert number
17A5: FE2B     [35]     	CP	'+'		; Positive?
17A7: CAAB17   [45|45]  	JP	Z,CNVNUM	; Yes - Convert number
17AA: 2B       [51]     	DEC	HL		; DEC 'cos GETCHR INCs
17AB: CDB814   [17]     CNVNUM: CALL	RESZER		; Set result to zero
17AE: 47       [21]     	LD	B,A		; Digits after point counter
17AF: 57       [25]     	LD	D,A		; Sign of exponent
17B0: 5F       [29]     	LD	E,A		; Exponent of ten
17B1: 2F       [33]     	CPL
17B2: 4F       [37]     	LD	C,A		; Before or after point flag
17B3: CD4908   [17]     MANLP:	CALL	GETCHR		; Get next character
17B6: DAFC17   [27|27]  	JP	C,ADDIG		; Digit - Add to number
17B9: FE2E     [34]     	CP	'.'
17BB: CAD717   [44|44]  	JP	Z,DPOINT	; '.' - Flag point
17BE: FE45     [51]     	CP	'E'
17C0: C2DB17   [61|61]  	JP	NZ,CONEXP	; Not 'E' - Scale number
17C3: CD4908   [78]     	CALL	GETCHR		; Get next character
17C6: CDEF0D   [95]     	CALL	SGNEXP		; Get sign of exponent
17C9: CD4908   [17]     EXPLP:	CALL	GETCHR		; Get next character
17CC: DA1E18   [27|27]  	JP	C,EDIGIT	; Digit - Add to exponent
17CF: 14       [31]     	INC	D		; Is sign negative?
17D0: C2DB17   [41|41]  	JP	NZ,CONEXP	; No - Scale number
17D3: AF       [45]     	XOR	A
17D4: 93       [49]     	SUB	E		; Negate exponent
17D5: 5F       [53]     	LD	E,A		; And re-save it
17D6: 0C       [57]     	INC	C		; Flag end of number
17D7: 0C       [ 4]     DPOINT: INC	C		; Flag point passed
17D8: CAB317   [14|14]  	JP	Z,MANLP		; Zero - Get another digit
17DB: E5       [11]     CONEXP: PUSH	HL		; Save code string address
17DC: 7B       [15]     	LD	A,E		; Get exponent
17DD: 90       [19]     	SUB	B		; Subtract digits after point
17DE: F4F417   [10|17]  SCALMI: CALL	P,SCALPL	; Positive - Multiply number
17E1: F2EA17   [20|20]  	JP	P,ENDCON	; Positive - All done
17E4: F5       [31]     	PUSH	AF		; Save number of times to /10
17E5: CDE015   [48]     	CALL	DIV10		; Divide by 10
17E8: F1       [58]     	POP	AF		; Restore count
17E9: 3C       [62]     	INC	A		; Count divides
                        ;
17EA: C2DE17   [10|10]  ENDCON: JP	NZ,SCALMI	; More to do
17ED: D1       [20]     	POP	DE		; Restore code string address
17EE: F1       [30]     	POP	AF		; Restore sign of number
17EF: CCC116   [40|47]  	CALL	Z,INVSGN	; Negative - Negate number
17F2: EB       [44]     	EX	DE,HL		; Code string address to HL
17F3: C9       [54]     	RET
                        ;
17F4: C8       [ 5|11]  SCALPL: RET	Z		; Exit if no scaling needed
17F5: F5       [11]     MULTEN: PUSH	AF		; Save count
17F6: CD8116   [28]     	CALL	MLSP10		; Multiply number by 10
17F9: F1       [38]     	POP	AF		; Restore count
17FA: 3D       [42]     	DEC	A		; Count multiplies
17FB: C9       [52]     	RET
                        ;
17FC: D5       [11]     ADDIG:	PUSH	DE		; Save sign of exponent
17FD: 57       [15]     	LD	D,A		; Save digit
17FE: 78       [19]     	LD	A,B		; Get digits after point
17FF: 89       [23]     	ADC	A,C		; Add one if after point
1800: 47       [27]     	LD	B,A		; Re-save counter
1801: C5       [38]     	PUSH	BC		; Save point flags
1802: E5       [49]     	PUSH	HL		; Save code string address
1803: D5       [60]     	PUSH	DE		; Save digit
1804: CD8116   [77]     	CALL	MLSP10		; Multiply number by 10
1807: F1       [87]     	POP	AF		; Restore digit
1808: D630     [94]     	SUB	'0'		; Make it absolute
180A: CD1318   [111]    	CALL	RSCALE		; Re-scale number
180D: E1       [121]    	POP	HL		; Restore code string address
180E: C1       [131]    	POP	BC		; Restore point flags
180F: D1       [141]    	POP	DE		; Restore sign of exponent
1810: C3B317   [151]    	JP	MANLP		; Get another digit
                        ;
1813: CDC916   [17]     RSCALE: CALL	STAKFP		; Put number on stack
1816: CDAA16   [34]     	CALL	FLGREL		; Digit to add to FPREG
1819: C1       [10]     PADD:	POP	BC		; Restore number
181A: D1       [20]     	POP	DE
181B: C35214   [30]     	JP	FPADD		; Add BCDE to FPREG and return
                        ;
181E: 7B       [ 4]     EDIGIT: LD	A,E		; Get digit
181F: 07       [ 8]     	RLCA			; Times 2
1820: 07       [12]     	RLCA			; Times 4
1821: 83       [16]     	ADD	A,E		; Times 5
1822: 07       [20]     	RLCA			; Times 10
1823: 86       [27]     	ADD	A,(HL)		; Add next digit
1824: D630     [34]     	SUB	'0'		; Make it absolute
1826: 5F       [38]     	LD	E,A		; Save new digit
1827: C3C917   [48]     	JP	EXPLP		; Look for another digit
                        ;
182A: E5       [11]     LINEIN: PUSH	HL		; Save code string address
182B: 218903   [21]     	LD	HL,INMSG	; Output " in "
182E: CD8F11   [38]     	CALL	PRS		; Output string at HL
1831: E1       [48]     	POP	HL		; Restore code string address
1832: EB       [ 4]     PRNTHL: EX	DE,HL		; Code string address to DE
1833: AF       [ 8]     	XOR	A
1834: 0698     [15]     	LD	B,80H+24	; 24 bits
1836: CDAF16   [32]     	CALL	RETINT		; Return the integer
1839: 218E11   [42]     	LD	HL,PRNUMS	; Print number string
183C: E5       [53]     	PUSH	HL		; Save for return
183D: 212E81   [10]     NUMASC: LD	HL,PBUFF	; Convert number to ASCII
1840: E5       [21]     	PUSH	HL		; Save for return
1841: CD9816   [38]     	CALL	TSTSGN		; Test sign of FPREG
1844: 3620     [48]     	LD	(HL),' '	; Space at start
1846: F24B18   [58|58]  	JP	P,SPCFST	; Positive - Space to start
1849: 362D     [68]     	LD	(HL),'-'	; '-' sign at start
184B: 23       [ 6]     SPCFST: INC	HL		; First byte of number
184C: 3630     [16]     	LD	(HL),'0'	; '0' if zero
184E: CA0119   [26|26]  	JP	Z,JSTZER	; Return '0' if zero
1851: E5       [37]     	PUSH	HL		; Save buffer address
1852: FCC116   [47|54]  	CALL	M,INVSGN	; Negate FPREG if negative
1855: AF       [51]     	XOR	A		; Zero A
1856: F5       [62]     	PUSH	AF		; Save it
1857: CD0719   [79]     	CALL	RNGTST		; Test number is in range
185A: 014391   [10]     SIXDIG: LD	BC,9143H	; BCDE - 99999.9
185D: 11F84F   [20]     	LD	DE,4FF8H
1860: CD1317   [37]     	CALL	CMPNUM		; Compare numbers
1863: B7       [41]     	OR	A
1864: E27818   [51|51]  	JP	PO,INRNG	; > 99999.9 - Sort it out
1867: F1       [61]     	POP	AF		; Restore count
1868: CDF517   [78]     	CALL	MULTEN		; Multiply by ten
186B: F5       [89]     	PUSH	AF		; Re-save count
186C: C35A18   [99]     	JP	SIXDIG		; Test it again
                        ;
186F: CDE015   [17]     GTSIXD: CALL	DIV10		; Divide by 10
1872: F1       [27]     	POP	AF		; Get count
1873: 3C       [31]     	INC	A		; Count divides
1874: F5       [42]     	PUSH	AF		; Re-save count
1875: CD0719   [59]     	CALL	RNGTST		; Test number is in range
1878: CD4014   [17]     INRNG:	CALL	ROUND		; Add 0.5 to FPREG
187B: 3C       [21]     	INC	A
187C: CD4017   [38]     	CALL	FPINT		; F.P to integer
187F: CDD916   [55]     	CALL	FPBCDE		; Move BCDE to FPREG
1882: 010603   [65]     	LD	BC,0306H	; 1E+06 to 1E-03 range
1885: F1       [75]     	POP	AF		; Restore count
1886: 81       [79]     	ADD	A,C		; 6 digits before point
1887: 3C       [83]     	INC	A		; Add one
1888: FA9418   [93|93]  	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
188B: FE08     [100]    	CP	6+1+1		; More than 999999 ?
188D: D29418   [110|110]	JP	NC,MAKNUM	; Yes - Do it in 'E' form
1890: 3C       [114]    	INC	A		; Adjust for exponent
1891: 47       [118]    	LD	B,A		; Exponent of number
1892: 3E02     [125]    	LD	A,2		; Make it zero after
                        ;
1894: 3D       [ 4]     MAKNUM: DEC	A		; Adjust for digits to do
1895: 3D       [ 8]     	DEC	A
1896: E1       [18]     	POP	HL		; Restore buffer address
1897: F5       [29]     	PUSH	AF		; Save count
1898: 111A19   [39]     	LD	DE,POWERS	; Powers of ten
189B: 05       [43]     	DEC	B		; Count digits before point
189C: C2A518   [53|53]  	JP	NZ,DIGTXT	; Not zero - Do number
189F: 362E     [63]     	LD	(HL),'.'	; Save point
18A1: 23       [69]     	INC	HL		; Move on
18A2: 3630     [79]     	LD	(HL),'0'	; Save zero
18A4: 23       [85]     	INC	HL		; Move on
18A5: 05       [ 4]     DIGTXT: DEC	B		; Count digits before point
18A6: 362E     [14]     	LD	(HL),'.'	; Save point in case
18A8: CCEE16   [24|31]  	CALL	Z,INCHL		; Last digit - move on
18AB: C5       [35]     	PUSH	BC		; Save digits before point
18AC: E5       [46]     	PUSH	HL		; Save buffer address
18AD: D5       [57]     	PUSH	DE		; Save powers of ten
18AE: CDE416   [74]     	CALL	BCDEFP		; Move FPREG to BCDE
18B1: E1       [84]     	POP	HL		; Powers of ten table
18B2: 062F     [91]     	LD	B, '0'-1	; ASCII '0' - 1
18B4: 04       [ 4]     TRYAGN: INC	B		; Count subtractions
18B5: 7B       [ 8]     	LD	A,E		; Get LSB
18B6: 96       [15]     	SUB	(HL)		; Subtract LSB
18B7: 5F       [19]     	LD	E,A		; Save LSB
18B8: 23       [25]     	INC	HL
18B9: 7A       [29]     	LD	A,D		; Get NMSB
18BA: 9E       [36]     	SBC	A,(HL)		; Subtract NMSB
18BB: 57       [40]     	LD	D,A		; Save NMSB
18BC: 23       [46]     	INC	HL
18BD: 79       [50]     	LD	A,C		; Get MSB
18BE: 9E       [57]     	SBC	A,(HL)		; Subtract MSB
18BF: 4F       [61]     	LD	C,A		; Save MSB
18C0: 2B       [67]     	DEC	HL		; Point back to start
18C1: 2B       [73]     	DEC	HL
18C2: D2B418   [83|83]  	JP	NC,TRYAGN	; No overflow - Try again
18C5: CDF714   [100]    	CALL	PLUCDE		; Restore number
18C8: 23       [106]    	INC	HL		; Start of next number
18C9: CDD916   [123]    	CALL	FPBCDE		; Move BCDE to FPREG
18CC: EB       [127]    	EX	DE,HL		; Save point in table
18CD: E1       [137]    	POP	HL		; Restore buffer address
18CE: 70       [144]    	LD	(HL),B		; Save digit in buffer
18CF: 23       [150]    	INC	HL		; And move on
18D0: C1       [160]    	POP	BC		; Restore digit count
18D1: 0D       [164]    	DEC	C		; Count digits
18D2: C2A518   [174|174]	JP	NZ,DIGTXT	; More - Do them
18D5: 05       [178]    	DEC	B		; Any decimal part?
18D6: CAE518   [188|188]	JP	Z,DOEBIT	; No - Do 'E' bit
18D9: 2B       [ 6]     SUPTLZ: DEC	HL		; Move back through buffer
18DA: 7E       [13]     	LD	A,(HL)		; Get character
18DB: FE30     [20]     	CP	'0'		; '0' character?
18DD: CAD918   [30|30]  	JP	Z,SUPTLZ	; Yes - Look back for more
18E0: FE2E     [37]     	CP	'.'		; A decimal point?
18E2: C4EE16   [47|54]  	CALL	NZ,INCHL	; Move back over digit
                        ;
18E5: F1       [10]     DOEBIT: POP	AF		; Get 'E' flag
18E6: CA0419   [20|20]  	JP	Z,NOENED	; No 'E' needed - End buffer
18E9: 3645     [30]     	LD	(HL),'E'	; Put 'E' in buffer
18EB: 23       [36]     	INC	HL		; And move on
18EC: 362B     [46]     	LD	(HL),'+'	; Put '+' in buffer
18EE: F2F518   [56|56]  	JP	P,OUTEXP	; Positive - Output exponent
18F1: 362D     [66]     	LD	(HL),'-'	; Put '-' in buffer
18F3: 2F       [70]     	CPL			; Negate exponent
18F4: 3C       [74]     	INC	A
18F5: 062F     [ 7]     OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
18F7: 04       [ 4]     EXPTEN: INC	B		; Count subtractions
18F8: D60A     [11]     	SUB	10		; Tens digit
18FA: D2F718   [21|21]  	JP	NC,EXPTEN	; More to do
18FD: C63A     [28]     	ADD	A,'0'+10	; Restore and make ASCII
18FF: 23       [34]     	INC	HL		; Move on
1900: 70       [41]     	LD	(HL),B		; Save MSB of exponent
1901: 23       [ 6]     JSTZER: INC	HL		;
1902: 77       [13]     	LD	(HL),A		; Save LSB of exponent
1903: 23       [19]     	INC	HL
1904: 71       [ 7]     NOENED: LD	(HL),C		; Mark end of buffer
1905: E1       [17]     	POP	HL		; Restore code string address
1906: C9       [27]     	RET
                        ;
1907: 017494   [10]     RNGTST: LD	BC,9474H	; BCDE = 999999.
190A: 11F723   [20]     	LD	DE,23F7H
190D: CD1317   [37]     	CALL	CMPNUM		; Compare numbers
1910: B7       [41]     	OR	A
1911: E1       [51]     	POP	HL		; Return address to HL
1912: E26F18   [61|61]  	JP	PO,GTSIXD	; Too big - Divide by ten
1915: E9       [65]     	JP	(HL)		; Otherwise return to caller
                        ;
1916: 00000080          HALF:	DB	00H,00H,00H,80H	; 0.5
                        ;
191A: A08601            POWERS: DB	0A0H,086H,001H	; 100000
191D: 102700            	DB	010H,027H,000H	; 10000
1920: E80300            	DB	0E8H,003H,000H	; 1000
1923: 640000            	DB	064H,000H,000H	; 100
1926: 0A0000            	DB	00AH,000H,000H	; 10
1929: 010000            	DB	001H,000H,000H	; 1
                        ;
192C: 21C116   [10]     NEGAFT: LD	HL,INVSGN	; Negate result
192F: E3       [29]     	EX	(SP),HL		; To be done after caller
1930: E9       [33]     	JP	(HL)		; Return to caller
                        ;
1931: CDC916   [17]     SQR:	CALL	STAKFP		; Put value on stack
1934: 211619   [27]     	LD	HL,HALF		; Set power to 1/2
1937: CDD616   [44]     	CALL	PHLTFP		; Move 1/2 to FPREG
                        ;
193A: C1       [10]     POWER:	POP	BC		; Get base
193B: D1       [20]     	POP	DE
193C: CD9816   [37]     	CALL	TSTSGN		; Test sign of power
193F: 78       [41]     	LD	A,B		; Get exponent of base
1940: CA7F19   [51|51]  	JP	Z,EXP		; Make result 1 if zero
1943: F24A19   [61|61]  	JP	P,POWER1	; Positive base - Ok
1946: B7       [65]     	OR	A		; Zero to negative power?
1947: CAF403   [75|75]  	JP	Z,DZERR		; Yes - ?/0 Error
194A: B7       [ 4]     POWER1: OR	A		; Base zero?
194B: CAB914   [14|14]  	JP	Z,SAVEXP	; Yes - Return zero
194E: D5       [25]     	PUSH	DE		; Save base
194F: C5       [36]     	PUSH	BC
1950: 79       [40]     	LD	A,C		; Get MSB of base
1951: F67F     [47]     	OR	01111111B	; Get sign status
1953: CDE416   [64]     	CALL	BCDEFP		; Move power to BCDE
1956: F26719   [74|74]  	JP	P,POWER2	; Positive base - Ok
1959: D5       [85]     	PUSH	DE		; Save power
195A: C5       [96]     	PUSH	BC
195B: CD6B17   [113]    	CALL	INT		; Get integer of power
195E: C1       [123]    	POP	BC		; Restore power
195F: D1       [133]    	POP	DE
1960: F5       [144]    	PUSH	AF		; MSB of base
1961: CD1317   [161]    	CALL	CMPNUM		; Power an integer?
1964: E1       [171]    	POP	HL		; Restore MSB of base
1965: 7C       [175]    	LD	A,H		; but don't affect flags
1966: 1F       [179]    	RRA			; Exponent odd or even?
1967: E1       [10]     POWER2: POP	HL		; Restore MSB and exponent
1968: 222B81   [26]     	LD	(FPREG+2),HL	; Save base in FPREG
196B: E1       [36]     	POP	HL		; LSBs of base
196C: 222981   [52]     	LD	(FPREG),HL	; Save in FPREG
196F: DC2C19   [62|69]  	CALL	C,NEGAFT	; Odd power - Negate result
1972: CCC116   [72|79]  	CALL	Z,INVSGN	; Negative base - Negate it
1975: D5       [83]     	PUSH	DE		; Save power
1976: C5       [94]     	PUSH	BC
1977: CD4C15   [111]    	CALL	LOG		; Get LOG of base
197A: C1       [121]    	POP	BC		; Restore power
197B: D1       [131]    	POP	DE
197C: CD8D15   [148]    	CALL	FPMULT		; Multiply LOG by power
                        ;
197F: CDC916   [17]     EXP:	CALL	STAKFP		; Put value on stack
1982: 013881   [27]     	LD	BC,08138H	; BCDE = 1/Ln(2)
1985: 113BAA   [37]     	LD	DE,0AA3BH
1988: CD8D15   [54]     	CALL	FPMULT		; Multiply value by 1/LN(2)
198B: 3A2C81   [67]     	LD	A,(FPEXP)	; Get exponent
198E: FE88     [74]     	CP	80H+8		; Is it in range?
1990: D27416   [84|84]  	JP	NC,OVTST1	; No - Test for overflow
1993: CD6B17   [101]    	CALL	INT		; Get INT of FPREG
1996: C680     [108]    	ADD	A,80H		; For excess 128
1998: C602     [115]    	ADD	A,2		; Exponent > 126?
199A: DA7416   [125|125]	JP	C,OVTST1	; Yes - Test for overflow
199D: F5       [136]    	PUSH	AF		; Save scaling factor
199E: 213B15   [146]    	LD	HL,UNITY	; Point to 1.
19A1: CD4314   [163]    	CALL	ADDPHL		; Add 1 to FPREG
19A4: CD8415   [180]    	CALL	MULLN2		; Multiply by LN(2)
19A7: F1       [190]    	POP	AF		; Restore scaling factor
19A8: C1       [200]    	POP	BC		; Restore exponent
19A9: D1       [210]    	POP	DE
19AA: F5       [221]    	PUSH	AF		; Save scaling factor
19AB: CD4F14   [238]    	CALL	SUBCDE		; Subtract exponent from FPREG
19AE: CDC116   [255]    	CALL	INVSGN		; Negate result
19B1: 21BF19   [265]    	LD	HL,EXPTAB	; Coefficient table
19B4: CDEF19   [282]    	CALL	SMSER1		; Sum the series
19B7: 110000   [292]    	LD	DE,0		; Zero LSBs
19BA: C1       [302]    	POP	BC		; Scaling factor
19BB: 4A       [306]    	LD	C,D		; Zero MSB
19BC: C38D15   [316]    	JP	FPMULT		; Scale result to correct value
                        ;
19BF: 08                EXPTAB: DB	8			; Table used by EXP
19C0: 402E9474          	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
19C4: 704F2E77          	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
19C8: 6E02887A          	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
19CC: E6A02A7C          	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
19D0: 50AAAA7E          	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
19D4: FFFF7F7F          	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
19D8: 00008081          	DB	000H,000H,080H,081H	; -1/1! (-1/1)
19DC: 00000081          	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
                        ;
19E0: CDC916   [17]     SUMSER: CALL	STAKFP		; Put FPREG on stack
19E3: 118B15   [27]     	LD	DE,MULT		; Multiply by "X"
19E6: D5       [38]     	PUSH	DE		; To be done after
19E7: E5       [49]     	PUSH	HL		; Save address of table
19E8: CDE416   [66]     	CALL	BCDEFP		; Move FPREG to BCDE
19EB: CD8D15   [83]     	CALL	FPMULT		; Square the value
19EE: E1       [93]     	POP	HL		; Restore address of table
19EF: CDC916   [17]     SMSER1: CALL	STAKFP		; Put value on stack
19F2: 7E       [24]     	LD	A,(HL)		; Get number of coefficients
19F3: 23       [30]     	INC	HL		; Point to start of table
19F4: CDD616   [47]     	CALL	PHLTFP		; Move coefficient to FPREG
19F7: 06                	DB	06H		; Skip "POP AF"
19F8: F1       [10]     SUMLP:	POP	AF		; Restore count
19F9: C1       [20]     	POP	BC		; Restore number
19FA: D1       [30]     	POP	DE
19FB: 3D       [34]     	DEC	A		; Cont coefficients
19FC: C8       [39|45]  	RET	Z		; All done
19FD: D5       [50]     	PUSH	DE		; Save number
19FE: C5       [61]     	PUSH	BC
19FF: F5       [72]     	PUSH	AF		; Save count
1A00: E5       [83]     	PUSH	HL		; Save address in table
1A01: CD8D15   [100]    	CALL	FPMULT		; Multiply FPREG by BCDE
1A04: E1       [110]    	POP	HL		; Restore address in table
1A05: CDE716   [127]    	CALL	LOADFP		; Number at HL to BCDE
1A08: E5       [138]    	PUSH	HL		; Save address in table
1A09: CD5214   [155]    	CALL	FPADD		; Add coefficient to FPREG
1A0C: E1       [165]    	POP	HL		; Restore address in table
1A0D: C3F819   [175]    	JP	SUMLP		; More coefficients
                        ;
1A10: CD9816   [17]     RND:	CALL	TSTSGN		; Test sign of FPREG
1A13: 215E80   [27]     	LD	HL,SEED+2	; Random number seed
1A16: FA711A   [37|37]  	JP	M,RESEED	; Negative - Re-seed
1A19: 217F80   [47]     	LD	HL,LSTRND	; Last random number
1A1C: CDD616   [64]     	CALL	PHLTFP		; Move last RND to FPREG
1A1F: 215E80   [74]     	LD	HL,SEED+2	; Random number seed
1A22: C8       [79|85]  	RET	Z		; Return if RND(0)
1A23: 86       [86]     	ADD	A,(HL)		; Add (SEED)+2)
1A24: E607     [93]     	AND	00000111B	; 0 to 7
1A26: 0600     [100]    	LD	B,0
1A28: 77       [107]    	LD	(HL),A		; Re-save seed
1A29: 23       [113]    	INC	HL		; Move to coefficient table
1A2A: 87       [117]    	ADD	A,A		; 4 bytes
1A2B: 87       [121]    	ADD	A,A		; per entry
1A2C: 4F       [125]    	LD	C,A		; BC = Offset into table
1A2D: 09       [136]    	ADD	HL,BC		; Point to coefficient
1A2E: CDE716   [153]    	CALL	LOADFP		; Coefficient to BCDE
1A31: CD8D15   [170]    	CALL	FPMULT	;	; Multiply FPREG by coefficient
1A34: 3A5D80   [183]    	LD	A,(SEED+1)	; Get (SEED+1)
1A37: 3C       [187]    	INC	A		; Add 1
1A38: E603     [194]    	AND	00000011B	; 0 to 3
1A3A: 0600     [201]    	LD	B,0
1A3C: FE01     [208]    	CP	1		; Is it zero?
1A3E: 88       [212]    	ADC	A,B		; Yes - Make it 1
1A3F: 325D80   [225]    	LD	(SEED+1),A	; Re-save seed
1A42: 21751A   [235]    	LD	HL,RNDTAB-4	; Addition table
1A45: 87       [239]    	ADD	A,A		; 4 bytes
1A46: 87       [243]    	ADD	A,A		; per entry
1A47: 4F       [247]    	LD	C,A		; BC = Offset into table
1A48: 09       [258]    	ADD	HL,BC		; Point to value
1A49: CD4314   [275]    	CALL	ADDPHL		; Add value to FPREG
1A4C: CDE416   [17]     RND1:	CALL	BCDEFP		; Move FPREG to BCDE
1A4F: 7B       [21]     	LD	A,E		; Get LSB
1A50: 59       [25]     	LD	E,C		; LSB = MSB
1A51: EE4F     [32]     	XOR	01001111B	; Fiddle around
1A53: 4F       [36]     	LD	C,A		; New MSB
1A54: 3680     [46]     	LD	(HL),80H	; Set exponent
1A56: 2B       [52]     	DEC	HL		; Point to MSB
1A57: 46       [59]     	LD	B,(HL)		; Get MSB
1A58: 3680     [69]     	LD	(HL),80H	; Make value -0.5
1A5A: 215C80   [79]     	LD	HL,SEED		; Random number seed
1A5D: 34       [90]     	INC	(HL)		; Count seed
1A5E: 7E       [97]     	LD	A,(HL)		; Get seed
1A5F: D6AB     [104]    	SUB	171		; Do it modulo 171
1A61: C2681A   [114|114]	JP	NZ,RND2		; Non-zero - Ok
1A64: 77       [121]    	LD	(HL),A		; Zero seed
1A65: 0C       [125]    	INC	C		; Fillde about
1A66: 15       [129]    	DEC	D		; with the
1A67: 1C       [133]    	INC	E		; number
1A68: CDA314   [17]     RND2:	CALL	BNORM		; Normalise number
1A6B: 217F80   [27]     	LD	HL,LSTRND	; Save random number
1A6E: C3F016   [37]     	JP	FPTHL		; Move FPREG to last and return
                        ;
1A71: 77       [ 7]     RESEED: LD	(HL),A		; Re-seed random numbers
1A72: 2B       [13]     	DEC	HL
1A73: 77       [20]     	LD	(HL),A
1A74: 2B       [26]     	DEC	HL
1A75: 77       [33]     	LD	(HL),A
1A76: C34C1A   [43]     	JP	RND1		; Return RND seed
                        ;
1A79: 68B14668          RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
1A7D: 99E99269          	DB	099H,0E9H,092H,069H
1A81: 10D17568          	DB	010H,0D1H,075H,068H
                        ;
1A85: 21CF1A   [10]     COS:	LD	HL,HALFPI	; Point to PI/2
1A88: CD4314   [27]     	CALL	ADDPHL		; Add it to PPREG
1A8B: CDC916   [17]     SIN:	CALL	STAKFP		; Put angle on stack
1A8E: 014983   [27]     	LD	BC,8349H	; BCDE = 2 PI
1A91: 11DB0F   [37]     	LD	DE,0FDBH
1A94: CDD916   [54]     	CALL	FPBCDE		; Move 2 PI to FPREG
1A97: C1       [64]     	POP	BC		; Restore angle
1A98: D1       [74]     	POP	DE
1A99: CDEE15   [91]     	CALL	DVBCDE		; Divide angle by 2 PI
1A9C: CDC916   [108]    	CALL	STAKFP		; Put it on stack
1A9F: CD6B17   [125]    	CALL	INT		; Get INT of result
1AA2: C1       [135]    	POP	BC		; Restore number
1AA3: D1       [145]    	POP	DE
1AA4: CD4F14   [162]    	CALL	SUBCDE		; Make it 0 <= value < 1
1AA7: 21D31A   [172]    	LD	HL,QUARTR	; Point to 0.25
1AAA: CD4914   [189]    	CALL	SUBPHL		; Subtract value from 0.25
1AAD: CD9816   [206]    	CALL	TSTSGN		; Test sign of value
1AB0: 37       [210]    	SCF			; Flag positive
1AB1: F2BB1A   [220|220]	JP	P,SIN1		; Positive - Ok
1AB4: CD4014   [237]    	CALL	ROUND		; Add 0.5 to value
1AB7: CD9816   [254]    	CALL	TSTSGN		; Test sign of value
1ABA: B7       [258]    	OR	A		; Flag negative
1ABB: F5       [11]     SIN1:	PUSH	AF		; Save sign
1ABC: F4C116   [21|28]  	CALL	P,INVSGN	; Negate value if positive
1ABF: 21D31A   [31]     	LD	HL,QUARTR	; Point to 0.25
1AC2: CD4314   [48]     	CALL	ADDPHL		; Add 0.25 to value
1AC5: F1       [58]     	POP	AF		; Restore sign
1AC6: D4C116   [68|75]  	CALL	NC,INVSGN	; Negative - Make positive
1AC9: 21D71A   [78]     	LD	HL,SINTAB	; Coefficient table
1ACC: C3E019   [88]     	JP	SUMSER		; Evaluate sum of series
                        ;
1ACF: DB0F4981          HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
                        ;
1AD3: 0000007F          QUARTR: DB	000H,000H,000H,07FH	; 0.25
                        ;
1AD7: 05                SINTAB: DB	5			; Table used by SIN
1AD8: BAD71E86          	DB	0BAH,0D7H,01EH,086H	; 39.711
1ADC: 64269987          	DB	064H,026H,099H,087H	;-76.575
1AE0: 58342387          	DB	058H,034H,023H,087H	; 81.602
1AE4: E05DA586          	DB	0E0H,05DH,0A5H,086H	;-41.342
1AE8: DA0F4983          	DB	0DAH,00FH,049H,083H	; 6.2832
                        ;
1AEC: CDC916   [17]     TAN:	CALL	STAKFP		; Put angle on stack
1AEF: CD8B1A   [34]     	CALL	SIN		; Get SIN of angle
1AF2: C1       [44]     	POP	BC		; Restore angle
1AF3: E1       [54]     	POP	HL
1AF4: CDC916   [71]     	CALL	STAKFP		; Save SIN of angle
1AF7: EB       [75]     	EX	DE,HL		; BCDE = Angle
1AF8: CDD916   [92]     	CALL	FPBCDE		; Angle to FPREG
1AFB: CD851A   [109]    	CALL	COS		; Get COS of angle
1AFE: C3EC15   [119]    	JP	DIV		; TAN = SIN / COS
                        ;
1B01: CD9816   [17]     ATN:	CALL	TSTSGN		; Test sign of value
1B04: FC2C19   [27|34]  	CALL	M,NEGAFT	; Negate result after if -ve
1B07: FCC116   [37|44]  	CALL	M,INVSGN	; Negate value if -ve
1B0A: 3A2C81   [50]     	LD	A,(FPEXP)	; Get exponent
1B0D: FE81     [57]     	CP	81H		; Number less than 1?
1B0F: DA1E1B   [67|67]  	JP	C,ATN1		; Yes - Get arc tangnt
1B12: 010081   [77]     	LD	BC,8100H	; BCDE = 1
1B15: 51       [81]     	LD	D,C
1B16: 59       [85]     	LD	E,C
1B17: CDEE15   [102]    	CALL	DVBCDE		; Get reciprocal of number
1B1A: 214914   [112]    	LD	HL,SUBPHL	; Sub angle from PI/2
1B1D: E5       [123]    	PUSH	HL		; Save for angle > 1
1B1E: 21281B   [10]     ATN1:	LD	HL,ATNTAB	; Coefficient table
1B21: CDE019   [27]     	CALL	SUMSER		; Evaluate sum of series
1B24: 21CF1A   [37]     	LD	HL,HALFPI	; PI/2 - angle in case > 1
1B27: C9       [47]     	RET			; Number > 1 - Sub from PI/2
                        ;
1B28: 09                ATNTAB: DB	9			; Table used by ATN
1B29: 4AD73B78          	DB	04AH,0D7H,03BH,078H	; 1/17
1B2D: 026E847B          	DB	002H,06EH,084H,07BH	;-1/15
1B31: FEC12F7C          	DB	0FEH,0C1H,02FH,07CH	; 1/13
1B35: 74319A7D          	DB	074H,031H,09AH,07DH	;-1/11
1B39: 843D5A7D          	DB	084H,03DH,05AH,07DH	; 1/9
1B3D: C87F917E          	DB	0C8H,07FH,091H,07EH	;-1/7
1B41: E4BB4C7E          	DB	0E4H,0BBH,04CH,07EH	; 1/5
1B45: 6CAAAA7F          	DB	06CH,0AAH,0AAH,07FH	;-1/3
1B49: 00000081          	DB	000H,000H,000H,081H	; 1/1
                        ;
                        
1B4D: C9       [10]     ARET:	RET			; A RETurn instruction
                        ;
1B4E: D7       [11]     GETINP: RST	10H		;input a character
1B4F: C9       [21]     	RET
                        ;
1B50:                   CLS: 
1B50: 3E0C     [ 7]     	LD	A,CS		; ASCII Clear screen
1B52: C3861C   [17]     	JP	MONOUT		; Output character
                        ;
1B55: CD1714   [17]     WIDTH:	CALL	GETINT		; Get integer 0-255
1B58: 7B       [21]     	LD	A,E		; Width to A
1B59: 328780   [34]     	LD	(LWIDTH),A	; Set width
1B5C: C9       [44]     	RET
                        ;
1B5D: CDB60C   [17]     LINES:	CALL	GETNUM		; Get a number
1B60: CDFB08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B63: ED538B80 [54]     	LD	(LINESC),DE	; Set lines counter
1B67: ED538D80 [74]     	LD	(LINESN),DE	; Set lines number
1B6B: C9       [84]     	RET
                        ;
1B6C: CDFB08   [17]     DEEK:	CALL	DEINT		; Get integer -32768 to 32767
1B6F: D5       [28]     	PUSH	DE		; Save number
1B70: E1       [38]     	POP	HL		; Number to HL
1B71: 46       [45]     	LD	B,(HL)		; Get LSB of contents
1B72: 23       [51]     	INC	HL
1B73: 7E       [58]     	LD	A,(HL)		; Get MSB of contents
1B74: C37110   [68]     	JP	ABPASS		; Return integer AB
                        ;
1B77: CDB60C   [17]     DOKE:	CALL	GETNUM		; Get a number
1B7A: CDFB08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B7D: D5       [45]     	PUSH	DE		; Save address
1B7E: CDBF06   [62]     	CALL	CHKSYN		; Make sure ',' follows
1B81: 2C                	DB	','
1B82: CDB60C   [79]     	CALL	GETNUM		; Get a number
1B85: CDFB08   [96]     	CALL	DEINT		; Get integer -32768 to 32767
1B88: E3       [115]    	EX	(SP),HL		; Save value,get address
1B89: 73       [122]    	LD	(HL),E		; Save LSB of value
1B8A: 23       [128]    	INC	HL
1B8B: 72       [135]    	LD	(HL),D		; Save MSB of value
1B8C: E1       [145]    	POP	HL		; Restore code string address
1B8D: C9       [155]    	RET
                        ;
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        ;
1B8E: CDB90C   [17]     HEX: 	CALL	TSTNUM		; Verify it's a number
1B91: CDFB08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B94: C5       [45]     	PUSH	BC		; Save contents of BC
1B95: 212E81   [55]     	LD	HL,PBUFF
1B98: 7A       [59]     	LD	A,D		; Get high order into A
1B99: FE00     [66]     	CP	0
1B9B: 280C     [73|78]  	JR	Z,HEX2		; Skip output if both high digits are zero
1B9D: CDC61B   [90]     	CALL	BYT2ASC		; Convert D to ASCII
1BA0: 78       [94]     	LD	A,B
1BA1: FE30     [101]    	CP	'0'
1BA3: 2802     [108|113]	JR	Z,HEX1		; Don't store high digit if zero
1BA5: 70       [115]    	LD	(HL),B		; Store it to PBUFF
1BA6: 23       [121]    	INC	HL		; Next location
1BA7: 71       [ 7]     HEX1:	LD	(HL),C		; Store C to PBUFF+1
1BA8: 23       [13]     	INC	HL		; Next location
1BA9: 7B       [ 4]     HEX2:	LD	A,E		; Get lower byte
1BAA: CDC61B   [21]     	CALL	BYT2ASC		; Convert E to ASCII
1BAD: 7A       [25]     	LD	A,D
1BAE: FE00     [32]     	CP	0
1BB0: 2005     [39|44]  	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
1BB2: 78       [43]     	LD	A,B
1BB3: FE30     [50]     	CP	'0'		; If high digit of lower byte is zero then don't print
1BB5: 2802     [57|62]  	JR	Z,HEX4
1BB7: 70       [ 7]     HEX3:	LD	(HL),B		; to PBUFF+2
1BB8: 23       [13]     	INC	HL		; Next location
1BB9: 71       [ 7]     HEX4:	LD	(HL),C		; to PBUFF+3
1BBA: 23       [13]     	INC	HL		; PBUFF+4 to zero
1BBB: AF       [17]     	XOR	A		; Terminating character
1BBC: 77       [24]     	LD	(HL),A		; Store zero to terminate
1BBD: 23       [30]     	INC	HL		; Make sure PBUFF is terminated
1BBE: 77       [37]     	LD	(HL),A		; Store the double zero there
1BBF: C1       [47]     	POP	BC		; Get BC back
1BC0: 212E81   [57]     	LD	HL,PBUFF	; Reset to start of PBUFF
1BC3: C31F11   [67]     	JP	STR1		; Convert the PBUFF to a string and return it
                        ;
1BC6: 47       [ 4]     BYT2ASC	LD	B,A		; Save original value
1BC7: E60F     [11]     	AND	0FH		; Strip off upper nybble
1BC9: FE0A     [18]     	CP	0AH		; 0-9?
1BCB: 3802     [25|30]  	JR	C,ADD30		; If A-F, add 7 more
1BCD: C607     [32]     	ADD	A,07H		; Bring value up to ASCII A-F
1BCF: C630     [ 7]     ADD30	ADD	A,30H		; And make ASCII
1BD1: 4F       [11]     	LD	C,A		; Save converted char to C
1BD2: 78       [15]     	LD	A,B		; Retrieve original value
1BD3: 0F       [19]     	RRCA			; and Rotate it right
1BD4: 0F       [23]     	RRCA
1BD5: 0F       [27]     	RRCA
1BD6: 0F       [31]     	RRCA
1BD7: E60F     [38]     	AND	0FH		; Mask off upper nybble
1BD9: FE0A     [45]     	CP	0AH		; 0-9? < A hex?
1BDB: 3802     [52|57]  	JR	C,ADD301	; Skip Add 7
1BDD: C607     [59]     	ADD	A,07H		; Bring it up to ASCII A-F
1BDF: C630     [ 7]     ADD301	ADD	A,30H		; And make it full ASCII
1BE1: 47       [11]     	LD	B,A		; Store high order byte
1BE2: C9       [21]     	RET	
                        ;
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
1BE3: EB       [ 4]     HEXTFP	EX	DE,HL		; Move code string pointer to DE
1BE4: 210000   [14]     	LD	HL,0000H	; Zero out the value
1BE7: CDFC1B   [31]     	CALL	GETHEX		; Check the number for valid hex
1BEA: DA1C1C   [41|41]  	JP	C,HXERR		; First value wasn't hex, HX error
1BED: 1805     [53]     	JR	HEXLP1		; Convert first character
1BEF: CDFC1B   [17]     HEXLP	CALL	GETHEX		; Get second and addtional characters
1BF2: 381F     [24|29]  	JR	C,HEXIT		; Exit if not a hex character
1BF4: 29       [11]     HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
1BF5: 29       [22]     	ADD	HL,HL
1BF6: 29       [33]     	ADD	HL,HL
1BF7: 29       [44]     	ADD	HL,HL
1BF8: B5       [48]     	OR	L		; Add in D0-D3 into L
1BF9: 6F       [52]     	LD	L,A		; Save new value
1BFA: 18F3     [64]     	JR	HEXLP		; And continue until all hex characters are in
                        ;
1BFC: 13       [ 6]     GETHEX	INC	DE		; Next location
1BFD: 1A       [13]     	LD	A,(DE)		; Load character at pointer
1BFE: FE20     [20]     	CP	' '
1C00: CAFC1B   [30|30]  	JP	Z,GETHEX	; Skip spaces
1C03: D630     [37]     	SUB	30H		; Get absolute value
1C05: D8       [42|48]  	RET	C		; < "0", error
1C06: FE0A     [49]     	CP	0AH
1C08: 3805     [56|61]  	JR	C,NOSUB7	; Is already in the range 0-9
1C0A: D607     [63]     	SUB	07H		; Reduce to A-F
1C0C: FE0A     [70]     	CP	0AH		; Value should be $0A-$0F at this point
1C0E: D8       [75|81]  	RET	C		; CY set if was :		; < = > ? @
1C0F: FE10     [ 7]     NOSUB7	CP	10H		; > Greater than "F"?
1C11: 3F       [11]     	CCF
1C12: C9       [21]     	RET			; CY set if it wasn't valid hex
                        	
1C13: EB       [ 4]     HEXIT	EX	DE,HL		; Value into DE, Code string into HL
1C14: 7A       [ 8]     	LD	A,D		; Load DE into AC
1C15: 4B       [12]     	LD	C,E		; For prep to 
1C16: E5       [23]     	PUSH	HL
1C17: CD7010   [40]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C1A: E1       [50]     	POP	HL
1C1B: C9       [60]     	RET
                        ;
1C1C: 1E26     [ 7]     HXERR:	LD	E,HX		; ?HEX Error
1C1E: C30504   [17]     	JP	ERROR
                        ;
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1C21: CDB90C   [17]     BIN:	CALL	TSTNUM		; Verify it's a number
1C24: CDFB08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1C27: C5       [11]     BIN2:	PUSH	BC		; Save contents of BC
1C28: 212E81   [21]     	LD	HL,PBUFF
1C2B: 0611     [28]     	LD	B,17		; One higher than max char count
1C2D:                   ZEROSUP:			; Suppress leading zeros
1C2D: 05       [ 4]     	DEC	B		; Max 16 chars
1C2E: 78       [ 8]     	LD	A,B
1C2F: FE01     [15]     	CP	01H
1C31: 2808     [22|27]  	JR	Z,BITOUT	; Always output at least one character
1C33: CB13     [30]     	RL	E
1C35: CB12     [38]     	RL	D
1C37: 30F4     [45|50]  	JR	NC,ZEROSUP
1C39: 1804     [57]     	JR	BITOUT2
1C3B:                   BITOUT:	
1C3B: CB13     [ 8]     	RL	E
1C3D: CB12     [16]     	RL	D		; Top bit now in carry
1C3F:                   BITOUT2:
1C3F: 3E30     [ 7]     	LD	A,'0'		; Char for '0'
1C41: CE00     [14]     	ADC	A,0		; If carry set then '0' --> '1'
1C43: 77       [21]     	LD	(HL),A
1C44: 23       [27]     	INC	HL
1C45: 05       [31]     	DEC	B
1C46: 20F3     [38|43]  	JR	NZ,BITOUT
1C48: AF       [42]     	XOR	A		; Terminating character
1C49: 77       [49]     	LD	(HL),A		; Store zero to terminate
1C4A: 23       [55]     	INC	HL		; Make sure PBUFF is terminated
1C4B: 77       [62]     	LD	(HL),A		; Store the double zero there
1C4C: C1       [72]     	POP	BC
1C4D: 212E81   [82]     	LD	HL,PBUFF
1C50: C31F11   [92]     	JP	STR1
                        ;
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1C53: EB       [ 4]     BINTFP: EX	DE,HL		; Move code string pointer to DE
1C54: 210000   [14]     	LD	HL,0000H	; Zero out the value
1C57: CD701C   [31]     	CALL	CHKBIN		; Check the number for valid bin
1C5A: DA7E1C   [41|41]  	JP	C,BINERR	; First value wasn't bin, HX error
1C5D: D630     [ 7]     BINIT:	SUB	'0'
1C5F: 29       [18]     	ADD	HL,HL		; Rotate HL left
1C60: B5       [22]     	OR	L
1C61: 6F       [26]     	LD	L,A
1C62: CD701C   [43]     	CALL	CHKBIN		; Get second and addtional characters
1C65: 30F6     [50|55]  	JR	NC,BINIT	; Process if a bin character
1C67: EB       [54]     	EX	DE,HL		; Value into DE, Code string into HL
1C68: 7A       [58]     	LD	A,D		; Load DE into AC
1C69: 4B       [62]     	LD	C,E		; For prep to 
1C6A: E5       [73]     	PUSH	HL
1C6B: CD7010   [90]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C6E: E1       [100]    	POP	HL
1C6F: C9       [110]    	RET
                        ;
                        ; Char is in A, NC if char is 0 or 1
1C70: 13       [ 6]     CHKBIN: INC	DE
1C71: 1A       [13]     	LD	A,(DE)
1C72: FE20     [20]     	CP	' '
1C74: CA701C   [30|30]  	JP	Z,CHKBIN	; Skip spaces
1C77: FE30     [37]     	CP	'0'		; Set C if < '0'
1C79: D8       [42|48]  	RET	C
1C7A: FE32     [49]     	CP	'2'
1C7C: 3F       [53]     	CCF			; Set C if > '1'
1C7D: C9       [63]     	RET
                        ;
1C7E: 1E28     [ 7]     BINERR: LD	E,BN		; ?BIN Error
1C80: C30504   [17]     	JP	ERROR
                        ;
1C83: C34A00   [10]     JJUMP1: JP	CSTART		; Go and initialise
                        ;
1C86: C30800   [10]     MONOUT: JP	0008H		; output a char
                        ;
1C89: C30000   [10]     MONITR: JP	0000H		; Restart (Normally Monitor Start)
                        ;
1C8C: 3E00     [ 7]     INITST: LD	A,0		; Clear break flag
1C8E: 329280   [20]     	LD	(BRKFLG),A
1C91: C35100   [30]     	JP	INIT
                        ;
1C94: F5       [11]     TSTBIT: PUSH	AF		; Save bit mask
1C95: A0       [15]     	AND	B		; Get common bits
1C96: C1       [25]     	POP	BC		; Restore bit mask
1C97: B8       [29]     	CP	B		; Same bit set?
1C98: 3E00     [36]     	LD	A,0		; Return 0 in A
1C9A: C9       [46]     	RET
                        ;
1C9B: CDCA06   [17]     OUTNCR: CALL	OUTC		; Output character in A
1C9E: C3F10A   [27]     	JP	PRCRLF		; Output CRLF
                        ;
                        	END


; +++ segments +++

#CODE          = $0000 =     0,  size = $1CA1 =  7329

; +++ global symbols +++

ABPASS  = $1071 =  4209          EMUZ80BASIC.ASM:2475
ABS     = $16BD =  5821          EMUZ80BASIC.ASM:3498
ACCSUM  = $08DA =  2266          EMUZ80BASIC.ASM:1377 (unused)
ACPASS  = $1070 =  4208          EMUZ80BASIC.ASM:2474
ADD30   = $1BCF =  7119          EMUZ80BASIC.ASM:4246
ADD301  = $1BDF =  7135          EMUZ80BASIC.ASM:4257
ADDEXP  = $1656 =  5718          EMUZ80BASIC.ASM:3433
ADDIG   = $17FC =  6140          EMUZ80BASIC.ASM:3721
ADDPHL  = $1443 =  5187          EMUZ80BASIC.ASM:3080
ALLFOL  = $133F =  4927          EMUZ80BASIC.ASM:2922
ANTVLU  = $0BDA =  3034          EMUZ80BASIC.ASM:1784
ARET    = $1B4D =  6989          EMUZ80BASIC.ASM:4161 (unused)
ARLDSV  = $0F91 =  3985          EMUZ80BASIC.ASM:2330
ARREND  = $811F = 33055          EMUZ80BASIC.ASM:174
ARRLP   = $120A =  4618          EMUZ80BASIC.ASM:2713
ASC     = $1310 =  4880          EMUZ80BASIC.ASM:2892
ASCTFP  = $179F =  6047          EMUZ80BASIC.ASM:3667
ASPCS   = $0B3C =  2876          EMUZ80BASIC.ASM:1707
ATN     = $1B01 =  6913          EMUZ80BASIC.ASM:4132
ATN1    = $1B1E =  6942          EMUZ80BASIC.ASM:4144
ATNTAB  = $1B28 =  6952          EMUZ80BASIC.ASM:4149
ATOH    = $0915 =  2325          EMUZ80BASIC.ASM:1410
BADINP  = $0B61 =  2913          EMUZ80BASIC.ASM:1719
BAKSTK  = $039A =   922          EMUZ80BASIC.ASM:585
BAKTMP  = $12F0 =  4848          EMUZ80BASIC.ASM:2870
BASTXT  = $80A3 = 32931          EMUZ80BASIC.ASM:150
BCDEFP  = $16E4 =  5860          EMUZ80BASIC.ASM:3525
BFREE   = $00CA =   202          EMUZ80BASIC.ASM:283
BIN     = $1C21 =  7201          EMUZ80BASIC.ASM:4306
BIN2    = $1C27 =  7207          EMUZ80BASIC.ASM:4308 (unused)
BINERR  = $1C7E =  7294          EMUZ80BASIC.ASM:4369
BINIT   = $1C5D =  7261          EMUZ80BASIC.ASM:4344
BINTFP  = $1C53 =  7251          EMUZ80BASIC.ASM:4340
BITOUT  = $1C3B =  7227          EMUZ80BASIC.ASM:4320
BITOUT2 = $1C3F =  7231          EMUZ80BASIC.ASM:4323
BKSP    = $0008 =     8          EMUZ80BASIC.ASM:107
BN      = $0028 =    40          EMUZ80BASIC.ASM:208
BNORM   = $14A3 =  5283          EMUZ80BASIC.ASM:3139
BNRMLP  = $14A6 =  5286          EMUZ80BASIC.ASM:3142
BRK     = $088C =  2188          EMUZ80BASIC.ASM:1332
BRKFLG  = $8092 = 32914          EMUZ80BASIC.ASM:143
BRKLIN  = $8113 = 33043          EMUZ80BASIC.ASM:168
BRKMSG  = $0394 =   916          EMUZ80BASIC.ASM:583
BRKRET  = $00BB =   187          EMUZ80BASIC.ASM:276
BS      = $0010 =    16          EMUZ80BASIC.ASM:196
BSERR   = $0FC4 =  4036          EMUZ80BASIC.ASM:2361
BUFFER  = $80A6 = 32934          EMUZ80BASIC.ASM:151
BYT2ASC = $1BC6 =  7110          EMUZ80BASIC.ASM:4241
BYTSFT  = $15DB =  5595          EMUZ80BASIC.ASM:3350
CFEVAL  = $0F27 =  3879          EMUZ80BASIC.ASM:2261
CHARTY  = $0ED5 =  3797          EMUZ80BASIC.ASM:2217
CHEKFN  = $1108 =  4360          EMUZ80BASIC.ASM:2566
CHKBIN  = $1C70 =  7280          EMUZ80BASIC.ASM:4359
CHKLTR  = $08E7 =  2279          EMUZ80BASIC.ASM:1386
CHKSTK  = $03CE =   974          EMUZ80BASIC.ASM:622
CHKSUM  = $808F = 32911          EMUZ80BASIC.ASM:141
CHKSYN  = $06BF =  1727          EMUZ80BASIC.ASM:1056
CHKTYP  = $0CBB =  3259          EMUZ80BASIC.ASM:1899
CHR     = $1321 =  4897          EMUZ80BASIC.ASM:2904
CLEAR   = $093A =  2362          EMUZ80BASIC.ASM:1434
CLOTST  = $06F4 =  1780          EMUZ80BASIC.ASM:1088
CLREG   = $0523 =  1315          EMUZ80BASIC.ASM:828
CLRPTR  = $04FE =  1278          EMUZ80BASIC.ASM:808
CLS     = $1B50 =  6992          EMUZ80BASIC.ASM:4166
CMPFP   = $172D =  5933          EMUZ80BASIC.ASM:3583
CMPLG1  = $0E3B =  3643          EMUZ80BASIC.ASM:2123
CMPLOG  = $0E39 =  3641          EMUZ80BASIC.ASM:2122
CMPNUM  = $1713 =  5907          EMUZ80BASIC.ASM:3566
CMPRES  = $0E7D =  3709          EMUZ80BASIC.ASM:2171
CMPSTR  = $0E65 =  3685          EMUZ80BASIC.ASM:2151
CN      = $0020 =    32          EMUZ80BASIC.ASM:204
CNVNUM  = $17AB =  6059          EMUZ80BASIC.ASM:3673
COLD    = $003D =    61          EMUZ80BASIC.ASM:210
COMMAN  = $8088 = 32904          EMUZ80BASIC.ASM:136
COMPL   = $1503 =  5379          EMUZ80BASIC.ASM:3213
CONCAT  = $1285 =  4741          EMUZ80BASIC.ASM:2803
CONEXP  = $17DB =  6107          EMUZ80BASIC.ASM:3697
CONIO   = $0001 =     1          EMUZ80BASIC.ASM:20
CONPOS  = $14A0 =  5280          EMUZ80BASIC.ASM:3137
CONSTA  = $0000 =     0          EMUZ80BASIC.ASM:19
CONT    = $08BF =  2239          EMUZ80BASIC.ASM:1360
CONTAD  = $8119 = 33049          EMUZ80BASIC.ASM:171
CONVAR  = $0DA6 =  3494          EMUZ80BASIC.ASM:2023
COPY    = $0059 =    89          EMUZ80BASIC.ASM:224
COS     = $1A85 =  6789          EMUZ80BASIC.ASM:4080
COUNT   = $0764 =  1892          EMUZ80BASIC.ASM:1154
CPDEHL  = $06B9 =  1721          EMUZ80BASIC.ASM:1049
CPYLIT  = $05F5 =  1525          EMUZ80BASIC.ASM:946
CR      = $000D =    13          EMUZ80BASIC.ASM:110
CRARLP  = $0FE4 =  4068          EMUZ80BASIC.ASM:2381
CREARY  = $0FC9 =  4041          EMUZ80BASIC.ASM:2364
CRESTR  = $0A39 =  2617          EMUZ80BASIC.ASM:1573
CRNCLP  = $0556 =  1366          EMUZ80BASIC.ASM:854
CRTMST  = $1141 =  4417          EMUZ80BASIC.ASM:2599
CRTST   = $114D =  4429          EMUZ80BASIC.ASM:2610
CRTSTE  = $1163 =  4451          EMUZ80BASIC.ASM:2624
CRUNCH  = $054D =  1357          EMUZ80BASIC.ASM:850
CS      = $000C =    12          EMUZ80BASIC.ASM:109
CSTART  = $004A =    74          EMUZ80BASIC.ASM:217
CTLOFG  = $808A = 32906          EMUZ80BASIC.ASM:138
CTRLC   = $0003 =     3          EMUZ80BASIC.ASM:105
CTRLG   = $0007 =     7          EMUZ80BASIC.ASM:106
CTRLO   = $000F =    15          EMUZ80BASIC.ASM:111
CTRLQ   = $0011 =    17          EMUZ80BASIC.ASM:112
CTRLR   = $0012 =    18          EMUZ80BASIC.ASM:113
CTRLS   = $0013 =    19          EMUZ80BASIC.ASM:114
CTRLU   = $0015 =    21          EMUZ80BASIC.ASM:115
CUROPR  = $810A = 33034          EMUZ80BASIC.ASM:162
CURPOS  = $80F0 = 33008          EMUZ80BASIC.ASM:153
DATA    = $09E0 =  2528          EMUZ80BASIC.ASM:1525
DATFLG  = $80F3 = 33011          EMUZ80BASIC.ASM:156
DATLIN  = $810E = 33038          EMUZ80BASIC.ASM:164
DATSNR  = $03EB =  1003          EMUZ80BASIC.ASM:642
DCBCDE  = $1764 =  5988          EMUZ80BASIC.ASM:3626
DDERR   = $03FA =  1018          EMUZ80BASIC.ASM:650
DEEK    = $1B6C =  7020          EMUZ80BASIC.ASM:4181
DEF     = $1085 =  4229          EMUZ80BASIC.ASM:2487
DEFSIZ  = $0FEC =  4076          EMUZ80BASIC.ASM:2385
DEINT   = $08FB =  2299          EMUZ80BASIC.ASM:1397
DEL     = $007F =   127          EMUZ80BASIC.ASM:117
DELCHR  = $0625 =  1573          EMUZ80BASIC.ASM:976
DEPINT  = $08F5 =  2293          EMUZ80BASIC.ASM:1395
DETHL4  = $16F3 =  5875          EMUZ80BASIC.ASM:3537
DETHLB  = $16F5 =  5877          EMUZ80BASIC.ASM:3538
DIGTXT  = $18A5 =  6309          EMUZ80BASIC.ASM:3819
DIM     = $0EA7 =  3751          EMUZ80BASIC.ASM:2197
DIMRET  = $0E9E =  3742          EMUZ80BASIC.ASM:2192
DINPOS  = $06EE =  1774          EMUZ80BASIC.ASM:1083
DIV     = $15EC =  5612          EMUZ80BASIC.ASM:3361
DIV1    = $804F = 32847          EMUZ80BASIC.ASM:126
DIV10   = $15E0 =  5600          EMUZ80BASIC.ASM:3356
DIV2    = $8053 = 32851          EMUZ80BASIC.ASM:127
DIV3    = $8057 = 32855          EMUZ80BASIC.ASM:128
DIV4    = $805A = 32858          EMUZ80BASIC.ASM:129
DIVLP   = $1613 =  5651          EMUZ80BASIC.ASM:3385
DIVSUP  = $804E = 32846          EMUZ80BASIC.ASM:125
DOAGN   = $053C =  1340          EMUZ80BASIC.ASM:841
DOCOM   = $0B0D =  2829          EMUZ80BASIC.ASM:1683
DODEL   = $0605 =  1541          EMUZ80BASIC.ASM:960
DOEBIT  = $18E5 =  6373          EMUZ80BASIC.ASM:3862
DOFN    = $10B2 =  4274          EMUZ80BASIC.ASM:2515
DOKE    = $1B77 =  7031          EMUZ80BASIC.ASM:4189
DONULL  = $0AFB =  2811          EMUZ80BASIC.ASM:1672
DOSPC   = $0B37 =  2871          EMUZ80BASIC.ASM:1704
DOTAB   = $0B24 =  2852          EMUZ80BASIC.ASM:1694
DPOINT  = $17D7 =  6103          EMUZ80BASIC.ASM:3695
DTSTR   = $1151 =  4433          EMUZ80BASIC.ASM:2613
DVBCDE  = $15EE =  5614          EMUZ80BASIC.ASM:3363
DZ      = $0014 =    20          EMUZ80BASIC.ASM:198
DZERR   = $03F4 =  1012          EMUZ80BASIC.ASM:646
ECHDEL  = $0619 =  1561          EMUZ80BASIC.ASM:969
EDIGIT  = $181E =  6174          EMUZ80BASIC.ASM:3744
ENDBUF  = $05FC =  1532          EMUZ80BASIC.ASM:952
ENDCON  = $17EA =  6122          EMUZ80BASIC.ASM:3707
ENDDIM  = $104B =  4171          EMUZ80BASIC.ASM:2454
ENDINP  = $0AEC =  2796          EMUZ80BASIC.ASM:1666
ENDNAM  = $0EC9 =  3785          EMUZ80BASIC.ASM:2213
ENDPRG  = $089B =  2203          EMUZ80BASIC.ASM:1343
ENFMEM  = $03D7 =   983          EMUZ80BASIC.ASM:628
ERRIN   = $0425 =  1061          EMUZ80BASIC.ASM:671
ERRLIN  = $8117 = 33047          EMUZ80BASIC.ASM:170
ERRMSG  = $0382 =   898          EMUZ80BASIC.ASM:579
ERROR   = $0405 =  1029          EMUZ80BASIC.ASM:658
ERRORS  = $02F8 =   760          EMUZ80BASIC.ASM:508
ESC     = $001B =    27          EMUZ80BASIC.ASM:116
EVAL    = $0CC8 =  3272          EMUZ80BASIC.ASM:1907
EVAL1   = $0CCB =  3275          EMUZ80BASIC.ASM:1909
EVAL2   = $0CD4 =  3284          EMUZ80BASIC.ASM:1913
EVAL3   = $0CD7 =  3287          EMUZ80BASIC.ASM:1914
EVLPAR  = $0D8D =  3469          EMUZ80BASIC.ASM:2009
EVNOT   = $0E87 =  3719          EMUZ80BASIC.ASM:2179
EXCUTE  = $0829 =  2089          EMUZ80BASIC.ASM:1265
EXP     = $197F =  6527          EMUZ80BASIC.ASM:3949
EXPLP   = $17C9 =  6089          EMUZ80BASIC.ASM:3687
EXPTAB  = $19BF =  6591          EMUZ80BASIC.ASM:3977
EXPTEN  = $18F7 =  6391          EMUZ80BASIC.ASM:3872
EXTIG   = $0C36 =  3126          EMUZ80BASIC.ASM:1832
FANDT   = $0C60 =  3168          EMUZ80BASIC.ASM:1850
FC      = $0008 =     8          EMUZ80BASIC.ASM:192
FCERR   = $0910 =  2320          EMUZ80BASIC.ASM:1407
FDTLP   = $0C47 =  3143          EMUZ80BASIC.ASM:1834
FINDEL  = $1027 =  4135          EMUZ80BASIC.ASM:2426
FLGDIF  = $16A3 =  5795          EMUZ80BASIC.ASM:3481
FLGREL  = $16AA =  5802          EMUZ80BASIC.ASM:3487
FNARG   = $8125 = 33061          EMUZ80BASIC.ASM:177
FNCTAB  = $0142 =   322          EMUZ80BASIC.ASM:294
FNDARY  = $0F97 =  3991          EMUZ80BASIC.ASM:2334
FNDELP  = $102C =  4140          EMUZ80BASIC.ASM:2431
FNDEND  = $04D1 =  1233          EMUZ80BASIC.ASM:771
FNDNUM  = $1414 =  5140          EMUZ80BASIC.ASM:3054
FNDTOK  = $0743 =  1859          EMUZ80BASIC.ASM:1134
FNDVAR  = $0F0E =  3854          EMUZ80BASIC.ASM:2245
FNDWRD  = $0580 =  1408          EMUZ80BASIC.ASM:874
FNOFST  = $0DB7 =  3511          EMUZ80BASIC.ASM:2033
FNRGNM  = $8123 = 33059          EMUZ80BASIC.ASM:176
FNTHR   = $0F1C =  3868          EMUZ80BASIC.ASM:2253
FNVAL   = $0DDE =  3550          EMUZ80BASIC.ASM:2055
FOPRND  = $0D00 =  3328          EMUZ80BASIC.ASM:1935
FOR     = $0790 =  1936          EMUZ80BASIC.ASM:1176
FORFLG  = $8110 = 33040          EMUZ80BASIC.ASM:165
FORFND  = $07C0 =  1984          EMUZ80BASIC.ASM:1204
FORSLP  = $07A4 =  1956          EMUZ80BASIC.ASM:1185
FPADD   = $1452 =  5202          EMUZ80BASIC.ASM:3088
FPBCDE  = $16D9 =  5849          EMUZ80BASIC.ASM:3517
FPEXP   = $812C = 33068          EMUZ80BASIC.ASM:179
FPINT   = $1740 =  5952          EMUZ80BASIC.ASM:3603
FPMULT  = $158D =  5517          EMUZ80BASIC.ASM:3299
FPREG   = $8129 = 33065          EMUZ80BASIC.ASM:178
FPROND  = $14EA =  5354          EMUZ80BASIC.ASM:3189
FPSINT  = $08EF =  2287          EMUZ80BASIC.ASM:1393
FPTHL   = $16F0 =  5872          EMUZ80BASIC.ASM:3536
FRE     = $104F =  4175          EMUZ80BASIC.ASM:2457
FRENUM  = $106B =  4203          EMUZ80BASIC.ASM:2469
FRMEVL  = $0DA9 =  3497          EMUZ80BASIC.ASM:2024
GARBGE  = $11D2 =  4562          EMUZ80BASIC.ASM:2686
GARBLP  = $11D5 =  4565          EMUZ80BASIC.ASM:2687
GETCHR  = $0849 =  2121          EMUZ80BASIC.ASM:1285
GETCMD  = $0449 =  1097          EMUZ80BASIC.ASM:688
GETHEX  = $1BFC =  7164          EMUZ80BASIC.ASM:4279
GETINP  = $1B4E =  6990          EMUZ80BASIC.ASM:4163
GETINT  = $1417 =  5143          EMUZ80BASIC.ASM:3055
GETLEN  = $1305 =  4869          EMUZ80BASIC.ASM:2884
GETLIN  = $0636 =  1590          EMUZ80BASIC.ASM:984
GETLN   = $0916 =  2326          EMUZ80BASIC.ASM:1411
GETNUM  = $0CB6 =  3254          EMUZ80BASIC.ASM:1896
GETNXT  = $059B =  1435          EMUZ80BASIC.ASM:889
GETSTR  = $12CF =  4815          EMUZ80BASIC.ASM:2850
GETVAR  = $0EAC =  3756          EMUZ80BASIC.ASM:2200
GNXARY  = $1209 =  4617          EMUZ80BASIC.ASM:2712
GOFUNC  = $0DE6 =  3558          EMUZ80BASIC.ASM:2059
GOSUB   = $098C =  2444          EMUZ80BASIC.ASM:1476
GOTO    = $099D =  2461          EMUZ80BASIC.ASM:1488
GRBARY  = $1229 =  4649          EMUZ80BASIC.ASM:2731
GRBDON  = $11AA =  4522          EMUZ80BASIC.ASM:2661
GRBLP   = $11E3 =  4579          EMUZ80BASIC.ASM:2693
GSTRCU  = $12D2 =  4818          EMUZ80BASIC.ASM:2851
GSTRDE  = $12D6 =  4822          EMUZ80BASIC.ASM:2853
GSTRHL  = $12D5 =  4821          EMUZ80BASIC.ASM:2852
GTFLNM  = $1314 =  4884          EMUZ80BASIC.ASM:2894 (unused)
GTFNAM  = $0EB1 =  3761          EMUZ80BASIC.ASM:2203
GTLNLP  = $0919 =  2329          EMUZ80BASIC.ASM:1412
GTSIXD  = $186F =  6255          EMUZ80BASIC.ASM:3788
GTVLUS  = $0BB2 =  2994          EMUZ80BASIC.ASM:1762
HALF    = $1916 =  6422          EMUZ80BASIC.ASM:3893
HALFPI  = $1ACF =  6863          EMUZ80BASIC.ASM:4111
HEX     = $1B8E =  7054          EMUZ80BASIC.ASM:4206
HEX1    = $1BA7 =  7079          EMUZ80BASIC.ASM:4219
HEX2    = $1BA9 =  7081          EMUZ80BASIC.ASM:4221
HEX3    = $1BB7 =  7095          EMUZ80BASIC.ASM:4229
HEX4    = $1BB9 =  7097          EMUZ80BASIC.ASM:4231
HEXIT   = $1C13 =  7187          EMUZ80BASIC.ASM:4294
HEXLP   = $1BEF =  7151          EMUZ80BASIC.ASM:4269
HEXLP1  = $1BF4 =  7156          EMUZ80BASIC.ASM:4271
HEXTFP  = $1BE3 =  7139          EMUZ80BASIC.ASM:4264
HX      = $0026 =    38          EMUZ80BASIC.ASM:207
HXERR   = $1C1C =  7196          EMUZ80BASIC.ASM:4302
ID      = $0016 =    22          EMUZ80BASIC.ASM:199
IDTEST  = $10FA =  4346          EMUZ80BASIC.ASM:2556
IF      = $0A6F =  2671          EMUZ80BASIC.ASM:1606
IFGO    = $0A7D =  2685          EMUZ80BASIC.ASM:1613
IFJMP   = $0830 =  2096          EMUZ80BASIC.ASM:1268
INCHL   = $16EE =  5870          EMUZ80BASIC.ASM:3533
INCLEN  = $06EA =  1770          EMUZ80BASIC.ASM:1081
INDFND  = $03B4 =   948          EMUZ80BASIC.ASM:604
INEWLN  = $0499 =  1177          EMUZ80BASIC.ASM:731
INIT    = $0051 =    81          EMUZ80BASIC.ASM:221
INITAB  = $0322 =   802          EMUZ80BASIC.ASM:532
INITBE  = $0382 =   898          EMUZ80BASIC.ASM:575
INITST  = $1C8C =  7308          EMUZ80BASIC.ASM:4378
INMSG   = $0389 =   905          EMUZ80BASIC.ASM:580
INP     = $13D4 =  5076          EMUZ80BASIC.ASM:3023
INPBIN  = $0C04 =  3076          EMUZ80BASIC.ASM:1806
INPBRK  = $0898 =  2200          EMUZ80BASIC.ASM:1341
INPORT  = $8084 = 32900          EMUZ80BASIC.ASM:133
INPSUB  = $8083 = 32899          EMUZ80BASIC.ASM:132
INPUT   = $0B72 =  2930          EMUZ80BASIC.ASM:1727
INRNG   = $1878 =  6264          EMUZ80BASIC.ASM:3793
INT     = $176B =  5995          EMUZ80BASIC.ASM:3634
INTVAR  = $050D =  1293          EMUZ80BASIC.ASM:819
INVSGN  = $16C1 =  5825          EMUZ80BASIC.ASM:3500
ITMSEP  = $0BF5 =  3061          EMUZ80BASIC.ASM:1797
JJUMP1  = $1C83 =  7299          EMUZ80BASIC.ASM:4372 (unused)
JSTZER  = $1901 =  6401          EMUZ80BASIC.ASM:3878
KBHIT   = $002B =    43          EMUZ80BASIC.ASM:57
KILFOR  = $0CA6 =  3238          EMUZ80BASIC.ASM:1887
KILIN   = $0630 =  1584          EMUZ80BASIC.ASM:981
LCRFLG  = $80F1 = 33009          EMUZ80BASIC.ASM:154
LEFT    = $1331 =  4913          EMUZ80BASIC.ASM:2912
LEN     = $1301 =  4865          EMUZ80BASIC.ASM:2882
LET     = $09F7 =  2551          EMUZ80BASIC.ASM:1541
LETNUM  = $0A4A =  2634          EMUZ80BASIC.ASM:1583
LETSTR  = $0A12 =  2578          EMUZ80BASIC.ASM:1554
LF      = $000A =    10          EMUZ80BASIC.ASM:108
LFRGNM  = $13CA =  5066          EMUZ80BASIC.ASM:3014
LINEAT  = $80A1 = 32929          EMUZ80BASIC.ASM:149
LINEIN  = $182A =  6186          EMUZ80BASIC.ASM:3754
LINES   = $1B5D =  7005          EMUZ80BASIC.ASM:4175
LINESC  = $808B = 32907          EMUZ80BASIC.ASM:139
LINESN  = $808D = 32909          EMUZ80BASIC.ASM:140
LINFND  = $0482 =  1154          EMUZ80BASIC.ASM:717
LIST    = $0705 =  1797          EMUZ80BASIC.ASM:1098
LISTLP  = $0711 =  1809          EMUZ80BASIC.ASM:1104
LOADFP  = $16E7 =  5863          EMUZ80BASIC.ASM:3526
LOG     = $154C =  5452          EMUZ80BASIC.ASM:3267
LOGTAB  = $153F =  5439          EMUZ80BASIC.ASM:3262
LOKFOR  = $039E =   926          EMUZ80BASIC.ASM:587
LOOPST  = $810C = 33036          EMUZ80BASIC.ASM:163
LS      = $001C =    28          EMUZ80BASIC.ASM:202
LSTBIN  = $8111 = 33041          EMUZ80BASIC.ASM:166
LSTLP2  = $0731 =  1841          EMUZ80BASIC.ASM:1125
LSTLP3  = $0734 =  1844          EMUZ80BASIC.ASM:1126
LSTRAM  = $80F4 = 33012          EMUZ80BASIC.ASM:157
LSTRND  = $807F = 32895          EMUZ80BASIC.ASM:131
LTSTND  = $0C0F =  3087          EMUZ80BASIC.ASM:1811
LWIDTH  = $8087 = 32903          EMUZ80BASIC.ASM:135
MAKINT  = $141A =  5146          EMUZ80BASIC.ASM:3056
MAKNUM  = $1894 =  6292          EMUZ80BASIC.ASM:3808
MANLP   = $17B3 =  6067          EMUZ80BASIC.ASM:3679
MATCH   = $05CD =  1485          EMUZ80BASIC.ASM:921
MEMMSG  = $0110 =   272          EMUZ80BASIC.ASM:289
MID     = $136B =  4971          EMUZ80BASIC.ASM:2952
MID1    = $1337 =  4919          EMUZ80BASIC.ASM:2916
MIDNUM  = $13CF =  5071          EMUZ80BASIC.ASM:3017
MINCDE  = $1492 =  5266          EMUZ80BASIC.ASM:3123
MINUS   = $0D95 =  3477          EMUZ80BASIC.ASM:2014
MKTMST  = $113E =  4414          EMUZ80BASIC.ASM:2598
MLDBLP  = $178C =  6028          EMUZ80BASIC.ASM:3655
MLDEBC  = $1784 =  6020          EMUZ80BASIC.ASM:3650
MLOOP   = $0071 =   113          EMUZ80BASIC.ASM:236
MLSP10  = $1681 =  5761          EMUZ80BASIC.ASM:3461
MO      = $0024 =    36          EMUZ80BASIC.ASM:206
MONITR  = $1C89 =  7305          EMUZ80BASIC.ASM:4376
MONOUT  = $1C86 =  7302          EMUZ80BASIC.ASM:4374
MORDT   = $0C1B =  3099          EMUZ80BASIC.ASM:1816
MORINP  = $063F =  1599          EMUZ80BASIC.ASM:989
MOVBUF  = $04B8 =  1208          EMUZ80BASIC.ASM:752
MOVDIR  = $05D5 =  1493          EMUZ80BASIC.ASM:929
MOVLP   = $03C3 =   963          EMUZ80BASIC.ASM:614
MOVSTR  = $03C0 =   960          EMUZ80BASIC.ASM:611
MOVUP   = $03BD =   957          EMUZ80BASIC.ASM:610
MRPRNT  = $0A8F =  2703          EMUZ80BASIC.ASM:1620
MSIZE   = $006E =   110          EMUZ80BASIC.ASM:235 (unused)
MUL8LP  = $15B8 =  5560          EMUZ80BASIC.ASM:3322
MULLN2  = $1584 =  5508          EMUZ80BASIC.ASM:3293
MULT    = $158B =  5515          EMUZ80BASIC.ASM:3297
MULT8   = $15AF =  5551          EMUZ80BASIC.ASM:3316
MULTEN  = $17F5 =  6133          EMUZ80BASIC.ASM:3715
MULVAL  = $813B = 33083          EMUZ80BASIC.ASM:182
MVSTPT  = $0A41 =  2625          EMUZ80BASIC.ASM:1577
NEDMOR  = $0BAE =  2990          EMUZ80BASIC.ASM:1760
NEGAFT  = $192C =  6444          EMUZ80BASIC.ASM:3902
NEMEM   = $00C1 =   193          EMUZ80BASIC.ASM:279
NEW     = $04FD =  1277          EMUZ80BASIC.ASM:807
NEXITM  = $0B47 =  2887          EMUZ80BASIC.ASM:1713
NEXT    = $0C6B =  3179          EMUZ80BASIC.ASM:1855
NEXT1   = $0C6E =  3182          EMUZ80BASIC.ASM:1856
NF      = $0000 =     0          EMUZ80BASIC.ASM:188
NFERR   = $03F7 =  1015          EMUZ80BASIC.ASM:648
NMIFLG  = $8091 = 32913          EMUZ80BASIC.ASM:142 (unused)
NOCHNG  = $05C5 =  1477          EMUZ80BASIC.ASM:916
NOENED  = $1904 =  6404          EMUZ80BASIC.ASM:3881
NOLIN   = $08AE =  2222          EMUZ80BASIC.ASM:1352
NOMADD  = $15C9 =  5577          EMUZ80BASIC.ASM:3333
NOMLAD  = $179A =  6042          EMUZ80BASIC.ASM:3663
NOPMPT  = $0B8C =  2956          EMUZ80BASIC.ASM:1739
NORMAL  = $14BD =  5309          EMUZ80BASIC.ASM:3158
NOSPC   = $05BC =  1468          EMUZ80BASIC.ASM:911
NOSUB7  = $1C0F =  7183          EMUZ80BASIC.ASM:4290
NOSWAP  = $146C =  5228          EMUZ80BASIC.ASM:3104
NOTAMP  = $0D6A =  3434          EMUZ80BASIC.ASM:1995
NOTSTR  = $0EE4 =  3812          EMUZ80BASIC.ASM:2225
NOXOR   = $13FA =  5114          EMUZ80BASIC.ASM:3040
NSCFOR  = $0EF4 =  3828          EMUZ80BASIC.ASM:2233
NULFLG  = $8089 = 32905          EMUZ80BASIC.ASM:137
NULL    = $08D2 =  2258          EMUZ80BASIC.ASM:1371
NULLP   = $0B02 =  2818          EMUZ80BASIC.ASM:1675
NULLS   = $8086 = 32902          EMUZ80BASIC.ASM:134
NUMASC  = $183D =  6205          EMUZ80BASIC.ASM:3764
NXTARY  = $0FAB =  4011          EMUZ80BASIC.ASM:2346
NXTBYT  = $05AB =  1451          EMUZ80BASIC.ASM:901
NXTCHR  = $05EC =  1516          EMUZ80BASIC.ASM:941
NXTDAT  = $8121 = 33057          EMUZ80BASIC.ASM:175
NXTDTA  = $09DF =  2527          EMUZ80BASIC.ASM:1523
NXTITM  = $0BA6 =  2982          EMUZ80BASIC.ASM:1755
NXTOPR  = $8115 = 33045          EMUZ80BASIC.ASM:169
NXTSTL  = $09E6 =  2534          EMUZ80BASIC.ASM:1528
NXTSTT  = $09E9 =  2537          EMUZ80BASIC.ASM:1531
OD      = $0006 =     6          EMUZ80BASIC.ASM:191
OKMSG   = $038E =   910          EMUZ80BASIC.ASM:582
OM      = $000C =    12          EMUZ80BASIC.ASM:194
OMERR   = $03E6 =   998          EMUZ80BASIC.ASM:639
ON      = $0A51 =  2641          EMUZ80BASIC.ASM:1589
ONGO    = $0A60 =  2656          EMUZ80BASIC.ASM:1597
ONGOLP  = $0A61 =  2657          EMUZ80BASIC.ASM:1598
ONJMP   = $0831 =  2097          EMUZ80BASIC.ASM:1269
OPNPAR  = $0CC4 =  3268          EMUZ80BASIC.ASM:1905
OPRND   = $0D3F =  3391          EMUZ80BASIC.ASM:1978
OS      = $001A =    26          EMUZ80BASIC.ASM:201
OTKLN   = $062D =  1581          EMUZ80BASIC.ASM:980
OTPORT  = $804C = 32844          EMUZ80BASIC.ASM:124
OUTC    = $06CA =  1738          EMUZ80BASIC.ASM:1064
OUTEXP  = $18F5 =  6389          EMUZ80BASIC.ASM:3871
OUTIT   = $06AB =  1707          EMUZ80BASIC.ASM:1042
OUTNBS  = $06B1 =  1713          EMUZ80BASIC.ASM:1045
OUTNCR  = $1C9B =  7323          EMUZ80BASIC.ASM:4389
OUTSUB  = $804B = 32843          EMUZ80BASIC.ASM:123
OUTWRD  = $074D =  1869          EMUZ80BASIC.ASM:1140
OV      = $000A =    10          EMUZ80BASIC.ASM:193
OVERR   = $0400 =  1024          EMUZ80BASIC.ASM:654
OVTST1  = $1674 =  5748          EMUZ80BASIC.ASM:3453
OVTST2  = $1679 =  5753          EMUZ80BASIC.ASM:3456
OVTST3  = $167A =  5754          EMUZ80BASIC.ASM:3457
PADD    = $1819 =  6169          EMUZ80BASIC.ASM:3740
PAND    = $0E00 =  3584          EMUZ80BASIC.ASM:2081
PASSA   = $1080 =  4224          EMUZ80BASIC.ASM:2483
PBUFF   = $812E = 33070          EMUZ80BASIC.ASM:181
PEEK    = $1428 =  5160          EMUZ80BASIC.ASM:3065
PEND    = $0893 =  2195          EMUZ80BASIC.ASM:1338
PHLTFP  = $16D6 =  5846          EMUZ80BASIC.ASM:3516
PLUCDE  = $14F7 =  5367          EMUZ80BASIC.ASM:3200
PNORM   = $14C5 =  5317          EMUZ80BASIC.ASM:3166
POINT   = $8096 = 32918          EMUZ80BASIC.ASM:145
POKE    = $142F =  5167          EMUZ80BASIC.ASM:3069
POPAF   = $11C4 =  4548          EMUZ80BASIC.ASM:2676
POPHL   = $12EE =  4846          EMUZ80BASIC.ASM:2867
POPHRT  = $15D9 =  5593          EMUZ80BASIC.ASM:3347
POPNOK  = $043B =  1083          EMUZ80BASIC.ASM:681
POR     = $0DFF =  3583          EMUZ80BASIC.ASM:2080
POR1    = $0E22 =  3618          EMUZ80BASIC.ASM:2104
POS     = $107D =  4221          EMUZ80BASIC.ASM:2482
POSINT  = $08F2 =  2290          EMUZ80BASIC.ASM:1394
POUT    = $13E0 =  5088          EMUZ80BASIC.ASM:3028
POWER   = $193A =  6458          EMUZ80BASIC.ASM:3910
POWER1  = $194A =  6474          EMUZ80BASIC.ASM:3918
POWER2  = $1967 =  6503          EMUZ80BASIC.ASM:3936
POWERS  = $191A =  6426          EMUZ80BASIC.ASM:3895
PRCRLF  = $0AF1 =  2801          EMUZ80BASIC.ASM:1668
PRINT   = $0A93 =  2707          EMUZ80BASIC.ASM:1622
PRITAB  = $02E3 =   739          EMUZ80BASIC.ASM:485
PRNTHL  = $1832 =  6194          EMUZ80BASIC.ASM:3758
PRNTLP  = $0A96 =  2710          EMUZ80BASIC.ASM:1623
PRNTNB  = $0AD9 =  2777          EMUZ80BASIC.ASM:1655
PRNTOK  = $043C =  1084          EMUZ80BASIC.ASM:683
PRNTST  = $0ADD =  2781          EMUZ80BASIC.ASM:1657
PRNUMS  = $118E =  4494          EMUZ80BASIC.ASM:2645
PROCES  = $0658 =  1624          EMUZ80BASIC.ASM:1000
PROGND  = $811B = 33051          EMUZ80BASIC.ASM:172
PROGST  = $813E = 33086          EMUZ80BASIC.ASM:183
PROMPT  = $0540 =  1344          EMUZ80BASIC.ASM:844
PRS     = $118F =  4495          EMUZ80BASIC.ASM:2646
PRS1    = $1192 =  4498          EMUZ80BASIC.ASM:2647
PRSLP   = $1199 =  4505          EMUZ80BASIC.ASM:2650
PSET    = $8099 = 32921          EMUZ80BASIC.ASM:146
PSUB    = $144D =  5197          EMUZ80BASIC.ASM:3085
PTRLP   = $04C5 =  1221          EMUZ80BASIC.ASM:761
PUTBUF  = $0697 =  1687          EMUZ80BASIC.ASM:1031
PUTCTL  = $069C =  1692          EMUZ80BASIC.ASM:1033
PUTFID  = $0805 =  2053          EMUZ80BASIC.ASM:1242
QTSTLP  = $1154 =  4436          EMUZ80BASIC.ASM:2615
QTSTR   = $114E =  4430          EMUZ80BASIC.ASM:2611
QUARTR  = $1AD3 =  6867          EMUZ80BASIC.ASM:4113
RD      = $0012 =    18          EMUZ80BASIC.ASM:197
READ    = $0BA1 =  2977          EMUZ80BASIC.ASM:1752
READFG  = $8112 = 33042          EMUZ80BASIC.ASM:167
REDO    = $0B4E =  2894          EMUZ80BASIC.ASM:1717
REM     = $09E2 =  2530          EMUZ80BASIC.ASM:1526
RESDIV  = $1626 =  5670          EMUZ80BASIC.ASM:3398
RESEED  = $1A71 =  6769          EMUZ80BASIC.ASM:4069
RESET   = $809C = 32924          EMUZ80BASIC.ASM:147
RESTNL  = $086E =  2158          EMUZ80BASIC.ASM:1308
RESTOR  = $0859 =  2137          EMUZ80BASIC.ASM:1297
RESZER  = $14B8 =  5304          EMUZ80BASIC.ASM:3154
RETADR  = $0F5B =  3931          EMUZ80BASIC.ASM:2293
RETINT  = $16AF =  5807          EMUZ80BASIC.ASM:3489
RETLIN  = $09DA =  2522          EMUZ80BASIC.ASM:1520
RETNAD  = $05D1 =  1489          EMUZ80BASIC.ASM:925
RETNUL  = $0F5E =  3934          EMUZ80BASIC.ASM:2297
RETNUM  = $0DA1 =  3489          EMUZ80BASIC.ASM:2019
RETREL  = $16A1 =  5793          EMUZ80BASIC.ASM:3479
RETURN  = $09BB =  2491          EMUZ80BASIC.ASM:1504
RG      = $0004 =     4          EMUZ80BASIC.ASM:190
RIGHT   = $1361 =  4961          EMUZ80BASIC.ASM:2945
RIGHT1  = $1335 =  4917          EMUZ80BASIC.ASM:2914
RINPUT  = $8093 = 32915          EMUZ80BASIC.ASM:144
RLTLP   = $0CE4 =  3300          EMUZ80BASIC.ASM:1921
RND     = $1A10 =  6672          EMUZ80BASIC.ASM:4016
RND1    = $1A4C =  6732          EMUZ80BASIC.ASM:4047
RND2    = $1A68 =  6760          EMUZ80BASIC.ASM:4065
RNDTAB  = $1A79 =  6777          EMUZ80BASIC.ASM:4076
RNGTST  = $1907 =  6407          EMUZ80BASIC.ASM:3885
ROMTOP  = $0000 =     0          EMUZ80BASIC.ASM:10
RONDB   = $14D9 =  5337          EMUZ80BASIC.ASM:3178
RONDUP  = $14D8 =  5336          EMUZ80BASIC.ASM:3177
ROUND   = $1440 =  5184          EMUZ80BASIC.ASM:3079
RSCALE  = $1813 =  6163          EMUZ80BASIC.ASM:3738
RSLNBK  = $0787 =  1927          EMUZ80BASIC.ASM:1172
RSTSTR  = $1384 =  4996          EMUZ80BASIC.ASM:2965
RUN     = $0980 =  2432          EMUZ80BASIC.ASM:1471
RUNCNT  = $0809 =  2057          EMUZ80BASIC.ASM:1246
RUNFST  = $0509 =  1289          EMUZ80BASIC.ASM:816
RUNLIN  = $099C =  2460          EMUZ80BASIC.ASM:1487
RXA     = $001B =    27          EMUZ80BASIC.ASM:41
SAVEXP  = $14B9 =  5305          EMUZ80BASIC.ASM:3155
SAVSTP  = $07FC =  2044          EMUZ80BASIC.ASM:1235
SAVSTR  = $1129 =  4393          EMUZ80BASIC.ASM:2582
SBSCPT  = $0F69 =  3945          EMUZ80BASIC.ASM:2303
SCALE   = $1517 =  5399          EMUZ80BASIC.ASM:3232
SCALLP  = $1519 =  5401          EMUZ80BASIC.ASM:3233
SCALMI  = $17DE =  6110          EMUZ80BASIC.ASM:3700
SCALPL  = $17F4 =  6132          EMUZ80BASIC.ASM:3714
SCNEND  = $1260 =  4704          EMUZ80BASIC.ASM:2772
SCPTLP  = $0F6F =  3951          EMUZ80BASIC.ASM:2307
SEARCH  = $0599 =  1433          EMUZ80BASIC.ASM:887
SEED    = $805C = 32860          EMUZ80BASIC.ASM:130
SETIO   = $1404 =  5124          EMUZ80BASIC.ASM:3047
SETLIN  = $075B =  1883          EMUZ80BASIC.ASM:1148
SETLIT  = $05E3 =  1507          EMUZ80BASIC.ASM:937
SETPTR  = $04C0 =  1216          EMUZ80BASIC.ASM:758
SETTOP  = $0080 =   128          EMUZ80BASIC.ASM:248
SFTPRG  = $048A =  1162          EMUZ80BASIC.ASM:721
SGN     = $16A7 =  5799          EMUZ80BASIC.ASM:3486
SGNEXP  = $0DEF =  3567          EMUZ80BASIC.ASM:2067
SGNRES  = $812D = 33069          EMUZ80BASIC.ASM:180
SHRITE  = $1526 =  5414          EMUZ80BASIC.ASM:3241
SHRLP   = $1529 =  5417          EMUZ80BASIC.ASM:3243
SHRT1   = $152D =  5421          EMUZ80BASIC.ASM:3247
SIGNON  = $00D9 =   217          EMUZ80BASIC.ASM:285
SIGNS   = $16FE =  5886          EMUZ80BASIC.ASM:3546
SIN     = $1A8B =  6795          EMUZ80BASIC.ASM:4082
SIN1    = $1ABB =  6843          EMUZ80BASIC.ASM:4102
SINIT   = $003A =    58          EMUZ80BASIC.ASM:79
SINTAB  = $1AD7 =  6871          EMUZ80BASIC.ASM:4115
SIXDIG  = $185A =  6234          EMUZ80BASIC.ASM:3778
SMPVAR  = $11F4 =  4596          EMUZ80BASIC.ASM:2700
SMSER1  = $19EF =  6639          EMUZ80BASIC.ASM:3994
SN      = $0002 =     2          EMUZ80BASIC.ASM:189
SNERR   = $03F1 =  1009          EMUZ80BASIC.ASM:644
SPCFST  = $184B =  6219          EMUZ80BASIC.ASM:3770
SPCLP   = $0B40 =  2880          EMUZ80BASIC.ASM:1710
SQR     = $1931 =  6449          EMUZ80BASIC.ASM:3906
SRCHLN  = $04DD =  1245          EMUZ80BASIC.ASM:780
SRCHLP  = $04E0 =  1248          EMUZ80BASIC.ASM:781
SSTSA   = $12BC =  4796          EMUZ80BASIC.ASM:2832
ST      = $001E =    30          EMUZ80BASIC.ASM:203
STACK   = $80AB = 32939          EMUZ80BASIC.ASM:152
STAKFP  = $16C9 =  5833          EMUZ80BASIC.ASM:3506
STALL   = $0882 =  2178          EMUZ80BASIC.ASM:1325
STARTB  = $0043 =    67          EMUZ80BASIC.ASM:212
STKTHS  = $0D28 =  3368          EMUZ80BASIC.ASM:1962
STLOOK  = $81A2 = 33186          EMUZ80BASIC.ASM:184
STOP    = $0891 =  2193          EMUZ80BASIC.ASM:1336
STORED  = $095D =  2397          EMUZ80BASIC.ASM:1451
STPOOL  = $1237 =  4663          EMUZ80BASIC.ASM:2737
STR     = $1119 =  4377          EMUZ80BASIC.ASM:2575
STR1    = $111F =  4383          EMUZ80BASIC.ASM:2577
STRADD  = $123A =  4666          EMUZ80BASIC.ASM:2739
STRBOT  = $8108 = 33032          EMUZ80BASIC.ASM:161
STRENT  = $0BF8 =  3064          EMUZ80BASIC.ASM:1799
STRSPC  = $809F = 32927          EMUZ80BASIC.ASM:148
STTLIN  = $0AE4 =  2788          EMUZ80BASIC.ASM:1661
SUBCDE  = $144F =  5199          EMUZ80BASIC.ASM:3087
SUBPHL  = $1449 =  5193          EMUZ80BASIC.ASM:3083
SUMLP   = $19F8 =  6648          EMUZ80BASIC.ASM:3999
SUMSER  = $19E0 =  6624          EMUZ80BASIC.ASM:3987
SUPTLZ  = $18D9 =  6361          EMUZ80BASIC.ASM:3855
SVNAM2  = $0EC8 =  3784          EMUZ80BASIC.ASM:2212
SVSTAD  = $1147 =  4423          EMUZ80BASIC.ASM:2603
TAN     = $1AEC =  6892          EMUZ80BASIC.ASM:4122
TESTOS  = $11C6 =  4550          EMUZ80BASIC.ASM:2679
TESTR   = $11A8 =  4520          EMUZ80BASIC.ASM:2659
TM      = $0018 =    24          EMUZ80BASIC.ASM:200
TMERR   = $0403 =  1027          EMUZ80BASIC.ASM:656
TMPSTR  = $8104 = 33028          EMUZ80BASIC.ASM:160
TMSTPL  = $80F8 = 33016          EMUZ80BASIC.ASM:159
TMSTPT  = $80F6 = 33014          EMUZ80BASIC.ASM:158
TOPOOL  = $132D =  4909          EMUZ80BASIC.ASM:2909
TOSTRA  = $12C5 =  4805          EMUZ80BASIC.ASM:2841
TRYAGN  = $18B4 =  6324          EMUZ80BASIC.ASM:3828
TSALP   = $12C6 =  4806          EMUZ80BASIC.ASM:2842
TSTACK  = $F000 = 61440          EMUZ80BASIC.ASM:13
TSTBIT  = $1C94 =  7316          EMUZ80BASIC.ASM:4382 (unused)
TSTBRK  = $0874 =  2164          EMUZ80BASIC.ASM:1314
TSTNUM  = $0CB9 =  3257          EMUZ80BASIC.ASM:1897
TSTOPL  = $116F =  4463          EMUZ80BASIC.ASM:2631
TSTRED  = $0E27 =  3623          EMUZ80BASIC.ASM:2110
TSTREM  = $05E6 =  1510          EMUZ80BASIC.ASM:938
TSTSGN  = $1698 =  5784          EMUZ80BASIC.ASM:3474
TSTSTR  = $0CBA =  3258          EMUZ80BASIC.ASM:1898
TTYLIN  = $0636 =  1590          EMUZ80BASIC.ASM:985
TXA     = $0030 =    48          EMUZ80BASIC.ASM:65
TXAST1  = $0031 =    49          EMUZ80BASIC.ASM:66
TYPE    = $80F2 = 33010          EMUZ80BASIC.ASM:155
UF      = $0022 =    34          EMUZ80BASIC.ASM:205
UFERR   = $03FD =  1021          EMUZ80BASIC.ASM:652
UL      = $000E =    14          EMUZ80BASIC.ASM:195
ULERR   = $09B6 =  2486          EMUZ80BASIC.ASM:1501
UNITY   = $153B =  5435          EMUZ80BASIC.ASM:3260
UPDATA  = $086F =  2159          EMUZ80BASIC.ASM:1309
USR     = $8048 = 32840          EMUZ80BASIC.ASM:122
VAL     = $139B =  5019          EMUZ80BASIC.ASM:2984
VAL1    = $13B9 =  5049          EMUZ80BASIC.ASM:3004
VAL2    = $13C3 =  5059          EMUZ80BASIC.ASM:3008
VAL3    = $13C6 =  5062          EMUZ80BASIC.ASM:3009
VAREND  = $811D = 33053          EMUZ80BASIC.ASM:173
WAIT    = $13E6 =  5094          EMUZ80BASIC.ASM:3031
WAITLP  = $13FB =  5115          EMUZ80BASIC.ASM:3041
WARM    = $0040 =    64          EMUZ80BASIC.ASM:211 (unused)
WARMST  = $00B8 =   184          EMUZ80BASIC.ASM:275
WIDTH   = $1B55 =  6997          EMUZ80BASIC.ASM:4170
WORDS   = $017A =   378          EMUZ80BASIC.ASM:325
WORDTB  = $0299 =   665          EMUZ80BASIC.ASM:414
WRKSPC  = $8045 = 32837          EMUZ80BASIC.ASM:121
XXXXX   = $00C7 =   199          EMUZ80BASIC.ASM:281
ZDATA   = $0083 =   131          EMUZ80BASIC.ASM:456
ZDIV    = $00AF =   175          EMUZ80BASIC.ASM:474 (unused)
ZEND    = $0080 =   128          EMUZ80BASIC.ASM:454
ZEQUAL  = $00B4 =   180          EMUZ80BASIC.ASM:477
ZERARY  = $100A =  4106          EMUZ80BASIC.ASM:2406
ZERBYT  = $038D =   909          EMUZ80BASIC.ASM:581
ZEROLP  = $0F4D =  3917          EMUZ80BASIC.ASM:2284
ZEROSUP = $1C2D =  7213          EMUZ80BASIC.ASM:4311
ZFN     = $00A7 =   167          EMUZ80BASIC.ASM:465
ZFOR    = $0081 =   129          EMUZ80BASIC.ASM:455
ZGOSUB  = $008C =   140          EMUZ80BASIC.ASM:458
ZGOTO   = $0088 =   136          EMUZ80BASIC.ASM:457
ZGTR    = $00B3 =   179          EMUZ80BASIC.ASM:476
ZLEFT   = $00CF =   207          EMUZ80BASIC.ASM:481
ZLTH    = $00B5 =   181          EMUZ80BASIC.ASM:478
ZMINUS  = $00AD =   173          EMUZ80BASIC.ASM:472
ZNEW    = $00A4 =   164          EMUZ80BASIC.ASM:461
ZNOT    = $00AA =   170          EMUZ80BASIC.ASM:468
ZONELP  = $0B1B =  2843          EMUZ80BASIC.ASM:1689
ZOR     = $00B2 =   178          EMUZ80BASIC.ASM:475
ZPLUS   = $00AC =   172          EMUZ80BASIC.ASM:471
ZPOINT  = $00C7 =   199          EMUZ80BASIC.ASM:480 (unused)
ZPRINT  = $009E =   158          EMUZ80BASIC.ASM:460
ZREM    = $008E =   142          EMUZ80BASIC.ASM:459
ZSGN    = $00B6 =   182          EMUZ80BASIC.ASM:479
ZSPC    = $00A8 =   168          EMUZ80BASIC.ASM:466
ZSTEP   = $00AB =   171          EMUZ80BASIC.ASM:469
ZTAB    = $00A5 =   165          EMUZ80BASIC.ASM:463
ZTHEN   = $00A9 =   169          EMUZ80BASIC.ASM:467
ZTIMES  = $00AE =   174          EMUZ80BASIC.ASM:473 (unused)
ZTO     = $00A6 =   166          EMUZ80BASIC.ASM:464
_end    = $1CA1 =  7329          EMUZ80BASIC.ASM:23 (unused)
_size   = $1CA1 =  7329          EMUZ80BASIC.ASM:23 (unused)


total time: 0.0122 sec.
no errors
