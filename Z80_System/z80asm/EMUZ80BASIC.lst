                        ; --------------------------------------
                        ; zasm: assemble "EMUZ80BASIC.ASM"
                        ; date: 2025-09-28 13:41:26
                        ; --------------------------------------


                        ;	EMUBASIC based on GRANT's BASIC
                        ;	TARGET: EMUZ80
                        ;	ASSEMBLER: ARCPIT XZ80.EXE
                        ;
                        ;	START UP ROUTINE
                        ;	VERSION 1.0, 2022/02/15
                        ;	WRITTEN by TETSUYA SUZUKI
                        ;
                        ;	MEMORY ASIGN
0000:                   ROMTOP	EQU	0000H
8000:                   RAMTOP	EQU	8000H
1000:                   RAMSIZ	EQU	1000H
80ED:                   TSTACK	EQU	80EDH
                        ;
                        ;	UART REGISTER ADDRESS
                        ; UARTDR	EQU	0E000H	; UART DATA REGISTOR  --> out (CONIO), a / out (CONIN), a
                        ; UARTCR	EQU	0E001H	; UART CONTROL REGISTOR. --> in a, (ONST)
                        ;
0000:                   CONST	EQU 	$00
0001:                   CONIO	EQU 	$01
                        
                        ;	RESET (RST 00H)
0000:                   	ORG	ROMTOP
0000: F3       [ 4]     	DI
0001: 31ED80   [14]     	LD	SP,TSTACK
0004: C33C00   [24]     	JP	SINIT
                        ;
                        ;	PUT 1CHAR (RST 08H)
                        	ORG	ROMTOP+08H
0008: C33100   [34]     	JP	TXA
                        ;
                        ;	GET 1CHAR (RST 10H)
                        	ORG	ROMTOP+10H
0010: C31B00   [44]     	JP	RXA
                        ;
                        ;	KBHIT (RST 18H)
                        	ORG	ROMTOP+18H
0018: C32C00   [54]     	JP	KBHIT
                        ;
                        ;	UART -> A
001B:                   RXA:
001B: DB00     [11]     	in 	a, (CONST)
                        	;LD	A,(UARTCR)
001D: CB47     [19]     	BIT	0,A
001F: 28FA     [26|31]  	JR	Z,RXA
0021: DB01     [37]     	in 	a, (CONIO)
                        	;LD	A,(UARTDR)
0023: FE61     [44]     	CP	'a'
0025: D8       [49|55]  	RET	C
0026: FE7B     [56]     	CP	'z'+1
0028: D0       [61|67]  	RET	NC
0029: E6DF     [68]     	AND	0DFH
002B: C9       [78]     	RET
                        ;
                        ;	CHECK RECEIVE STATUS
002C:                   KBHIT:	
002C: DB00     [11]     	in 	a, (CONST)
                        	;LD	A,(UARTCR)
002E: CB47     [19]     	BIT	0,A
0030: C9       [29]     	RET
                        ;
                        ;	A -> UART
0031: F5       [11]     TXA:	PUSH	AF
0032:                   TXAST1:	
0032: DB00     [11]     	in 	a, (CONST)
                        	;LD	A,(UARTCR)
0034: CB4F     [19]     	BIT	1,A
0036: 28FA     [26|31]  	JR	Z,TXAST1
0038: F1       [36]     	POP	AF
0039: D301     [47]     	out (CONIO), a
                        	;LD	(UARTDR),A
003B: C9       [57]     	RET
                        ;
                        ;
                        ;	SYSTEM INITIALIZE
003C:                   SINIT:
003C: C33F00   [10]     	JP	COLD
                        ;
                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        ;
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        ;
                        ; GENERAL EQUATES
                        ;
0003:                   CTRLC	EQU	03H		; Control "C"
0007:                   CTRLG	EQU	07H		; Control "G"
0008:                   BKSP	EQU	08H		; Back space
000A:                   LF	EQU	0AH		; Line feed
000C:                   CS	EQU	0CH		; Clear screen
000D:                   CR	EQU	0DH		; Carriage return
000F:                   CTRLO	EQU	0FH		; Control "O"
0011:                   CTRLQ	EQU	11H		; Control "Q"
0012:                   CTRLR	EQU	12H		; Control "R"
0013:                   CTRLS	EQU	13H		; Control "S"
0015:                   CTRLU	EQU	15H		; Control "U"
001B:                   ESC	EQU	1BH		; Escape
007F:                   DEL	EQU	7FH		; Delete
                        ;
                        ; BASIC WORK SPACE LOCATIONS
                        ;
8045:                   WRKSPC	EQU	8045H		; BASIC Work space
8048:                   USR	EQU	WRKSPC+3H	; "USR (x)" jump
804B:                   OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
804C:                   OTPORT	EQU	WRKSPC+7H	; Port (p)
804E:                   DIVSUP	EQU	WRKSPC+9H	; Division support routine
804F:                   DIV1	EQU	WRKSPC+0AH	; <- Values
8053:                   DIV2	EQU	WRKSPC+0EH	; <- to
8057:                   DIV3	EQU	WRKSPC+12H	; <- be
805A:                   DIV4	EQU	WRKSPC+15H	; <- inserted
805C:                   SEED	EQU	WRKSPC+17H	; Random number seed
807F:                   LSTRND	EQU	WRKSPC+3AH	; Last random number
8083:                   INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
8084:                   INPORT	EQU	WRKSPC+3FH	; PORT (x)
8086:                   NULLS	EQU	WRKSPC+41H	; Number of nulls
8087:                   LWIDTH	EQU	WRKSPC+42H	; Terminal width
8088:                   COMMAN	EQU	WRKSPC+43H	; Width for commas
8089:                   NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
808A:                   CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
808B:                   LINESC	EQU	WRKSPC+46H	; Lines counter
808D:                   LINESN	EQU	WRKSPC+48H	; Lines number
808F:                   CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
8091:                   NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
8092:                   BRKFLG	EQU	WRKSPC+4DH	; Break flag
8093:                   RINPUT	EQU	WRKSPC+4EH	; Input reflection
8096:                   POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
8099:                   PSET	EQU	WRKSPC+54H	; "SET"	reflection
809C:                   RESET	EQU	WRKSPC+57H	; "RESET" reflection
809F:                   STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
80A1:                   LINEAT	EQU	WRKSPC+5CH	; Current line number
80A3:                   BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
80A6:                   BUFFER	EQU	WRKSPC+61H	; Input buffer
80AB:                   STACK	EQU	WRKSPC+66H	; Initial stack
80F0:                   CURPOS	EQU	WRKSPC+0ABH	; Character position on line
80F1:                   LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
80F2:                   TYPE	EQU	WRKSPC+0ADH	; Data type flag
80F3:                   DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
80F4:                   LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
80F6:                   TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
80F8:                   TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
8104:                   TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
8108:                   STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
810A:                   CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
810C:                   LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
810E:                   DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
8110:                   FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
8111:                   LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
8112:                   READFG	EQU	WRKSPC+0CDH	; Read/Input flag
8113:                   BRKLIN	EQU	WRKSPC+0CEH	; Line of break
8115:                   NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
8117:                   ERRLIN	EQU	WRKSPC+0D2H	; Line of error
8119:                   CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
811B:                   PROGND	EQU	WRKSPC+0D6H	; End of program
811D:                   VAREND	EQU	WRKSPC+0D8H	; End of variables
811F:                   ARREND	EQU	WRKSPC+0DAH	; End of arrays
8121:                   NXTDAT	EQU	WRKSPC+0DCH	; Next data item
8123:                   FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
8125:                   FNARG	EQU	WRKSPC+0E0H	; FN argument value
8129:                   FPREG	EQU	WRKSPC+0E4H	; Floating point register
812C:                   FPEXP	EQU	FPREG+3		; Floating point exponent
812D:                   SGNRES	EQU	WRKSPC+0E8H	; Sign of result
812E:                   PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
813B:                   MULVAL	EQU	WRKSPC+0F6H	; Multiplier
813E:                   PROGST	EQU	WRKSPC+0F9H	; Start of program text area
81A2:                   STLOOK	EQU	WRKSPC+15DH	; Start of memory test
                        ;
                        ; BASIC ERROR CODE VALUES
                        ;
0000:                   NF	EQU	00H		; NEXT without FOR
0002:                   SN	EQU	02H		; Syntax error
0004:                   RG	EQU	04H		; RETURN without GOSUB
0006:                   OD	EQU	06H		; Out of DATA
0008:                   FC	EQU	08H		; Function call error
000A:                   OV	EQU	0AH		; Overflow
000C:                   OM	EQU	0CH		; Out of memory
000E:                   UL	EQU	0EH		; Undefined line number
0010:                   BS	EQU	10H		; Bad subscript
0012:                   RD	EQU	12H		; Re-DIMensioned array
0014:                   DZ	EQU	14H		; Division by zero (/0)
0016:                   ID	EQU	16H		; Illegal direct
0018:                   TM	EQU	18H		; Type miss-match
001A:                   OS	EQU	1AH		; Out of string space
001C:                   LS	EQU	1CH		; String too long
001E:                   ST	EQU	1EH		; String formula too complex
0020:                   CN	EQU	20H		; Can't CONTinue
0022:                   UF	EQU	22H		; UnDEFined FN function
0024:                   MO	EQU	24H		; Missing operand
0026:                   HX	EQU	26H		; HEX error
0028:                   BN	EQU	28H		; BIN error
                        ;
003F: C34500   [10]     COLD:	JP	STARTB		; Jump for cold start
0042: C3BA00   [10]     WARM:	JP	WARMST		; Jump for warm start
0045: C34C00   [10]     STARTB: JP	CSTART		; Jump to initialise
                        ;
0048: FD08              	DW	DEINT		; Get integer -32768 to 32767
004A: 7310              	DW	ABPASS		; Return integer in AB
                        ;
004C: 214580   [10]     CSTART: LD	HL,WRKSPC	; Start of workspace RAM
004F: F9       [16]     	LD	SP,HL		; Set up a temporary stack
0050: C38E1C   [26]     	JP	INITST		; Go to initialise
                        ;
0053: 112403   [10]     INIT:	LD	DE,INITAB	; Initialise workspace
0056: 0663     [17]     	LD	B,INITBE-INITAB+3; Bytes to copy
0058: 214580   [27]     	LD	HL,WRKSPC	; Into workspace RAM
005B: 1A       [ 7]     COPY:	LD	A,(DE)		; Get source
005C: 77       [14]     	LD	(HL),A		; To destination
005D: 23       [20]     	INC	HL		; Next destination
005E: 13       [26]     	INC	DE		; Next source
005F: 05       [30]     	DEC	B		; Count bytes
0060: C25B00   [40|40]  	JP	NZ,COPY		; More to move
0063: F9       [46]     	LD	SP,HL		; Temporary stack
0064: CD2505   [63]     	CALL	CLREG		; Clear registers and stack
0067: CDF30A   [80]     	CALL	PRCRLF		; Output CRLF
006A: 32EF80   [93]     	LD	(BUFFER+72+1),A	; Mark end of buffer
006D: 323E81   [106]    	LD	(PROGST),A	; Initialise program area
0070: 21A281   [10]     MSIZE:	LD	HL,STLOOK	; Point to start of RAM
0073: 23       [ 6]     MLOOP:	INC	HL		; Next byte
0074: 7C       [10]     	LD	A,H		; Above address FFFF ?
0075: B5       [14]     	OR	L
0076: CA8200   [24|24]  	JP	Z,SETTOP	; Yes - 64K RAM
0079: 7E       [31]     	LD	A,(HL)		; Get contents
007A: 47       [35]     	LD	B,A		; Save it
007B: 2F       [39]     	CPL			; Flip all bits
007C: 77       [46]     	LD	(HL),A		; Put it back
007D: BE       [53]     	CP	(HL)		; RAM there if same
007E: 70       [60]     	LD	(HL),B		; Restore old contents
007F: CA7300   [70|70]  	JP	Z,MLOOP		; If RAM - test next byte
                        ;
0082: 2B       [ 6]     SETTOP: DEC	HL		; Back one byte
0083: 11A181   [16]     	LD	DE,STLOOK-1	; See if enough RAM
0086: CDBB06   [33]     	CALL	CPDEHL		; Compare DE with HL
0089: DAC300   [43|43]  	JP	C,NEMEM		; If not enough RAM
008C: 11CEFF   [53]     	LD	DE,0-50		; 50 Bytes string space
008F: 22F480   [69]     	LD	(LSTRAM),HL	; Save last available RAM
0092: 19       [80]     	ADD	HL,DE		; Allocate string space
0093: 229F80   [96]     	LD	(STRSPC),HL	; Save string space
0096: CD0005   [113]    	CALL	CLRPTR		; Clear program area
0099: 2A9F80   [129]    	LD	HL,(STRSPC)	; Get end of memory
009C: 11EFFF   [139]    	LD	DE,0-17		; Offset for free bytes
009F: 19       [150]    	ADD	HL,DE		; Adjust HL
00A0: 113E81   [160]    	LD	DE,PROGST	; Start of program text
00A3: 7D       [164]    	LD	A,L		; Get LSB
00A4: 93       [168]    	SUB	E		; Adjust it
00A5: 6F       [172]    	LD	L,A		; Re-save
00A6: 7C       [176]    	LD	A,H		; Get MSB
00A7: 9A       [180]    	SBC	A,D		; Adjust it
00A8: 67       [184]    	LD	H,A		; Re-save
00A9: E5       [195]    	PUSH	HL		; Save bytes free
00AA: 21DB00   [205]    	LD	HL,SIGNON	; Sign-on message
00AD: CD9111   [222]    	CALL	PRS		; Output string
00B0: E1       [232]    	POP	HL		; Get bytes free back
00B1: CD3418   [249]    	CALL	PRNTHL		; Output amount of free memory
00B4: 21CC00   [259]    	LD	HL,BFREE	; " Bytes free" message
00B7: CD9111   [276]    	CALL	PRS		; Output string
                        ;
00BA: 31AB80   [10]     WARMST: LD	SP,STACK	; Temporary stack
00BD: CD2505   [17]     BRKRET: CALL	CLREG		; Clear registers and stack
00C0: C33E04   [27]     	JP	PRNTOK		; Go to get command line
                        ;
00C3: 211201   [10]     NEMEM:	LD	HL,MEMMSG	; Memory size not enough
00C6: CD9111   [27]     	CALL	PRS		; Print it
00C9: C3C900   [10]     XXXXX:	JP	XXXXX		; Stop
                        ;
00CC: 20427974          BFREE:	DB	" Bytes free",CR,LF,0,0
00D0: 65732066          
00D4: 7265650D          
00D8: 0A0000            
                        ;
00DB: 5A383020          SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
00DF: 42415349          
00E3: 43205665          
00E7: 7220342E          
00EB: 37620D0A          
00EF: 436F7079          	DB	"Copyright ",40,"C",41
00F3: 72696768          
00F7: 74202843          
00FB: 29                
00FC: 20313937          	DB	" 1978 by Microsoft",CR,LF,0,0
0100: 38206279          
0104: 204D6963          
0108: 726F736F          
010C: 66740D0A          
0110: 0000              
                        ;
0112: 4D656D6F          MEMMSG: DB	"Memory size not enough",CR,LF
0116: 72792073          
011A: 697A6520          
011E: 6E6F7420          
0122: 656E6F75          
0126: 67680D0A          
012A: 54686520          	DB	"The system is stopped.",CR,LF,0,0
012E: 73797374          
0132: 656D2069          
0136: 73207374          
013A: 6F707065          
013E: 642E0D0A          
0142: 0000              
                        ;
                        ; FUNCTION ADDRESS TABLE
                        ;
0144: A916              FNCTAB: DW	SGN
0146: 6D17              	DW	INT
0148: BF16              	DW	ABS
014A: 4880              	DW	USR
014C: 5110              	DW	FRE
014E: D613              	DW	INP
0150: 7F10              	DW	POS
0152: 3319              	DW	SQR
0154: 121A              	DW	RND
0156: 4E15              	DW	LOG
0158: 8119              	DW	EXP
015A: 871A              	DW	COS
015C: 8D1A              	DW	SIN
015E: EE1A              	DW	TAN
0160: 031B              	DW	ATN
0162: 2A14              	DW	PEEK
0164: 6E1B              	DW	DEEK
0166: 9680              	DW	POINT
0168: 0313              	DW	LEN
016A: 1B11              	DW	STR
016C: 9D13              	DW	VAL
016E: 1213              	DW	ASC
0170: 2313              	DW	CHR
0172: 901B              	DW	HEX
0174: 231C              	DW	BIN
0176: 3313              	DW	LEFT
0178: 6313              	DW	RIGHT
017A: 6D13              	DW	MID
                        ;
                        ; RESERVED WORD LIST
                        ;
017C: C54E44            WORDS:	DB	0C5H,"ND"
017F: C64F52            	DB	0C6H,"OR"
0182: CE455854          	DB	0CEH,"EXT"
0186: C4415441          	DB	0C4H,"ATA"
018A: C94E5055          	DB	0C9H,"NPUT"
018E: 54                
018F: C4494D            	DB	0C4H,"IM"
0192: D2454144          	DB	0D2H,"EAD"
0196: CC4554            	DB	0CCH,"ET"
0199: C74F544F          	DB	0C7H,"OTO"
019D: D2554E            	DB	0D2H,"UN"
01A0: C946              	DB	0C9H,"F"
01A2: D2455354          	DB	0D2H,"ESTORE"
01A6: 4F5245            
01A9: C74F5355          	DB	0C7H,"OSUB"
01AD: 42                
01AE: D2455455          	DB	0D2H,"ETURN"
01B2: 524E              
01B4: D2454D            	DB	0D2H,"EM"
01B7: D3544F50          	DB	0D3H,"TOP"
01BB: CF5554            	DB	0CFH,"UT"
01BE: CF4E              	DB	0CFH,"N"
01C0: CE554C4C          	DB	0CEH,"ULL"
01C4: D7414954          	DB	0D7H,"AIT"
01C8: C44546            	DB	0C4H,"EF"
01CB: D04F4B45          	DB	0D0H,"OKE"
01CF: C44F4B45          	DB	0C4H,"OKE"
01D3: D3435245          	DB	0D3H,"CREEN"
01D7: 454E              
01D9: CC494E45          	DB	0CCH,"INES"
01DD: 53                
01DE: C34C53            	DB	0C3H,"LS"
01E1: D7494454          	DB	0D7H,"IDTH"
01E5: 48                
01E6: CD4F4E49          	DB	0CDH,"ONITOR"
01EA: 544F52            
01ED: D34554            	DB	0D3H,"ET"
01F0: D2455345          	DB	0D2H,"ESET"
01F4: 54                
01F5: D052494E          	DB	0D0H,"RINT"
01F9: 54                
01FA: C34F4E54          	DB	0C3H,"ONT"
01FE: CC495354          	DB	0CCH,"IST"
0202: C34C4541          	DB	0C3H,"LEAR"
0206: 52                
0207: C34C4F41          	DB	0C3H,"LOAD"
020B: 44                
020C: C3534156          	DB	0C3H,"SAVE"
0210: 45                
0211: CE4557            	DB	0CEH,"EW"
                        ;
0214: D4414228          	DB	0D4H,"AB("
0218: D44F              	DB	0D4H,"O"
021A: C64E              	DB	0C6H,"N"
021C: D3504328          	DB	0D3H,"PC("
0220: D448454E          	DB	0D4H,"HEN"
0224: CE4F54            	DB	0CEH,"OT"
0227: D3544550          	DB	0D3H,"TEP"
                        ;
022B: AB                	DB	0ABH
022C: AD                	DB	0ADH
022D: AA                	DB	0AAH
022E: AF                	DB	0AFH
022F: DE                	DB	0DEH
0230: C14E44            	DB	0C1H,"ND"
0233: CF52              	DB	0CFH,"R"
0235: BE                	DB	0BEH
0236: BD                	DB	0BDH
0237: BC                	DB	0BCH
                        ;
0238: D3474E            	DB	0D3H,"GN"
023B: C94E54            	DB	0C9H,"NT"
023E: C14253            	DB	0C1H,"BS"
0241: D55352            	DB	0D5H,"SR"
0244: C65245            	DB	0C6H,"RE"
0247: C94E50            	DB	0C9H,"NP"
024A: D04F53            	DB	0D0H,"OS"
024D: D35152            	DB	0D3H,"QR"
0250: D24E44            	DB	0D2H,"ND"
0253: CC4F47            	DB	0CCH,"OG"
0256: C55850            	DB	0C5H,"XP"
0259: C34F53            	DB	0C3H,"OS"
025C: D3494E            	DB	0D3H,"IN"
025F: D4414E            	DB	0D4H,"AN"
0262: C1544E            	DB	0C1H,"TN"
0265: D045454B          	DB	0D0H,"EEK"
0269: C445454B          	DB	0C4H,"EEK"
026D: D04F494E          	DB	0D0H,"OINT"
0271: 54                
0272: CC454E            	DB	0CCH,"EN"
0275: D3545224          	DB	0D3H,"TR$"
0279: D6414C            	DB	0D6H,"AL"
027C: C15343            	DB	0C1H,"SC"
027F: C3485224          	DB	0C3H,"HR$"
0283: C8455824          	DB	0C8H,"EX$"
0287: C2494E24          	DB	0C2H,"IN$"
028B: CC454654          	DB	0CCH,"EFT$"
028F: 24                
0290: D2494748          	DB	0D2H,"IGHT$"
0294: 5424              
0296: CD494424          	DB	0CDH,"ID$"
029A: 80                	DB	80H		; End of list marker
                        ;
                        ; KEYWORD ADDRESS TABLE
                        ;
029B: 9508              WORDTB: DW	PEND
029D: 9207              	DW	FOR
029F: 6D0C              	DW	NEXT
02A1: E209              	DW	DATA
02A3: 740B              	DW	INPUT
02A5: A90E              	DW	DIM
02A7: A30B              	DW	READ
02A9: F909              	DW	LET
02AB: 9F09              	DW	GOTO
02AD: 8209              	DW	RUN
02AF: 710A              	DW	IF
02B1: 5B08              	DW	RESTOR
02B3: 8E09              	DW	GOSUB
02B5: BD09              	DW	RETURN
02B7: E409              	DW	REM
02B9: 9308              	DW	STOP
02BB: E213              	DW	POUT
02BD: 530A              	DW	ON
02BF: D408              	DW	NULL
02C1: E813              	DW	WAIT
02C3: 8710              	DW	DEF
02C5: 3114              	DW	POKE
02C7: 791B              	DW	DOKE
02C9: E409              	DW	REM
02CB: 5F1B              	DW	LINES
02CD: 521B              	DW	CLS
02CF: 571B              	DW	WIDTH
02D1: 8B1C              	DW	MONITR
02D3: 9980              	DW	PSET
02D5: 9C80              	DW	RESET
02D7: 950A              	DW	PRINT
02D9: C108              	DW	CONT
02DB: 0707              	DW	LIST
02DD: 3C09              	DW	CLEAR
02DF: E409              	DW	REM
02E1: E409              	DW	REM
02E3: FF04              	DW	NEW
                        ;
                        ; RESERVED WORD TOKEN VALUES
                        ;
0080:                   ZEND	EQU	080H		; END
0081:                   ZFOR	EQU	081H		; FOR
0083:                   ZDATA	EQU	083H		; DATA
0088:                   ZGOTO	EQU	088H		; GOTO
008C:                   ZGOSUB	EQU	08CH		; GOSUB
008E:                   ZREM	EQU	08EH		; REM
009E:                   ZPRINT	EQU	09EH		; PRINT
00A4:                   ZNEW	EQU	0A4H		; NEW
                        ;
00A5:                   ZTAB	EQU	0A5H		; TAB
00A6:                   ZTO	EQU	0A6H		; TO
00A7:                   ZFN	EQU	0A7H		; FN
00A8:                   ZSPC	EQU	0A8H		; SPC
00A9:                   ZTHEN	EQU	0A9H		; THEN
00AA:                   ZNOT	EQU	0AAH		; NOT
00AB:                   ZSTEP	EQU	0ABH		; STEP
                        ;
00AC:                   ZPLUS	EQU	0ACH		; +
00AD:                   ZMINUS	EQU	0ADH		; -
00AE:                   ZTIMES	EQU	0AEH		; *
00AF:                   ZDIV	EQU	0AFH		; /
00B2:                   ZOR	EQU	0B2H		; OR
00B3:                   ZGTR	EQU	0B3H		; >
00B4:                   ZEQUAL	EQU	0B4H		; M
00B5:                   ZLTH	EQU	0B5H		; <
00B6:                   ZSGN	EQU	0B6H		; SGN
00C7:                   ZPOINT	EQU	0C7H		; POINT
00CF:                   ZLEFT	EQU	0CDH +2		; LEFT$
                        ;
                        ; ARITHMETIC PRECEDENCE TABLE
                        ;
02E5: 79                PRITAB: DB	79H		; Precedence value
02E6: 1B18              	DW	PADD		; FPREG = <last> + FPREG
                        ;
02E8: 79                	DB	79H		; Precedence value
02E9: 4F14              	DW	PSUB		; FPREG = <last> - FPREG
                        ;
02EB: 7C                	DB	7CH		; Precedence value
02EC: 8D15              	DW	MULT		; PPREG = <last> * FPREG
                        ;
02EE: 7C                	DB	7CH		; Precedence value
02EF: EE15              	DW	DIV		; FPREG = <last> / FPREG
                        ;
02F1: 7F                	DB	7FH		; Precedence value
02F2: 3C19              	DW	POWER		; FPREG = <last> ^ FPREG
                        ;
02F4: 50                	DB	50H		; Precedence value
02F5: 020E              	DW	PAND		; FPREG = <last> AND FPREG
                        ;
02F7: 46                	DB	46H		; Precedence value
02F8: 010E              	DW	POR		; FPREG = <last> OR FPREG
                        ;
                        ; BASIC ERROR CODE LIST
                        ;
02FA: 4E46              ERRORS: DB	"NF"		; NEXT without FOR
02FC: 534E              	DB	"SN"		; Syntax error
02FE: 5247              	DB	"RG"		; RETURN without GOSUB
0300: 4F44              	DB	"OD"		; Out of DATA
0302: 4643              	DB	"FC"		; Illegal function call
0304: 4F56              	DB	"OV"		; Overflow error
0306: 4F4D              	DB	"OM"		; Out of memory
0308: 554C              	DB	"UL"		; Undefined line
030A: 4253              	DB	"BS"		; Bad subscript
030C: 4444              	DB	"DD"		; Re-DIMensioned array
030E: 2F30              	DB	"/0"		; Division by zero
0310: 4944              	DB	"ID"		; Illegal direct
0312: 544D              	DB	"TM"		; Type mis-match
0314: 4F53              	DB	"OS"		; Out of string space
0316: 4C53              	DB	"LS"		; String too long
0318: 5354              	DB	"ST"		; String formula too complex
031A: 434E              	DB	"CN"		; Can't CONTinue
031C: 5546              	DB	"UF"		; Undefined FN function
031E: 4D4F              	DB	"MO"		; Missing operand
0320: 4858              	DB	"HX"		; HEX error
0322: 424E              	DB	"BN"		; BIN error
                        ;
                        ; INITIALISATION TABLE -------------------------------------------------------
                        ;
0324: C3BA00   [10]     INITAB: JP	WARMST		; Warm start jump
0327: C31209   [20]     	JP	FCERR		; "USR (X)" jump (Set to Error)
032A: D300     [31]     	OUT	(0),A		; "OUT p,n" skeleton
032C: C9       [41]     	RET
032D: D600     [48]     	SUB	0		; Division support routine
032F: 6F       [52]     	LD	L,A
0330: 7C       [56]     	LD	A,H
0331: DE00     [63]     	SBC	A,0
0333: 67       [67]     	LD	H,A
0334: 78       [71]     	LD	A,B
0335: DE00     [78]     	SBC	A,0
0337: 47       [82]     	LD	B,A
0338: 3E00     [89]     	LD	A,0
033A: C9       [99]     	RET
033B: 000000            	DB	0,0,0			; Random number seed table used by RND
033E: 354ACA99          	DB	035H,04AH,0CAH,099H	;-2.65145E+07
0342: 391C7698          	DB	039H,01CH,076H,098H	; 1.61291E+07
0346: 2295B398          	DB	022H,095H,0B3H,098H	;-1.17691E+07
034A: 0ADD4798          	DB	00AH,0DDH,047H,098H	; 1.30983E+07
034E: 53D19999          	DB	053H,0D1H,099H,099H	;-2-01612E+07
0352: 0A1A9F98          	DB	00AH,01AH,09FH,098H	;-1.04269E+07
0356: 65BCCD98          	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
035A: D6773E98          	DB	0D6H,077H,03EH,098H	; 1.24825E+07
035E: 52C74F80          	DB	052H,0C7H,04FH,080H	; Last random number
0362: DB00     [110]    	IN	A,(0)		; INP (x) skeleton
0364: C9       [120]    	RET
0365: 01                	DB	1		; POS (x) number (1)
0366: FF                	DB	255		; Terminal width (255 = no auto CRLF)
0367: 1C                	DB	28		; Width for commas (3 columns)
0368: 00                	DB	0		; No nulls after input bytes
0369: 00                	DB	0		; Output enabled (^O off)
036A: 1400              	DW	20		; Initial lines counter
036C: 1400              	DW	20		; Initial lines number
036E: 0000              	DW	0		; Array load/save check sum
0370: 00                	DB	0		; Break not by NMI
0371: 00                	DB	0		; Break flag
0372: C33806   [130]    	JP	TTYLIN		; Input reflection (set to TTY)
0375: C30000   [140]    	JP	0000H		; POINT reflection unused
0378: C30000   [150]    	JP	0000H		; SET reflection
037B: C30000   [160]    	JP	0000H			; RESET reflection
037E: A281              	DW	STLOOK		; Temp string space
0380: FEFF              	DW	-2		; Current line number (cold)
0382: 3F81              	DW	PROGST+1	; Start of program text
0384:                   INITBE:			 
                        ;
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        ;
0384: 20457272          ERRMSG: DB	" Error",0
0388: 6F7200            
038B: 20696E20          INMSG:	DB	" in ",0
038F: 00                
038F:                   ZERBYT	EQU	$-1		; A zero byte
0390: 4F6B0D0A          OKMSG:	DB	"Ok",CR,LF,0,0
0394: 0000              
0396: 42726561          BRKMSG: DB	"Break",0
039A: 6B00              
                        ;
039C: 210400   [10]     BAKSTK: LD	HL,4		; Look for "FOR" block with
039F: 39       [21]     	ADD	HL,SP		; same index as specified
03A0: 7E       [ 7]     LOKFOR: LD	A,(HL)		; Get block ID
03A1: 23       [13]     	INC	HL		; Point to index address
03A2: FE81     [20]     	CP	ZFOR		; Is it a "FOR" token
03A4: C0       [25|31]  	RET	NZ		; No - exit
03A5: 4E       [32]     	LD	C,(HL)		; BC = Address of "FOR" index
03A6: 23       [38]     	INC	HL
03A7: 46       [45]     	LD	B,(HL)
03A8: 23       [51]     	INC	HL		; Point to sign of STEP
03A9: E5       [62]     	PUSH	HL		; Save pointer to sign
03AA: 69       [66]     	LD	L,C		; HL = address of "FOR" index
03AB: 60       [70]     	LD	H,B
03AC: 7A       [74]     	LD	A,D		; See if an index was specified
03AD: B3       [78]     	OR	E		; DE = 0 if no index specified
03AE: EB       [82]     	EX	DE,HL		; Specified index into HL
03AF: CAB603   [92|92]  	JP	Z,INDFND	; Skip if no index given
03B2: EB       [96]     	EX	DE,HL		; Index back into DE
03B3: CDBB06   [113]    	CALL	CPDEHL		; Compare index with one given
03B6: 010D00   [10]     INDFND: LD	BC,16-3		; Offset to next block
03B9: E1       [20]     	POP	HL		; Restore pointer to sign
03BA: C8       [25|31]  	RET	Z		; Return if block found
03BB: 09       [36]     	ADD	HL,BC		; Point to next block
03BC: C3A003   [46]     	JP	LOKFOR		; Keep on looking
                        ;
03BF: CDD903   [17]     MOVUP:	CALL	ENFMEM		; See if enough memory
03C2: C5       [11]     MOVSTR: PUSH	BC		; Save end of source
03C3: E3       [30]     	EX	(SP),HL		; Swap source and dest" end
03C4: C1       [40]     	POP	BC		; Get end of destination
03C5: CDBB06   [17]     MOVLP:	CALL	CPDEHL		; See if list moved
03C8: 7E       [24]     	LD	A,(HL)		; Get byte
03C9: 02       [31]     	LD	(BC),A		; Move it
03CA: C8       [36|42]  	RET	Z		; Exit if all done
03CB: 0B       [42]     	DEC	BC		; Next byte to move to
03CC: 2B       [48]     	DEC	HL		; Next byte to move
03CD: C3C503   [58]     	JP	MOVLP		; Loop until all bytes moved
                        ;
03D0: E5       [11]     CHKSTK: PUSH	HL		; Save code string address
03D1: 2A1F81   [27]     	LD	HL,(ARREND)	; Lowest free memory
03D4: 0600     [34]     	LD	B,0		; BC = Number of levels to test
03D6: 09       [45]     	ADD	HL,BC		; 2 Bytes for each level
03D7: 09       [56]     	ADD	HL,BC
03D8: 3E                	DB	3EH		; Skip "PUSH HL"
03D9: E5       [11]     ENFMEM: PUSH	HL		; Save code string address
03DA: 3ED0     [18]     	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
03DC: 95       [22]     	SUB	L
03DD: 6F       [26]     	LD	L,A
03DE: 3EFF     [33]     	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
03E0: 9C       [37]     	SBC	A,H
03E1: DAE803   [47|47]  	JP	C,OMERR		; Not enough - ?OM Error
03E4: 67       [51]     	LD	H,A
03E5: 39       [62]     	ADD	HL,SP		; Test if stack is overflowed
03E6: E1       [72]     	POP	HL		; Restore code string address
03E7: D8       [77|83]  	RET	C		; Return if enough mmory
03E8: 1E0C     [ 7]     OMERR:	LD	E,OM		; ?OM Error
03EA: C30704   [17]     	JP	ERROR
                        ;
03ED: 2A0E81   [16]     DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
03F0: 22A180   [32]     	LD	(LINEAT),HL	; Save as current line
03F3: 1E02     [ 7]     SNERR:	LD	E,SN		; ?SN Error
03F5: 01                	DB	01H		; Skip "LD E,DZ"
03F6: 1E14     [ 7]     DZERR:	LD	E,DZ		; ?/0 Error
03F8: 01                	DB	01H		; Skip "LD E,NF"
03F9: 1E00     [ 7]     NFERR:	LD	E,NF		; ?NF Error
03FB: 01                	DB	01H		; Skip "LD E,RD"
03FC: 1E12     [ 7]     DDERR:	LD	E,RD		; ?DD Error
03FE: 01                	DB	01H		; Skip "LD E,UF"
03FF: 1E22     [ 7]     UFERR:	LD	E,UF		; ?UF Error
0401: 01                	DB	01H		; Skip "LD E,OV
0402: 1E0A     [ 7]     OVERR:	LD	E,OV		; ?OV Error
0404: 01                	DB	01H		; Skip "LD E,TM"
0405: 1E18     [ 7]     TMERR:	LD	E,TM		; ?TM Error
                        ;
0407: CD2505   [17]     ERROR:	CALL	CLREG		; Clear registers and stack
040A: 328A80   [30]     	LD	(CTLOFG),A	; Enable output (A is 0)
040D: CDE60A   [47]     	CALL	STTLIN		; Start new line
0410: 21FA02   [57]     	LD	HL,ERRORS	; Point to error codes
0413: 57       [61]     	LD	D,A		; D = 0 (A is 0)
0414: 3E3F     [68]     	LD	A,'?'
0416: CDCC06   [85]     	CALL	OUTC		; Output '?'
0419: 19       [96]     	ADD	HL,DE		; Offset to correct error code
041A: 7E       [103]    	LD	A,(HL)		; First character
041B: CDCC06   [120]    	CALL	OUTC		; Output it
041E: CD4B08   [137]    	CALL	GETCHR		; Get next character
0421: CDCC06   [154]    	CALL	OUTC		; Output it
0424: 218403   [164]    	LD	HL,ERRMSG	; "Error" message
0427: CD9111   [17]     ERRIN:	CALL	PRS		; Output message
042A: 2AA180   [33]     	LD	HL,(LINEAT)	; Get line of error
042D: 11FEFF   [43]     	LD	DE,-2		; Cold start error if -2
0430: CDBB06   [60]     	CALL	CPDEHL		; See if cold start error
0433: CA4C00   [70|70]  	JP	Z,CSTART	; Cold start error - Restart
0436: 7C       [74]     	LD	A,H		; Was it a direct error?
0437: A5       [78]     	AND	L		; Line = -1 if direct error
0438: 3C       [82]     	INC	A
0439: C42C18   [92|99]  	CALL	NZ,LINEIN	; No - output line of error
043C: 3E                	DB	3EH		; Skip "POP BC"
043D: C1       [10]     POPNOK: POP	BC		; Drop address in input buffer
                        ;
043E: AF       [ 4]     PRNTOK: XOR	A		; Output "Ok" and get command
043F: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
0442: CDE60A   [34]     	CALL	STTLIN		; Start new line
0445: 219003   [44]     	LD	HL,OKMSG	; "Ok" message
0448: CD9111   [61]     	CALL	PRS		; Output "Ok"
044B: 21FFFF   [10]     GETCMD: LD	HL,-1		; Flag direct mode
044E: 22A180   [26]     	LD	(LINEAT),HL	; Save as current line
0451: CD3806   [43]     	CALL	GETLIN		; Get an input line
0454: DA4B04   [53|53]  	JP	C,GETCMD	; Get line again if break
0457: CD4B08   [70]     	CALL	GETCHR		; Get first character
045A: 3C       [74]     	INC	A		; Test if end of line
045B: 3D       [78]     	DEC	A		; Without affecting Carry
045C: CA4B04   [88|88]  	JP	Z,GETCMD	; Nothing entered - Get another
045F: F5       [99]     	PUSH	AF		; Save Carry status
0460: CD1709   [116]    	CALL	ATOH		; Get line number into DE
0463: D5       [127]    	PUSH	DE		; Save line number
0464: CD4F05   [144]    	CALL	CRUNCH		; Tokenise rest of line
0467: 47       [148]    	LD	B,A		; Length of tokenised line
0468: D1       [158]    	POP	DE		; Restore line number
0469: F1       [168]    	POP	AF		; Restore Carry
046A: D22B08   [178|178]	JP	NC,EXCUTE	; No line number - Direct mode
046D: D5       [189]    	PUSH	DE		; Save line number
046E: C5       [200]    	PUSH	BC		; Save length of tokenised line
046F: AF       [204]    	XOR	A
0470: 321181   [217]    	LD	(LSTBIN),A	; Clear last byte input
0473: CD4B08   [234]    	CALL	GETCHR		; Get next character
0476: B7       [238]    	OR	A		; Set flags
0477: F5       [249]    	PUSH	AF		; And save them
0478: CDDF04   [266]    	CALL	SRCHLN		; Search for line number in DE
047B: DA8404   [276|276]	JP	C,LINFND	; Jump if line found
047E: F1       [286]    	POP	AF		; Get status
047F: F5       [297]    	PUSH	AF		; And re-save
0480: CAB809   [307|307]	JP	Z,ULERR	; Nothing after number - Error
0483: B7       [311]    	OR	A		; Clear Carry
0484: C5       [11]     LINFND: PUSH	BC		; Save address of line in prog
0485: D29B04   [21|21]  	JP	NC,INEWLN	; Line not found - Insert new
0488: EB       [25]     	EX	DE,HL		; Next line address in DE
0489: 2A1B81   [41]     	LD	HL,(PROGND)	; End of program
048C: 1A       [ 7]     SFTPRG: LD	A,(DE)		; Shift rest of program down
048D: 02       [14]     	LD	(BC),A
048E: 03       [20]     	INC	BC		; Next destination
048F: 13       [26]     	INC	DE		; Next source
0490: CDBB06   [43]     	CALL	CPDEHL		; All done?
0493: C28C04   [53|53]  	JP	NZ,SFTPRG	; More to do
0496: 60       [57]     	LD	H,B		; HL - New end of program
0497: 69       [61]     	LD	L,C
0498: 221B81   [77]     	LD	(PROGND),HL	; Update end of program
                        ;
049B: D1       [10]     INEWLN: POP	DE		; Get address of line,
049C: F1       [20]     	POP	AF		; Get status
049D: CAC204   [30|30]  	JP	Z,SETPTR	; No text - Set up pointers
04A0: 2A1B81   [46]     	LD	HL,(PROGND)	; Get end of program
04A3: E3       [65]     	EX	(SP),HL		; Get length of input line
04A4: C1       [75]     	POP	BC		; End of program to BC
04A5: 09       [86]     	ADD	HL,BC		; Find new end
04A6: E5       [97]     	PUSH	HL		; Save new end
04A7: CDBF03   [114]    	CALL	MOVUP		; Make space for line
04AA: E1       [124]    	POP	HL		; Restore new end
04AB: 221B81   [140]    	LD	(PROGND),HL	; Update end of program pointer
04AE: EB       [144]    	EX	DE,HL		; Get line to move up in HL
04AF: 74       [151]    	LD	(HL),H		; Save MSB
04B0: D1       [161]    	POP	DE		; Get new line number
04B1: 23       [167]    	INC	HL		; Skip pointer
04B2: 23       [173]    	INC	HL
04B3: 73       [180]    	LD	(HL),E		; Save LSB of line number
04B4: 23       [186]    	INC	HL
04B5: 72       [193]    	LD	(HL),D		; Save MSB of line number
04B6: 23       [199]    	INC	HL		; To first byte in line
04B7: 11A680   [209]    	LD	DE,BUFFER	; Copy buffer to program
04BA: 1A       [ 7]     MOVBUF: LD	A,(DE)		; Get source
04BB: 77       [14]     	LD	(HL),A		; Save destinations
04BC: 23       [20]     	INC	HL		; Next source
04BD: 13       [26]     	INC	DE		; Next destination
04BE: B7       [30]     	OR	A		; Done?
04BF: C2BA04   [40|40]  	JP	NZ,MOVBUF	; No - Repeat
04C2: CD0B05   [17]     SETPTR: CALL	RUNFST		; Set line pointers
04C5: 23       [23]     	INC	HL		; To LSB of pointer
04C6: EB       [27]     	EX	DE,HL		; Address to DE
04C7: 62       [ 4]     PTRLP:	LD	H,D		; Address to HL
04C8: 6B       [ 8]     	LD	L,E
04C9: 7E       [15]     	LD	A,(HL)		; Get LSB of pointer
04CA: 23       [21]     	INC	HL		; To MSB of pointer
04CB: B6       [28]     	OR	(HL)		; Compare with MSB pointer
04CC: CA4B04   [38|38]  	JP	Z,GETCMD	; Get command line if end
04CF: 23       [44]     	INC	HL		; To LSB of line number
04D0: 23       [50]     	INC	HL		; Skip line number
04D1: 23       [56]     	INC	HL		; Point to first byte in line
04D2: AF       [60]     	XOR	A		; Looking for 00 byte
04D3: BE       [ 7]     FNDEND: CP	(HL)		; Found end of line?
04D4: 23       [13]     	INC	HL		; Move to next byte
04D5: C2D304   [23|23]  	JP	NZ,FNDEND	; No - Keep looking
04D8: EB       [27]     	EX	DE,HL		; Next line address to HL
04D9: 73       [34]     	LD	(HL),E		; Save LSB of pointer
04DA: 23       [40]     	INC	HL
04DB: 72       [47]     	LD	(HL),D		; Save MSB of pointer
04DC: C3C704   [57]     	JP	PTRLP		; Do next line
                        ;
04DF: 2AA380   [16]     SRCHLN: LD	HL,(BASTXT)	; Start of program text
04E2: 44       [ 4]     SRCHLP: LD	B,H		; BC = Address to look at
04E3: 4D       [ 8]     	LD	C,L
04E4: 7E       [15]     	LD	A,(HL)		; Get address of next line
04E5: 23       [21]     	INC	HL
04E6: B6       [28]     	OR	(HL)		; End of program found?
04E7: 2B       [34]     	DEC	HL
04E8: C8       [39|45]  	RET	Z		; Yes - Line not found
04E9: 23       [45]     	INC	HL
04EA: 23       [51]     	INC	HL
04EB: 7E       [58]     	LD	A,(HL)		; Get LSB of line number
04EC: 23       [64]     	INC	HL
04ED: 66       [71]     	LD	H,(HL)		; Get MSB of line number
04EE: 6F       [75]     	LD	L,A
04EF: CDBB06   [92]     	CALL	CPDEHL		; Compare with line in DE
04F2: 60       [96]     	LD	H,B		; HL = Start of this line
04F3: 69       [100]    	LD	L,C
04F4: 7E       [107]    	LD	A,(HL)		; Get LSB of next line address
04F5: 23       [113]    	INC	HL
04F6: 66       [120]    	LD	H,(HL)		; Get MSB of next line address
04F7: 6F       [124]    	LD	L,A		; Next line to HL
04F8: 3F       [128]    	CCF
04F9: C8       [133|139]	RET	Z		; Lines found - Exit
04FA: 3F       [137]    	CCF
04FB: D0       [142|148]	RET	NC		; Line not found,at line after
04FC: C3E204   [152]    	JP	SRCHLP		; Keep looking
                        ;
04FF: C0       [ 5|11]  NEW:	RET	NZ		; Return if any more on line
0500: 2AA380   [16]     CLRPTR: LD	HL,(BASTXT)	; Point to start of program
0503: AF       [20]     	XOR	A		; Set program area to empty
0504: 77       [27]     	LD	(HL),A		; Save LSB = 00
0505: 23       [33]     	INC	HL
0506: 77       [40]     	LD	(HL),A		; Save MSB = 00
0507: 23       [46]     	INC	HL
0508: 221B81   [62]     	LD	(PROGND),HL	; Set program end
                        ;
050B: 2AA380   [16]     RUNFST: LD	HL,(BASTXT)	; Clear all variables
050E: 2B       [22]     	DEC	HL
                        ;
050F: 221381   [16]     INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
0512: 2AF480   [32]     	LD	HL,(LSTRAM)	; Get end of RAM
0515: 220881   [48]     	LD	(STRBOT),HL	; Clear string space
0518: AF       [52]     	XOR	A
0519: CD5B08   [69]     	CALL	RESTOR		; Reset DATA pointers
051C: 2A1B81   [85]     	LD	HL,(PROGND)	; Get end of program
051F: 221D81   [101]    	LD	(VAREND),HL	; Clear variables
0522: 221F81   [117]    	LD	(ARREND),HL	; Clear arrays
                        ;
0525: C1       [10]     CLREG:	POP	BC		; Save return address
0526: 2A9F80   [26]     	LD	HL,(STRSPC)	; Get end of working RAN
0529: F9       [32]     	LD	SP,HL		; Set stack
052A: 21F880   [42]     	LD	HL,TMSTPL	; Temporary string pool
052D: 22F680   [58]     	LD	(TMSTPT),HL	; Reset temporary string ptr
0530: AF       [62]     	XOR	A		; A = 00
0531: 6F       [66]     	LD	L,A		; HL = 0000
0532: 67       [70]     	LD	H,A
0533: 221981   [86]     	LD	(CONTAD),HL	; No CONTinue
0536: 321081   [99]     	LD	(FORFLG),A	; Clear FOR flag
0539: 222381   [115]    	LD	(FNRGNM),HL	; Clear FN argument
053C: E5       [126]    	PUSH	HL		; HL = 0000
053D: C5       [137]    	PUSH	BC		; Put back return
053E: 2A1381   [16]     DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
0541: C9       [26]     	RET			; Return to execution driver
                        ;
0542: 3E3F     [ 7]     PROMPT: LD	A,'?'		; '?'
0544: CDCC06   [24]     	CALL	OUTC		; Output character
0547: 3E20     [31]     	LD	A,' '		; Space
0549: CDCC06   [48]     	CALL	OUTC		; Output character
054C: C39380   [58]     	JP	RINPUT		; Get input line
                        ;
054F: AF       [ 4]     CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
0550: 32F380   [17]     	LD	(DATFLG),A	; Reset literal flag
0553: 0E05     [24]     	LD	C,2+3		; 2 byte number and 3 nulls
0555: 11A680   [34]     	LD	DE,BUFFER	; Start of input buffer
0558: 7E       [ 7]     CRNCLP: LD	A,(HL)		; Get byte
0559: FE20     [14]     	CP	' '		; Is it a space?
055B: CAD705   [24|24]  	JP	Z,MOVDIR	; Yes - Copy direct
055E: 47       [28]     	LD	B,A		; Save character
055F: FE22     [35]     	CP	'"'		; Is it a quote?
0561: CAF705   [45|45]  	JP	Z,CPYLIT	; Yes - Copy literal string
0564: B7       [49]     	OR	A		; Is it end of buffer?
0565: CAFE05   [59|59]  	JP	Z,ENDBUF	; Yes - End buffer
0568: 3AF380   [72]     	LD	A,(DATFLG)	; Get data type
056B: B7       [76]     	OR	A		; Literal?
056C: 7E       [83]     	LD	A,(HL)		; Get byte to copy
056D: C2D705   [93|93]  	JP	NZ,MOVDIR	; Literal - Copy direct
0570: FE3F     [100]    	CP	'?'		; Is it '?' short for PRINT
0572: 3E9E     [107]    	LD	A,ZPRINT	; "PRINT" token
0574: CAD705   [117|117]	JP	Z,MOVDIR	; Yes - replace it
0577: 7E       [124]    	LD	A,(HL)		; Get byte again
0578: FE30     [131]    	CP	'0'		; Is it less than '0'
057A: DA8205   [141|141]	JP	C,FNDWRD	; Yes - Look for reserved words
057D: FE3C     [148]    	CP	60		; ";"+1; Is it "0123456789:;" ?
057F: DAD705   [158|158]	JP	C,MOVDIR	; Yes - copy it direct
0582: D5       [11]     FNDWRD: PUSH	DE		; Look for reserved words
0583: 117B01   [21]     	LD	DE,WORDS-1	; Point to table
0586: C5       [32]     	PUSH	BC		; Save count
0587: 01D305   [42]     	LD	BC,RETNAD	; Where to return to
058A: C5       [53]     	PUSH	BC		; Save return address
058B: 067F     [60]     	LD	B,ZEND-1	; First token value -1
058D: 7E       [67]     	LD	A,(HL)		; Get byte
058E: FE61     [74]     	CP	'a'		; Less than 'a' ?
0590: DA9B05   [84|84]  	JP	C,SEARCH	; Yes - search for words
0593: FE7B     [91]     	CP	'z'+1		; Greater than 'z' ?
0595: D29B05   [101|101]	JP	NC,SEARCH	; Yes - search for words
0598: E65F     [108]    	AND	01011111B	; Force upper case
059A: 77       [115]    	LD	(HL),A		; Replace byte
059B: 4E       [ 7]     SEARCH: LD	C,(HL)		; Search for a word
059C: EB       [11]     	EX	DE,HL
059D: 23       [ 6]     GETNXT: INC	HL		; Get next reserved word
059E: B6       [13]     	OR	(HL)		; Start of word?
059F: F29D05   [23|23]  	JP	P,GETNXT	; No - move on
05A2: 04       [27]     	INC	B		; Increment token value
05A3: 7E       [34]     	LD	A, (HL)		; Get byte from table
05A4: E67F     [41]     	AND	01111111B	; Strip bit 7
05A6: C8       [46|52]  	RET	Z		; Return if end of list
05A7: B9       [50]     	CP	C		; Same character as in buffer?
05A8: C29D05   [60|60]  	JP	NZ,GETNXT	; No - get next word
05AB: EB       [64]     	EX	DE,HL
05AC: E5       [75]     	PUSH	HL		; Save start of word
                        ;
05AD: 13       [ 6]     NXTBYT: INC	DE		; Look through rest of word
05AE: 1A       [13]     	LD	A,(DE)		; Get byte from table
05AF: B7       [17]     	OR	A		; End of word ?
05B0: FACF05   [27|27]  	JP	M,MATCH		; Yes - Match found
05B3: 4F       [31]     	LD	C,A		; Save it
05B4: 78       [35]     	LD	A,B		; Get token value
05B5: FE88     [42]     	CP	ZGOTO		; Is it "GOTO" token ?
05B7: C2BE05   [52|52]  	JP	NZ,NOSPC	; No - Don't allow spaces
05BA: CD4B08   [69]     	CALL	GETCHR		; Get next character
05BD: 2B       [75]     	DEC	HL		; Cancel increment from GETCHR
05BE: 23       [ 6]     NOSPC:	INC	HL		; Next byte
05BF: 7E       [13]     	LD	A,(HL)		; Get byte
05C0: FE61     [20]     	CP	'a'		; Less than 'a' ?
05C2: DAC705   [30|30]  	JP	C,NOCHNG	; Yes - don't change
05C5: E65F     [37]     	AND	01011111B	; Make upper case
05C7: B9       [ 4]     NOCHNG: CP	C		; Same as in buffer ?
05C8: CAAD05   [14|14]  	JP	Z,NXTBYT	; Yes - keep testing
05CB: E1       [24]     	POP	HL		; Get back start of word
05CC: C39B05   [34]     	JP	SEARCH		; Look at next word
                        ;
05CF: 48       [ 4]     MATCH:	LD	C,B		; Word found - Save token value
05D0: F1       [14]     	POP	AF		; Throw away return
05D1: EB       [18]     	EX	DE,HL
05D2: C9       [28]     	RET			; Return to "RETNAD"
05D3: EB       [ 4]     RETNAD: EX	DE,HL		; Get address in string
05D4: 79       [ 8]     	LD	A,C		; Get token value
05D5: C1       [18]     	POP	BC		; Restore buffer length
05D6: D1       [28]     	POP	DE		; Get destination address
05D7: 23       [ 6]     MOVDIR: INC	HL		; Next source in buffer
05D8: 12       [13]     	LD	(DE),A		; Put byte in buffer
05D9: 13       [19]     	INC	DE		; Move up buffer
05DA: 0C       [23]     	INC	C		; Increment length of buffer
05DB: D63A     [30]     	SUB	':'		; End of statement?
05DD: CAE505   [40|40]  	JP	Z,SETLIT	; Jump if multi-statement line
05E0: FE49     [47]     	CP	ZDATA-3AH	; Is it DATA statement ?
05E2: C2E805   [57|57]  	JP	NZ,TSTREM	; No - see if REM
05E5: 32F380   [13]     SETLIT: LD	(DATFLG),A	; Set literal flag
05E8: D654     [ 7]     TSTREM: SUB	ZREM-3AH	; Is it REM?
05EA: C25805   [17|17]  	JP	NZ,CRNCLP	; No - Leave flag
05ED: 47       [21]     	LD	B,A		; Copy rest of buffer
05EE: 7E       [ 7]     NXTCHR: LD	A,(HL)		; Get byte
05EF: B7       [11]     	OR	A		; End of line ?
05F0: CAFE05   [21|21]  	JP	Z,ENDBUF	; Yes - Terminate buffer
05F3: B8       [25]     	CP	B		; End of statement ?
05F4: CAD705   [35|35]  	JP	Z,MOVDIR	; Yes - Get next one
05F7: 23       [ 6]     CPYLIT: INC	HL		; Move up source string
05F8: 12       [13]     	LD	(DE),A		; Save in destination
05F9: 0C       [17]     	INC	C		; Increment length
05FA: 13       [23]     	INC	DE		; Move up destination
05FB: C3EE05   [33]     	JP	NXTCHR		; Repeat
                        ;
05FE: 21A580   [10]     ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
0601: 12       [17]     	LD	(DE),A		; Mark end of buffer (A = 00)
0602: 13       [23]     	INC	DE
0603: 12       [30]     	LD	(DE),A		; A = 00
0604: 13       [36]     	INC	DE
0605: 12       [43]     	LD	(DE),A		; A = 00
0606: C9       [53]     	RET
                        ;
0607: 3A8980   [13]     DODEL:	LD	A,(NULFLG)	; Get null flag status
060A: B7       [17]     	OR	A		; Is it zero?
060B: 3E00     [24]     	LD	A,0		; Zero A - Leave flags
060D: 328980   [37]     	LD	(NULFLG),A	; Zero null flag
0610: C21B06   [47|47]  	JP	NZ,ECHDEL	; Set - Echo it
0613: 05       [51]     	DEC	B		; Decrement length
0614: CA3806   [61|61]  	JP	Z,GETLIN	; Get line again if empty
0617: CDCC06   [78]     	CALL	OUTC		; Output null character
061A: 3E                	DB	3EH		; Skip "DEC B"
061B: 05       [ 4]     ECHDEL: DEC	B		; Count bytes in buffer
061C: 2B       [10]     	DEC	HL		; Back space buffer
061D: CA2F06   [20|20]  	JP	Z,OTKLN		; No buffer - Try again
0620: 7E       [27]     	LD	A,(HL)		; Get deleted byte
0621: CDCC06   [44]     	CALL	OUTC		; Echo it
0624: C34106   [54]     	JP	MORINP		; Get more input
                        ;
0627: 05       [ 4]     DELCHR: DEC	B		; Count bytes in buffer
0628: 2B       [10]     	DEC	HL		; Back space buffer
0629: CDCC06   [27]     	CALL	OUTC		; Output character in A
062C: C24106   [37|37]  	JP	NZ,MORINP	; Not end - Get more
062F: CDCC06   [17]     OTKLN:	CALL	OUTC		; Output character in A
0632: CDF30A   [17]     KILIN:	CALL	PRCRLF		; Output CRLF
0635: C33806   [27]     	JP	TTYLIN		; Get line again
                        ;
0638:                   GETLIN:
0638: 21A680   [10]     TTYLIN: LD	HL,BUFFER	; Get a line by character
063B: 0601     [17]     	LD	B,1		; Set buffer as empty
063D: AF       [21]     	XOR	A
063E: 328980   [34]     	LD	(NULFLG),A	; Clear null flag
0641: CDF606   [17]     MORINP: CALL	CLOTST		; Get character and test ^O
0644: 4F       [21]     	LD	C,A		; Save character in C
0645: FE7F     [28]     	CP	DEL		; Delete character?
0647: CA0706   [38|38]  	JP	Z,DODEL	; Yes - Process it
064A: 3A8980   [51]     	LD	A,(NULFLG)	; Get null flag
064D: B7       [55]     	OR	A		; Test null flag status
064E: CA5A06   [65|65]  	JP	Z,PROCES	; Reset - Process character
0651: 3E00     [72]     	LD	A,0		; Set a null
0653: CDCC06   [89]     	CALL	OUTC		; Output null
0656: AF       [93]     	XOR	A		; Clear A
0657: 328980   [106]    	LD	(NULFLG),A	; Reset null flag
065A: 79       [ 4]     PROCES: LD	A,C		; Get character
065B: FE07     [11]     	CP	CTRLG		; Bell?
065D: CA9E06   [21|21]  	JP	Z,PUTCTL	; Yes - Save it
0660: FE03     [28]     	CP	CTRLC		; Is it control "C"?
0662: CCF30A   [38|45]  	CALL	Z,PRCRLF	; Yes - Output CRLF
0665: 37       [42]     	SCF			; Flag break
0666: C8       [47|53]  	RET	Z		; Return if control "C"
0667: FE0D     [54]     	CP	CR		; Is it enter?
0669: CAEE0A   [64|64]  	JP	Z,ENDINP	; Yes - Terminate input
066C: FE15     [71]     	CP	CTRLU		; Is it control "U"?
066E: CA3206   [81|81]  	JP	Z,KILIN		; Yes - Get another line
0671: FE40     [88]     	CP	'@'		; Is it "kill line"?
0673: CA2F06   [98|98]  	JP	Z,OTKLN		; Yes - Kill line
0676: FE5F     [105]    	CP	'_'		; Is it delete?
0678: CA2706   [115|115]	JP	Z,DELCHR	; Yes - Delete character
067B: FE08     [122]    	CP	BKSP		; Is it backspace?
067D: CA2706   [132|132]	JP	Z,DELCHR	; Yes - Delete character
0680: FE12     [139]    	CP	CTRLR		; Is it control "R"?
0682: C29906   [149|149]	JP	NZ,PUTBUF	; No - Put in buffer
0685: C5       [160]    	PUSH	BC		; Save buffer length
0686: D5       [171]    	PUSH	DE		; Save DE
0687: E5       [182]    	PUSH	HL		; Save buffer address
0688: 3600     [192]    	LD	(HL),0		; Mark end of buffer
068A: CD9D1C   [209]    	CALL	OUTNCR		; Output and do CRLF
068D: 21A680   [219]    	LD	HL,BUFFER	; Point to buffer start
0690: CD9111   [236]    	CALL	PRS		; Output buffer
0693: E1       [246]    	POP	HL		; Restore buffer address
0694: D1       [256]    	POP	DE		; Restore DE
0695: C1       [266]    	POP	BC		; Restore buffer length
0696: C34106   [276]    	JP	MORINP		; Get another character
                        ;
0699: FE20     [ 7]     PUTBUF: CP	' '		; Is it a control code?
069B: DA4106   [17|17]  	JP	C,MORINP	; Yes - Ignore
069E: 78       [ 4]     PUTCTL: LD	A,B		; Get number of bytes in buffer
069F: FE49     [11]     	CP	72+1		; Test for line overflow
06A1: 3E07     [18]     	LD	A,CTRLG		; Set a bell
06A3: D2B306   [28|28]  	JP	NC,OUTNBS	; Ring bell if buffer full
06A6: 79       [32]     	LD	A,C		; Get character
06A7: 71       [39]     	LD	(HL),C		; Save in buffer
06A8: 321181   [52]     	LD	(LSTBIN),A	; Save last input byte
06AB: 23       [58]     	INC	HL		; Move up buffer
06AC: 04       [62]     	INC	B		; Increment length
06AD: CDCC06   [17]     OUTIT:	CALL	OUTC		; Output the character entered
06B0: C34106   [27]     	JP	MORINP		; Get another character
                        ;
06B3: CDCC06   [17]     OUTNBS: CALL	OUTC		; Output bell and back over it
06B6: 3E08     [24]     	LD	A,BKSP		; Set back space
06B8: C3AD06   [34]     	JP	OUTIT		; Output it and get more
                        ;
06BB: 7C       [ 4]     CPDEHL: LD	A,H		; Get H
06BC: 92       [ 8]     	SUB	D		; Compare with D
06BD: C0       [13|19]  	RET	NZ		; Different - Exit
06BE: 7D       [17]     	LD	A,L		; Get L
06BF: 93       [21]     	SUB	E		; Compare with E
06C0: C9       [31]     	RET			; Return status
                        ;
06C1: 7E       [ 7]     CHKSYN: LD	A,(HL)		; Check syntax of character
06C2: E3       [26]     	EX	(SP),HL		; Address of test byte
06C3: BE       [33]     	CP	(HL)		; Same as in code string?
06C4: 23       [39]     	INC	HL		; Return address
06C5: E3       [58]     	EX	(SP),HL		; Put it back
06C6: CA4B08   [68|68]  	JP	Z,GETCHR	; Yes - Get next character
06C9: C3F303   [78]     	JP	SNERR		; Different - ?SN Error
                        ;
06CC: F5       [11]     OUTC:	PUSH	AF		; Save character
06CD: 3A8A80   [24]     	LD	A,(CTLOFG)	; Get control "O" flag
06D0: B7       [28]     	OR	A		; Is it set?
06D1: C2C611   [38|38]  	JP	NZ,POPAF	; Yes - don't output
06D4: F1       [48]     	POP	AF		; Restore character
06D5: C5       [59]     	PUSH	BC		; Save buffer length
06D6: F5       [70]     	PUSH	AF		; Save character
06D7: FE20     [77]     	CP	' '		; Is it a control code?
06D9: DAF006   [87|87]  	JP	C,DINPOS	; Yes - Don't INC POS(X)
06DC: 3A8780   [100]    	LD	A,(LWIDTH)	; Get line width
06DF: 47       [104]    	LD	B,A		; To B
06E0: 3AF080   [117]    	LD	A,(CURPOS)	; Get cursor position
06E3: 04       [121]    	INC	B		; Width 255?
06E4: CAEC06   [131|131]	JP	Z,INCLEN	; Yes - No width limit
06E7: 05       [135]    	DEC	B		; Restore width
06E8: B8       [139]    	CP	B		; At end of line?
06E9: CCF30A   [149|156]	CALL	Z,PRCRLF	; Yes - output CRLF
06EC: 3C       [ 4]     INCLEN: INC	A		; Move on one character
06ED: 32F080   [17]     	LD	(CURPOS),A	; Save new position
06F0: F1       [10]     DINPOS: POP	AF		; Restore character
06F1: C1       [20]     	POP	BC		; Restore buffer length
06F2: CD881C   [37]     	CALL	MONOUT		; Send it
06F5: C9       [47]     	RET
                        ;
06F6: CD501B   [17]     CLOTST: CALL	GETINP		; Get input character
06F9: E67F     [24]     	AND	01111111B	; Strip bit 7
06FB: FE0F     [31]     	CP	CTRLO		; Is it control "O"?
06FD: C0       [36|42]  	RET	NZ		; No don't flip flag
06FE: 3A8A80   [49]     	LD	A,(CTLOFG)	; Get flag
0701: 2F       [53]     	CPL			; Flip it
0702: 328A80   [66]     	LD	(CTLOFG),A	; Put it back
0705: AF       [70]     	XOR	A		; Null character
0706: C9       [80]     	RET
                        ;
0707: CD1709   [17]     LIST:	CALL	ATOH		; ASCII number to DE
070A: C0       [22|28]  	RET	NZ		; Return if anything extra
070B: C1       [32]     	POP	BC		; Rubbish - Not needed
070C: CDDF04   [49]     	CALL	SRCHLN		; Search for line number in DE
070F: C5       [60]     	PUSH	BC		; Save address of line
0710: CD5D07   [77]     	CALL	SETLIN		; Set up lines counter
0713: E1       [10]     LISTLP: POP	HL		; Restore address of line
0714: 4E       [17]     	LD	C,(HL)		; Get LSB of next line
0715: 23       [23]     	INC	HL
0716: 46       [30]     	LD	B,(HL)		; Get MSB of next line
0717: 23       [36]     	INC	HL
0718: 78       [40]     	LD	A,B		; BC = 0 (End of program)?
0719: B1       [44]     	OR	C
071A: CA3E04   [54|54]  	JP	Z,PRNTOK	; Yes - Go to command mode
071D: CD6607   [71]     	CALL	COUNT		; Count lines
0720: CD7608   [88]     	CALL	TSTBRK		; Test for break key
0723: C5       [99]     	PUSH	BC		; Save address of next line
0724: CDF30A   [116]    	CALL	PRCRLF		; Output CRLF
0727: 5E       [123]    	LD	E,(HL)		; Get LSB of line number
0728: 23       [129]    	INC	HL
0729: 56       [136]    	LD	D,(HL)		; Get MSB of line number
072A: 23       [142]    	INC	HL
072B: E5       [153]    	PUSH	HL		; Save address of line start
072C: EB       [157]    	EX	DE,HL		; Line number to HL
072D: CD3418   [174]    	CALL	PRNTHL		; Output line number in decimal
0730: 3E20     [181]    	LD	A,' '		; Space after line number
0732: E1       [191]    	POP	HL		; Restore start of line address
0733: CDCC06   [17]     LSTLP2: CALL	OUTC		; Output character in A
0736: 7E       [ 7]     LSTLP3: LD	A,(HL)		; Get next byte in line
0737: B7       [11]     	OR	A		; End of line?
0738: 23       [17]     	INC	HL		; To next byte in line
0739: CA1307   [27|27]  	JP	Z,LISTLP	; Yes - get next line
073C: F23307   [37|37]  	JP	P,LSTLP2	; No token - output it
073F: D67F     [44]     	SUB	ZEND-1		; Find and output word
0741: 4F       [48]     	LD	C,A		; Token offset+1 to C
0742: 117C01   [58]     	LD	DE,WORDS	; Reserved word list
0745: 1A       [ 7]     FNDTOK: LD	A,(DE)		; Get character in list
0746: 13       [13]     	INC	DE		; Move on to next
0747: B7       [17]     	OR	A		; Is it start of word?
0748: F24507   [27|27]  	JP	P,FNDTOK	; No - Keep looking for word
074B: 0D       [31]     	DEC	C		; Count words
074C: C24507   [41|41]  	JP	NZ,FNDTOK	; Not there - keep looking
074F: E67F     [ 7]     OUTWRD: AND	01111111B	; Strip bit 7
0751: CDCC06   [24]     	CALL	OUTC		; Output first character
0754: 1A       [31]     	LD	A,(DE)		; Get next character
0755: 13       [37]     	INC	DE		; Move on to next
0756: B7       [41]     	OR	A		; Is it end of word?
0757: F24F07   [51|51]  	JP	P,OUTWRD	; No - output the rest
075A: C33607   [61]     	JP	LSTLP3		; Next byte in line
                        ;
075D: E5       [11]     SETLIN: PUSH	HL		; Set up LINES counter
075E: 2A8D80   [27]     	LD	HL,(LINESN)	; Get LINES number
0761: 228B80   [43]     	LD	(LINESC),HL	; Save in LINES counter
0764: E1       [53]     	POP	HL
0765: C9       [63]     	RET
                        ;
0766: E5       [11]     COUNT:	PUSH	HL		; Save code string address
0767: D5       [22]     	PUSH	DE
0768: 2A8B80   [38]     	LD	HL,(LINESC)	; Get LINES counter
076B: 11FFFF   [48]     	LD	DE,-1
076E: ED5A     [63]     	ADC	HL,DE		; Decrement
0770: 228B80   [79]     	LD	(LINESC),HL	; Put it back
0773: D1       [89]     	POP	DE
0774: E1       [99]     	POP	HL		; Restore code string address
0775: F0       [104|110]	RET	P		; Return if more lines to go
0776: E5       [115]    	PUSH	HL		; Save code string address
0777: 2A8D80   [131]    	LD	HL,(LINESN)	; Get LINES number
077A: 228B80   [147]    	LD	(LINESC),HL	; Reset LINES counter
077D: CD501B   [164]    	CALL	GETINP		; Get input character
0780: FE03     [171]    	CP	CTRLC		; Is it control "C"?
0782: CA8907   [181|181]	JP	Z,RSLNBK	; Yes - Reset LINES and break
0785: E1       [191]    	POP	HL		; Restore code string address
0786: C36607   [201]    	JP	COUNT		; Keep on counting
                        ;
0789: 2A8D80   [16]     RSLNBK: LD	HL,(LINESN)	; Get LINES number
078C: 228B80   [32]     	LD	(LINESC),HL	; Reset LINES counter
078F: C3BD00   [42]     	JP	BRKRET		; Go and output "Break"
                        ;
0792: 3E64     [ 7]     FOR:	LD	A,64H		; Flag "FOR" assignment
0794: 321081   [20]     	LD	(FORFLG),A	; Save "FOR" flag
0797: CDF909   [37]     	CALL	LET		; Set up initial index
079A: C1       [47]     	POP	BC		; Drop RETurn address
079B: E5       [58]     	PUSH	HL		; Save code string address
079C: CDE209   [75]     	CALL	DATA		; Get next statement address
079F: 220C81   [91]     	LD	(LOOPST),HL	; Save it for start of loop
07A2: 210200   [101]    	LD	HL,2		; Offset for "FOR" block
07A5: 39       [112]    	ADD	HL,SP		; Point to it
07A6: CDA003   [17]     FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
07A9: D1       [27]     	POP	DE		; Get code string address
07AA: C2C207   [37|37]  	JP	NZ,FORFND	; No nesting found
07AD: 09       [48]     	ADD	HL,BC		; Move into "FOR" block
07AE: D5       [59]     	PUSH	DE		; Save code string address
07AF: 2B       [65]     	DEC	HL
07B0: 56       [72]     	LD	D,(HL)		; Get MSB of loop statement
07B1: 2B       [78]     	DEC	HL
07B2: 5E       [85]     	LD	E,(HL)		; Get LSB of loop statement
07B3: 23       [91]     	INC	HL
07B4: 23       [97]     	INC	HL
07B5: E5       [108]    	PUSH	HL		; Save block address
07B6: 2A0C81   [124]    	LD	HL,(LOOPST)	; Get address of loop statement
07B9: CDBB06   [141]    	CALL	CPDEHL		; Compare the FOR loops
07BC: E1       [151]    	POP	HL		; Restore block address
07BD: C2A607   [161|161]	JP	NZ,FORSLP	; Different FORs - Find another
07C0: D1       [171]    	POP	DE		; Restore code string address
07C1: F9       [177]    	LD	SP,HL		; Remove all nested loops
                        ;
07C2: EB       [ 4]     FORFND: EX	DE,HL		; Code string address to HL
07C3: 0E08     [11]     	LD	C,8
07C5: CDD003   [28]     	CALL	CHKSTK		; Check for 8 levels of stack
07C8: E5       [39]     	PUSH	HL		; Save code string address
07C9: 2A0C81   [55]     	LD	HL,(LOOPST)	; Get first statement of loop
07CC: E3       [74]     	EX	(SP),HL		; Save and restore code string
07CD: E5       [85]     	PUSH	HL		; Re-save code string address
07CE: 2AA180   [101]    	LD	HL,(LINEAT)	; Get current line number
07D1: E3       [120]    	EX	(SP),HL		; Save and restore code string
07D2: CDBB0C   [137]    	CALL	TSTNUM		; Make sure it's a number
07D5: CDC106   [154]    	CALL	CHKSYN		; Make sure "TO" is next
07D8: A6                	DB	ZTO		; "TO" token
07D9: CDB80C   [171]    	CALL	GETNUM		; Get "TO" expression value
07DC: E5       [182]    	PUSH	HL		; Save code string address
07DD: CDE616   [199]    	CALL	BCDEFP		; Move "TO" value to BCDE
07E0: E1       [209]    	POP	HL		; Restore code string address
07E1: C5       [220]    	PUSH	BC		; Save "TO" value in block
07E2: D5       [231]    	PUSH	DE
07E3: 010081   [241]    	LD	BC,8100H	; BCDE - 1 (default STEP)
07E6: 51       [245]    	LD	D,C		; C=0
07E7: 5A       [249]    	LD	E,D		; D=0
07E8: 7E       [256]    	LD	A,(HL)		; Get next byte in code string
07E9: FEAB     [263]    	CP	ZSTEP		; See if "STEP" is stated
07EB: 3E01     [270]    	LD	A,1		; Sign of step = 1
07ED: C2FE07   [280|280]	JP	NZ,SAVSTP	; No STEP given - Default to 1
07F0: CD4B08   [297]    	CALL	GETCHR		; Jump over "STEP" token
07F3: CDB80C   [314]    	CALL	GETNUM		; Get step value
07F6: E5       [325]    	PUSH	HL		; Save code string address
07F7: CDE616   [342]    	CALL	BCDEFP		; Move STEP to BCDE
07FA: CD9A16   [359]    	CALL	TSTSGN		; Test sign of FPREG
07FD: E1       [369]    	POP	HL		; Restore code string address
07FE: C5       [11]     SAVSTP: PUSH	BC		; Save the STEP value in block
07FF: D5       [22]     	PUSH	DE
0800: F5       [33]     	PUSH	AF		; Save sign of STEP
0801: 33       [39]     	INC	SP		; Don't save flags
0802: E5       [50]     	PUSH	HL		; Save code string address
0803: 2A1381   [66]     	LD	HL,(BRKLIN)	; Get address of index variable
0806: E3       [85]     	EX	(SP),HL		; Save and restore code string
0807: 0681     [ 7]     PUTFID: LD	B,ZFOR		; "FOR" block marker
0809: C5       [18]     	PUSH	BC		; Save it
080A: 33       [24]     	INC	SP		; Don't save C
                        ;
080B: CD7608   [17]     RUNCNT: CALL	TSTBRK		; Execution driver - Test break
080E: 221381   [33]     	LD	(BRKLIN),HL	; Save code address for break
0811: 7E       [40]     	LD	A,(HL)		; Get next byte in code string
0812: FE3A     [47]     	CP	':'		; Multi statement line?
0814: CA2B08   [57|57]  	JP	Z,EXCUTE	; Yes - Execute it
0817: B7       [61]     	OR	A		; End of line?
0818: C2F303   [71|71]  	JP	NZ,SNERR	; No - Syntax error
081B: 23       [77]     	INC	HL		; Point to address of next line
081C: 7E       [84]     	LD	A,(HL)		; Get LSB of line pointer
081D: 23       [90]     	INC	HL
081E: B6       [97]     	OR	(HL)		; Is it zero (End of prog)?
081F: CA9D08   [107|107]	JP	Z,ENDPRG	; Yes - Terminate execution
0822: 23       [113]    	INC	HL		; Point to line number
0823: 5E       [120]    	LD	E,(HL)		; Get LSB of line number
0824: 23       [126]    	INC	HL
0825: 56       [133]    	LD	D,(HL)		; Get MSB of line number
0826: EB       [137]    	EX	DE,HL		; Line number to HL
0827: 22A180   [153]    	LD	(LINEAT),HL	; Save as current line number
082A: EB       [157]    	EX	DE,HL		; Line number back to DE
082B: CD4B08   [17]     EXCUTE: CALL	GETCHR		; Get key word
082E: 110B08   [27]     	LD	DE,RUNCNT	; Where to RETurn to
0831: D5       [38]     	PUSH	DE		; Save for RETurn
0832: C8       [ 5|11]  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
0833: D680     [ 7]     ONJMP:	SUB	ZEND		; Is it a token?
0835: DAF909   [17|17]  	JP	C,LET		; No - try to assign it
0838: FE25     [24]     	CP	ZNEW+1-ZEND	; END to NEW ?
083A: D2F303   [34|34]  	JP	NC,SNERR	; Not a key word - ?SN Error
083D: 07       [38]     	RLCA			; Double it
083E: 4F       [42]     	LD	C,A		; BC = Offset into table
083F: 0600     [49]     	LD	B,0
0841: EB       [53]     	EX	DE,HL		; Save code string address
0842: 219B02   [63]     	LD	HL,WORDTB	; Keyword address table
0845: 09       [74]     	ADD	HL,BC		; Point to routine address
0846: 4E       [81]     	LD	C,(HL)		; Get LSB of routine address
0847: 23       [87]     	INC	HL
0848: 46       [94]     	LD	B,(HL)		; Get MSB of routine address
0849: C5       [105]    	PUSH	BC		; Save routine address
084A: EB       [109]    	EX	DE,HL		; Restore code string address
                        ;
084B: 23       [ 6]     GETCHR: INC	HL		; Point to next character
084C: 7E       [13]     	LD	A,(HL)		; Get next code string byte
084D: FE3A     [20]     	CP	':'		; Z if ':'
084F: D0       [25|31]  	RET	NC		; NC if > "9"
0850: FE20     [32]     	CP	' '
0852: CA4B08   [42|42]  	JP	Z,GETCHR	; Skip over spaces
0855: FE30     [49]     	CP	'0'
0857: 3F       [53]     	CCF			; NC if < '0'
0858: 3C       [57]     	INC	A		; Test for zero - Leave carry
0859: 3D       [61]     	DEC	A		; Z if Null
085A: C9       [71]     	RET
                        ;
085B: EB       [ 4]     RESTOR: EX	DE,HL		; Save code string address
085C: 2AA380   [20]     	LD	HL,(BASTXT)	; Point to start of program
085F: CA7008   [30|30]  	JP	Z,RESTNL	; Just RESTORE - reset pointer
0862: EB       [34]     	EX	DE,HL		; Restore code string address
0863: CD1709   [51]     	CALL	ATOH		; Get line number to DE
0866: E5       [62]     	PUSH	HL		; Save code string address
0867: CDDF04   [79]     	CALL	SRCHLN		; Search for line number in DE
086A: 60       [83]     	LD	H,B		; HL = Address of line
086B: 69       [87]     	LD	L,C
086C: D1       [97]     	POP	DE		; Restore code string address
086D: D2B809   [107|107]	JP	NC,ULERR	; ?UL Error if not found
0870: 2B       [ 6]     RESTNL: DEC	HL		; Byte before DATA statement
0871: 222181   [16]     UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
0874: EB       [20]     	EX	DE,HL		; Restore code string address
0875: C9       [30]     	RET
                        ;
                        
0876: DF       [11]     TSTBRK: RST	18H		; Check input status
0877: C8       [16|22]  	RET	Z		; No key, go back
0878: D7       [27]     	RST	10H		; Get the key into A
0879: FE1B     [34]     	CP	ESC		; Escape key?
087B: 2811     [41|46]  	JR	Z,BRK		; Yes, break
087D: FE03     [48]     	CP	CTRLC		; <Ctrl-C>
087F: 280D     [55|60]  	JR	Z,BRK		; Yes, break
0881: FE13     [62]     	CP	CTRLS		; Stop scrolling?
0883: C0       [67|73]  	RET	NZ		; Other key, ignore
                        ;
                        
0884: D7       [11]     STALL:	RST	10H		; Wait for key
0885: FE11     [18]     	CP	CTRLQ		; Resume scrolling?
0887: C8       [23|29]  	RET	Z		; Release the chokehold
0888: FE03     [30]     	CP	CTRLC		; Second break?
088A: 2807     [37|42]  	JR	Z,STOP		; Break during hold exits prog
088C: 18F6     [49]     	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                        ;
088E: 3EFF     [ 7]     BRK	LD	A,0FFH		; Set BRKFLG
0890: 329280   [20]     	LD	(BRKFLG),A	; Store it
                        ;
                        
0893: C0       [ 5|11]  STOP:	RET	NZ		; Exit if anything else
0894: F6                	DB	0F6H		; Flag "STOP"
0895: C0       [ 5|11]  PEND:	RET	NZ		; Exit if anything else
0896: 221381   [21]     	LD	(BRKLIN),HL	; Save point of break
0899: 21                	DB	21H		; Skip "OR 11111111B"
089A: F6FF     [ 7]     INPBRK: OR	11111111B	; Flag "Break" wanted
089C: C1       [17]     	POP	BC		; Return not needed and more
089D: 2AA180   [16]     ENDPRG: LD	HL,(LINEAT)	; Get current line number
08A0: F5       [27]     	PUSH	AF		; Save STOP / END status
08A1: 7D       [31]     	LD	A,L		; Is it direct break?
08A2: A4       [35]     	AND	H
08A3: 3C       [39]     	INC	A		; Line is -1 if direct break
08A4: CAB008   [49|49]  	JP	Z,NOLIN		; Yes - No line number
08A7: 221781   [65]     	LD	(ERRLIN),HL	; Save line of break
08AA: 2A1381   [81]     	LD	HL,(BRKLIN)	; Get point of break
08AD: 221981   [97]     	LD	(CONTAD),HL	; Save point to CONTinue
08B0: AF       [ 4]     NOLIN:	XOR	A
08B1: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
08B4: CDE60A   [34]     	CALL	STTLIN		; Start a new line
08B7: F1       [44]     	POP	AF		; Restore STOP / END status
08B8: 219603   [54]     	LD	HL,BRKMSG	; "Break" message
08BB: C22704   [64|64]  	JP	NZ,ERRIN	; "in line" wanted?
08BE: C33E04   [74]     	JP	PRNTOK		; Go to command mode
                        ;
08C1: 2A1981   [16]     CONT:	LD	HL,(CONTAD)	; Get CONTinue address
08C4: 7C       [20]     	LD	A,H		; Is it zero?
08C5: B5       [24]     	OR	L
08C6: 1E20     [31]     	LD	E,CN		; ?CN Error
08C8: CA0704   [41|41]  	JP	Z,ERROR		; Yes - output "?CN Error"
08CB: EB       [45]     	EX	DE,HL		; Save code string address
08CC: 2A1781   [61]     	LD	HL,(ERRLIN)	; Get line of last break
08CF: 22A180   [77]     	LD	(LINEAT),HL	; Set up current line number
08D2: EB       [81]     	EX	DE,HL		; Restore code string address
08D3: C9       [91]     	RET			; CONTinue where left off
                        ;
08D4: CD1914   [17]     NULL:	CALL	GETINT		; Get integer 0-255
08D7: C0       [22|28]  	RET	NZ		; Return if bad value
08D8: 328680   [35]     	LD	(NULLS),A	; Set nulls number
08DB: C9       [45]     	RET
                        ;
                        
08DC: E5       [11]     ACCSUM: PUSH	HL		; Save address in array
08DD: 2A8F80   [27]     	LD	HL,(CHKSUM)	; Get check sum
08E0: 0600     [34]     	LD	B,0		; BC - Value of byte
08E2: 4F       [38]     	LD	C,A
08E3: 09       [49]     	ADD	HL,BC		; Add byte to check sum
08E4: 228F80   [65]     	LD	(CHKSUM),HL	; Re-save check sum
08E7: E1       [75]     	POP	HL		; Restore address in array
08E8: C9       [85]     	RET
                        ;
08E9: 7E       [ 7]     CHKLTR: LD	A,(HL)		; Get byte
08EA: FE41     [14]     	CP	'A'		; < 'a' ?
08EC: D8       [19|25]  	RET	C		; Carry set if not letter
08ED: FE5B     [26]     	CP	'Z'+1		; > 'z' ?
08EF: 3F       [30]     	CCF
08F0: C9       [40]     	RET			; Carry set if not letter
                        ;
08F1: CD4B08   [17]     FPSINT: CALL	GETCHR		; Get next character
08F4: CDB80C   [17]     POSINT: CALL	GETNUM		; Get integer 0 to 32767
08F7: CD9A16   [17]     DEPINT: CALL	TSTSGN		; Test sign of FPREG
08FA: FA1209   [27|27]  	JP	M,FCERR		; Negative - ?FC Error
08FD: 3A2C81   [13]     DEINT:	LD	A,(FPEXP)	; Get integer value to DE
0900: FE90     [20]     	CP	80H+16		; Exponent in range (16 bits)?
0902: DA4217   [30|30]  	JP	C,FPINT		; Yes - convert it
0905: 018090   [40]     	LD	BC,9080H	; BCDE = -32768
0908: 110000   [50]     	LD	DE,0000
090B: E5       [61]     	PUSH	HL		; Save code string address
090C: CD1517   [78]     	CALL	CMPNUM		; Compare FPREG with BCDE
090F: E1       [88]     	POP	HL		; Restore code string address
0910: 51       [92]     	LD	D,C		; MSB to D
0911: C8       [97|103] 	RET	Z		; Return if in range
0912: 1E08     [ 7]     FCERR:	LD	E,FC		; ?FC Error
0914: C30704   [17]     	JP	ERROR		; Output error-
                        ;
0917: 2B       [ 6]     ATOH:	DEC	HL		; ASCII number to DE binary
0918: 110000   [10]     GETLN:	LD	DE,0		; Get number to DE
091B: CD4B08   [17]     GTLNLP: CALL	GETCHR		; Get next character
091E: D0       [22|28]  	RET	NC		; Exit if not a digit
091F: E5       [33]     	PUSH	HL		; Save code string address
0920: F5       [44]     	PUSH	AF		; Save digit
0921: 219819   [54]     	LD	HL,65529/10	; Largest number 65529
0924: CDBB06   [71]     	CALL	CPDEHL		; Number in range?
0927: DAF303   [81|81]  	JP	C,SNERR		; No - ?SN Error
092A: 62       [85]     	LD	H,D		; HL = Number
092B: 6B       [89]     	LD	L,E
092C: 19       [100]    	ADD	HL,DE		; Times 2
092D: 29       [111]    	ADD	HL,HL		; Times 4
092E: 19       [122]    	ADD	HL,DE		; Times 5
092F: 29       [133]    	ADD	HL,HL		; Times 10
0930: F1       [143]    	POP	AF		; Restore digit
0931: D630     [150]    	SUB	'0'		; Make it 0 to 9
0933: 5F       [154]    	LD	E,A		; DE = Value of digit
0934: 1600     [161]    	LD	D,0
0936: 19       [172]    	ADD	HL,DE		; Add to number
0937: EB       [176]    	EX	DE,HL		; Number to DE
0938: E1       [186]    	POP	HL		; Restore code string address
0939: C31B09   [196]    	JP	GTLNLP		; Go to next character
                        ;
093C: CA0F05   [10|10]  CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
093F: CDF408   [27]     	CALL	POSINT		; Get integer 0 to 32767 to DE
0942: 2B       [33]     	DEC	HL		; Cancel increment
0943: CD4B08   [50]     	CALL	GETCHR		; Get next character
0946: E5       [61]     	PUSH	HL		; Save code string address
0947: 2AF480   [77]     	LD	HL,(LSTRAM)	; Get end of RAM
094A: CA5F09   [87|87]  	JP	Z,STORED	; No value given - Use stored
094D: E1       [97]     	POP	HL		; Restore code string address
094E: CDC106   [114]    	CALL	CHKSYN		; Check for comma
0951: 2C                	DB	','
0952: D5       [125]    	PUSH	DE		; Save number
0953: CDF408   [142]    	CALL	POSINT		; Get integer 0 to 32767
0956: 2B       [148]    	DEC	HL		; Cancel increment
0957: CD4B08   [165]    	CALL	GETCHR		; Get next character
095A: C2F303   [175|175]	JP	NZ,SNERR	; ?SN Error if more on line
095D: E3       [194]    	EX	(SP),HL		; Save code string address
095E: EB       [198]    	EX	DE,HL		; Number to DE
095F: 7D       [ 4]     STORED: LD	A,L		; Get LSB of new RAM top
0960: 93       [ 8]     	SUB	E		; Subtract LSB of string space
0961: 5F       [12]     	LD	E,A		; Save LSB
0962: 7C       [16]     	LD	A,H		; Get MSB of new RAM top
0963: 9A       [20]     	SBC	A,D		; Subtract MSB of string space
0964: 57       [24]     	LD	D,A		; Save MSB
0965: DAE803   [34|34]  	JP	C,OMERR		; ?OM Error if not enough mem
0968: E5       [45]     	PUSH	HL		; Save RAM top
0969: 2A1B81   [61]     	LD	HL,(PROGND)	; Get program end
096C: 012800   [71]     	LD	BC,40		; 40 Bytes minimum working RAM
096F: 09       [82]     	ADD	HL,BC		; Get lowest address
0970: CDBB06   [99]     	CALL	CPDEHL		; Enough memory?
0973: D2E803   [109|109]	JP	NC,OMERR	; No - ?OM Error
0976: EB       [113]    	EX	DE,HL		; RAM top to HL
0977: 229F80   [129]    	LD	(STRSPC),HL	; Set new string space
097A: E1       [139]    	POP	HL		; End of memory to use
097B: 22F480   [155]    	LD	(LSTRAM),HL	; Set new top of RAM
097E: E1       [165]    	POP	HL		; Restore code string address
097F: C30F05   [175]    	JP	INTVAR		; Initialise variables
                        ;
0982: CA0B05   [10|10]  RUN:	JP	Z,RUNFST	; RUN from start if just RUN
0985: CD0F05   [27]     	CALL	INTVAR		; Initialise variables
0988: 010B08   [37]     	LD	BC,RUNCNT	; Execution driver loop
098B: C39E09   [47]     	JP	RUNLIN		; RUN from line number
                        ;
098E: 0E03     [ 7]     GOSUB:	LD	C,3		; 3 Levels of stack needed
0990: CDD003   [24]     	CALL	CHKSTK		; Check for 3 levels of stack
0993: C1       [34]     	POP	BC		; Get return address
0994: E5       [45]     	PUSH	HL		; Save code string for RETURN
0995: E5       [56]     	PUSH	HL		; And for GOSUB routine
0996: 2AA180   [72]     	LD	HL,(LINEAT)	; Get current line
0999: E3       [91]     	EX	(SP),HL		; Into stack - Code string out
099A: 3E8C     [98]     	LD	A,ZGOSUB	; "GOSUB" token
099C: F5       [109]    	PUSH	AF		; Save token
099D: 33       [115]    	INC	SP		; Don't save flags
                        ;
099E: C5       [11]     RUNLIN: PUSH	BC		; Save return address
099F: CD1709   [17]     GOTO:	CALL	ATOH		; ASCII number to DE binary
09A2: CDE409   [34]     	CALL	REM		; Get end of line
09A5: E5       [45]     	PUSH	HL		; Save end of line
09A6: 2AA180   [61]     	LD	HL,(LINEAT)	; Get current line
09A9: CDBB06   [78]     	CALL	CPDEHL		; Line after current?
09AC: E1       [88]     	POP	HL		; Restore end of line
09AD: 23       [94]     	INC	HL		; Start of next line
09AE: DCE204   [104|111]	CALL	C,SRCHLP	; Line is after current line
09B1: D4DF04   [114|121]	CALL	NC,SRCHLN	; Line is before current line
09B4: 60       [118]    	LD	H,B		; Set up code string address
09B5: 69       [122]    	LD	L,C
09B6: 2B       [128]    	DEC	HL		; Incremented after
09B7: D8       [133|139]	RET	C		; Line found
09B8: 1E0E     [ 7]     ULERR:	LD	E,UL		; ?UL Error
09BA: C30704   [17]     	JP	ERROR		; Output error message
                        ;
09BD: C0       [ 5|11]  RETURN: RET	NZ		; Return if not just RETURN
09BE: 16FF     [12]     	LD	D,-1		; Flag "GOSUB" search
09C0: CD9C03   [29]     	CALL	BAKSTK		; Look "GOSUB" block
09C3: F9       [35]     	LD	SP,HL		; Kill all FORs in subroutine
09C4: FE8C     [42]     	CP	ZGOSUB		; Test for "GOSUB" token
09C6: 1E04     [49]     	LD	E,RG		; ?RG Error
09C8: C20704   [59|59]  	JP	NZ,ERROR	; Error if no "GOSUB" found
09CB: E1       [69]     	POP	HL		; Get RETURN line number
09CC: 22A180   [85]     	LD	(LINEAT),HL	; Save as current
09CF: 23       [91]     	INC	HL		; Was it from direct statement?
09D0: 7C       [95]     	LD	A,H
09D1: B5       [99]     	OR	L		; Return to line
09D2: C2DC09   [109|109]	JP	NZ,RETLIN	; No - Return to line
09D5: 3A1181   [122]    	LD	A,(LSTBIN)	; Any INPUT in subroutine?
09D8: B7       [126]    	OR	A		; If so buffer is corrupted
09D9: C23D04   [136|136]	JP	NZ,POPNOK	; Yes - Go to command mode
09DC: 210B08   [10]     RETLIN: LD	HL,RUNCNT	; Execution driver loop
09DF: E3       [29]     	EX	(SP),HL		; Into stack - Code string out
09E0: 3E                	DB	3EH		; Skip "POP HL"
09E1: E1       [10]     NXTDTA: POP	HL		; Restore code string address
                        ;
09E2: 013A              DATA:	DB	01H,3AH		; ':' End of statement
09E4: 0E00     [ 7]     REM:	LD	C,0		; 00	End of statement
09E6: 0600     [14]     	LD	B,0
09E8: 79       [ 4]     NXTSTL: LD	A,C		; Statement and byte
09E9: 48       [ 8]     	LD	C,B
09EA: 47       [12]     	LD	B,A		; Statement end byte
09EB: 7E       [ 7]     NXTSTT: LD	A,(HL)		; Get byte
09EC: B7       [11]     	OR	A		; End of line?
09ED: C8       [16|22]  	RET	Z		; Yes - Exit
09EE: B8       [20]     	CP	B		; End of statement?
09EF: C8       [25|31]  	RET	Z		; Yes - Exit
09F0: 23       [31]     	INC	HL		; Next byte
09F1: FE22     [38]     	CP	'"'		; Literal string?
09F3: CAE809   [48|48]  	JP	Z,NXTSTL	; Yes - Look for another '"'
09F6: C3EB09   [58]     	JP	NXTSTT		; Keep looking
                        ;
09F9: CDAE0E   [17]     LET:	CALL	GETVAR		; Get variable name
09FC: CDC106   [34]     	CALL	CHKSYN		; Make sure "=" follows
09FF: B4                	DB	ZEQUAL		; "=" token
0A00: D5       [45]     	PUSH	DE		; Save address of variable
0A01: 3AF280   [58]     	LD	A,(TYPE)	; Get data type
0A04: F5       [69]     	PUSH	AF		; Save type
0A05: CDCA0C   [86]     	CALL	EVAL		; Evaluate expression
0A08: F1       [96]     	POP	AF		; Restore type
0A09: E3       [115]    	EX	(SP),HL		; Save code - Get var addr
0A0A: 221381   [131]    	LD	(BRKLIN),HL	; Save address of variable
0A0D: 1F       [135]    	RRA			; Adjust type
0A0E: CDBD0C   [152]    	CALL	CHKTYP		; Check types are the same
0A11: CA4C0A   [162|162]	JP	Z,LETNUM	; Numeric - Move value
0A14: E5       [11]     LETSTR: PUSH	HL		; Save address of string var
0A15: 2A2981   [27]     	LD	HL,(FPREG)	; Pointer to string entry
0A18: E5       [38]     	PUSH	HL		; Save it on stack
0A19: 23       [44]     	INC	HL		; Skip over length
0A1A: 23       [50]     	INC	HL
0A1B: 5E       [57]     	LD	E,(HL)		; LSB of string address
0A1C: 23       [63]     	INC	HL
0A1D: 56       [70]     	LD	D,(HL)		; MSB of string address
0A1E: 2AA380   [86]     	LD	HL,(BASTXT)	; Point to start of program
0A21: CDBB06   [103]    	CALL	CPDEHL		; Is string before program?
0A24: D23B0A   [113|113]	JP	NC,CRESTR	; Yes - Create string entry
0A27: 2A9F80   [129]    	LD	HL,(STRSPC)	; Point to string space
0A2A: CDBB06   [146]    	CALL	CPDEHL		; Is string literal in program?
0A2D: D1       [156]    	POP	DE		; Restore address of string
0A2E: D2430A   [166|166]	JP	NC,MVSTPT	; Yes - Set up pointer
0A31: 210481   [176]    	LD	HL,TMPSTR	; Temporary string pool
0A34: CDBB06   [193]    	CALL	CPDEHL		; Is string in temporary pool?
0A37: D2430A   [203|203]	JP	NC,MVSTPT	; No - Set up pointer
0A3A: 3E                	DB	3EH		; Skip "POP DE"
0A3B: D1       [10]     CRESTR: POP	DE		; Restore address of string
0A3C: CDF212   [27]     	CALL	BAKTMP		; Back to last tmp-str entry
0A3F: EB       [31]     	EX	DE,HL		; Address of string entry
0A40: CD2B11   [48]     	CALL	SAVSTR		; Save string in string area
0A43: CDF212   [17]     MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
0A46: E1       [27]     	POP	HL		; Get string pointer
0A47: CDF516   [44]     	CALL	DETHL4		; Move string pointer to var
0A4A: E1       [54]     	POP	HL		; Restore code string address
0A4B: C9       [64]     	RET
                        ;
0A4C: E5       [11]     LETNUM: PUSH	HL		; Save address of variable
0A4D: CDF216   [28]     	CALL	FPTHL		; Move value to variable
0A50: D1       [38]     	POP	DE		; Restore address of variable
0A51: E1       [48]     	POP	HL		; Restore code string address
0A52: C9       [58]     	RET
                        ;
0A53: CD1914   [17]     ON:	CALL	GETINT		; Get integer 0-255
0A56: 7E       [24]     	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
0A57: 47       [28]     	LD	B,A		; Save in B
0A58: FE8C     [35]     	CP	ZGOSUB		; "GOSUB" token?
0A5A: CA620A   [45|45]  	JP	Z,ONGO		; Yes - Find line number
0A5D: CDC106   [62]     	CALL	CHKSYN		; Make sure it's "GOTO"
0A60: 88                	DB	ZGOTO		; "GOTO" token
0A61: 2B       [68]     	DEC	HL		; Cancel increment
0A62: 4B       [ 4]     ONGO:	LD	C,E		; Integer of branch value
0A63: 0D       [ 4]     ONGOLP: DEC	C		; Count branches
0A64: 78       [ 8]     	LD	A,B		; Get "GOTO" or "GOSUB" token
0A65: CA3308   [18|18]  	JP	Z,ONJMP		; Go to that line if right one
0A68: CD1809   [35]     	CALL	GETLN		; Get line number to DE
0A6B: FE2C     [42]     	CP	','		; Another line number?
0A6D: C0       [47|53]  	RET	NZ		; No - Drop through
0A6E: C3630A   [57]     	JP	ONGOLP		; Yes - loop
                        ;
0A71: CDCA0C   [17]     IF:	CALL	EVAL		; Evaluate expression
0A74: 7E       [24]     	LD	A,(HL)		; Get token
0A75: FE88     [31]     	CP	ZGOTO		; "GOTO" token?
0A77: CA7F0A   [41|41]  	JP	Z,IFGO		; Yes - Get line
0A7A: CDC106   [58]     	CALL	CHKSYN		; Make sure it's "THEN"
0A7D: A9                	DB	ZTHEN		; "THEN" token
0A7E: 2B       [64]     	DEC	HL		; Cancel increment
0A7F: CDBB0C   [17]     IFGO:	CALL	TSTNUM		; Make sure it's numeric
0A82: CD9A16   [34]     	CALL	TSTSGN		; Test state of expression
0A85: CAE409   [44|44]  	JP	Z,REM		; False - Drop through
0A88: CD4B08   [61]     	CALL	GETCHR		; Get next character
0A8B: DA9F09   [71|71]  	JP	C,GOTO		; Number - GOTO that line
0A8E: C33208   [81]     	JP	IFJMP		; Otherwise do statement
                        ;
0A91: 2B       [ 6]     MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
0A92: CD4B08   [23]     	CALL	GETCHR		; Get next character
0A95: CAF30A   [10|10]  PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
0A98: C8       [ 5|11]  PRNTLP: RET	Z		; End of list - Exit
0A99: FEA5     [12]     	CP	ZTAB		; "TAB(" token?
0A9B: CA260B   [22|22]  	JP	Z,DOTAB		; Yes - Do TAB routine
0A9E: FEA8     [29]     	CP	ZSPC		; "SPC(" token?
0AA0: CA260B   [39|39]  	JP	Z,DOTAB		; Yes - Do SPC routine
0AA3: E5       [50]     	PUSH	HL		; Save code string address
0AA4: FE2C     [57]     	CP	','		; Comma?
0AA6: CA0F0B   [67|67]  	JP	Z,DOCOM		; Yes - Move to next zone
0AA9: FE3B     [74]     	CP	59;";"		; Semi-colon?
0AAB: CA490B   [84|84]  	JP	Z,NEXITM	; Do semi-colon routine
0AAE: C1       [94]     	POP	BC		; Code string address to BC
0AAF: CDCA0C   [111]    	CALL	EVAL		; Evaluate expression
0AB2: E5       [122]    	PUSH	HL		; Save code string address
0AB3: 3AF280   [135]    	LD	A,(TYPE)	; Get variable type
0AB6: B7       [139]    	OR	A		; Is it a string variable?
0AB7: C2DF0A   [149|149]	JP	NZ,PRNTST	; Yes - Output string contents
0ABA: CD3F18   [166]    	CALL	NUMASC		; Convert number to text
0ABD: CD4F11   [183]    	CALL	CRTST		; Create temporary string
0AC0: 3620     [193]    	LD	(HL),' '	; Followed by a space
0AC2: 2A2981   [209]    	LD	HL,(FPREG)	; Get length of output
0AC5: 34       [220]    	INC	(HL)		; Plus 1 for the space
0AC6: 2A2981   [236]    	LD	HL,(FPREG)	; < Not needed >
0AC9: 3A8780   [249]    	LD	A,(LWIDTH)	; Get width of line
0ACC: 47       [253]    	LD	B,A		; To B
0ACD: 04       [257]    	INC	B		; Width 255 (No limit)?
0ACE: CADB0A   [267|267]	JP	Z,PRNTNB	; Yes - Output number string
0AD1: 04       [271]    	INC	B		; Adjust it
0AD2: 3AF080   [284]    	LD	A,(CURPOS)	; Get cursor position
0AD5: 86       [291]    	ADD	A,(HL)		; Add length of string
0AD6: 3D       [295]    	DEC	A		; Adjust it
0AD7: B8       [299]    	CP	B		; Will output fit on this line?
0AD8: D4F30A   [309|316]	CALL	NC,PRCRLF	; No - CRLF first
0ADB: CD9411   [17]     PRNTNB: CALL	PRS1		; Output string at (HL)
0ADE: AF       [21]     	XOR	A		; Skip CALL by setting 'z' flag
0ADF: C49411   [10|17]  PRNTST: CALL	NZ,PRS1		; Output string at (HL)
0AE2: E1       [20]     	POP	HL		; Restore code string address
0AE3: C3910A   [30]     	JP	MRPRNT		; See if more to PRINT
                        ;
0AE6: 3AF080   [13]     STTLIN: LD	A,(CURPOS)	; Make sure on new line
0AE9: B7       [17]     	OR	A		; Already at start?
0AEA: C8       [22|28]  	RET	Z		; Yes - Do nothing
0AEB: C3F30A   [32]     	JP	PRCRLF		; Start a new line
                        ;
0AEE: 3600     [10]     ENDINP: LD	(HL),0		; Mark end of buffer
0AF0: 21A580   [20]     	LD	HL,BUFFER-1	; Point to buffer
0AF3: 3E0D     [ 7]     PRCRLF: LD	A,CR		; Load a CR
0AF5: CDCC06   [24]     	CALL	OUTC		; Output character
0AF8: 3E0A     [31]     	LD	A,LF		; Load a LF
0AFA: CDCC06   [48]     	CALL	OUTC		; Output character
0AFD: AF       [ 4]     DONULL: XOR	A		; Set to position 0
0AFE: 32F080   [17]     	LD	(CURPOS),A	; Store it
0B01: 3A8680   [30]     	LD	A,(NULLS)	; Get number of nulls
0B04: 3D       [ 4]     NULLP:	DEC	A		; Count them
0B05: C8       [ 9|15]  	RET	Z		; Return if done
0B06: F5       [20]     	PUSH	AF		; Save count
0B07: AF       [24]     	XOR	A		; Load a null
0B08: CDCC06   [41]     	CALL	OUTC		; Output it
0B0B: F1       [51]     	POP	AF		; Restore count
0B0C: C3040B   [61]     	JP	NULLP		; Keep counting
                        ;
0B0F: 3A8880   [13]     DOCOM:	LD	A,(COMMAN)	; Get comma width
0B12: 47       [17]     	LD	B,A		; Save in B
0B13: 3AF080   [30]     	LD	A,(CURPOS)	; Get current position
0B16: B8       [34]     	CP	B		; Within the limit?
0B17: D4F30A   [44|51]  	CALL	NC,PRCRLF	; No - output CRLF
0B1A: D2490B   [54|54]  	JP	NC,NEXITM	; Get next item
0B1D: D60E     [ 7]     ZONELP: SUB	14		; Next zone of 14 characters
0B1F: D21D0B   [17|17]  	JP	NC,ZONELP	; Repeat if more zones
0B22: 2F       [21]     	CPL			; Number of spaces to output
0B23: C33E0B   [31]     	JP	ASPCS		; Output them
                        ;
0B26: F5       [11]     DOTAB:	PUSH	AF		; Save token
0B27: CD1614   [28]     	CALL	FNDNUM		; Evaluate expression
0B2A: CDC106   [45]     	CALL	CHKSYN		; Make sure ")" follows
0B2D: 29                	DB	")"
0B2E: 2B       [51]     	DEC	HL		; Back space on to ")"
0B2F: F1       [61]     	POP	AF		; Restore token
0B30: D6A8     [68]     	SUB	ZSPC		; Was it "SPC(" ?
0B32: E5       [79]     	PUSH	HL		; Save code string address
0B33: CA390B   [89|89]  	JP	Z,DOSPC	; Yes - Do 'E' spaces
0B36: 3AF080   [102]    	LD	A,(CURPOS)	; Get current position
0B39: 2F       [ 4]     DOSPC:	CPL			; Number of spaces to print to
0B3A: 83       [ 8]     	ADD	A,E		; Total number to print
0B3B: D2490B   [18|18]  	JP	NC,NEXITM	; TAB < Current POS(X)
0B3E: 3C       [ 4]     ASPCS:	INC	A		; Output A spaces
0B3F: 47       [ 8]     	LD	B,A		; Save number to print
0B40: 3E20     [15]     	LD	A,' '		; Space
0B42: CDCC06   [17]     SPCLP:	CALL	OUTC		; Output character in A
0B45: 05       [21]     	DEC	B		; Count them
0B46: C2420B   [31|31]  	JP	NZ,SPCLP	; Repeat if more
0B49: E1       [10]     NEXITM: POP	HL		; Restore code string address
0B4A: CD4B08   [27]     	CALL	GETCHR		; Get next character
0B4D: C3980A   [37]     	JP	PRNTLP		; More to print
                        ;
0B50: 3F526564          REDO:	DB	"?Redo from start",CR,LF,0
0B54: 6F206672          
0B58: 6F6D2073          
0B5C: 74617274          
0B60: 0D0A00            
                        ;
0B63: 3A1281   [13]     BADINP: LD	A,(READFG)	; READ or INPUT?
0B66: B7       [17]     	OR	A
0B67: C2ED03   [27|27]  	JP	NZ,DATSNR	; READ - ?SN Error
0B6A: C1       [37]     	POP	BC		; Throw away code string addr
0B6B: 21500B   [47]     	LD	HL,REDO		; "Redo from start" message
0B6E: CD9111   [64]     	CALL	PRS		; Output string
0B71: C33E05   [74]     	JP	DOAGN		; Do last INPUT again
                        ;
0B74: CDFC10   [17]     INPUT:	CALL	IDTEST		; Test for illegal direct
0B77: 7E       [24]     	LD	A,(HL)		; Get character after "INPUT"
0B78: FE22     [31]     	CP	'"'		; Is there a prompt string?
0B7A: 3E00     [38]     	LD	A,0		; Clear A and leave flags
0B7C: 328A80   [51]     	LD	(CTLOFG),A	; Enable output
0B7F: C28E0B   [61|61]  	JP	NZ,NOPMPT	; No prompt - get input
0B82: CD5011   [78]     	CALL	QTSTR		; Get string terminated by '"'
0B85: CDC106   [95]     	CALL	CHKSYN		; Check for ';' after prompt
0B88: 3B                	DB	';'
0B89: E5       [106]    	PUSH	HL		; Save code string address
0B8A: CD9411   [123]    	CALL	PRS1		; Output prompt string
0B8D: 3E                	DB	3EH		; Skip "PUSH HL"
0B8E: E5       [11]     NOPMPT: PUSH	HL		; Save code string address
0B8F: CD4205   [28]     	CALL	PROMPT		; Get input with "? " prompt
0B92: C1       [38]     	POP	BC		; Restore code string address
0B93: DA9A08   [48|48]  	JP	C,INPBRK	; Break pressed - Exit
0B96: 23       [54]     	INC	HL		; Next byte
0B97: 7E       [61]     	LD	A,(HL)		; Get it
0B98: B7       [65]     	OR	A		; End of line?
0B99: 2B       [71]     	DEC	HL		; Back again
0B9A: C5       [82]     	PUSH	BC		; Re-save code string address
0B9B: CAE109   [92|92]  	JP	Z,NXTDTA	; Yes - Find next DATA stmt
0B9E: 362C     [102]    	LD	(HL),','	; Store comma as separator
0BA0: C3A80B   [112]    	JP	NXTITM		; Get next item
                        ;
0BA3: E5       [11]     READ:	PUSH	HL		; Save code string address
0BA4: 2A2181   [27]     	LD	HL,(NXTDAT)	; Next DATA statement
0BA7: F6                	DB	0F6H		; Flag "READ"
0BA8: AF       [ 4]     NXTITM: XOR	A		; Flag "INPUT"
0BA9: 321281   [17]     	LD	(READFG),A	; Save "READ"/"INPUT" flag
0BAC: E3       [36]     	EX	(SP),HL		; Get code str' , Save pointer
0BAD: C3B40B   [46]     	JP	GTVLUS		; Get values
                        ;
0BB0: CDC106   [17]     NEDMOR: CALL	CHKSYN		; Check for comma between items
0BB3: 2C                	DB	','
0BB4: CDAE0E   [17]     GTVLUS: CALL	GETVAR		; Get variable name
0BB7: E3       [36]     	EX	(SP),HL		; Save code str" , Get pointer
0BB8: D5       [47]     	PUSH	DE		; Save variable address
0BB9: 7E       [54]     	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
0BBA: FE2C     [61]     	CP	','		; Comma?
0BBC: CADC0B   [71|71]  	JP	Z,ANTVLU	; Yes - Get another value
0BBF: 3A1281   [84]     	LD	A,(READFG)	; Is it READ?
0BC2: B7       [88]     	OR	A
0BC3: C2490C   [98|98]  	JP	NZ,FDTLP	; Yes - Find next DATA stmt
0BC6: 3E3F     [105]    	LD	A,'?'		; More INPUT needed
0BC8: CDCC06   [122]    	CALL	OUTC		; Output character
0BCB: CD4205   [139]    	CALL	PROMPT		; Get INPUT with prompt
0BCE: D1       [149]    	POP	DE		; Variable address
0BCF: C1       [159]    	POP	BC		; Code string address
0BD0: DA9A08   [169|169]	JP	C,INPBRK	; Break pressed
0BD3: 23       [175]    	INC	HL		; Point to next DATA byte
0BD4: 7E       [182]    	LD	A,(HL)		; Get byte
0BD5: B7       [186]    	OR	A		; Is it zero (No input) ?
0BD6: 2B       [192]    	DEC	HL		; Back space INPUT pointer
0BD7: C5       [203]    	PUSH	BC		; Save code string address
0BD8: CAE109   [213|213]	JP	Z,NXTDTA	; Find end of buffer
0BDB: D5       [224]    	PUSH	DE		; Save variable address
0BDC: 3AF280   [13]     ANTVLU: LD	A,(TYPE)	; Check data type
0BDF: B7       [17]     	OR	A		; Is it numeric?
0BE0: CA060C   [27|27]  	JP	Z,INPBIN	; Yes - Convert to binary
0BE3: CD4B08   [44]     	CALL	GETCHR		; Get next character
0BE6: 57       [48]     	LD	D,A		; Save input character
0BE7: 47       [52]     	LD	B,A		; Again
0BE8: FE22     [59]     	CP	'"'		; Start of literal sting?
0BEA: CAFA0B   [69|69]  	JP	Z,STRENT	; Yes - Create string entry
0BED: 3A1281   [82]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0BF0: B7       [86]     	OR	A
0BF1: 57       [90]     	LD	D,A		; Save 00 if "INPUT"
0BF2: CAF70B   [100|100]	JP	Z,ITMSEP	; "INPUT" - End with 00
0BF5: 163A     [107]    	LD	D,':'		; "DATA" - End with 00 or ':'
0BF7: 062C     [ 7]     ITMSEP: LD	B,','		; Item separator
0BF9: 2B       [13]     	DEC	HL		; Back space for DTSTR
0BFA: CD5311   [17]     STRENT: CALL	DTSTR		; Get string terminated by D
0BFD: EB       [21]     	EX	DE,HL		; String address to DE
0BFE: 21110C   [31]     	LD	HL,LTSTND	; Where to go after LETSTR
0C01: E3       [50]     	EX	(SP),HL		; Save HL , get input pointer
0C02: D5       [61]     	PUSH	DE		; Save address of string
0C03: C3140A   [71]     	JP	LETSTR		; Assign string to variable
                        ;
0C06: CD4B08   [17]     INPBIN: CALL	GETCHR		; Get next character
0C09: CDA117   [34]     	CALL	ASCTFP		; Convert ASCII to FP number
0C0C: E3       [53]     	EX	(SP),HL		; Save input ptr, Get var addr
0C0D: CDF216   [70]     	CALL	FPTHL		; Move FPREG to variable
0C10: E1       [80]     	POP	HL		; Restore input pointer
0C11: 2B       [ 6]     LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
0C12: CD4B08   [23]     	CALL	GETCHR		; Get next character
0C15: CA1D0C   [33|33]  	JP	Z,MORDT		; End of line - More needed?
0C18: FE2C     [40]     	CP	','		; Another value?
0C1A: C2630B   [50|50]  	JP	NZ,BADINP	; No - Bad input
0C1D: E3       [19]     MORDT:	EX	(SP),HL		; Get code string address
0C1E: 2B       [25]     	DEC	HL		; DEC 'cos GETCHR INCs
0C1F: CD4B08   [42]     	CALL	GETCHR		; Get next character
0C22: C2B00B   [52|52]  	JP	NZ,NEDMOR	; More needed - Get it
0C25: D1       [62]     	POP	DE		; Restore DATA pointer
0C26: 3A1281   [75]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0C29: B7       [79]     	OR	A
0C2A: EB       [83]     	EX	DE,HL		; DATA pointer to HL
0C2B: C27108   [93|93]  	JP	NZ,UPDATA	; Update DATA pointer if "READ"
0C2E: D5       [104]    	PUSH	DE		; Save code string address
0C2F: B6       [111]    	OR	(HL)		; More input given?
0C30: 21380C   [121]    	LD	HL,EXTIG	; "?Extra ignored" message
0C33: C49111   [131|138]	CALL	NZ,PRS		; Output string if extra given
0C36: E1       [141]    	POP	HL		; Restore code string address
0C37: C9       [151]    	RET
                        ;
0C38: 3F457874          EXTIG:	DB	"?Extra ignored",CR,LF,0
0C3C: 72612069          
0C40: 676E6F72          
0C44: 65640D0A          
0C48: 00                
                        ;
0C49: CDE209   [17]     FDTLP:	CALL	DATA		; Get next statement
0C4C: B7       [21]     	OR	A		; End of line?
0C4D: C2620C   [31|31]  	JP	NZ,FANDT	; No - See if DATA statement
0C50: 23       [37]     	INC	HL
0C51: 7E       [44]     	LD	A,(HL)		; End of program?
0C52: 23       [50]     	INC	HL
0C53: B6       [57]     	OR	(HL)		; 00 00 Ends program
0C54: 1E06     [64]     	LD	E,OD		; ?OD Error
0C56: CA0704   [74|74]  	JP	Z,ERROR		; Yes - Out of DATA
0C59: 23       [80]     	INC	HL
0C5A: 5E       [87]     	LD	E,(HL)		; LSB of line number
0C5B: 23       [93]     	INC	HL
0C5C: 56       [100]    	LD	D,(HL)		; MSB of line number
0C5D: EB       [104]    	EX	DE,HL
0C5E: 220E81   [120]    	LD	(DATLIN),HL	; Set line of current DATA item
0C61: EB       [124]    	EX	DE,HL
0C62: CD4B08   [17]     FANDT:	CALL	GETCHR		; Get next character
0C65: FE83     [24]     	CP	ZDATA		; "DATA" token
0C67: C2490C   [34|34]  	JP	NZ,FDTLP	; No "DATA" - Keep looking
0C6A: C3DC0B   [44]     	JP	ANTVLU		; Found - Convert input
                        ;
0C6D: 110000   [10]     NEXT:	LD	DE,0		; In case no index given
0C70: C4AE0E   [10|17]  NEXT1:	CALL	NZ,GETVAR	; Get index address
0C73: 221381   [26]     	LD	(BRKLIN),HL	; Save code string address
0C76: CD9C03   [43]     	CALL	BAKSTK		; Look for "FOR" block
0C79: C2F903   [53|53]  	JP	NZ,NFERR	; No "FOR" - ?NF Error
0C7C: F9       [59]     	LD	SP,HL		; Clear nested loops
0C7D: D5       [70]     	PUSH	DE		; Save index address
0C7E: 7E       [77]     	LD	A,(HL)		; Get sign of STEP
0C7F: 23       [83]     	INC	HL
0C80: F5       [94]     	PUSH	AF		; Save sign of STEP
0C81: D5       [105]    	PUSH	DE		; Save index address
0C82: CDD816   [122]    	CALL	PHLTFP		; Move index value to FPREG
0C85: E3       [141]    	EX	(SP),HL		; Save address of TO value
0C86: E5       [152]    	PUSH	HL		; Save address of index
0C87: CD4514   [169]    	CALL	ADDPHL		; Add STEP to index value
0C8A: E1       [179]    	POP	HL		; Restore address of index
0C8B: CDF216   [196]    	CALL	FPTHL		; Move value to index variable
0C8E: E1       [206]    	POP	HL		; Restore address of TO value
0C8F: CDE916   [223]    	CALL	LOADFP		; Move TO value to BCDE
0C92: E5       [234]    	PUSH	HL		; Save address of line of FOR
0C93: CD1517   [251]    	CALL	CMPNUM		; Compare index with TO value
0C96: E1       [261]    	POP	HL		; Restore address of line num
0C97: C1       [271]    	POP	BC		; Address of sign of STEP
0C98: 90       [275]    	SUB	B		; Compare with expected sign
0C99: CDE916   [292]    	CALL	LOADFP		; BC = Loop stmt,DE = Line num
0C9C: CAA80C   [302|302]	JP	Z,KILFOR	; Loop finished - Terminate it
0C9F: EB       [306]    	EX	DE,HL		; Loop statement line number
0CA0: 22A180   [322]    	LD	(LINEAT),HL	; Set loop line number
0CA3: 69       [326]    	LD	L,C		; Set code string to loop
0CA4: 60       [330]    	LD	H,B
0CA5: C30708   [340]    	JP	PUTFID		; Put back "FOR" and continue
                        ;
0CA8: F9       [ 6]     KILFOR: LD	SP,HL		; Remove "FOR" block
0CA9: 2A1381   [22]     	LD	HL,(BRKLIN)	; Code string after "NEXT"
0CAC: 7E       [29]     	LD	A,(HL)		; Get next byte in code string
0CAD: FE2C     [36]     	CP	','		; More NEXTs ?
0CAF: C20B08   [46|46]  	JP	NZ,RUNCNT	; No - Do next statement
0CB2: CD4B08   [63]     	CALL	GETCHR		; Position to index name
0CB5: CD700C   [80]     	CALL	NEXT1		; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        ;
0CB8: CDCA0C   [17]     GETNUM: CALL	EVAL		; Get a numeric expression
0CBB: F6                TSTNUM: DB	0F6H		; Clear carry (numeric)
0CBC: 37       [ 4]     TSTSTR: SCF			; Set carry (string)
0CBD: 3AF280   [13]     CHKTYP: LD	A,(TYPE)	; Check types match
0CC0: 8F       [17]     	ADC	A,A		; Expected + actual
0CC1: B7       [21]     	OR	A		; Clear carry , set parity
0CC2: E8       [26|32]  	RET	PE		; Even parity - Types match
0CC3: C30504   [36]     	JP	TMERR		; Different types - Error
                        ;
0CC6: CDC106   [17]     OPNPAR: CALL	CHKSYN		; Make sure "(" follows
0CC9: 28                	DB	"("
0CCA: 2B       [ 6]     EVAL:	DEC	HL		; Evaluate expression & save
0CCB: 1600     [13]     	LD	D,0		; Precedence value
0CCD: D5       [11]     EVAL1:	PUSH	DE		; Save precedence
0CCE: 0E01     [18]     	LD	C,1
0CD0: CDD003   [35]     	CALL	CHKSTK		; Check for 1 level of stack
0CD3: CD410D   [52]     	CALL	OPRND		; Get next expression value
0CD6: 221581   [16]     EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
0CD9: 2A1581   [16]     EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
0CDC: C1       [26]     	POP	BC		; Precedence value and operator
0CDD: 78       [30]     	LD	A,B		; Get precedence value
0CDE: FE78     [37]     	CP	78H		; "AND" or "OR" ?
0CE0: D4BB0C   [47|54]  	CALL	NC,TSTNUM	; No - Make sure it's a number
0CE3: 7E       [54]     	LD	A,(HL)		; Get next operator / function
0CE4: 1600     [61]     	LD	D,0		; Clear Last relation
0CE6: D6B3     [ 7]     RLTLP:	SUB	ZGTR		; ">" Token
0CE8: DA020D   [17|17]  	JP	C,FOPRND	; + - * / ^ AND OR - Test it
0CEB: FE03     [24]     	CP	ZLTH+1-ZGTR	; < = >
0CED: D2020D   [34|34]  	JP	NC,FOPRND	; Function - Call it
0CF0: FE01     [41]     	CP	ZEQUAL-ZGTR	; "="
0CF2: 17       [45]     	RLA			; <- Test for legal
0CF3: AA       [49]     	XOR	D		; <- combinations of < = >
0CF4: BA       [53]     	CP	D		; <- by combining last token
0CF5: 57       [57]     	LD	D,A		; <- with current one
0CF6: DAF303   [67|67]  	JP	C,SNERR		; Error if "<<' '==" or ">>"
0CF9: 220A81   [83]     	LD	(CUROPR),HL	; Save address of current token
0CFC: CD4B08   [100]    	CALL	GETCHR		; Get next character
0CFF: C3E60C   [110]    	JP	RLTLP		; Treat the two as one
                        ;
0D02: 7A       [ 4]     FOPRND: LD	A,D		; < = > found ?
0D03: B7       [ 8]     	OR	A
0D04: C2290E   [18|18]  	JP	NZ,TSTRED	; Yes - Test for reduction
0D07: 7E       [25]     	LD	A,(HL)		; Get operator token
0D08: 220A81   [41]     	LD	(CUROPR),HL	; Save operator address
0D0B: D6AC     [48]     	SUB	ZPLUS		; Operator or function?
0D0D: D8       [53|59]  	RET	C		; Neither - Exit
0D0E: FE07     [60]     	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
0D10: D0       [65|71]  	RET	NC		; No - Exit
0D11: 5F       [69]     	LD	E,A		; Coded operator
0D12: 3AF280   [82]     	LD	A,(TYPE)	; Get data type
0D15: 3D       [86]     	DEC	A		; FF = numeric , 00 = string
0D16: B3       [90]     	OR	E		; Combine with coded operator
0D17: 7B       [94]     	LD	A,E		; Get coded operator
0D18: CA8712   [104|104]	JP	Z,CONCAT	; String concatenation
0D1B: 07       [108]    	RLCA			; Times 2
0D1C: 83       [112]    	ADD	A,E		; Times 3
0D1D: 5F       [116]    	LD	E,A		; To DE (D is 0)
0D1E: 21E502   [126]    	LD	HL,PRITAB	; Precedence table
0D21: 19       [137]    	ADD	HL,DE		; To the operator concerned
0D22: 78       [141]    	LD	A,B		; Last operator precedence
0D23: 56       [148]    	LD	D,(HL)		; Get evaluation precedence
0D24: BA       [152]    	CP	D		; Compare with eval precedence
0D25: D0       [157|163]	RET	NC		; Exit if higher precedence
0D26: 23       [163]    	INC	HL		; Point to routine address
0D27: CDBB0C   [180]    	CALL	TSTNUM		; Make sure it's a number
                        ;
0D2A: C5       [11]     STKTHS: PUSH	BC		; Save last precedence & token
0D2B: 01D90C   [21]     	LD	BC,EVAL3	; Where to go on prec' break
0D2E: C5       [32]     	PUSH	BC		; Save on stack for return
0D2F: 43       [36]     	LD	B,E		; Save operator
0D30: 4A       [40]     	LD	C,D		; Save precedence
0D31: CDCB16   [57]     	CALL	STAKFP		; Move value to stack
0D34: 58       [61]     	LD	E,B		; Restore operator
0D35: 51       [65]     	LD	D,C		; Restore precedence
0D36: 4E       [72]     	LD	C,(HL)		; Get LSB of routine address
0D37: 23       [78]     	INC	HL
0D38: 46       [85]     	LD	B,(HL)		; Get MSB of routine address
0D39: 23       [91]     	INC	HL
0D3A: C5       [102]    	PUSH	BC		; Save routine address
0D3B: 2A0A81   [118]    	LD	HL,(CUROPR)	; Address of current operator
0D3E: C3CD0C   [128]    	JP	EVAL1		; Loop until prec' break
                        ;
0D41: AF       [ 4]     OPRND:	XOR	A		; Get operand routine
0D42: 32F280   [17]     	LD	(TYPE),A	; Set numeric expected
0D45: CD4B08   [34]     	CALL	GETCHR		; Get next character
0D48: 1E24     [41]     	LD	E,MO		; ?MO Error
0D4A: CA0704   [51|51]  	JP	Z,ERROR		; No operand - Error
0D4D: DAA117   [61|61]  	JP	C,ASCTFP	; Number - Get value
0D50: CDE908   [78]     	CALL	CHKLTR		; See if a letter
0D53: D2A80D   [88|88]  	JP	NC,CONVAR	; Letter - Find variable
0D56: FE26     [95]     	CP	'&'		; &H = HEX, &B = BINARY
0D58: 2012     [102|107]	JR	NZ, NOTAMP
0D5A: CD4B08   [119]    	CALL	GETCHR		; Get next character
0D5D: FE48     [126]    	CP	'H'		; Hex number indicated? [function added]
0D5F: CAE51B   [136|136]	JP	Z,HEXTFP	; Convert Hex to FPREG
0D62: FE42     [143]    	CP	'B'		; Binary number indicated? [function added]
0D64: CA551C   [153|153]	JP	Z,BINTFP	; Convert Bin to FPREG
0D67: 1E02     [160]    	LD	E,SN		; If neither then a ?SN Error
0D69: CA0704   [170|170]	JP	Z,ERROR
0D6C: FEAC     [ 7]     NOTAMP: CP	ZPLUS		; '+' Token ?
0D6E: CA410D   [17|17]  	JP	Z,OPRND		; Yes - Look for operand
0D71: FE2E     [24]     	CP	'.'		; '.' ?
0D73: CAA117   [34|34]  	JP	Z,ASCTFP	; Yes - Create FP number
0D76: FEAD     [41]     	CP	ZMINUS		; '-' Token ?
0D78: CA970D   [51|51]  	JP	Z,MINUS		; Yes - Do minus
0D7B: FE22     [58]     	CP	'"'		; Literal string ?
0D7D: CA5011   [68|68]  	JP	Z,QTSTR		; Get string terminated by '"'
0D80: FEAA     [75]     	CP	ZNOT		; "NOT" Token ?
0D82: CA890E   [85|85]  	JP	Z,EVNOT		; Yes - Eval NOT expression
0D85: FEA7     [92]     	CP	ZFN		; "FN" Token ?
0D87: CAB410   [102|102]	JP	Z,DOFN		; Yes - Do FN routine
0D8A: D6B6     [109]    	SUB	ZSGN		; Is it a function?
0D8C: D2B90D   [119|119]	JP	NC,FNOFST	; Yes - Evaluate function
0D8F: CDC60C   [17]     EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
0D92: CDC106   [34]     	CALL	CHKSYN		; Make sure ")" follows
0D95: 29                	DB	")"
0D96: C9       [44]     	RET
                        ;
0D97: 167D     [ 7]     MINUS:	LD	D,7DH		; '-' precedence
0D99: CDCD0C   [24]     	CALL	EVAL1		; Evaluate until prec' break
0D9C: 2A1581   [40]     	LD	HL,(NXTOPR)	; Get next operator address
0D9F: E5       [51]     	PUSH	HL		; Save next operator address
0DA0: CDC316   [68]     	CALL	INVSGN		; Negate value
0DA3: CDBB0C   [17]     RETNUM: CALL	TSTNUM		; Make sure it's a number
0DA6: E1       [27]     	POP	HL		; Restore next operator address
0DA7: C9       [37]     	RET
                        ;
0DA8: CDAE0E   [17]     CONVAR: CALL	GETVAR		; Get variable address to DE
0DAB: E5       [11]     FRMEVL: PUSH	HL		; Save code string address
0DAC: EB       [15]     	EX	DE,HL		; Variable address to HL
0DAD: 222981   [31]     	LD	(FPREG),HL	; Save address of variable
0DB0: 3AF280   [44]     	LD	A,(TYPE)	; Get type
0DB3: B7       [48]     	OR	A		; Numeric?
0DB4: CCD816   [58|65]  	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
0DB7: E1       [68]     	POP	HL		; Restore code string address
0DB8: C9       [78]     	RET
                        ;
0DB9: 0600     [ 7]     FNOFST: LD	B,0		; Get address of function
0DBB: 07       [11]     	RLCA			; Double function offset
0DBC: 4F       [15]     	LD	C,A		; BC = Offset in function table
0DBD: C5       [26]     	PUSH	BC		; Save adjusted token value
0DBE: CD4B08   [43]     	CALL	GETCHR		; Get next character
0DC1: 79       [47]     	LD	A,C		; Get adjusted token value
0DC2: FE31     [54]     	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
0DC4: DAE00D   [64|64]  	JP	C,FNVAL		; No - Do function
0DC7: CDC60C   [81]     	CALL	OPNPAR		; Evaluate expression	(X,...
0DCA: CDC106   [98]     	CALL	CHKSYN		; Make sure ',' follows
0DCD: 2C                	DB	','
0DCE: CDBC0C   [115]    	CALL	TSTSTR		; Make sure it's a string
0DD1: EB       [119]    	EX	DE,HL		; Save code string address
0DD2: 2A2981   [135]    	LD	HL,(FPREG)	; Get address of string
0DD5: E3       [154]    	EX	(SP),HL		; Save address of string
0DD6: E5       [165]    	PUSH	HL		; Save adjusted token value
0DD7: EB       [169]    	EX	DE,HL		; Restore code string address
0DD8: CD1914   [186]    	CALL	GETINT		; Get integer 0-255
0DDB: EB       [190]    	EX	DE,HL		; Save code string address
0DDC: E3       [209]    	EX	(SP),HL		; Save integer,HL = adj' token
0DDD: C3E80D   [219]    	JP	GOFUNC		; Jump to string function
                        ;
0DE0: CD8F0D   [17]     FNVAL:	CALL	EVLPAR		; Evaluate expression
0DE3: E3       [36]     	EX	(SP),HL		; HL = Adjusted token value
0DE4: 11A30D   [46]     	LD	DE,RETNUM	; Return number from function
0DE7: D5       [57]     	PUSH	DE		; Save on stack
0DE8: 014401   [10]     GOFUNC: LD	BC,FNCTAB	; Function routine addresses
0DEB: 09       [21]     	ADD	HL,BC		; Point to right address
0DEC: 4E       [28]     	LD	C,(HL)		; Get LSB of address
0DED: 23       [34]     	INC	HL		;
0DEE: 66       [41]     	LD	H,(HL)		; Get MSB of address
0DEF: 69       [45]     	LD	L,C		; Address to HL
0DF0: E9       [49]     	JP	(HL)		; Jump to function
                        ;
0DF1: 15       [ 4]     SGNEXP: DEC	D		; Dee to flag negative exponent
0DF2: FEAD     [11]     	CP	ZMINUS		; '-' token ?
0DF4: C8       [16|22]  	RET	Z		; Yes - Return
0DF5: FE2D     [23]     	CP	'-'		; '-' ASCII ?
0DF7: C8       [28|34]  	RET	Z		; Yes - Return
0DF8: 14       [32]     	INC	D		; Inc to flag positive exponent
0DF9: FE2B     [39]     	CP	'+'		; '+' ASCII ?
0DFB: C8       [44|50]  	RET	Z		; Yes - Return
0DFC: FEAC     [51]     	CP	ZPLUS		; '+' token ?
0DFE: C8       [56|62]  	RET	Z		; Yes - Return
0DFF: 2B       [62]     	DEC	HL		; DEC 'cos GETCHR INCs
0E00: C9       [72]     	RET			; Return "NZ"
                        ;
0E01: F6                POR:	DB	0F6H		; Flag "OR"
0E02: AF       [ 4]     PAND:	XOR	A		; Flag "AND"
0E03: F5       [15]     	PUSH	AF		; Save "AND" / "OR" flag
0E04: CDBB0C   [32]     	CALL	TSTNUM		; Make sure it's a number
0E07: CDFD08   [49]     	CALL	DEINT		; Get integer -32768 to 32767
0E0A: F1       [59]     	POP	AF		; Restore "AND" / "OR" flag
0E0B: EB       [63]     	EX	DE,HL		; <- Get last
0E0C: C1       [73]     	POP	BC		; <- value
0E0D: E3       [92]     	EX	(SP),HL		; <- from
0E0E: EB       [96]     	EX	DE,HL		; <- stack
0E0F: CDDB16   [113]    	CALL	FPBCDE		; Move last value to FPREG
0E12: F5       [124]    	PUSH	AF		; Save "AND" / "OR" flag
0E13: CDFD08   [141]    	CALL	DEINT		; Get integer -32768 to 32767
0E16: F1       [151]    	POP	AF		; Restore "AND" / "OR" flag
0E17: C1       [161]    	POP	BC		; Get value
0E18: 79       [165]    	LD	A,C		; Get LSB
0E19: 217210   [175]    	LD	HL,ACPASS	; Address of save AC as current
0E1C: C2240E   [185|185]	JP	NZ,POR1		; Jump if OR
0E1F: A3       [189]    	AND	E		; "AND" LSBs
0E20: 4F       [193]    	LD	C,A		; Save LSB
0E21: 78       [197]    	LD	A,B		; Get MBS
0E22: A2       [201]    	AND	D		; "AND" MSBs
0E23: E9       [205]    	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E24: B3       [ 4]     POR1:	OR	E		; "OR" LSBs
0E25: 4F       [ 8]     	LD	C,A		; Save LSB
0E26: 78       [12]     	LD	A,B		; Get MSB
0E27: B2       [16]     	OR	D		; "OR" MSBs
0E28: E9       [20]     	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E29: 213B0E   [10]     TSTRED: LD	HL,CMPLOG	; Logical compare routine
0E2C: 3AF280   [23]     	LD	A,(TYPE)	; Get data type
0E2F: 1F       [27]     	RRA			; Carry set = string
0E30: 7A       [31]     	LD	A,D		; Get last precedence value
0E31: 17       [35]     	RLA			; Times 2 plus carry
0E32: 5F       [39]     	LD	E,A		; To E
0E33: 1664     [46]     	LD	D,64H		; Relational precedence
0E35: 78       [50]     	LD	A,B		; Get current precedence
0E36: BA       [54]     	CP	D		; Compare with last
0E37: D0       [59|65]  	RET	NC		; Eval if last was rel' or log'
0E38: C32A0D   [69]     	JP	STKTHS		; Stack this one and get next
                        ;
0E3B: 3D0E              CMPLOG: DW	CMPLG1		; Compare two values / strings
0E3D: 79       [ 4]     CMPLG1: LD	A,C		; Get data type
0E3E: B7       [ 8]     	OR	A
0E3F: 1F       [12]     	RRA
0E40: C1       [22]     	POP	BC		; Get last expression to BCDE
0E41: D1       [32]     	POP	DE
0E42: F5       [43]     	PUSH	AF		; Save status
0E43: CDBD0C   [60]     	CALL	CHKTYP		; Check that types match
0E46: 217F0E   [70]     	LD	HL,CMPRES	; Result to comparison
0E49: E5       [81]     	PUSH	HL		; Save for RETurn
0E4A: CA1517   [91|91]  	JP	Z,CMPNUM	; Compare values if numeric
0E4D: AF       [95]     	XOR	A		; Compare two strings
0E4E: 32F280   [108]    	LD	(TYPE),A	; Set type to numeric
0E51: D5       [119]    	PUSH	DE		; Save string name
0E52: CDD412   [136]    	CALL	GSTRCU		; Get current string
0E55: 7E       [143]    	LD	A,(HL)		; Get length of string
0E56: 23       [149]    	INC	HL
0E57: 23       [155]    	INC	HL
0E58: 4E       [162]    	LD	C,(HL)		; Get LSB of address
0E59: 23       [168]    	INC	HL
0E5A: 46       [175]    	LD	B,(HL)		; Get MSB of address
0E5B: D1       [185]    	POP	DE		; Restore string name
0E5C: C5       [196]    	PUSH	BC		; Save address of string
0E5D: F5       [207]    	PUSH	AF		; Save length of string
0E5E: CDD812   [224]    	CALL	GSTRDE		; Get second string
0E61: CDE916   [241]    	CALL	LOADFP		; Get address of second string
0E64: F1       [251]    	POP	AF		; Restore length of string 1
0E65: 57       [255]    	LD	D,A		; Length to D
0E66: E1       [265]    	POP	HL		; Restore address of string 1
0E67: 7B       [ 4]     CMPSTR: LD	A,E		; Bytes of string 2 to do
0E68: B2       [ 8]     	OR	D		; Bytes of string 1 to do
0E69: C8       [13|19]  	RET	Z		; Exit if all bytes compared
0E6A: 7A       [17]     	LD	A,D		; Get bytes of string 1 to do
0E6B: D601     [24]     	SUB	1
0E6D: D8       [29|35]  	RET	C		; Exit if end of string 1
0E6E: AF       [33]     	XOR	A
0E6F: BB       [37]     	CP	E		; Bytes of string 2 to do
0E70: 3C       [41]     	INC	A
0E71: D0       [46|52]  	RET	NC		; Exit if end of string 2
0E72: 15       [50]     	DEC	D		; Count bytes in string 1
0E73: 1D       [54]     	DEC	E		; Count bytes in string 2
0E74: 0A       [61]     	LD	A,(BC)		; Byte in string 2
0E75: BE       [68]     	CP	(HL)		; Compare to byte in string 1
0E76: 23       [74]     	INC	HL		; Move up string 1
0E77: 03       [80]     	INC	BC		; Move up string 2
0E78: CA670E   [90|90]  	JP	Z,CMPSTR	; Same - Try next bytes
0E7B: 3F       [94]     	CCF			; Flag difference (">" or "<")
0E7C: C3A516   [104]    	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                        ;
0E7F: 3C       [ 4]     CMPRES: INC	A		; Increment current value
0E80: 8F       [ 8]     	ADC	A,A		; Double plus carry
0E81: C1       [18]     	POP	BC		; Get other value
0E82: A0       [22]     	AND	B		; Combine them
0E83: C6FF     [29]     	ADD	A,-1		; Carry set if different
0E85: 9F       [33]     	SBC	A,A		; 00 - Equal , FF - Different
0E86: C3AC16   [43]     	JP	FLGREL		; Set current value & continue
                        ;
0E89: 165A     [ 7]     EVNOT:	LD	D,5AH		; Precedence value for "NOT"
0E8B: CDCD0C   [24]     	CALL	EVAL1		; Eval until precedence break
0E8E: CDBB0C   [41]     	CALL	TSTNUM		; Make sure it's a number
0E91: CDFD08   [58]     	CALL	DEINT		; Get integer -32768 - 32767
0E94: 7B       [62]     	LD	A,E		; Get LSB
0E95: 2F       [66]     	CPL			; Invert LSB
0E96: 4F       [70]     	LD	C,A		; Save "NOT" of LSB
0E97: 7A       [74]     	LD	A,D		; Get MSB
0E98: 2F       [78]     	CPL			; Invert MSB
0E99: CD7210   [95]     	CALL	ACPASS		; Save AC as current
0E9C: C1       [105]    	POP	BC		; Clean up stack
0E9D: C3D90C   [115]    	JP	EVAL3		; Continue evaluation
                        ;
0EA0: 2B       [ 6]     DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
0EA1: CD4B08   [23]     	CALL	GETCHR		; Get next character
0EA4: C8       [28|34]  	RET	Z		; End of DIM statement
0EA5: CDC106   [45]     	CALL	CHKSYN		; Make sure ',' follows
0EA8: 2C                	DB	','
0EA9: 01A00E   [10]     DIM:	LD	BC,DIMRET	; Return to "DIMRET"
0EAC: C5       [21]     	PUSH	BC		; Save on stack
0EAD: F6                	DB	0F6H		; Flag "Create" variable
0EAE: AF       [ 4]     GETVAR: XOR	A		; Find variable address,to DE
0EAF: 32F180   [17]     	LD	(LCRFLG),A	; Set locate / create flag
0EB2: 46       [24]     	LD	B,(HL)		; Get First byte of name
0EB3: CDE908   [17]     GTFNAM: CALL	CHKLTR		; See if a letter
0EB6: DAF303   [27|27]  	JP	C,SNERR		; ?SN Error if not a letter
0EB9: AF       [31]     	XOR	A
0EBA: 4F       [35]     	LD	C,A		; Clear second byte of name
0EBB: 32F280   [48]     	LD	(TYPE),A	; Set type to numeric
0EBE: CD4B08   [65]     	CALL	GETCHR		; Get next character
0EC1: DACA0E   [75|75]  	JP	C,SVNAM2	; Numeric - Save in name
0EC4: CDE908   [92]     	CALL	CHKLTR		; See if a letter
0EC7: DAD70E   [102|102]	JP	C,CHARTY	; Not a letter - Check type
0ECA: 4F       [ 4]     SVNAM2: LD	C,A		; Save second byte of name
0ECB: CD4B08   [17]     ENDNAM: CALL	GETCHR		; Get next character
0ECE: DACB0E   [27|27]  	JP	C,ENDNAM	; Numeric - Get another
0ED1: CDE908   [44]     	CALL	CHKLTR		; See if a letter
0ED4: D2CB0E   [54|54]  	JP	NC,ENDNAM	; Letter - Get another
0ED7: D624     [ 7]     CHARTY: SUB	'$'		; String variable?
0ED9: C2E60E   [17|17]  	JP	NZ,NOTSTR	; No - Numeric variable
0EDC: 3C       [21]     	INC	A		; A = 1 (string type)
0EDD: 32F280   [34]     	LD	(TYPE),A	; Set type to string
0EE0: 0F       [38]     	RRCA			; A = 80H , Flag for string
0EE1: 81       [42]     	ADD	A,C		; 2nd byte of name has bit 7 on
0EE2: 4F       [46]     	LD	C,A		; Resave second byte on name
0EE3: CD4B08   [63]     	CALL	GETCHR		; Get next character
0EE6: 3A1081   [13]     NOTSTR: LD	A,(FORFLG)	; Array name needed ?
0EE9: 3D       [17]     	DEC	A
0EEA: CA930F   [27|27]  	JP	Z,ARLDSV	; Yes - Get array name
0EED: F2F60E   [37|37]  	JP	P,NSCFOR	; No array with "FOR" or "FN"
0EF0: 7E       [44]     	LD	A,(HL)		; Get byte again
0EF1: D628     [51]     	SUB	'('		; Subscripted variable?
0EF3: CA6B0F   [61|61]  	JP	Z,SBSCPT	; Yes - Sort out subscript
                        ;
0EF6: AF       [ 4]     NSCFOR: XOR	A		; Simple variable
0EF7: 321081   [17]     	LD	(FORFLG),A	; Clear "FOR" flag
0EFA: E5       [28]     	PUSH	HL		; Save code string address
0EFB: 50       [32]     	LD	D,B		; DE = Variable name to find
0EFC: 59       [36]     	LD	E,C
0EFD: 2A2381   [52]     	LD	HL,(FNRGNM)	; FN argument name
0F00: CDBB06   [69]     	CALL	CPDEHL		; Is it the FN argument?
0F03: 112581   [79]     	LD	DE,FNARG	; Point to argument value
0F06: CADB15   [89|89]  	JP	Z,POPHRT	; Yes - Return FN argument value
0F09: 2A1D81   [105]    	LD	HL,(VAREND)	; End of variables
0F0C: EB       [109]    	EX	DE,HL		; Address of end of search
0F0D: 2A1B81   [125]    	LD	HL,(PROGND)	; Start of variables address
0F10: CDBB06   [17]     FNDVAR: CALL	CPDEHL		; End of variable list table?
0F13: CA290F   [27|27]  	JP	Z,CFEVAL	; Yes - Called from EVAL?
0F16: 79       [31]     	LD	A,C		; Get second byte of name
0F17: 96       [38]     	SUB	(HL)		; Compare with name in list
0F18: 23       [44]     	INC	HL		; Move on to first byte
0F19: C21E0F   [54|54]  	JP	NZ,FNTHR	; Different - Find another
0F1C: 78       [58]     	LD	A,B		; Get first byte of name
0F1D: 96       [65]     	SUB	(HL)		; Compare with name in list
0F1E: 23       [ 6]     FNTHR:	INC	HL		; Move on to LSB of value
0F1F: CA5D0F   [16|16]  	JP	Z,RETADR	; Found - Return address
0F22: 23       [22]     	INC	HL		; <- Skip
0F23: 23       [28]     	INC	HL		; <- over
0F24: 23       [34]     	INC	HL		; <- F.P.
0F25: 23       [40]     	INC	HL		; <- value
0F26: C3100F   [50]     	JP	FNDVAR		; Keep looking
                        ;
0F29: E1       [10]     CFEVAL: POP	HL		; Restore code string address
0F2A: E3       [29]     	EX	(SP),HL		; Get return address
0F2B: D5       [40]     	PUSH	DE		; Save address of variable
0F2C: 11AB0D   [50]     	LD	DE,FRMEVL	; Return address in EVAL
0F2F: CDBB06   [67]     	CALL	CPDEHL		; Called from EVAL ?
0F32: D1       [77]     	POP	DE		; Restore address of variable
0F33: CA600F   [87|87]  	JP	Z,RETNUL	; Yes - Return null variable
0F36: E3       [106]    	EX	(SP),HL		; Put back return
0F37: E5       [117]    	PUSH	HL		; Save code string address
0F38: C5       [128]    	PUSH	BC		; Save variable name
0F39: 010600   [138]    	LD	BC,6		; 2 byte name plus 4 byte data
0F3C: 2A1F81   [154]    	LD	HL,(ARREND)	; End of arrays
0F3F: E5       [165]    	PUSH	HL		; Save end of arrays
0F40: 09       [176]    	ADD	HL,BC		; Move up 6 bytes
0F41: C1       [186]    	POP	BC		; Source address in BC
0F42: E5       [197]    	PUSH	HL		; Save new end address
0F43: CDBF03   [214]    	CALL	MOVUP		; Move arrays up
0F46: E1       [224]    	POP	HL		; Restore new end address
0F47: 221F81   [240]    	LD	(ARREND),HL	; Set new end address
0F4A: 60       [244]    	LD	H,B		; End of variables to HL
0F4B: 69       [248]    	LD	L,C
0F4C: 221D81   [264]    	LD	(VAREND),HL	; Set new end address
                        ;
0F4F: 2B       [ 6]     ZEROLP: DEC	HL		; Back through to zero variable
0F50: 3600     [16]     	LD	(HL),0		; Zero byte in variable
0F52: CDBB06   [33]     	CALL	CPDEHL		; Done them all?
0F55: C24F0F   [43|43]  	JP	NZ,ZEROLP	; No - Keep on going
0F58: D1       [53]     	POP	DE		; Get variable name
0F59: 73       [60]     	LD	(HL),E		; Store second character
0F5A: 23       [66]     	INC	HL
0F5B: 72       [73]     	LD	(HL),D		; Store first character
0F5C: 23       [79]     	INC	HL
0F5D: EB       [ 4]     RETADR: EX	DE,HL		; Address of variable in DE
0F5E: E1       [14]     	POP	HL		; Restore code string address
0F5F: C9       [24]     	RET
                        ;
0F60: 322C81   [13]     RETNUL: LD	(FPEXP),A	; Set result to zero
0F63: 218F03   [23]     	LD	HL,ZERBYT	; Also set a null string
0F66: 222981   [39]     	LD	(FPREG),HL	; Save for EVAL
0F69: E1       [49]     	POP	HL		; Restore code string address
0F6A: C9       [59]     	RET
                        ;
0F6B: E5       [11]     SBSCPT: PUSH	HL		; Save code string address
0F6C: 2AF180   [27]     	LD	HL,(LCRFLG)	; Locate/Create and Type
0F6F: E3       [46]     	EX	(SP),HL		; Save and get code string
0F70: 57       [50]     	LD	D,A		; Zero number of dimensions
0F71: D5       [11]     SCPTLP: PUSH	DE		; Save number of dimensions
0F72: C5       [22]     	PUSH	BC		; Save array name
0F73: CDF108   [39]     	CALL	FPSINT		; Get subscript (0-32767)
0F76: C1       [49]     	POP	BC		; Restore array name
0F77: F1       [59]     	POP	AF		; Get number of dimensions
0F78: EB       [63]     	EX	DE,HL
0F79: E3       [82]     	EX	(SP),HL		; Save subscript value
0F7A: E5       [93]     	PUSH	HL		; Save LCRFLG and TYPE
0F7B: EB       [97]     	EX	DE,HL
0F7C: 3C       [101]    	INC	A		; Count dimensions
0F7D: 57       [105]    	LD	D,A		; Save in D
0F7E: 7E       [112]    	LD	A,(HL)		; Get next byte in code string
0F7F: FE2C     [119]    	CP	','		; Comma (more to come)?
0F81: CA710F   [129|129]	JP	Z,SCPTLP	; Yes - More subscripts
0F84: CDC106   [146]    	CALL	CHKSYN		; Make sure ")" follows
0F87: 29                	DB	")"
0F88: 221581   [162]    	LD	(NXTOPR),HL	; Save code string address
0F8B: E1       [172]    	POP	HL		; Get LCRFLG and TYPE
0F8C: 22F180   [188]    	LD	(LCRFLG),HL	; Restore Locate/create & type
0F8F: 1E00     [195]    	LD	E,0		; Flag not CSAVE* or CLOAD*
0F91: D5       [206]    	PUSH	DE		; Save number of dimensions (D)
0F92: 11                	DB	11H		; Skip "PUSH HL" and "PUSH AF'
                        ;
0F93: E5       [11]     ARLDSV: PUSH	HL		; Save code string address
0F94: F5       [22]     	PUSH	AF		; A = 00 , Flags set = Z,N
0F95: 2A1D81   [38]     	LD	HL,(VAREND)	; Start of arrays
0F98: 3E                	DB	3EH		; Skip "ADD HL,DE"
0F99: 19       [11]     FNDARY: ADD	HL,DE		; Move to next array start
0F9A: EB       [15]     	EX	DE,HL
0F9B: 2A1F81   [31]     	LD	HL,(ARREND)	; End of arrays
0F9E: EB       [35]     	EX	DE,HL		; Current array pointer
0F9F: CDBB06   [52]     	CALL	CPDEHL		; End of arrays found?
0FA2: CACB0F   [62|62]  	JP	Z,CREARY	; Yes - Create array
0FA5: 7E       [69]     	LD	A,(HL)		; Get second byte of name
0FA6: B9       [73]     	CP	C		; Compare with name given
0FA7: 23       [79]     	INC	HL		; Move on
0FA8: C2AD0F   [89|89]  	JP	NZ,NXTARY	; Different - Find next array
0FAB: 7E       [96]     	LD	A,(HL)		; Get first byte of name
0FAC: B8       [100]    	CP	B		; Compare with name given
0FAD: 23       [ 6]     NXTARY: INC	HL		; Move on
0FAE: 5E       [13]     	LD	E,(HL)		; Get LSB of next array address
0FAF: 23       [19]     	INC	HL
0FB0: 56       [26]     	LD	D,(HL)		; Get MSB of next array address
0FB1: 23       [32]     	INC	HL
0FB2: C2990F   [42|42]  	JP	NZ,FNDARY	; Not found - Keep looking
0FB5: 3AF180   [55]     	LD	A,(LCRFLG)	; Found Locate or Create it?
0FB8: B7       [59]     	OR	A
0FB9: C2FC03   [69|69]  	JP	NZ,DDERR	; Create - ?DD Error
0FBC: F1       [79]     	POP	AF		; Locate - Get number of dim'ns
0FBD: 44       [83]     	LD	B,H		; BC Points to array dim'ns
0FBE: 4D       [87]     	LD	C,L
0FBF: CADB15   [97|97]  	JP	Z,POPHRT	; Jump if array load/save
0FC2: 96       [104]    	SUB	(HL)		; Same number of dimensions?
0FC3: CA2910   [114|114]	JP	Z,FINDEL	; Yes - Find element
0FC6: 1E10     [ 7]     BSERR:	LD	E,BS		; ?BS Error
0FC8: C30704   [17]     	JP	ERROR		; Output error
                        ;
0FCB: 110400   [10]     CREARY: LD	DE,4		; 4 Bytes per entry
0FCE: F1       [20]     	POP	AF		; Array to save or 0 dim'ns?
0FCF: CA1209   [30|30]  	JP	Z,FCERR		; Yes - ?FC Error
0FD2: 71       [37]     	LD	(HL),C		; Save second byte of name
0FD3: 23       [43]     	INC	HL
0FD4: 70       [50]     	LD	(HL),B		; Save first byte of name
0FD5: 23       [56]     	INC	HL
0FD6: 4F       [60]     	LD	C,A		; Number of dimensions to C
0FD7: CDD003   [77]     	CALL	CHKSTK		; Check if enough memory
0FDA: 23       [83]     	INC	HL		; Point to number of dimensions
0FDB: 23       [89]     	INC	HL
0FDC: 220A81   [105]    	LD	(CUROPR),HL	; Save address of pointer
0FDF: 71       [112]    	LD	(HL),C		; Set number of dimensions
0FE0: 23       [118]    	INC	HL
0FE1: 3AF180   [131]    	LD	A,(LCRFLG)	; Locate of Create?
0FE4: 17       [135]    	RLA			; Carry set = Create
0FE5: 79       [139]    	LD	A,C		; Get number of dimensions
0FE6: 010B00   [10]     CRARLP: LD	BC,10+1		; Default dimension size 10
0FE9: D2EE0F   [20|20]  	JP	NC,DEFSIZ	; Locate - Set default size
0FEC: C1       [30]     	POP	BC		; Get specified dimension size
0FED: 03       [36]     	INC	BC		; Include zero element
0FEE: 71       [ 7]     DEFSIZ: LD	(HL),C		; Save LSB of dimension size
0FEF: 23       [13]     	INC	HL
0FF0: 70       [20]     	LD	(HL),B		; Save MSB of dimension size
0FF1: 23       [26]     	INC	HL
0FF2: F5       [37]     	PUSH	AF		; Save num' of dim'ns an status
0FF3: E5       [48]     	PUSH	HL		; Save address of dim'n size
0FF4: CD8617   [65]     	CALL	MLDEBC		; Multiply DE by BC to find
0FF7: EB       [69]     	EX	DE,HL		; amount of mem needed (to DE)
0FF8: E1       [79]     	POP	HL		; Restore address of dimension
0FF9: F1       [89]     	POP	AF		; Restore number of dimensions
0FFA: 3D       [93]     	DEC	A		; Count them
0FFB: C2E60F   [103|103]	JP	NZ,CRARLP	; Do next dimension if more
0FFE: F5       [114]    	PUSH	AF		; Save locate/create flag
0FFF: 42       [118]    	LD	B,D		; MSB of memory needed
1000: 4B       [122]    	LD	C,E		; LSB of memory needed
1001: EB       [126]    	EX	DE,HL
1002: 19       [137]    	ADD	HL,DE		; Add bytes to array start
1003: DAE803   [147|147]	JP	C,OMERR		; Too big - Error
1006: CDD903   [164]    	CALL	ENFMEM		; See if enough memory
1009: 221F81   [180]    	LD	(ARREND),HL	; Save new end of array
                        ;
100C: 2B       [ 6]     ZERARY: DEC	HL		; Back through array data
100D: 3600     [16]     	LD	(HL),0		; Set array element to zero
100F: CDBB06   [33]     	CALL	CPDEHL		; All elements zeroed?
1012: C20C10   [43|43]  	JP	NZ,ZERARY	; No - Keep on going
1015: 03       [49]     	INC	BC		; Number of bytes + 1
1016: 57       [53]     	LD	D,A		; A=0
1017: 2A0A81   [69]     	LD	HL,(CUROPR)	; Get address of array
101A: 5E       [76]     	LD	E,(HL)		; Number of dimensions
101B: EB       [80]     	EX	DE,HL		; To HL
101C: 29       [91]     	ADD	HL,HL		; Two bytes per dimension size
101D: 09       [102]    	ADD	HL,BC		; Add number of bytes
101E: EB       [106]    	EX	DE,HL		; Bytes needed to DE
101F: 2B       [112]    	DEC	HL
1020: 2B       [118]    	DEC	HL
1021: 73       [125]    	LD	(HL),E		; Save LSB of bytes needed
1022: 23       [131]    	INC	HL
1023: 72       [138]    	LD	(HL),D		; Save MSB of bytes needed
1024: 23       [144]    	INC	HL
1025: F1       [154]    	POP	AF		; Locate / Create?
1026: DA4D10   [164|164]	JP	C,ENDDIM	; A is 0 , End if create
1029: 47       [ 4]     FINDEL: LD	B,A		; Find array element
102A: 4F       [ 8]     	LD	C,A
102B: 7E       [15]     	LD	A,(HL)		; Number of dimensions
102C: 23       [21]     	INC	HL
102D: 16                	DB	16H		; Skip "POP HL"
102E: E1       [10]     FNDELP: POP	HL		; Address of next dim' size
102F: 5E       [17]     	LD	E,(HL)		; Get LSB of dim'n size
1030: 23       [23]     	INC	HL
1031: 56       [30]     	LD	D,(HL)		; Get MSB of dim'n size
1032: 23       [36]     	INC	HL
1033: E3       [55]     	EX	(SP),HL		; Save address - Get index
1034: F5       [66]     	PUSH	AF		; Save number of dim'ns
1035: CDBB06   [83]     	CALL	CPDEHL		; Dimension too large?
1038: D2C60F   [93|93]  	JP	NC,BSERR	; Yes - ?BS Error
103B: E5       [104]    	PUSH	HL		; Save index
103C: CD8617   [121]    	CALL	MLDEBC		; Multiply previous by size
103F: D1       [131]    	POP	DE		; Index supplied to DE
1040: 19       [142]    	ADD	HL,DE		; Add index to pointer
1041: F1       [152]    	POP	AF		; Number of dimensions
1042: 3D       [156]    	DEC	A		; Count them
1043: 44       [160]    	LD	B,H		; MSB of pointer
1044: 4D       [164]    	LD	C,L		; LSB of pointer
1045: C22E10   [174|174]	JP	NZ,FNDELP	; More - Keep going
1048: 29       [185]    	ADD	HL,HL		; 4 Bytes per element
1049: 29       [196]    	ADD	HL,HL
104A: C1       [206]    	POP	BC		; Start of array
104B: 09       [217]    	ADD	HL,BC		; Point to element
104C: EB       [221]    	EX	DE,HL		; Address of element to DE
104D: 2A1581   [16]     ENDDIM: LD	HL,(NXTOPR)	; Got code string address
1050: C9       [26]     	RET
                        ;
1051: 2A1F81   [16]     FRE:	LD	HL,(ARREND)	; Start of free memory
1054: EB       [20]     	EX	DE,HL		; To DE
1055: 210000   [30]     	LD	HL,0		; End of free memory
1058: 39       [41]     	ADD	HL,SP		; Current stack value
1059: 3AF280   [54]     	LD	A,(TYPE)	; Dummy argument type
105C: B7       [58]     	OR	A
105D: CA6D10   [68|68]  	JP	Z,FRENUM	; Numeric - Free variable space
1060: CDD412   [85]     	CALL	GSTRCU		; Current string to pool
1063: CDD411   [102]    	CALL	GARBGE		; Garbage collection
1066: 2A9F80   [118]    	LD	HL,(STRSPC)	; Bottom of string space in use
1069: EB       [122]    	EX	DE,HL		; To DE
106A: 2A0881   [138]    	LD	HL,(STRBOT)	; Bottom of string space
106D: 7D       [ 4]     FRENUM: LD	A,L		; Get LSB of end
106E: 93       [ 8]     	SUB	E		; Subtract LSB of beginning
106F: 4F       [12]     	LD	C,A		; Save difference if C
1070: 7C       [16]     	LD	A,H		; Get MSB of end
1071: 9A       [20]     	SBC	A,D		; Subtract MSB of beginning
1072: 41       [ 4]     ACPASS: LD	B,C		; Return integer AC
1073: 50       [ 4]     ABPASS: LD	D,B		; Return integer AB
1074: 1E00     [11]     	LD	E,0
1076: 21F280   [21]     	LD	HL,TYPE		; Point to type
1079: 73       [28]     	LD	(HL),E		; Set type to numeric
107A: 0690     [35]     	LD	B,80H+16	; 16 bit integer
107C: C3B116   [45]     	JP	RETINT		; Return the integr
                        ;
107F: 3AF080   [13]     POS:	LD	A,(CURPOS)	; Get cursor position
1082: 47       [ 4]     PASSA:	LD	B,A		; Put A into AB
1083: AF       [ 8]     	XOR	A		; Zero A
1084: C37310   [18]     	JP	ABPASS		; Return integer AB
                        ;
1087: CD0A11   [17]     DEF:	CALL	CHEKFN		; Get "FN" and name
108A: CDFC10   [34]     	CALL	IDTEST		; Test for illegal direct
108D: 01E209   [44]     	LD	BC,DATA		; To get next statement
1090: C5       [55]     	PUSH	BC		; Save address for RETurn
1091: D5       [66]     	PUSH	DE		; Save address of function ptr
1092: CDC106   [83]     	CALL	CHKSYN		; Make sure "(" follows
1095: 28                	DB	"("
1096: CDAE0E   [100]    	CALL	GETVAR		; Get argument variable name
1099: E5       [111]    	PUSH	HL		; Save code string address
109A: EB       [115]    	EX	DE,HL		; Argument address to HL
109B: 2B       [121]    	DEC	HL
109C: 56       [128]    	LD	D,(HL)		; Get first byte of arg name
109D: 2B       [134]    	DEC	HL
109E: 5E       [141]    	LD	E,(HL)		; Get second byte of arg name
109F: E1       [151]    	POP	HL		; Restore code string address
10A0: CDBB0C   [168]    	CALL	TSTNUM		; Make sure numeric argument
10A3: CDC106   [185]    	CALL	CHKSYN		; Make sure ")" follows
10A6: 29                	DB	")"
10A7: CDC106   [202]    	CALL	CHKSYN		; Make sure "=" follows
10AA: B4                	DB	ZEQUAL		; "=" token
10AB: 44       [206]    	LD	B,H		; Code string address to BC
10AC: 4D       [210]    	LD	C,L
10AD: E3       [229]    	EX	(SP),HL		; Save code str , Get FN ptr
10AE: 71       [236]    	LD	(HL),C		; Save LSB of FN code string
10AF: 23       [242]    	INC	HL
10B0: 70       [249]    	LD	(HL),B		; Save MSB of FN code string
10B1: C34911   [259]    	JP	SVSTAD		; Save address and do function
                        ;
10B4: CD0A11   [17]     DOFN:	CALL	CHEKFN		; Make sure FN follows
10B7: D5       [28]     	PUSH	DE		; Save function pointer address
10B8: CD8F0D   [45]     	CALL	EVLPAR		; Evaluate expression in "()"
10BB: CDBB0C   [62]     	CALL	TSTNUM		; Make sure numeric result
10BE: E3       [81]     	EX	(SP),HL		; Save code str , Get FN ptr
10BF: 5E       [88]     	LD	E,(HL)		; Get LSB of FN code string
10C0: 23       [94]     	INC	HL
10C1: 56       [101]    	LD	D,(HL)		; Get MSB of FN code string
10C2: 23       [107]    	INC	HL
10C3: 7A       [111]    	LD	A,D		; And function DEFined?
10C4: B3       [115]    	OR	E
10C5: CAFF03   [125|125]	JP	Z,UFERR		; No - ?UF Error
10C8: 7E       [132]    	LD	A,(HL)		; Get LSB of argument address
10C9: 23       [138]    	INC	HL
10CA: 66       [145]    	LD	H,(HL)		; Get MSB of argument address
10CB: 6F       [149]    	LD	L,A		; HL = Arg variable address
10CC: E5       [160]    	PUSH	HL		; Save it
10CD: 2A2381   [176]    	LD	HL,(FNRGNM)	; Get old argument name
10D0: E3       [195]    	EX	(SP),HL;	; Save old , Get new
10D1: 222381   [211]    	LD	(FNRGNM),HL	; Set new argument name
10D4: 2A2781   [227]    	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
10D7: E5       [238]    	PUSH	HL		; Save it
10D8: 2A2581   [254]    	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
10DB: E5       [265]    	PUSH	HL		; Save it
10DC: 212581   [275]    	LD	HL,FNARG	; HL = Value of argument
10DF: D5       [286]    	PUSH	DE		; Save FN code string address
10E0: CDF216   [303]    	CALL	FPTHL		; Move FPREG to argument
10E3: E1       [313]    	POP	HL		; Get FN code string address
10E4: CDB80C   [330]    	CALL	GETNUM		; Get value from function
10E7: 2B       [336]    	DEC	HL		; DEC 'cos GETCHR INCs
10E8: CD4B08   [353]    	CALL	GETCHR		; Get next character
10EB: C2F303   [363|363]	JP	NZ,SNERR	; Bad character in FN - Error
10EE: E1       [373]    	POP	HL		; Get MSB,EXP of old arg
10EF: 222581   [389]    	LD	(FNARG),HL	; Restore it
10F2: E1       [399]    	POP	HL		; Get LSB,NLSB of old arg
10F3: 222781   [415]    	LD	(FNARG+2),HL	; Restore it
10F6: E1       [425]    	POP	HL		; Get name of old arg
10F7: 222381   [441]    	LD	(FNRGNM),HL	; Restore it
10FA: E1       [451]    	POP	HL		; Restore code string address
10FB: C9       [461]    	RET
                        ;
10FC: E5       [11]     IDTEST: PUSH	HL		; Save code string address
10FD: 2AA180   [27]     	LD	HL,(LINEAT)	; Get current line number
1100: 23       [33]     	INC	HL		; -1 means direct statement
1101: 7C       [37]     	LD	A,H
1102: B5       [41]     	OR	L
1103: E1       [51]     	POP	HL		; Restore code string address
1104: C0       [56|62]  	RET	NZ		; Return if in program
1105: 1E16     [63]     	LD	E,ID		; ?ID Error
1107: C30704   [73]     	JP	ERROR
                        ;
110A: CDC106   [17]     CHEKFN: CALL	CHKSYN		; Make sure FN follows
110D: A7                	DB	ZFN		; "FN" token
110E: 3E80     [24]     	LD	A,80H
1110: 321081   [37]     	LD	(FORFLG),A	; Flag FN name to find
1113: B6       [44]     	OR	(HL)		; FN name has bit 7 set
1114: 47       [48]     	LD	B,A		; in first byte of name
1115: CDB30E   [65]     	CALL	GTFNAM		; Get FN name
1118: C3BB0C   [75]     	JP	TSTNUM		; Make sure numeric function
                        ;
111B: CDBB0C   [17]     STR:	CALL	TSTNUM		; Make sure it's a number
111E: CD3F18   [34]     	CALL	NUMASC		; Turn number into text
1121: CD4F11   [17]     STR1:	CALL	CRTST		; Create string entry for it
1124: CDD412   [34]     	CALL	GSTRCU		; Current string to pool
1127: 012F13   [44]     	LD	BC,TOPOOL	; Save in string pool
112A: C5       [55]     	PUSH	BC		; Save address on stack
                        ;
112B: 7E       [ 7]     SAVSTR: LD	A,(HL)		; Get string length
112C: 23       [13]     	INC	HL
112D: 23       [19]     	INC	HL
112E: E5       [30]     	PUSH	HL		; Save pointer to string
112F: CDAA11   [47]     	CALL	TESTR		; See if enough string space
1132: E1       [57]     	POP	HL		; Restore pointer to string
1133: 4E       [64]     	LD	C,(HL)		; Get LSB of address
1134: 23       [70]     	INC	HL
1135: 46       [77]     	LD	B,(HL)		; Get MSB of address
1136: CD4311   [94]     	CALL	CRTMST		; Create string entry
1139: E5       [105]    	PUSH	HL		; Save pointer to MSB of addr
113A: 6F       [109]    	LD	L,A		; Length of string
113B: CDC712   [126]    	CALL	TOSTRA		; Move to string area
113E: D1       [136]    	POP	DE		; Restore pointer to MSB
113F: C9       [146]    	RET
                        ;
1140: CDAA11   [17]     MKTMST: CALL	TESTR		; See if enough string space
1143: 210481   [10]     CRTMST: LD	HL,TMPSTR	; Temporary string
1146: E5       [21]     	PUSH	HL		; Save it
1147: 77       [28]     	LD	(HL),A		; Save length of string
1148: 23       [34]     	INC	HL
1149: 23       [ 6]     SVSTAD: INC	HL
114A: 73       [13]     	LD	(HL),E		; Save LSB of address
114B: 23       [19]     	INC	HL
114C: 72       [26]     	LD	(HL),D		; Save MSB of address
114D: E1       [36]     	POP	HL		; Restore pointer
114E: C9       [46]     	RET
                        ;
114F: 2B       [ 6]     CRTST:	DEC	HL		; DEC - INCed after
1150: 0622     [ 7]     QTSTR:	LD	B,'"'		; Terminating quote
1152: 50       [11]     	LD	D,B		; Quote to D
1153: E5       [11]     DTSTR:	PUSH	HL		; Save start
1154: 0EFF     [18]     	LD	C,-1		; Set counter to -1
1156: 23       [ 6]     QTSTLP: INC	HL		; Move on
1157: 7E       [13]     	LD	A,(HL)		; Get byte
1158: 0C       [17]     	INC	C		; Count bytes
1159: B7       [21]     	OR	A		; End of line?
115A: CA6511   [31|31]  	JP	Z,CRTSTE	; Yes - Create string entry
115D: BA       [35]     	CP	D		; Terminator D found?
115E: CA6511   [45|45]  	JP	Z,CRTSTE	; Yes - Create string entry
1161: B8       [49]     	CP	B		; Terminator B found?
1162: C25611   [59|59]  	JP	NZ,QTSTLP	; No - Keep looking
1165: FE22     [ 7]     CRTSTE: CP	'"'		; End with '"'?
1167: CC4B08   [17|24]  	CALL	Z,GETCHR	; Yes - Get next character
116A: E3       [36]     	EX	(SP),HL		; Starting quote
116B: 23       [42]     	INC	HL		; First byte of string
116C: EB       [46]     	EX	DE,HL		; To DE
116D: 79       [50]     	LD	A,C		; Get length
116E: CD4311   [67]     	CALL	CRTMST		; Create string entry
1171: 110481   [10]     TSTOPL: LD	DE,TMPSTR	; Temporary string
1174: 2AF680   [26]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
1177: 222981   [42]     	LD	(FPREG),HL	; Save address of string ptr
117A: 3E01     [49]     	LD	A,1
117C: 32F280   [62]     	LD	(TYPE),A	; Set type to string
117F: CDF516   [79]     	CALL	DETHL4		; Move string to pool
1182: CDBB06   [96]     	CALL	CPDEHL		; Out of string pool?
1185: 22F680   [112]    	LD	(TMSTPT),HL	; Save new pointer
1188: E1       [122]    	POP	HL		; Restore code string address
1189: 7E       [129]    	LD	A,(HL)		; Get next code byte
118A: C0       [134|140]	RET	NZ		; Return if pool OK
118B: 1E1E     [141]    	LD	E,ST		; ?ST Error
118D: C30704   [151]    	JP	ERROR		; String pool overflow
                        ;
1190: 23       [ 6]     PRNUMS: INC	HL		; Skip leading space
1191: CD4F11   [17]     PRS:	CALL	CRTST		; Create string entry for it
1194: CDD412   [17]     PRS1:	CALL	GSTRCU		; Current string to pool
1197: CDE916   [34]     	CALL	LOADFP		; Move string block to BCDE
119A: 1C       [38]     	INC	E		; Length + 1
119B: 1D       [ 4]     PRSLP:	DEC	E		; Count characters
119C: C8       [ 9|15]  	RET	Z		; End of string
119D: 0A       [16]     	LD	A,(BC)		; Get byte to output
119E: CDCC06   [33]     	CALL	OUTC		; Output character in A
11A1: FE0D     [40]     	CP	CR		; Return?
11A3: CCFD0A   [50|57]  	CALL	Z,DONULL	; Yes - Do nulls
11A6: 03       [56]     	INC	BC		; Next byte in string
11A7: C39B11   [66]     	JP	PRSLP		; More characters to output
                        ;
11AA: B7       [ 4]     TESTR:	OR	A		; Test if enough room
11AB: 0E                	DB	0EH		; No garbage collection done
11AC: F1       [10]     GRBDON: POP	AF		; Garbage collection done
11AD: F5       [21]     	PUSH	AF		; Save status
11AE: 2A9F80   [37]     	LD	HL,(STRSPC)	; Bottom of string space in use
11B1: EB       [41]     	EX	DE,HL		; To DE
11B2: 2A0881   [57]     	LD	HL,(STRBOT)	; Bottom of string area
11B5: 2F       [61]     	CPL			; Negate length (Top down)
11B6: 4F       [65]     	LD	C,A		; -Length to BC
11B7: 06FF     [72]     	LD	B,-1		; BC = -ve length of string
11B9: 09       [83]     	ADD	HL,BC		; Add to bottom of space in use
11BA: 23       [89]     	INC	HL		; Plus one for 2's complement
11BB: CDBB06   [106]    	CALL	CPDEHL		; Below string RAM area?
11BE: DAC811   [116|116]	JP	C,TESTOS	; Tidy up if not done else err
11C1: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of area
11C4: 23       [138]    	INC	HL		; Point to first byte of string
11C5: EB       [142]    	EX	DE,HL		; Address to DE
11C6: F1       [10]     POPAF:	POP	AF		; Throw away status push
11C7: C9       [20]     	RET
                        ;
11C8: F1       [10]     TESTOS: POP	AF		; Garbage collect been done?
11C9: 1E1A     [17]     	LD	E,OS		; ?OS Error
11CB: CA0704   [27|27]  	JP	Z,ERROR		; Yes - Not enough string apace
11CE: BF       [31]     	CP	A		; Flag garbage collect done
11CF: F5       [42]     	PUSH	AF		; Save status
11D0: 01AC11   [52]     	LD	BC,GRBDON	; Garbage collection done
11D3: C5       [63]     	PUSH	BC		; Save for RETurn
11D4: 2AF480   [16]     GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
11D7: 220881   [16]     GARBLP: LD	(STRBOT),HL	; Reset string pointer
11DA: 210000   [26]     	LD	HL,0
11DD: E5       [37]     	PUSH	HL		; Flag no string found
11DE: 2A9F80   [53]     	LD	HL,(STRSPC)	; Get bottom of string space
11E1: E5       [64]     	PUSH	HL		; Save bottom of string space
11E2: 21F880   [74]     	LD	HL,TMSTPL	; Temporary string pool
11E5: EB       [ 4]     GRBLP:	EX	DE,HL
11E6: 2AF680   [20]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
11E9: EB       [24]     	EX	DE,HL
11EA: CDBB06   [41]     	CALL	CPDEHL		; Temporary string pool done?
11ED: 01E511   [51]     	LD	BC,GRBLP	; Loop until string pool done
11F0: C23912   [61|61]  	JP	NZ,STPOOL	; No - See if in string area
11F3: 2A1B81   [77]     	LD	HL,(PROGND)	; Start of simple variables
11F6: EB       [ 4]     SMPVAR: EX	DE,HL
11F7: 2A1D81   [20]     	LD	HL,(VAREND)	; End of simple variables
11FA: EB       [24]     	EX	DE,HL
11FB: CDBB06   [41]     	CALL	CPDEHL		; All simple strings done?
11FE: CA0C12   [51|51]  	JP	Z,ARRLP		; Yes - Do string arrays
1201: 7E       [58]     	LD	A,(HL)		; Get type of variable
1202: 23       [64]     	INC	HL
1203: 23       [70]     	INC	HL
1204: B7       [74]     	OR	A		; "S" flag set if string
1205: CD3C12   [91]     	CALL	STRADD		; See if string in string area
1208: C3F611   [101]    	JP	SMPVAR		; Loop until simple ones done
                        ;
120B: C1       [10]     GNXARY: POP	BC		; Scrap address of this array
120C: EB       [ 4]     ARRLP:	EX	DE,HL
120D: 2A1F81   [20]     	LD	HL,(ARREND)	; End of string arrays
1210: EB       [24]     	EX	DE,HL
1211: CDBB06   [41]     	CALL	CPDEHL		; All string arrays done?
1214: CA6212   [51|51]  	JP	Z,SCNEND	; Yes - Move string if found
1217: CDE916   [68]     	CALL	LOADFP		; Get array name to BCDE
121A: 7B       [72]     	LD	A,E		; Get type of array	
121B: E5       [83]     	PUSH	HL		; Save address of num of dim'ns
121C: 09       [94]     	ADD	HL,BC		; Start of next array
121D: B7       [98]     	OR	A		; Test type of array
121E: F20B12   [108|108]	JP	P,GNXARY	; Numeric array - Ignore it
1221: 220A81   [124]    	LD	(CUROPR),HL	; Save address of next array
1224: E1       [134]    	POP	HL		; Get address of num of dim'ns
1225: 4E       [141]    	LD	C,(HL)		; BC = Number of dimensions
1226: 0600     [148]    	LD	B,0
1228: 09       [159]    	ADD	HL,BC		; Two bytes per dimension size
1229: 09       [170]    	ADD	HL,BC
122A: 23       [176]    	INC	HL		; Plus one for number of dim'ns
122B: EB       [ 4]     GRBARY: EX	DE,HL
122C: 2A0A81   [20]     	LD	HL,(CUROPR)	; Get address of next array
122F: EB       [24]     	EX	DE,HL
1230: CDBB06   [41]     	CALL	CPDEHL		; Is this array finished?
1233: CA0C12   [51|51]  	JP	Z,ARRLP		; Yes - Get next one
1236: 012B12   [61]     	LD	BC,GRBARY	; Loop until array all done
1239: C5       [11]     STPOOL: PUSH	BC		; Save return address
123A: F680     [18]     	OR	80H		; Flag string type
123C: 7E       [ 7]     STRADD: LD	A,(HL)		; Get string length
123D: 23       [13]     	INC	HL
123E: 23       [19]     	INC	HL
123F: 5E       [26]     	LD	E,(HL)		; Get LSB of string address
1240: 23       [32]     	INC	HL
1241: 56       [39]     	LD	D,(HL)		; Get MSB of string address
1242: 23       [45]     	INC	HL
1243: F0       [50|56]  	RET	P		; Not a string - Return
1244: B7       [54]     	OR	A		; Set flags on string length
1245: C8       [59|65]  	RET	Z		; Null string - Return
1246: 44       [63]     	LD	B,H		; Save variable pointer
1247: 4D       [67]     	LD	C,L
1248: 2A0881   [83]     	LD	HL,(STRBOT)	; Bottom of new area
124B: CDBB06   [100]    	CALL	CPDEHL		; String been done?
124E: 60       [104]    	LD	H,B		; Restore variable pointer
124F: 69       [108]    	LD	L,C
1250: D8       [113|119]	RET	C		; String done - Ignore
1251: E1       [123]    	POP	HL		; Return address
1252: E3       [142]    	EX	(SP),HL		; Lowest available string area
1253: CDBB06   [159]    	CALL	CPDEHL		; String within string area?
1256: E3       [178]    	EX	(SP),HL		; Lowest available string area
1257: E5       [189]    	PUSH	HL		; Re-save return address
1258: 60       [193]    	LD	H,B		; Restore variable pointer
1259: 69       [197]    	LD	L,C
125A: D0       [202|208]	RET	NC		; Outside string area - Ignore
125B: C1       [212]    	POP	BC		; Get return , Throw 2 away
125C: F1       [222]    	POP	AF		; 
125D: F1       [232]    	POP	AF		; 
125E: E5       [243]    	PUSH	HL		; Save variable pointer
125F: D5       [254]    	PUSH	DE		; Save address of current
1260: C5       [265]    	PUSH	BC		; Put back return address
1261: C9       [275]    	RET			; Go to it
                        ;
1262: D1       [10]     SCNEND: POP	DE		; Addresses of strings
1263: E1       [20]     	POP	HL		; 
1264: 7D       [24]     	LD	A,L		; HL = 0 if no more to do
1265: B4       [28]     	OR	H
1266: C8       [33|39]  	RET	Z		; No more to do - Return
1267: 2B       [39]     	DEC	HL
1268: 46       [46]     	LD	B,(HL)		; MSB of address of string
1269: 2B       [52]     	DEC	HL
126A: 4E       [59]     	LD	C,(HL)		; LSB of address of string
126B: E5       [70]     	PUSH	HL		; Save variable address
126C: 2B       [76]     	DEC	HL
126D: 2B       [82]     	DEC	HL
126E: 6E       [89]     	LD	L,(HL)		; HL = Length of string
126F: 2600     [96]     	LD	H,0
1271: 09       [107]    	ADD	HL,BC		; Address of end of string+1
1272: 50       [111]    	LD	D,B		; String address to DE
1273: 59       [115]    	LD	E,C
1274: 2B       [121]    	DEC	HL		; Last byte in string
1275: 44       [125]    	LD	B,H		; Address to BC
1276: 4D       [129]    	LD	C,L
1277: 2A0881   [145]    	LD	HL,(STRBOT)	; Current bottom of string area
127A: CDC203   [162]    	CALL	MOVSTR		; Move string to new address
127D: E1       [172]    	POP	HL		; Restore variable address
127E: 71       [179]    	LD	(HL),C		; Save new LSB of address
127F: 23       [185]    	INC	HL
1280: 70       [192]    	LD	(HL),B		; Save new MSB of address
1281: 69       [196]    	LD	L,C		; Next string area+1 to HL
1282: 60       [200]    	LD	H,B
1283: 2B       [206]    	DEC	HL		; Next string area address
1284: C3D711   [216]    	JP	GARBLP		; Look for more strings
                        ;
1287: C5       [11]     CONCAT: PUSH	BC		; Save prec' opr & code string
1288: E5       [22]     	PUSH	HL		; 
1289: 2A2981   [38]     	LD	HL,(FPREG)	; Get first string
128C: E3       [57]     	EX	(SP),HL		; Save first string
128D: CD410D   [74]     	CALL	OPRND		; Get second string
1290: E3       [93]     	EX	(SP),HL		; Restore first string
1291: CDBC0C   [110]    	CALL	TSTSTR		; Make sure it's a string
1294: 7E       [117]    	LD	A,(HL)		; Get length of second string
1295: E5       [128]    	PUSH	HL		; Save first string
1296: 2A2981   [144]    	LD	HL,(FPREG)	; Get second string
1299: E5       [155]    	PUSH	HL		; Save second string
129A: 86       [162]    	ADD	A,(HL)		; Add length of second string
129B: 1E1C     [169]    	LD	E,LS		; ?LS Error
129D: DA0704   [179|179]	JP	C,ERROR		; String too long - Error
12A0: CD4011   [196]    	CALL	MKTMST		; Make temporary string
12A3: D1       [206]    	POP	DE		; Get second string to DE
12A4: CDD812   [223]    	CALL	GSTRDE		; Move to string pool if needed
12A7: E3       [242]    	EX	(SP),HL		; Get first string
12A8: CDD712   [259]    	CALL	GSTRHL		; Move to string pool if needed
12AB: E5       [270]    	PUSH	HL		; Save first string
12AC: 2A0681   [286]    	LD	HL,(TMPSTR+2)	; Temporary string address
12AF: EB       [290]    	EX	DE,HL		; To DE
12B0: CDBE12   [307]    	CALL	SSTSA		; First string to string area
12B3: CDBE12   [324]    	CALL	SSTSA		; Second string to string area
12B6: 21D60C   [334]    	LD	HL,EVAL2	; Return to evaluation loop
12B9: E3       [353]    	EX	(SP),HL		; Save return,get code string
12BA: E5       [364]    	PUSH	HL		; Save code string address
12BB: C37111   [374]    	JP	TSTOPL		; To temporary string to pool
                        ;
12BE: E1       [10]     SSTSA:	POP	HL		; Return address
12BF: E3       [29]     	EX	(SP),HL		; Get string block,save return
12C0: 7E       [36]     	LD	A,(HL)		; Get length of string
12C1: 23       [42]     	INC	HL
12C2: 23       [48]     	INC	HL
12C3: 4E       [55]     	LD	C,(HL)		; Get LSB of string address
12C4: 23       [61]     	INC	HL
12C5: 46       [68]     	LD	B,(HL)		; Get MSB of string address
12C6: 6F       [72]     	LD	L,A		; Length to L
12C7: 2C       [ 4]     TOSTRA: INC	L		; INC - DECed after
12C8: 2D       [ 4]     TSALP:	DEC	L		; Count bytes moved
12C9: C8       [ 9|15]  	RET	Z		; End of string - Return
12CA: 0A       [16]     	LD	A,(BC)		; Get source
12CB: 12       [23]     	LD	(DE),A		; Save destination
12CC: 03       [29]     	INC	BC		; Next source
12CD: 13       [35]     	INC	DE		; Next destination
12CE: C3C812   [45]     	JP	TSALP		; Loop until string moved
                        ;
12D1: CDBC0C   [17]     GETSTR: CALL	TSTSTR		; Make sure it's a string
12D4: 2A2981   [16]     GSTRCU: LD	HL,(FPREG)	; Get current string
12D7: EB       [ 4]     GSTRHL: EX	DE,HL		; Save DE
12D8: CDF212   [17]     GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
12DB: EB       [21]     	EX	DE,HL		; Restore DE
12DC: C0       [26|32]  	RET	NZ		; No - Return
12DD: D5       [37]     	PUSH	DE		; Save string
12DE: 50       [41]     	LD	D,B		; String block address to DE
12DF: 59       [45]     	LD	E,C
12E0: 1B       [51]     	DEC	DE		; Point to length
12E1: 4E       [58]     	LD	C,(HL)		; Get string length
12E2: 2A0881   [74]     	LD	HL,(STRBOT)	; Current bottom of string area
12E5: CDBB06   [91]     	CALL	CPDEHL		; Last one in string area?
12E8: C2F012   [101|101]	JP	NZ,POPHL	; No - Return
12EB: 47       [105]    	LD	B,A		; Clear B (A=0)
12EC: 09       [116]    	ADD	HL,BC		; Remove string from str' area
12ED: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of str' area
12F0: E1       [10]     POPHL:	POP	HL		; Restore string
12F1: C9       [20]     	RET
                        ;
12F2: 2AF680   [16]     BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
12F5: 2B       [22]     	DEC	HL		; Back
12F6: 46       [29]     	LD	B,(HL)		; Get MSB of address
12F7: 2B       [35]     	DEC	HL		; Back
12F8: 4E       [42]     	LD	C,(HL)		; Get LSB of address
12F9: 2B       [48]     	DEC	HL		; Back
12FA: 2B       [54]     	DEC	HL		; Back
12FB: CDBB06   [71]     	CALL	CPDEHL		; String last in string pool?
12FE: C0       [76|82]  	RET	NZ		; Yes - Leave it
12FF: 22F680   [92]     	LD	(TMSTPT),HL	; Save new string pool top
1302: C9       [102]    	RET
                        ;
1303: 018210   [10]     LEN:	LD	BC,PASSA	; To return integer A
1306: C5       [21]     	PUSH	BC		; Save address
1307: CDD112   [17]     GETLEN: CALL	GETSTR		; Get string and its length
130A: AF       [21]     	XOR	A
130B: 57       [25]     	LD	D,A		; Clear D
130C: 32F280   [38]     	LD	(TYPE),A	; Set type to numeric
130F: 7E       [45]     	LD	A,(HL)		; Get length of string
1310: B7       [49]     	OR	A		; Set status flags
1311: C9       [59]     	RET
                        ;
1312: 018210   [10]     ASC:	LD	BC,PASSA	; To return integer A
1315: C5       [21]     	PUSH	BC		; Save address
1316: CD0713   [17]     GTFLNM: CALL	GETLEN		; Get length of string
1319: CA1209   [27|27]  	JP	Z,FCERR		; Null string - Error
131C: 23       [33]     	INC	HL
131D: 23       [39]     	INC	HL
131E: 5E       [46]     	LD	E,(HL)		; Get LSB of address
131F: 23       [52]     	INC	HL
1320: 56       [59]     	LD	D,(HL)		; Get MSB of address
1321: 1A       [66]     	LD	A,(DE)		; Get first byte of string
1322: C9       [76]     	RET
                        ;
1323: 3E01     [ 7]     CHR:	LD	A,1		; One character string
1325: CD4011   [24]     	CALL	MKTMST		; Make a temporary string
1328: CD1C14   [41]     	CALL	MAKINT		; Make it integer A
132B: 2A0681   [57]     	LD	HL,(TMPSTR+2)	; Get address of string
132E: 73       [64]     	LD	(HL),E		; Save character
132F: C1       [10]     TOPOOL: POP	BC		; Clean up stack
1330: C37111   [20]     	JP	TSTOPL		; Temporary string to pool
                        ;
1333: CDCC13   [17]     LEFT:	CALL	LFRGNM		; Get number and ending ")"
1336: AF       [21]     	XOR	A		; Start at first byte in string
1337: E3       [19]     RIGHT1: EX	(SP),HL		; Save code string,Get string
1338: 4F       [23]     	LD	C,A		; Starting position in string
1339: E5       [11]     MID1:	PUSH	HL		; Save string block address
133A: 7E       [18]     	LD	A,(HL)		; Get length of string
133B: B8       [22]     	CP	B		; Compare with number given
133C: DA4113   [32|32]  	JP	C,ALLFOL	; All following bytes required
133F: 78       [36]     	LD	A,B		; Get new length
1340: 11                	DB	11H		; Skip "LD C,0"
1341: 0E00     [ 7]     ALLFOL: LD	C,0		; First byte of string
1343: C5       [18]     	PUSH	BC		; Save position in string
1344: CDAA11   [35]     	CALL	TESTR		; See if enough string space
1347: C1       [45]     	POP	BC		; Get position in string
1348: E1       [55]     	POP	HL		; Restore string block address
1349: E5       [66]     	PUSH	HL		; And re-save it
134A: 23       [72]     	INC	HL
134B: 23       [78]     	INC	HL
134C: 46       [85]     	LD	B,(HL)		; Get LSB of address
134D: 23       [91]     	INC	HL
134E: 66       [98]     	LD	H,(HL)		; Get MSB of address
134F: 68       [102]    	LD	L,B		; HL = address of string
1350: 0600     [109]    	LD	B,0		; BC = starting address
1352: 09       [120]    	ADD	HL,BC		; Point to that byte
1353: 44       [124]    	LD	B,H		; BC = source string
1354: 4D       [128]    	LD	C,L
1355: CD4311   [145]    	CALL	CRTMST		; Create a string entry
1358: 6F       [149]    	LD	L,A		; Length of new string
1359: CDC712   [166]    	CALL	TOSTRA		; Move string to string area
135C: D1       [176]    	POP	DE		; Clear stack
135D: CDD812   [193]    	CALL	GSTRDE		; Move to string pool if needed
1360: C37111   [203]    	JP	TSTOPL		; Temporary string to pool
                        ;
1363: CDCC13   [17]     RIGHT:	CALL	LFRGNM		; Get number and ending ")"
1366: D1       [27]     	POP	DE		; Get string length
1367: D5       [38]     	PUSH	DE		; And re-save
1368: 1A       [45]     	LD	A,(DE)		; Get length
1369: 90       [49]     	SUB	B		; Move back N bytes
136A: C33713   [59]     	JP	RIGHT1		; Go and get sub-string
                        ;
136D: EB       [ 4]     MID:	EX	DE,HL		; Get code string address
136E: 7E       [11]     	LD	A,(HL)		; Get next byte ',' or ")"
136F: CDD113   [28]     	CALL	MIDNUM		; Get number supplied
1372: 04       [32]     	INC	B		; Is it character zero?
1373: 05       [36]     	DEC	B
1374: CA1209   [46|46]  	JP	Z,FCERR		; Yes - Error
1377: C5       [57]     	PUSH	BC		; Save starting position
1378: 1EFF     [64]     	LD	E,255		; All of string
137A: FE29     [71]     	CP	')'		; Any length given?
137C: CA8613   [81|81]  	JP	Z,RSTSTR	; No - Rest of string
137F: CDC106   [98]     	CALL	CHKSYN		; Make sure ',' follows
1382: 2C                	DB	','
1383: CD1914   [115]    	CALL	GETINT		; Get integer 0-255
1386: CDC106   [17]     RSTSTR: CALL	CHKSYN		; Make sure ")" follows
1389: 29                	DB	")"
138A: F1       [27]     	POP	AF		; Restore starting position
138B: E3       [46]     	EX	(SP),HL		; Get string,8ave code string
138C: 013913   [56]     	LD	BC,MID1		; Continuation of MID$ routine
138F: C5       [67]     	PUSH	BC		; Save for return
1390: 3D       [71]     	DEC	A		; Starting position-1
1391: BE       [78]     	CP	(HL)		; Compare with length
1392: 0600     [85]     	LD	B,0		; Zero bytes length
1394: D0       [90|96]  	RET	NC		; Null string if start past end
1395: 4F       [94]     	LD	C,A		; Save starting position-1
1396: 7E       [101]    	LD	A,(HL)		; Get length of string
1397: 91       [105]    	SUB	C		; Subtract start
1398: BB       [109]    	CP	E		; Enough string for it?
1399: 47       [113]    	LD	B,A		; Save maximum length available
139A: D8       [118|124]	RET	C		; Truncate string if needed
139B: 43       [122]    	LD	B,E		; Set specified length
139C: C9       [132]    	RET			; Go and create string
                        ;
139D: CD0713   [17]     VAL:	CALL	GETLEN		; Get length of string
13A0: CABA14   [27|27]  	JP	Z,RESZER	; Result zero
13A3: 5F       [31]     	LD	E,A		; Save length
13A4: 23       [37]     	INC	HL
13A5: 23       [43]     	INC	HL
13A6: 7E       [50]     	LD	A,(HL)		; Get LSB of address
13A7: 23       [56]     	INC	HL
13A8: 66       [63]     	LD	H,(HL)		; Get MSB of address
13A9: 6F       [67]     	LD	L,A		; HL = String address
13AA: E5       [78]     	PUSH	HL		; Save string address
13AB: 19       [89]     	ADD	HL,DE
13AC: 46       [96]     	LD	B,(HL)		; Get end of string+1 byte
13AD: 72       [103]    	LD	(HL),D		; Zero it to terminate
13AE: E3       [122]    	EX	(SP),HL		; Save string end,get start
13AF: C5       [133]    	PUSH	BC		; Save end+1 byte
13B0: 7E       [140]    	LD	A,(HL)		; Get starting byte
13B1: FE24     [147]    	CP	'$'		; Hex number indicated? [function added]
13B3: C2BB13   [157|157]	JP	NZ,VAL1
13B6: CDE51B   [174]    	CALL	HEXTFP		; Convert Hex to FPREG
13B9: 180D     [186]    	JR	VAL3
13BB: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
13BD: C2C513   [17|17]  	JP	NZ,VAL2
13C0: CD551C   [34]     	CALL	BINTFP		; Convert Bin to FPREG
13C3: 1803     [46]     	JR	VAL3
13C5: CDA117   [17]     VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
13C8: C1       [10]     VAL3:	POP	BC		; Restore end+1 byte
13C9: E1       [20]     	POP	HL		; Restore end+1 address
13CA: 70       [27]     	LD	(HL),B		; Put back original byte
13CB: C9       [37]     	RET
                        ;
13CC: EB       [ 4]     LFRGNM: EX	DE,HL		; Code string address to HL
13CD: CDC106   [21]     	CALL	CHKSYN		; Make sure ")" follows
13D0: 29                	DB	")"
13D1: C1       [10]     MIDNUM: POP	BC		; Get return address
13D2: D1       [20]     	POP	DE		; Get number supplied
13D3: C5       [31]     	PUSH	BC		; Re-save return address
13D4: 43       [35]     	LD	B,E		; Number to B
13D5: C9       [45]     	RET
                        ;
13D6: CD1C14   [17]     INP:	CALL	MAKINT		; Make it integer A
13D9: 328480   [30]     	LD	(INPORT),A	; Set input port
13DC: CD8380   [47]     	CALL	INPSUB		; Get input from port
13DF: C38210   [57]     	JP	PASSA		; Return integer A
                        ;
13E2: CD0614   [17]     POUT:	CALL	SETIO		; Set up port number
13E5: C34B80   [27]     	JP	OUTSUB		; Output data and return
                        ;
13E8: CD0614   [17]     WAIT:	CALL	SETIO		; Set up port number
13EB: F5       [28]     	PUSH	AF		; Save AND mask
13EC: 1E00     [35]     	LD	E,0		; Assume zero if none given
13EE: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
13EF: CD4B08   [58]     	CALL	GETCHR		; Get next character
13F2: CAFC13   [68|68]  	JP	Z,NOXOR		; No XOR byte given
13F5: CDC106   [85]     	CALL	CHKSYN		; Make sure ',' follows
13F8: 2C                	DB	','
13F9: CD1914   [102]    	CALL	GETINT		; Get integer 0-255 to XOR with
13FC: C1       [10]     NOXOR:	POP	BC		; Restore AND mask
13FD: CD8380   [17]     WAITLP: CALL	INPSUB		; Get input
1400: AB       [21]     	XOR	E		; Flip selected bits
1401: A0       [25]     	AND	B		; Result non-zero?
1402: CAFD13   [35|35]  	JP	Z,WAITLP	; No = keep waiting
1405: C9       [45]     	RET
                        ;
1406: CD1914   [17]     SETIO:	CALL	GETINT		; Get integer 0-255
1409: 328480   [30]     	LD	(INPORT),A	; Set input port
140C: 324C80   [43]     	LD	(OTPORT),A	; Set output port
140F: CDC106   [60]     	CALL	CHKSYN		; Make sure ',' follows
1412: 2C                	DB	','
1413: C31914   [70]     	JP	GETINT		; Get integer 0-255 and return
                        ;
1416: CD4B08   [17]     FNDNUM: CALL	GETCHR		; Get next character
1419: CDB80C   [17]     GETINT: CALL	GETNUM		; Get a number from 0 to 255
141C: CDF708   [17]     MAKINT: CALL	DEPINT		; Make sure value 0 - 255
141F: 7A       [21]     	LD	A,D		; Get MSB of number
1420: B7       [25]     	OR	A		; Zero?
1421: C21209   [35|35]  	JP	NZ,FCERR	; No - Error
1424: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
1425: CD4B08   [58]     	CALL	GETCHR		; Get next character
1428: 7B       [62]     	LD	A,E		; Get number to A
1429: C9       [72]     	RET
                        ;
142A: CDFD08   [17]     PEEK:	CALL	DEINT		; Get memory address
142D: 1A       [24]     	LD	A,(DE)		; Get byte in memory
142E: C38210   [34]     	JP	PASSA		; Return integer A
                        ;
1431: CDB80C   [17]     POKE:	CALL	GETNUM		; Get memory address
1434: CDFD08   [34]     	CALL	DEINT		; Get integer -32768 to 3276
1437: D5       [45]     	PUSH	DE		; Save memory address
1438: CDC106   [62]     	CALL	CHKSYN		; Make sure ',' follows
143B: 2C                	DB	','
143C: CD1914   [79]     	CALL	GETINT		; Get integer 0-255
143F: D1       [89]     	POP	DE		; Restore memory address
1440: 12       [96]     	LD	(DE),A		; Load it into memory
1441: C9       [106]    	RET
                        ;
1442: 211819   [10]     ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
1445: CDE916   [17]     ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
1448: C35414   [27]     	JP	FPADD		; Add BCDE to FPREG
                        ;
144B: CDE916   [17]     SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
144E: 21                	DB	21H		; Skip "POP BC" and "POP DE"
144F: C1       [10]     PSUB:	POP	BC		; Get FP number from stack
1450: D1       [20]     	POP	DE
1451: CDC316   [17]     SUBCDE: CALL	INVSGN		; Negate FPREG
1454: 78       [ 4]     FPADD:	LD	A,B		; Get FP exponent
1455: B7       [ 8]     	OR	A		; Is number zero?
1456: C8       [13|19]  	RET	Z		; Yes - Nothing to add
1457: 3A2C81   [26]     	LD	A,(FPEXP)	; Get FPREG exponent
145A: B7       [30]     	OR	A		; Is this number zero?
145B: CADB16   [40|40]  	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
145E: 90       [44]     	SUB	B		; BCDE number larger?
145F: D26E14   [54|54]  	JP	NC,NOSWAP	; No - Don't swap them
1462: 2F       [58]     	CPL			; Two's complement
1463: 3C       [62]     	INC	A		;	FP exponent
1464: EB       [66]     	EX	DE,HL
1465: CDCB16   [83]     	CALL	STAKFP		; Put FPREG on stack
1468: EB       [87]     	EX	DE,HL
1469: CDDB16   [104]    	CALL	FPBCDE		; Move BCDE to FPREG
146C: C1       [114]    	POP	BC		; Restore number from stack
146D: D1       [124]    	POP	DE
146E: FE19     [ 7]     NOSWAP: CP	24+1		; Second number insignificant?
1470: D0       [12|18]  	RET	NC		; Yes - First number is result
1471: F5       [23]     	PUSH	AF		; Save number of bits to scale
1472: CD0017   [40]     	CALL	SIGNS		; Set MSBs & sign of result
1475: 67       [44]     	LD	H,A		; Save sign of result
1476: F1       [54]     	POP	AF		; Restore scaling factor
1477: CD1915   [71]     	CALL	SCALE		; Scale BCDE to same exponent
147A: B4       [75]     	OR	H		; Result to be positive?
147B: 212981   [85]     	LD	HL,FPREG	; Point to FPREG
147E: F29414   [95|95]  	JP	P,MINCDE	; No - Subtract FPREG from CDE
1481: CDF914   [112]    	CALL	PLUCDE		; Add FPREG to CDE
1484: D2DA14   [122|122]	JP	NC,RONDUP	; No overflow - Round it up
1487: 23       [128]    	INC	HL		; Point to exponent
1488: 34       [139]    	INC	(HL)		; Increment it
1489: CA0204   [149|149]	JP	Z,OVERR		; Number overflowed - Error
148C: 2E01     [156]    	LD	L,1		; 1 bit to shift right
148E: CD2F15   [173]    	CALL	SHRT1		; Shift result right
1491: C3DA14   [183]    	JP	RONDUP		; Round it up
                        ;
1494: AF       [ 4]     MINCDE: XOR	A		; Clear A and carry
1495: 90       [ 8]     	SUB	B		; Negate exponent
1496: 47       [12]     	LD	B,A		; Re-save exponent
1497: 7E       [19]     	LD	A,(HL)		; Get LSB of FPREG
1498: 9B       [23]     	SBC	A, E		; Subtract LSB of BCDE
1499: 5F       [27]     	LD	E,A		; Save LSB of BCDE
149A: 23       [33]     	INC	HL
149B: 7E       [40]     	LD	A,(HL)		; Get NMSB of FPREG
149C: 9A       [44]     	SBC	A,D		; Subtract NMSB of BCDE
149D: 57       [48]     	LD	D,A		; Save NMSB of BCDE
149E: 23       [54]     	INC	HL
149F: 7E       [61]     	LD	A,(HL)		; Get MSB of FPREG
14A0: 99       [65]     	SBC	A,C		; Subtract MSB of BCDE
14A1: 4F       [69]     	LD	C,A		; Save MSB of BCDE
14A2: DC0515   [10|17]  CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                        ;
14A5: 68       [ 4]     BNORM:	LD	L,B		; L = Exponent
14A6: 63       [ 8]     	LD	H,E		; H = LSB
14A7: AF       [12]     	XOR	A
14A8: 47       [ 4]     BNRMLP: LD	B,A		; Save bit count
14A9: 79       [ 8]     	LD	A,C		; Get MSB
14AA: B7       [12]     	OR	A		; Is it zero?
14AB: C2C714   [22|22]  	JP	NZ,PNORM	; No - Do it bit at a time
14AE: 4A       [26]     	LD	C,D		; MSB = NMSB
14AF: 54       [30]     	LD	D,H		; NMSB= LSB
14B0: 65       [34]     	LD	H,L		; LSB = VLSB
14B1: 6F       [38]     	LD	L,A		; VLSB= 0
14B2: 78       [42]     	LD	A,B		; Get exponent
14B3: D608     [49]     	SUB	8		; Count 8 bits
14B5: FEE0     [56]     	CP	0E0H		; -24-8 Was number zero?
14B7: C2A814   [66|66]  	JP	NZ,BNRMLP	; No - Keep normalising
14BA: AF       [ 4]     RESZER: XOR	A		; Result is zero
14BB: 322C81   [13]     SAVEXP: LD	(FPEXP),A	; Save result as zero
14BE: C9       [23]     	RET
                        ;
14BF: 05       [ 4]     NORMAL: DEC	B		; Count bits
14C0: 29       [15]     	ADD	HL,HL		; Shift HL left
14C1: 7A       [19]     	LD	A,D		; Get NMSB
14C2: 17       [23]     	RLA			; Shift left with last bit
14C3: 57       [27]     	LD	D,A		; Save NMSB
14C4: 79       [31]     	LD	A,C		; Get MSB
14C5: 8F       [35]     	ADC	A,A		; Shift left with last bit
14C6: 4F       [39]     	LD	C,A		; Save MSB
14C7: F2BF14   [10|10]  PNORM:	JP	P,NORMAL	; Not done - Keep going
14CA: 78       [14]     	LD	A,B		; Number of bits shifted
14CB: 5C       [18]     	LD	E,H		; Save HL in EB
14CC: 45       [22]     	LD	B,L
14CD: B7       [26]     	OR	A		; Any shifting done?
14CE: CADA14   [36|36]  	JP	Z,RONDUP	; No - Round it up
14D1: 212C81   [46]     	LD	HL,FPEXP	; Point to exponent
14D4: 86       [53]     	ADD	A,(HL)		; Add shifted bits
14D5: 77       [60]     	LD	(HL),A		; Re-save exponent
14D6: D2BA14   [70|70]  	JP	NC,RESZER	; Underflow - Result is zero
14D9: C8       [75|81]  	RET	Z		; Result is zero
14DA: 78       [ 4]     RONDUP: LD	A,B		; Get VLSB of number
14DB: 212C81   [10]     RONDB:	LD	HL,FPEXP	; Point to exponent
14DE: B7       [14]     	OR	A		; Any rounding?
14DF: FCEC14   [24|31]  	CALL	M,FPROND	; Yes - Round number up
14E2: 46       [31]     	LD	B,(HL)		; B = Exponent
14E3: 23       [37]     	INC	HL
14E4: 7E       [44]     	LD	A,(HL)		; Get sign of result
14E5: E680     [51]     	AND	10000000B	; Only bit 7 needed
14E7: A9       [55]     	XOR	C		; Set correct sign
14E8: 4F       [59]     	LD	C,A		; Save correct sign in number
14E9: C3DB16   [69]     	JP	FPBCDE		; Move BCDE to FPREG
                        ;
14EC: 1C       [ 4]     FPROND: INC	E		; Round LSB
14ED: C0       [ 9|15]  	RET	NZ		; Return if ok
14EE: 14       [13]     	INC	D		; Round NMSB
14EF: C0       [18|24]  	RET	NZ		; Return if ok
14F0: 0C       [22]     	INC	C		; Round MSB
14F1: C0       [27|33]  	RET	NZ		; Return if ok
14F2: 0E80     [34]     	LD	C,80H		; Set normal value
14F4: 34       [45]     	INC	(HL)		; Increment exponent
14F5: C0       [50|56]  	RET	NZ		; Return if ok
14F6: C30204   [60]     	JP	OVERR		; Overflow error
                        ;
14F9: 7E       [ 7]     PLUCDE: LD	A,(HL)		; Get LSB of FPREG
14FA: 83       [11]     	ADD	A,E		; Add LSB of BCDE
14FB: 5F       [15]     	LD	E,A		; Save LSB of BCDE
14FC: 23       [21]     	INC	HL
14FD: 7E       [28]     	LD	A,(HL)		; Get NMSB of FPREG
14FE: 8A       [32]     	ADC	A,D		; Add NMSB of BCDE
14FF: 57       [36]     	LD	D,A		; Save NMSB of BCDE
1500: 23       [42]     	INC	HL
1501: 7E       [49]     	LD	A,(HL)		; Get MSB of FPREG
1502: 89       [53]     	ADC	A,C		; Add MSB of BCDE
1503: 4F       [57]     	LD	C,A		; Save MSB of BCDE
1504: C9       [67]     	RET
                        ;
1505: 212D81   [10]     COMPL:	LD	HL,SGNRES	; Sign of result
1508: 7E       [17]     	LD	A,(HL)		; Get sign of result
1509: 2F       [21]     	CPL			; Negate it
150A: 77       [28]     	LD	(HL),A		; Put it back
150B: AF       [32]     	XOR	A
150C: 6F       [36]     	LD	L,A		; Set L to zero
150D: 90       [40]     	SUB	B		; Negate exponent,set carry
150E: 47       [44]     	LD	B,A		; Re-save exponent
150F: 7D       [48]     	LD	A,L		; Load zero
1510: 9B       [52]     	SBC	A,E		; Negate LSB
1511: 5F       [56]     	LD	E,A		; Re-save LSB
1512: 7D       [60]     	LD	A,L		; Load zero
1513: 9A       [64]     	SBC	A,D		; Negate NMSB
1514: 57       [68]     	LD	D,A		; Re-save NMSB
1515: 7D       [72]     	LD	A,L		; Load zero
1516: 99       [76]     	SBC	A,C		; Negate MSB
1517: 4F       [80]     	LD	C,A		; Re-save MSB
1518: C9       [90]     	RET
                        ;
1519: 0600     [ 7]     SCALE:	LD	B,0		; Clear underflow
151B: D608     [ 7]     SCALLP: SUB	8		; 8 bits (a whole byte)?
151D: DA2815   [17|17]  	JP	C,SHRITE	; No - Shift right A bits
1520: 43       [21]     	LD	B,E		; <- Shift
1521: 5A       [25]     	LD	E,D		; <- right
1522: 51       [29]     	LD	D,C		; <- eight
1523: 0E00     [36]     	LD	C,0		; <- bits
1525: C31B15   [46]     	JP	SCALLP		; More bits to shift
                        ;
1528: C609     [ 7]     SHRITE: ADD	A,8+1		; Adjust count
152A: 6F       [11]     	LD	L,A		; Save bits to shift
152B: AF       [ 4]     SHRLP:	XOR	A		; Flag for all done
152C: 2D       [ 8]     	DEC	L		; All shifting done?
152D: C8       [13|19]  	RET	Z		; Yes - Return
152E: 79       [17]     	LD	A,C		; Get MSB
152F: 1F       [ 4]     SHRT1:	RRA			; Shift it right
1530: 4F       [ 8]     	LD	C,A		; Re-save
1531: 7A       [12]     	LD	A,D		; Get NMSB
1532: 1F       [16]     	RRA			; Shift right with last bit
1533: 57       [20]     	LD	D,A		; Re-save it
1534: 7B       [24]     	LD	A,E		; Get LSB
1535: 1F       [28]     	RRA			; Shift right with last bit
1536: 5F       [32]     	LD	E,A		; Re-save it
1537: 78       [36]     	LD	A,B		; Get underflow
1538: 1F       [40]     	RRA			; Shift right with last bit
1539: 47       [44]     	LD	B,A		; Re-save underflow
153A: C32B15   [54]     	JP	SHRLP		; More bits to do
                        ;
153D: 00000081          UNITY:	DB	 000H,000H,000H,081H	; 1.00000
                        ;
1541: 03                LOGTAB: DB	3			; Table used by LOG
1542: AA561980          	DB	0AAH,056H,019H,080H	; 0.59898
1546: F1227680          	DB	0F1H,022H,076H,080H	; 0.96147
154A: 45AA3882          	DB	045H,0AAH,038H,082H	; 2.88539
                        ;
154E: CD9A16   [17]     LOG:	CALL	TSTSGN		; Test sign of value
1551: B7       [21]     	OR	A
1552: EA1209   [31|31]  	JP	PE,FCERR	; ?FC Error if <= zero
1555: 212C81   [41]     	LD	HL,FPEXP	; Point to exponent
1558: 7E       [48]     	LD	A,(HL)		; Get exponent
1559: 013580   [58]     	LD	BC,8035H	; BCDE = SQR(1/2)
155C: 11F304   [68]     	LD	DE,04F3H
155F: 90       [72]     	SUB	B		; Scale value to be < 1
1560: F5       [83]     	PUSH	AF		; Save scale factor
1561: 70       [90]     	LD	(HL),B		; Save new exponent
1562: D5       [101]    	PUSH	DE		; Save SQR(1/2)
1563: C5       [112]    	PUSH	BC
1564: CD5414   [129]    	CALL	FPADD		; Add SQR(1/2) to value
1567: C1       [139]    	POP	BC		; Restore SQR(1/2)
1568: D1       [149]    	POP	DE
1569: 04       [153]    	INC	B		; Make it SQR(2)
156A: CDF015   [170]    	CALL	DVBCDE		; Divide by SQR(2)
156D: 213D15   [180]    	LD	HL,UNITY	; Point to 1.
1570: CD4B14   [197]    	CALL	SUBPHL		; Subtract FPREG from 1
1573: 214115   [207]    	LD	HL,LOGTAB	; Coefficient table
1576: CDE219   [224]    	CALL	SUMSER		; Evaluate sum of series
1579: 018080   [234]    	LD	BC,8080H	; BCDE = -0.5
157C: 110000   [244]    	LD	DE,0000H
157F: CD5414   [261]    	CALL	FPADD		; Subtract 0.5 from FPREG
1582: F1       [271]    	POP	AF		; Restore scale factor
1583: CD1518   [288]    	CALL	RSCALE		; Re-scale number
1586: 013180   [10]     MULLN2: LD	BC,8031H	; BCDE = Ln(2)
1589: 111872   [20]     	LD	DE,7218H
158C: 21                	DB	21H		; Skip "POP BC" and "POP DE"
                        ;
158D: C1       [10]     MULT:	POP	BC		; Get number from stack
158E: D1       [20]     	POP	DE
158F: CD9A16   [17]     FPMULT: CALL	TSTSGN		; Test sign of FPREG
1592: C8       [22|28]  	RET	Z		; Return zero if zero
1593: 2E00     [29]     	LD	L,0		; Flag add exponents
1595: CD5816   [46]     	CALL	ADDEXP		; Add exponents
1598: 79       [50]     	LD	A,C		; Get MSB of multiplier
1599: 323B81   [63]     	LD	(MULVAL),A	; Save MSB of multiplier
159C: EB       [67]     	EX	DE,HL
159D: 223C81   [83]     	LD	(MULVAL+1),HL	; Save rest of multiplier
15A0: 010000   [93]     	LD	BC,0		; Partial product (BCDE) = zero
15A3: 50       [97]     	LD	D,B
15A4: 58       [101]    	LD	E,B
15A5: 21A514   [111]    	LD	HL,BNORM	; Address of normalise
15A8: E5       [122]    	PUSH	HL		; Save for return
15A9: 21B115   [132]    	LD	HL,MULT8	; Address of 8 bit multiply
15AC: E5       [143]    	PUSH	HL		; Save for NMSB,MSB
15AD: E5       [154]    	PUSH	HL		; 
15AE: 212981   [164]    	LD	HL,FPREG	; Point to number
15B1: 7E       [ 7]     MULT8:	LD	A,(HL)		; Get LSB of number
15B2: 23       [13]     	INC	HL		; Point to NMSB
15B3: B7       [17]     	OR	A		; Test LSB
15B4: CADD15   [27|27]  	JP	Z,BYTSFT	; Zero - shift to next byte
15B7: E5       [38]     	PUSH	HL		; Save address of number
15B8: 2E08     [45]     	LD	L,8		; 8 bits to multiply by
15BA: 1F       [ 4]     MUL8LP: RRA			; Shift LSB right
15BB: 67       [ 8]     	LD	H,A		; Save LSB
15BC: 79       [12]     	LD	A,C		; Get MSB
15BD: D2CB15   [22|22]  	JP	NC,NOMADD	; Bit was zero - Don't add
15C0: E5       [33]     	PUSH	HL		; Save LSB and count
15C1: 2A3C81   [49]     	LD	HL,(MULVAL+1)	; Get LSB and NMSB
15C4: 19       [60]     	ADD	HL,DE		; Add NMSB and LSB
15C5: EB       [64]     	EX	DE,HL		; Leave sum in DE
15C6: E1       [74]     	POP	HL		; Restore MSB and count
15C7: 3A3B81   [87]     	LD	A,(MULVAL)	; Get MSB of multiplier
15CA: 89       [91]     	ADC	A,C		; Add MSB
15CB: 1F       [ 4]     NOMADD: RRA			; Shift MSB right
15CC: 4F       [ 8]     	LD	C,A		; Re-save MSB
15CD: 7A       [12]     	LD	A,D		; Get NMSB
15CE: 1F       [16]     	RRA			; Shift NMSB right
15CF: 57       [20]     	LD	D,A		; Re-save NMSB
15D0: 7B       [24]     	LD	A,E		; Get LSB
15D1: 1F       [28]     	RRA			; Shift LSB right
15D2: 5F       [32]     	LD	E,A		; Re-save LSB
15D3: 78       [36]     	LD	A,B		; Get VLSB
15D4: 1F       [40]     	RRA			; Shift VLSB right
15D5: 47       [44]     	LD	B,A		; Re-save VLSB
15D6: 2D       [48]     	DEC	L		; Count bits multiplied
15D7: 7C       [52]     	LD	A,H		; Get LSB of multiplier
15D8: C2BA15   [62|62]  	JP	NZ,MUL8LP	; More - Do it
15DB: E1       [10]     POPHRT: POP	HL		; Restore address of number
15DC: C9       [20]     	RET
                        ;
15DD: 43       [ 4]     BYTSFT: LD	B,E		; Shift partial product left
15DE: 5A       [ 8]     	LD	E,D
15DF: 51       [12]     	LD	D,C
15E0: 4F       [16]     	LD	C,A
15E1: C9       [26]     	RET
                        ;
15E2: CDCB16   [17]     DIV10:	CALL	STAKFP		; Save FPREG on stack
15E5: 012084   [27]     	LD	BC,8420H	; BCDE = 10.
15E8: 110000   [37]     	LD	DE,0000H
15EB: CDDB16   [54]     	CALL	FPBCDE		; Move 10 to FPREG
                        ;
15EE: C1       [10]     DIV:	POP	BC		; Get number from stack
15EF: D1       [20]     	POP	DE
15F0: CD9A16   [17]     DVBCDE: CALL	TSTSGN		; Test sign of FPREG
15F3: CAF603   [27|27]  	JP	Z,DZERR		; Error if division by zero
15F6: 2EFF     [34]     	LD	L,-1		; Flag subtract exponents
15F8: CD5816   [51]     	CALL	ADDEXP		; Subtract exponents
15FB: 34       [62]     	INC	(HL)		; Add 2 to exponent to adjust
15FC: 34       [73]     	INC	(HL)
15FD: 2B       [79]     	DEC	HL		; Point to MSB
15FE: 7E       [86]     	LD	A,(HL)		; Get MSB of dividend
15FF: 325780   [99]     	LD	(DIV3),A	; Save for subtraction
1602: 2B       [105]    	DEC	HL
1603: 7E       [112]    	LD	A,(HL)		; Get NMSB of dividend
1604: 325380   [125]    	LD	(DIV2),A	; Save for subtraction
1607: 2B       [131]    	DEC	HL
1608: 7E       [138]    	LD	A,(HL)		; Get MSB of dividend
1609: 324F80   [151]    	LD	(DIV1),A	; Save for subtraction
160C: 41       [155]    	LD	B,C		; Get MSB
160D: EB       [159]    	EX	DE,HL		; NMSB,LSB to HL
160E: AF       [163]    	XOR	A
160F: 4F       [167]    	LD	C,A		; Clear MSB of quotient
1610: 57       [171]    	LD	D,A		; Clear NMSB of quotient
1611: 5F       [175]    	LD	E,A		; Clear LSB of quotient
1612: 325A80   [188]    	LD	(DIV4),A	; Clear overflow count
1615: E5       [11]     DIVLP:	PUSH	HL		; Save divisor
1616: C5       [22]     	PUSH	BC
1617: 7D       [26]     	LD	A,L		; Get LSB of number
1618: CD4E80   [43]     	CALL	DIVSUP		; Subt' divisor from dividend
161B: DE00     [50]     	SBC	A,0		; Count for overflows
161D: 3F       [54]     	CCF
161E: D22816   [64|64]  	JP	NC,RESDIV	; Restore divisor if borrow
1621: 325A80   [77]     	LD	(DIV4),A	; Re-save overflow count
1624: F1       [87]     	POP	AF		; Scrap divisor
1625: F1       [97]     	POP	AF
1626: 37       [101]    	SCF			; Set carry to
1627: D2                	DB	0D2H		; Skip "POP BC" and "POP HL"
                        ;
1628: C1       [10]     RESDIV: POP	BC		; Restore divisor
1629: E1       [20]     	POP	HL
162A: 79       [24]     	LD	A,C		; Get MSB of quotient
162B: 3C       [28]     	INC	A
162C: 3D       [32]     	DEC	A
162D: 1F       [36]     	RRA			; Bit 0 to bit 7
162E: FADB14   [46|46]  	JP	M,RONDB		; Done - Normalise result
1631: 17       [50]     	RLA			; Restore carry
1632: 7B       [54]     	LD	A,E		; Get LSB of quotient
1633: 17       [58]     	RLA			; Double it
1634: 5F       [62]     	LD	E,A		; Put it back
1635: 7A       [66]     	LD	A,D		; Get NMSB of quotient
1636: 17       [70]     	RLA			; Double it
1637: 57       [74]     	LD	D,A		; Put it back
1638: 79       [78]     	LD	A,C		; Get MSB of quotient
1639: 17       [82]     	RLA			; Double it
163A: 4F       [86]     	LD	C,A		; Put it back
163B: 29       [97]     	ADD	HL,HL		; Double NMSB,LSB of divisor
163C: 78       [101]    	LD	A,B		; Get MSB of divisor
163D: 17       [105]    	RLA			; Double it
163E: 47       [109]    	LD	B,A		; Put it back
163F: 3A5A80   [122]    	LD	A,(DIV4)	; Get VLSB of quotient
1642: 17       [126]    	RLA			; Double it
1643: 325A80   [139]    	LD	(DIV4),A	; Put it back
1646: 79       [143]    	LD	A,C		; Get MSB of quotient
1647: B2       [147]    	OR	D		; Merge NMSB
1648: B3       [151]    	OR	E		; Merge LSB
1649: C21516   [161|161]	JP	NZ,DIVLP	; Not done - Keep dividing
164C: E5       [172]    	PUSH	HL		; Save divisor
164D: 212C81   [182]    	LD	HL,FPEXP	; Point to exponent
1650: 35       [193]    	DEC	(HL)		; Divide by 2
1651: E1       [203]    	POP	HL		; Restore divisor
1652: C21516   [213|213]	JP	NZ,DIVLP	; Ok - Keep going
1655: C30204   [223]    	JP	OVERR		; Overflow error
                        ;
1658: 78       [ 4]     ADDEXP: LD	A,B		; Get exponent of dividend
1659: B7       [ 8]     	OR	A		; Test it
165A: CA7C16   [18|18]  	JP	Z,OVTST3	; Zero - Result zero
165D: 7D       [22]     	LD	A,L		; Get add/subtract flag
165E: 212C81   [32]     	LD	HL,FPEXP	; Point to exponent
1661: AE       [39]     	XOR	(HL)		; Add or subtract it
1662: 80       [43]     	ADD	A,B		; Add the other exponent
1663: 47       [47]     	LD	B,A		; Save new exponent
1664: 1F       [51]     	RRA			; Test exponent for overflow
1665: A8       [55]     	XOR	B
1666: 78       [59]     	LD	A,B		; Get exponent
1667: F27B16   [69|69]  	JP	P,OVTST2	; Positive - Test for overflow
166A: C680     [76]     	ADD	A,80H		; Add excess 128
166C: 77       [83]     	LD	(HL),A		; Save new exponent
166D: CADB15   [93|93]  	JP	Z,POPHRT	; Zero - Result zero
1670: CD0017   [110]    	CALL	SIGNS		; Set MSBs and sign of result
1673: 77       [117]    	LD	(HL),A		; Save new exponent
1674: 2B       [123]    	DEC	HL		; Point to MSB
1675: C9       [133]    	RET
                        ;
1676: CD9A16   [17]     OVTST1: CALL	TSTSGN		; Test sign of FPREG
1679: 2F       [21]     	CPL			; Invert sign
167A: E1       [31]     	POP	HL		; Clean up stack
167B: B7       [ 4]     OVTST2: OR	A		; Test if new exponent zero
167C: E1       [10]     OVTST3: POP	HL		; Clear off return address
167D: F2BA14   [20|20]  	JP	P,RESZER	; Result zero
1680: C30204   [30]     	JP	OVERR		; Overflow error
                        ;
1683: CDE616   [17]     MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
1686: 78       [21]     	LD	A,B		; Get exponent
1687: B7       [25]     	OR	A		; Is it zero?
1688: C8       [30|36]  	RET	Z		; Yes - Result is zero
1689: C602     [37]     	ADD	A,2		; Multiply by 4
168B: DA0204   [47|47]  	JP	C,OVERR		; Overflow - ?OV Error
168E: 47       [51]     	LD	B,A		; Re-save exponent
168F: CD5414   [68]     	CALL	FPADD		; Add BCDE to FPREG (Times 5)
1692: 212C81   [78]     	LD	HL,FPEXP	; Point to exponent
1695: 34       [89]     	INC	(HL)		; Double number (Times 10)
1696: C0       [94|100] 	RET	NZ		; Ok - Return
1697: C30204   [104]    	JP	OVERR		; Overflow error
                        ;
169A: 3A2C81   [13]     TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
169D: B7       [17]     	OR	A
169E: C8       [22|28]  	RET	Z		; RETurn if number is zero
169F: 3A2B81   [35]     	LD	A,(FPREG+2)	; Get MSB of FPREG
16A2: FE                	DB	0FEH		; Test sign
16A3: 2F       [ 4]     RETREL: CPL			; Invert sign
16A4: 17       [ 8]     	RLA			; Sign bit to carry
16A5: 9F       [ 4]     FLGDIF: SBC	A,A		; Carry to all bits of A
16A6: C0       [ 9|15]  	RET	NZ		; Return -1 if negative
16A7: 3C       [13]     	INC	A		; Bump to +1
16A8: C9       [23]     	RET			; Positive - Return +1
                        ;
16A9: CD9A16   [17]     SGN:	CALL	TSTSGN		; Test sign of FPREG
16AC: 0688     [ 7]     FLGREL: LD	B,80H+8		; 8 bit integer in exponent
16AE: 110000   [17]     	LD	DE,0		; Zero NMSB and LSB
16B1: 212C81   [10]     RETINT: LD	HL,FPEXP	; Point to exponent
16B4: 4F       [14]     	LD	C,A		; CDE = MSB,NMSB and LSB
16B5: 70       [21]     	LD	(HL),B		; Save exponent
16B6: 0600     [28]     	LD	B,0		; CDE = integer to normalise
16B8: 23       [34]     	INC	HL		; Point to sign of result
16B9: 3680     [44]     	LD	(HL),80H	; Set sign of result
16BB: 17       [48]     	RLA			; Carry = sign of integer
16BC: C3A214   [58]     	JP	CONPOS		; Set sign of result
                        ;
16BF: CD9A16   [17]     ABS:	CALL	TSTSGN		; Test sign of FPREG
16C2: F0       [22|28]  	RET	P		; Return if positive
16C3: 212B81   [10]     INVSGN: LD	HL,FPREG+2	; Point to MSB
16C6: 7E       [17]     	LD	A,(HL)		; Get sign of mantissa
16C7: EE80     [24]     	XOR	80H		; Invert sign of mantissa
16C9: 77       [31]     	LD	(HL),A		; Re-save sign of mantissa
16CA: C9       [41]     	RET
                        ;
16CB: EB       [ 4]     STAKFP: EX	DE,HL		; Save code string address
16CC: 2A2981   [20]     	LD	HL,(FPREG)	; LSB,NLSB of FPREG
16CF: E3       [39]     	EX	(SP),HL		; Stack them,get return
16D0: E5       [50]     	PUSH	HL		; Re-save return
16D1: 2A2B81   [66]     	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
16D4: E3       [85]     	EX	(SP),HL		; Stack them,get return
16D5: E5       [96]     	PUSH	HL		; Re-save return
16D6: EB       [100]    	EX	DE,HL		; Restore code string address
16D7: C9       [110]    	RET
                        ;
16D8: CDE916   [17]     PHLTFP: CALL	LOADFP		; Number at HL to BCDE
16DB: EB       [ 4]     FPBCDE: EX	DE,HL		; Save code string address
16DC: 222981   [20]     	LD	(FPREG),HL	; Save LSB,NLSB of number
16DF: 60       [24]     	LD	H,B		; Exponent of number
16E0: 69       [28]     	LD	L,C		; MSB of number
16E1: 222B81   [44]     	LD	(FPREG+2),HL	; Save MSB and exponent
16E4: EB       [48]     	EX	DE,HL		; Restore code string address
16E5: C9       [58]     	RET
                        ;
16E6: 212981   [10]     BCDEFP: LD	HL,FPREG	; Point to FPREG
16E9: 5E       [ 7]     LOADFP: LD	E,(HL)		; Get LSB of number
16EA: 23       [13]     	INC	HL
16EB: 56       [20]     	LD	D,(HL)		; Get NMSB of number
16EC: 23       [26]     	INC	HL
16ED: 4E       [33]     	LD	C,(HL)		; Get MSB of number
16EE: 23       [39]     	INC	HL
16EF: 46       [46]     	LD	B,(HL)		; Get exponent of number
16F0: 23       [ 6]     INCHL:	INC	HL		; Used for conditional "INC HL"
16F1: C9       [16]     	RET
                        ;
16F2: 112981   [10]     FPTHL:	LD	DE,FPREG	; Point to FPREG
16F5: 0604     [ 7]     DETHL4: LD	B,4		; 4 bytes to move
16F7: 1A       [ 7]     DETHLB: LD	A,(DE)		; Get source
16F8: 77       [14]     	LD	(HL),A		; Save destination
16F9: 13       [20]     	INC	DE		; Next source
16FA: 23       [26]     	INC	HL		; Next destination
16FB: 05       [30]     	DEC	B		; Count bytes
16FC: C2F716   [40|40]  	JP	NZ,DETHLB	; Loop if more
16FF: C9       [50]     	RET
                        ;
1700: 212B81   [10]     SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
1703: 7E       [17]     	LD	A,(HL)		; Get MSB
1704: 07       [21]     	RLCA			; Old sign to carry
1705: 37       [25]     	SCF			; Set MSBit
1706: 1F       [29]     	RRA			; Set MSBit of MSB
1707: 77       [36]     	LD	(HL),A		; Save new MSB
1708: 3F       [40]     	CCF			; Complement sign
1709: 1F       [44]     	RRA			; Old sign to carry
170A: 23       [50]     	INC	HL
170B: 23       [56]     	INC	HL
170C: 77       [63]     	LD	(HL),A		; Set sign of result
170D: 79       [67]     	LD	A,C		; Get MSB
170E: 07       [71]     	RLCA			; Old sign to carry
170F: 37       [75]     	SCF			; Set MSBit
1710: 1F       [79]     	RRA			; Set MSBit of MSB
1711: 4F       [83]     	LD	C,A		; Save MSB
1712: 1F       [87]     	RRA
1713: AE       [94]     	XOR	(HL)		; New sign of result
1714: C9       [104]    	RET
                        ;
1715: 78       [ 4]     CMPNUM: LD	A,B		; Get exponent of number
1716: B7       [ 8]     	OR	A
1717: CA9A16   [18|18]  	JP	Z,TSTSGN	; Zero - Test sign of FPREG
171A: 21A316   [28]     	LD	HL,RETREL	; Return relation routine
171D: E5       [39]     	PUSH	HL		; Save for return
171E: CD9A16   [56]     	CALL	TSTSGN		; Test sign of FPREG
1721: 79       [60]     	LD	A,C		; Get MSB of number
1722: C8       [65|71]  	RET	Z		; FPREG zero - Number's MSB
1723: 212B81   [75]     	LD	HL,FPREG+2	; MSB of FPREG
1726: AE       [82]     	XOR	(HL)		; Combine signs
1727: 79       [86]     	LD	A,C		; Get MSB of number
1728: F8       [91|97]  	RET	M		; Exit if signs different
1729: CD2F17   [108]    	CALL	CMPFP		; Compare FP numbers
172C: 1F       [112]    	RRA			; Get carry to sign
172D: A9       [116]    	XOR	C		; Combine with MSB of number
172E: C9       [126]    	RET
                        ;
172F: 23       [ 6]     CMPFP:	INC	HL		; Point to exponent
1730: 78       [10]     	LD	A,B		; Get exponent
1731: BE       [17]     	CP	(HL)		; Compare exponents
1732: C0       [22|28]  	RET	NZ		; Different
1733: 2B       [28]     	DEC	HL		; Point to MBS
1734: 79       [32]     	LD	A,C		; Get MSB
1735: BE       [39]     	CP	(HL)		; Compare MSBs
1736: C0       [44|50]  	RET	NZ		; Different
1737: 2B       [50]     	DEC	HL		; Point to NMSB
1738: 7A       [54]     	LD	A,D		; Get NMSB
1739: BE       [61]     	CP	(HL)		; Compare NMSBs
173A: C0       [66|72]  	RET	NZ		; Different
173B: 2B       [72]     	DEC	HL		; Point to LSB
173C: 7B       [76]     	LD	A,E		; Get LSB
173D: 96       [83]     	SUB	(HL)		; Compare LSBs
173E: C0       [88|94]  	RET	NZ		; Different
173F: E1       [98]     	POP	HL		; Drop RETurn
1740: E1       [108]    	POP	HL		; Drop another RETurn
1741: C9       [118]    	RET
                        ;
1742: 47       [ 4]     FPINT:	LD	B,A		; <- Move
1743: 4F       [ 8]     	LD	C,A		; <- exponent
1744: 57       [12]     	LD	D,A		; <- to all
1745: 5F       [16]     	LD	E,A		; <- bits
1746: B7       [20]     	OR	A		; Test exponent
1747: C8       [25|31]  	RET	Z		; Zero - Return zero
1748: E5       [36]     	PUSH	HL		; Save pointer to number
1749: CDE616   [53]     	CALL	BCDEFP		; Move FPREG to BCDE
174C: CD0017   [70]     	CALL	SIGNS		; Set MSBs & sign of result
174F: AE       [77]     	XOR	(HL)		; Combine with sign of FPREG
1750: 67       [81]     	LD	H,A		; Save combined signs
1751: FC6617   [91|98]  	CALL	M,DCBCDE	; Negative - Decrement BCDE
1754: 3E98     [98]     	LD	A,80H+24	; 24 bits
1756: 90       [102]    	SUB	B		; Bits to shift
1757: CD1915   [119]    	CALL	SCALE		; Shift BCDE
175A: 7C       [123]    	LD	A,H		; Get combined sign
175B: 17       [127]    	RLA			; Sign to carry
175C: DCEC14   [137|144]	CALL	C,FPROND	; Negative - Round number up
175F: 0600     [144]    	LD	B,0		; Zero exponent
1761: DC0515   [154|161]	CALL	C,COMPL		; If negative make positive
1764: E1       [164]    	POP	HL		; Restore pointer to number
1765: C9       [174]    	RET
                        ;
1766: 1B       [ 6]     DCBCDE: DEC	DE		; Decrement BCDE
1767: 7A       [10]     	LD	A,D		; Test LSBs
1768: A3       [14]     	AND	E
1769: 3C       [18]     	INC	A
176A: C0       [23|29]  	RET	NZ		; Exit if LSBs not FFFF
176B: 0B       [29]     	DEC	BC		; Decrement MSBs
176C: C9       [39]     	RET
                        ;
176D: 212C81   [10]     INT:	LD	HL,FPEXP	; Point to exponent
1770: 7E       [17]     	LD	A,(HL)		; Get exponent
1771: FE98     [24]     	CP	80H+24		; Integer accuracy only?
1773: 3A2981   [37]     	LD	A,(FPREG)	; Get LSB
1776: D0       [42|48]  	RET	NC		; Yes - Already integer
1777: 7E       [49]     	LD	A,(HL)		; Get exponent
1778: CD4217   [66]     	CALL	FPINT		; F.P to integer
177B: 3698     [76]     	LD	(HL),80H+24	; Save 24 bit integer
177D: 7B       [80]     	LD	A,E		; Get LSB of number
177E: F5       [91]     	PUSH	AF		; Save LSB
177F: 79       [95]     	LD	A,C		; Get MSB of number
1780: 17       [99]     	RLA			; Sign to carry
1781: CDA214   [116]    	CALL	CONPOS		; Set sign of result
1784: F1       [126]    	POP	AF		; Restore LSB of number
1785: C9       [136]    	RET
                        ;
1786: 210000   [10]     MLDEBC: LD	HL,0		; Clear partial product
1789: 78       [14]     	LD	A,B		; Test multiplier
178A: B1       [18]     	OR	C
178B: C8       [23|29]  	RET	Z		; Return zero if zero
178C: 3E10     [30]     	LD	A,16		; 16 bits
178E: 29       [11]     MLDBLP: ADD	HL,HL		; Shift P.P left
178F: DAC60F   [21|21]  	JP	C,BSERR		; ?BS Error if overflow
1792: EB       [25]     	EX	DE,HL
1793: 29       [36]     	ADD	HL,HL		; Shift multiplier left
1794: EB       [40]     	EX	DE,HL
1795: D29C17   [50|50]  	JP	NC,NOMLAD	; Bit was zero - No add
1798: 09       [61]     	ADD	HL,BC		; Add multiplicand
1799: DAC60F   [71|71]  	JP	C,BSERR		; ?BS Error if overflow
179C: 3D       [ 4]     NOMLAD: DEC	A		; Count bits
179D: C28E17   [14|14]  	JP	NZ,MLDBLP	; More
17A0: C9       [24]     	RET
                        ;
17A1: FE2D     [ 7]     ASCTFP: CP	'-'		; Negative?
17A3: F5       [18]     	PUSH	AF		; Save it and flags
17A4: CAAD17   [28|28]  	JP	Z,CNVNUM	; Yes - Convert number
17A7: FE2B     [35]     	CP	'+'		; Positive?
17A9: CAAD17   [45|45]  	JP	Z,CNVNUM	; Yes - Convert number
17AC: 2B       [51]     	DEC	HL		; DEC 'cos GETCHR INCs
17AD: CDBA14   [17]     CNVNUM: CALL	RESZER		; Set result to zero
17B0: 47       [21]     	LD	B,A		; Digits after point counter
17B1: 57       [25]     	LD	D,A		; Sign of exponent
17B2: 5F       [29]     	LD	E,A		; Exponent of ten
17B3: 2F       [33]     	CPL
17B4: 4F       [37]     	LD	C,A		; Before or after point flag
17B5: CD4B08   [17]     MANLP:	CALL	GETCHR		; Get next character
17B8: DAFE17   [27|27]  	JP	C,ADDIG		; Digit - Add to number
17BB: FE2E     [34]     	CP	'.'
17BD: CAD917   [44|44]  	JP	Z,DPOINT	; '.' - Flag point
17C0: FE45     [51]     	CP	'E'
17C2: C2DD17   [61|61]  	JP	NZ,CONEXP	; Not 'E' - Scale number
17C5: CD4B08   [78]     	CALL	GETCHR		; Get next character
17C8: CDF10D   [95]     	CALL	SGNEXP		; Get sign of exponent
17CB: CD4B08   [17]     EXPLP:	CALL	GETCHR		; Get next character
17CE: DA2018   [27|27]  	JP	C,EDIGIT	; Digit - Add to exponent
17D1: 14       [31]     	INC	D		; Is sign negative?
17D2: C2DD17   [41|41]  	JP	NZ,CONEXP	; No - Scale number
17D5: AF       [45]     	XOR	A
17D6: 93       [49]     	SUB	E		; Negate exponent
17D7: 5F       [53]     	LD	E,A		; And re-save it
17D8: 0C       [57]     	INC	C		; Flag end of number
17D9: 0C       [ 4]     DPOINT: INC	C		; Flag point passed
17DA: CAB517   [14|14]  	JP	Z,MANLP		; Zero - Get another digit
17DD: E5       [11]     CONEXP: PUSH	HL		; Save code string address
17DE: 7B       [15]     	LD	A,E		; Get exponent
17DF: 90       [19]     	SUB	B		; Subtract digits after point
17E0: F4F617   [10|17]  SCALMI: CALL	P,SCALPL	; Positive - Multiply number
17E3: F2EC17   [20|20]  	JP	P,ENDCON	; Positive - All done
17E6: F5       [31]     	PUSH	AF		; Save number of times to /10
17E7: CDE215   [48]     	CALL	DIV10		; Divide by 10
17EA: F1       [58]     	POP	AF		; Restore count
17EB: 3C       [62]     	INC	A		; Count divides
                        ;
17EC: C2E017   [10|10]  ENDCON: JP	NZ,SCALMI	; More to do
17EF: D1       [20]     	POP	DE		; Restore code string address
17F0: F1       [30]     	POP	AF		; Restore sign of number
17F1: CCC316   [40|47]  	CALL	Z,INVSGN	; Negative - Negate number
17F4: EB       [44]     	EX	DE,HL		; Code string address to HL
17F5: C9       [54]     	RET
                        ;
17F6: C8       [ 5|11]  SCALPL: RET	Z		; Exit if no scaling needed
17F7: F5       [11]     MULTEN: PUSH	AF		; Save count
17F8: CD8316   [28]     	CALL	MLSP10		; Multiply number by 10
17FB: F1       [38]     	POP	AF		; Restore count
17FC: 3D       [42]     	DEC	A		; Count multiplies
17FD: C9       [52]     	RET
                        ;
17FE: D5       [11]     ADDIG:	PUSH	DE		; Save sign of exponent
17FF: 57       [15]     	LD	D,A		; Save digit
1800: 78       [19]     	LD	A,B		; Get digits after point
1801: 89       [23]     	ADC	A,C		; Add one if after point
1802: 47       [27]     	LD	B,A		; Re-save counter
1803: C5       [38]     	PUSH	BC		; Save point flags
1804: E5       [49]     	PUSH	HL		; Save code string address
1805: D5       [60]     	PUSH	DE		; Save digit
1806: CD8316   [77]     	CALL	MLSP10		; Multiply number by 10
1809: F1       [87]     	POP	AF		; Restore digit
180A: D630     [94]     	SUB	'0'		; Make it absolute
180C: CD1518   [111]    	CALL	RSCALE		; Re-scale number
180F: E1       [121]    	POP	HL		; Restore code string address
1810: C1       [131]    	POP	BC		; Restore point flags
1811: D1       [141]    	POP	DE		; Restore sign of exponent
1812: C3B517   [151]    	JP	MANLP		; Get another digit
                        ;
1815: CDCB16   [17]     RSCALE: CALL	STAKFP		; Put number on stack
1818: CDAC16   [34]     	CALL	FLGREL		; Digit to add to FPREG
181B: C1       [10]     PADD:	POP	BC		; Restore number
181C: D1       [20]     	POP	DE
181D: C35414   [30]     	JP	FPADD		; Add BCDE to FPREG and return
                        ;
1820: 7B       [ 4]     EDIGIT: LD	A,E		; Get digit
1821: 07       [ 8]     	RLCA			; Times 2
1822: 07       [12]     	RLCA			; Times 4
1823: 83       [16]     	ADD	A,E		; Times 5
1824: 07       [20]     	RLCA			; Times 10
1825: 86       [27]     	ADD	A,(HL)		; Add next digit
1826: D630     [34]     	SUB	'0'		; Make it absolute
1828: 5F       [38]     	LD	E,A		; Save new digit
1829: C3CB17   [48]     	JP	EXPLP		; Look for another digit
                        ;
182C: E5       [11]     LINEIN: PUSH	HL		; Save code string address
182D: 218B03   [21]     	LD	HL,INMSG	; Output " in "
1830: CD9111   [38]     	CALL	PRS		; Output string at HL
1833: E1       [48]     	POP	HL		; Restore code string address
1834: EB       [ 4]     PRNTHL: EX	DE,HL		; Code string address to DE
1835: AF       [ 8]     	XOR	A
1836: 0698     [15]     	LD	B,80H+24	; 24 bits
1838: CDB116   [32]     	CALL	RETINT		; Return the integer
183B: 219011   [42]     	LD	HL,PRNUMS	; Print number string
183E: E5       [53]     	PUSH	HL		; Save for return
183F: 212E81   [10]     NUMASC: LD	HL,PBUFF	; Convert number to ASCII
1842: E5       [21]     	PUSH	HL		; Save for return
1843: CD9A16   [38]     	CALL	TSTSGN		; Test sign of FPREG
1846: 3620     [48]     	LD	(HL),' '	; Space at start
1848: F24D18   [58|58]  	JP	P,SPCFST	; Positive - Space to start
184B: 362D     [68]     	LD	(HL),'-'	; '-' sign at start
184D: 23       [ 6]     SPCFST: INC	HL		; First byte of number
184E: 3630     [16]     	LD	(HL),'0'	; '0' if zero
1850: CA0319   [26|26]  	JP	Z,JSTZER	; Return '0' if zero
1853: E5       [37]     	PUSH	HL		; Save buffer address
1854: FCC316   [47|54]  	CALL	M,INVSGN	; Negate FPREG if negative
1857: AF       [51]     	XOR	A		; Zero A
1858: F5       [62]     	PUSH	AF		; Save it
1859: CD0919   [79]     	CALL	RNGTST		; Test number is in range
185C: 014391   [10]     SIXDIG: LD	BC,9143H	; BCDE - 99999.9
185F: 11F84F   [20]     	LD	DE,4FF8H
1862: CD1517   [37]     	CALL	CMPNUM		; Compare numbers
1865: B7       [41]     	OR	A
1866: E27A18   [51|51]  	JP	PO,INRNG	; > 99999.9 - Sort it out
1869: F1       [61]     	POP	AF		; Restore count
186A: CDF717   [78]     	CALL	MULTEN		; Multiply by ten
186D: F5       [89]     	PUSH	AF		; Re-save count
186E: C35C18   [99]     	JP	SIXDIG		; Test it again
                        ;
1871: CDE215   [17]     GTSIXD: CALL	DIV10		; Divide by 10
1874: F1       [27]     	POP	AF		; Get count
1875: 3C       [31]     	INC	A		; Count divides
1876: F5       [42]     	PUSH	AF		; Re-save count
1877: CD0919   [59]     	CALL	RNGTST		; Test number is in range
187A: CD4214   [17]     INRNG:	CALL	ROUND		; Add 0.5 to FPREG
187D: 3C       [21]     	INC	A
187E: CD4217   [38]     	CALL	FPINT		; F.P to integer
1881: CDDB16   [55]     	CALL	FPBCDE		; Move BCDE to FPREG
1884: 010603   [65]     	LD	BC,0306H	; 1E+06 to 1E-03 range
1887: F1       [75]     	POP	AF		; Restore count
1888: 81       [79]     	ADD	A,C		; 6 digits before point
1889: 3C       [83]     	INC	A		; Add one
188A: FA9618   [93|93]  	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
188D: FE08     [100]    	CP	6+1+1		; More than 999999 ?
188F: D29618   [110|110]	JP	NC,MAKNUM	; Yes - Do it in 'E' form
1892: 3C       [114]    	INC	A		; Adjust for exponent
1893: 47       [118]    	LD	B,A		; Exponent of number
1894: 3E02     [125]    	LD	A,2		; Make it zero after
                        ;
1896: 3D       [ 4]     MAKNUM: DEC	A		; Adjust for digits to do
1897: 3D       [ 8]     	DEC	A
1898: E1       [18]     	POP	HL		; Restore buffer address
1899: F5       [29]     	PUSH	AF		; Save count
189A: 111C19   [39]     	LD	DE,POWERS	; Powers of ten
189D: 05       [43]     	DEC	B		; Count digits before point
189E: C2A718   [53|53]  	JP	NZ,DIGTXT	; Not zero - Do number
18A1: 362E     [63]     	LD	(HL),'.'	; Save point
18A3: 23       [69]     	INC	HL		; Move on
18A4: 3630     [79]     	LD	(HL),'0'	; Save zero
18A6: 23       [85]     	INC	HL		; Move on
18A7: 05       [ 4]     DIGTXT: DEC	B		; Count digits before point
18A8: 362E     [14]     	LD	(HL),'.'	; Save point in case
18AA: CCF016   [24|31]  	CALL	Z,INCHL		; Last digit - move on
18AD: C5       [35]     	PUSH	BC		; Save digits before point
18AE: E5       [46]     	PUSH	HL		; Save buffer address
18AF: D5       [57]     	PUSH	DE		; Save powers of ten
18B0: CDE616   [74]     	CALL	BCDEFP		; Move FPREG to BCDE
18B3: E1       [84]     	POP	HL		; Powers of ten table
18B4: 062F     [91]     	LD	B, '0'-1	; ASCII '0' - 1
18B6: 04       [ 4]     TRYAGN: INC	B		; Count subtractions
18B7: 7B       [ 8]     	LD	A,E		; Get LSB
18B8: 96       [15]     	SUB	(HL)		; Subtract LSB
18B9: 5F       [19]     	LD	E,A		; Save LSB
18BA: 23       [25]     	INC	HL
18BB: 7A       [29]     	LD	A,D		; Get NMSB
18BC: 9E       [36]     	SBC	A,(HL)		; Subtract NMSB
18BD: 57       [40]     	LD	D,A		; Save NMSB
18BE: 23       [46]     	INC	HL
18BF: 79       [50]     	LD	A,C		; Get MSB
18C0: 9E       [57]     	SBC	A,(HL)		; Subtract MSB
18C1: 4F       [61]     	LD	C,A		; Save MSB
18C2: 2B       [67]     	DEC	HL		; Point back to start
18C3: 2B       [73]     	DEC	HL
18C4: D2B618   [83|83]  	JP	NC,TRYAGN	; No overflow - Try again
18C7: CDF914   [100]    	CALL	PLUCDE		; Restore number
18CA: 23       [106]    	INC	HL		; Start of next number
18CB: CDDB16   [123]    	CALL	FPBCDE		; Move BCDE to FPREG
18CE: EB       [127]    	EX	DE,HL		; Save point in table
18CF: E1       [137]    	POP	HL		; Restore buffer address
18D0: 70       [144]    	LD	(HL),B		; Save digit in buffer
18D1: 23       [150]    	INC	HL		; And move on
18D2: C1       [160]    	POP	BC		; Restore digit count
18D3: 0D       [164]    	DEC	C		; Count digits
18D4: C2A718   [174|174]	JP	NZ,DIGTXT	; More - Do them
18D7: 05       [178]    	DEC	B		; Any decimal part?
18D8: CAE718   [188|188]	JP	Z,DOEBIT	; No - Do 'E' bit
18DB: 2B       [ 6]     SUPTLZ: DEC	HL		; Move back through buffer
18DC: 7E       [13]     	LD	A,(HL)		; Get character
18DD: FE30     [20]     	CP	'0'		; '0' character?
18DF: CADB18   [30|30]  	JP	Z,SUPTLZ	; Yes - Look back for more
18E2: FE2E     [37]     	CP	'.'		; A decimal point?
18E4: C4F016   [47|54]  	CALL	NZ,INCHL	; Move back over digit
                        ;
18E7: F1       [10]     DOEBIT: POP	AF		; Get 'E' flag
18E8: CA0619   [20|20]  	JP	Z,NOENED	; No 'E' needed - End buffer
18EB: 3645     [30]     	LD	(HL),'E'	; Put 'E' in buffer
18ED: 23       [36]     	INC	HL		; And move on
18EE: 362B     [46]     	LD	(HL),'+'	; Put '+' in buffer
18F0: F2F718   [56|56]  	JP	P,OUTEXP	; Positive - Output exponent
18F3: 362D     [66]     	LD	(HL),'-'	; Put '-' in buffer
18F5: 2F       [70]     	CPL			; Negate exponent
18F6: 3C       [74]     	INC	A
18F7: 062F     [ 7]     OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
18F9: 04       [ 4]     EXPTEN: INC	B		; Count subtractions
18FA: D60A     [11]     	SUB	10		; Tens digit
18FC: D2F918   [21|21]  	JP	NC,EXPTEN	; More to do
18FF: C63A     [28]     	ADD	A,'0'+10	; Restore and make ASCII
1901: 23       [34]     	INC	HL		; Move on
1902: 70       [41]     	LD	(HL),B		; Save MSB of exponent
1903: 23       [ 6]     JSTZER: INC	HL		;
1904: 77       [13]     	LD	(HL),A		; Save LSB of exponent
1905: 23       [19]     	INC	HL
1906: 71       [ 7]     NOENED: LD	(HL),C		; Mark end of buffer
1907: E1       [17]     	POP	HL		; Restore code string address
1908: C9       [27]     	RET
                        ;
1909: 017494   [10]     RNGTST: LD	BC,9474H	; BCDE = 999999.
190C: 11F723   [20]     	LD	DE,23F7H
190F: CD1517   [37]     	CALL	CMPNUM		; Compare numbers
1912: B7       [41]     	OR	A
1913: E1       [51]     	POP	HL		; Return address to HL
1914: E27118   [61|61]  	JP	PO,GTSIXD	; Too big - Divide by ten
1917: E9       [65]     	JP	(HL)		; Otherwise return to caller
                        ;
1918: 00000080          HALF:	DB	00H,00H,00H,80H	; 0.5
                        ;
191C: A08601            POWERS: DB	0A0H,086H,001H	; 100000
191F: 102700            	DB	010H,027H,000H	; 10000
1922: E80300            	DB	0E8H,003H,000H	; 1000
1925: 640000            	DB	064H,000H,000H	; 100
1928: 0A0000            	DB	00AH,000H,000H	; 10
192B: 010000            	DB	001H,000H,000H	; 1
                        ;
192E: 21C316   [10]     NEGAFT: LD	HL,INVSGN	; Negate result
1931: E3       [29]     	EX	(SP),HL		; To be done after caller
1932: E9       [33]     	JP	(HL)		; Return to caller
                        ;
1933: CDCB16   [17]     SQR:	CALL	STAKFP		; Put value on stack
1936: 211819   [27]     	LD	HL,HALF		; Set power to 1/2
1939: CDD816   [44]     	CALL	PHLTFP		; Move 1/2 to FPREG
                        ;
193C: C1       [10]     POWER:	POP	BC		; Get base
193D: D1       [20]     	POP	DE
193E: CD9A16   [37]     	CALL	TSTSGN		; Test sign of power
1941: 78       [41]     	LD	A,B		; Get exponent of base
1942: CA8119   [51|51]  	JP	Z,EXP		; Make result 1 if zero
1945: F24C19   [61|61]  	JP	P,POWER1	; Positive base - Ok
1948: B7       [65]     	OR	A		; Zero to negative power?
1949: CAF603   [75|75]  	JP	Z,DZERR		; Yes - ?/0 Error
194C: B7       [ 4]     POWER1: OR	A		; Base zero?
194D: CABB14   [14|14]  	JP	Z,SAVEXP	; Yes - Return zero
1950: D5       [25]     	PUSH	DE		; Save base
1951: C5       [36]     	PUSH	BC
1952: 79       [40]     	LD	A,C		; Get MSB of base
1953: F67F     [47]     	OR	01111111B	; Get sign status
1955: CDE616   [64]     	CALL	BCDEFP		; Move power to BCDE
1958: F26919   [74|74]  	JP	P,POWER2	; Positive base - Ok
195B: D5       [85]     	PUSH	DE		; Save power
195C: C5       [96]     	PUSH	BC
195D: CD6D17   [113]    	CALL	INT		; Get integer of power
1960: C1       [123]    	POP	BC		; Restore power
1961: D1       [133]    	POP	DE
1962: F5       [144]    	PUSH	AF		; MSB of base
1963: CD1517   [161]    	CALL	CMPNUM		; Power an integer?
1966: E1       [171]    	POP	HL		; Restore MSB of base
1967: 7C       [175]    	LD	A,H		; but don't affect flags
1968: 1F       [179]    	RRA			; Exponent odd or even?
1969: E1       [10]     POWER2: POP	HL		; Restore MSB and exponent
196A: 222B81   [26]     	LD	(FPREG+2),HL	; Save base in FPREG
196D: E1       [36]     	POP	HL		; LSBs of base
196E: 222981   [52]     	LD	(FPREG),HL	; Save in FPREG
1971: DC2E19   [62|69]  	CALL	C,NEGAFT	; Odd power - Negate result
1974: CCC316   [72|79]  	CALL	Z,INVSGN	; Negative base - Negate it
1977: D5       [83]     	PUSH	DE		; Save power
1978: C5       [94]     	PUSH	BC
1979: CD4E15   [111]    	CALL	LOG		; Get LOG of base
197C: C1       [121]    	POP	BC		; Restore power
197D: D1       [131]    	POP	DE
197E: CD8F15   [148]    	CALL	FPMULT		; Multiply LOG by power
                        ;
1981: CDCB16   [17]     EXP:	CALL	STAKFP		; Put value on stack
1984: 013881   [27]     	LD	BC,08138H	; BCDE = 1/Ln(2)
1987: 113BAA   [37]     	LD	DE,0AA3BH
198A: CD8F15   [54]     	CALL	FPMULT		; Multiply value by 1/LN(2)
198D: 3A2C81   [67]     	LD	A,(FPEXP)	; Get exponent
1990: FE88     [74]     	CP	80H+8		; Is it in range?
1992: D27616   [84|84]  	JP	NC,OVTST1	; No - Test for overflow
1995: CD6D17   [101]    	CALL	INT		; Get INT of FPREG
1998: C680     [108]    	ADD	A,80H		; For excess 128
199A: C602     [115]    	ADD	A,2		; Exponent > 126?
199C: DA7616   [125|125]	JP	C,OVTST1	; Yes - Test for overflow
199F: F5       [136]    	PUSH	AF		; Save scaling factor
19A0: 213D15   [146]    	LD	HL,UNITY	; Point to 1.
19A3: CD4514   [163]    	CALL	ADDPHL		; Add 1 to FPREG
19A6: CD8615   [180]    	CALL	MULLN2		; Multiply by LN(2)
19A9: F1       [190]    	POP	AF		; Restore scaling factor
19AA: C1       [200]    	POP	BC		; Restore exponent
19AB: D1       [210]    	POP	DE
19AC: F5       [221]    	PUSH	AF		; Save scaling factor
19AD: CD5114   [238]    	CALL	SUBCDE		; Subtract exponent from FPREG
19B0: CDC316   [255]    	CALL	INVSGN		; Negate result
19B3: 21C119   [265]    	LD	HL,EXPTAB	; Coefficient table
19B6: CDF119   [282]    	CALL	SMSER1		; Sum the series
19B9: 110000   [292]    	LD	DE,0		; Zero LSBs
19BC: C1       [302]    	POP	BC		; Scaling factor
19BD: 4A       [306]    	LD	C,D		; Zero MSB
19BE: C38F15   [316]    	JP	FPMULT		; Scale result to correct value
                        ;
19C1: 08                EXPTAB: DB	8			; Table used by EXP
19C2: 402E9474          	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
19C6: 704F2E77          	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
19CA: 6E02887A          	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
19CE: E6A02A7C          	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
19D2: 50AAAA7E          	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
19D6: FFFF7F7F          	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
19DA: 00008081          	DB	000H,000H,080H,081H	; -1/1! (-1/1)
19DE: 00000081          	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
                        ;
19E2: CDCB16   [17]     SUMSER: CALL	STAKFP		; Put FPREG on stack
19E5: 118D15   [27]     	LD	DE,MULT		; Multiply by "X"
19E8: D5       [38]     	PUSH	DE		; To be done after
19E9: E5       [49]     	PUSH	HL		; Save address of table
19EA: CDE616   [66]     	CALL	BCDEFP		; Move FPREG to BCDE
19ED: CD8F15   [83]     	CALL	FPMULT		; Square the value
19F0: E1       [93]     	POP	HL		; Restore address of table
19F1: CDCB16   [17]     SMSER1: CALL	STAKFP		; Put value on stack
19F4: 7E       [24]     	LD	A,(HL)		; Get number of coefficients
19F5: 23       [30]     	INC	HL		; Point to start of table
19F6: CDD816   [47]     	CALL	PHLTFP		; Move coefficient to FPREG
19F9: 06                	DB	06H		; Skip "POP AF"
19FA: F1       [10]     SUMLP:	POP	AF		; Restore count
19FB: C1       [20]     	POP	BC		; Restore number
19FC: D1       [30]     	POP	DE
19FD: 3D       [34]     	DEC	A		; Cont coefficients
19FE: C8       [39|45]  	RET	Z		; All done
19FF: D5       [50]     	PUSH	DE		; Save number
1A00: C5       [61]     	PUSH	BC
1A01: F5       [72]     	PUSH	AF		; Save count
1A02: E5       [83]     	PUSH	HL		; Save address in table
1A03: CD8F15   [100]    	CALL	FPMULT		; Multiply FPREG by BCDE
1A06: E1       [110]    	POP	HL		; Restore address in table
1A07: CDE916   [127]    	CALL	LOADFP		; Number at HL to BCDE
1A0A: E5       [138]    	PUSH	HL		; Save address in table
1A0B: CD5414   [155]    	CALL	FPADD		; Add coefficient to FPREG
1A0E: E1       [165]    	POP	HL		; Restore address in table
1A0F: C3FA19   [175]    	JP	SUMLP		; More coefficients
                        ;
1A12: CD9A16   [17]     RND:	CALL	TSTSGN		; Test sign of FPREG
1A15: 215E80   [27]     	LD	HL,SEED+2	; Random number seed
1A18: FA731A   [37|37]  	JP	M,RESEED	; Negative - Re-seed
1A1B: 217F80   [47]     	LD	HL,LSTRND	; Last random number
1A1E: CDD816   [64]     	CALL	PHLTFP		; Move last RND to FPREG
1A21: 215E80   [74]     	LD	HL,SEED+2	; Random number seed
1A24: C8       [79|85]  	RET	Z		; Return if RND(0)
1A25: 86       [86]     	ADD	A,(HL)		; Add (SEED)+2)
1A26: E607     [93]     	AND	00000111B	; 0 to 7
1A28: 0600     [100]    	LD	B,0
1A2A: 77       [107]    	LD	(HL),A		; Re-save seed
1A2B: 23       [113]    	INC	HL		; Move to coefficient table
1A2C: 87       [117]    	ADD	A,A		; 4 bytes
1A2D: 87       [121]    	ADD	A,A		; per entry
1A2E: 4F       [125]    	LD	C,A		; BC = Offset into table
1A2F: 09       [136]    	ADD	HL,BC		; Point to coefficient
1A30: CDE916   [153]    	CALL	LOADFP		; Coefficient to BCDE
1A33: CD8F15   [170]    	CALL	FPMULT	;	; Multiply FPREG by coefficient
1A36: 3A5D80   [183]    	LD	A,(SEED+1)	; Get (SEED+1)
1A39: 3C       [187]    	INC	A		; Add 1
1A3A: E603     [194]    	AND	00000011B	; 0 to 3
1A3C: 0600     [201]    	LD	B,0
1A3E: FE01     [208]    	CP	1		; Is it zero?
1A40: 88       [212]    	ADC	A,B		; Yes - Make it 1
1A41: 325D80   [225]    	LD	(SEED+1),A	; Re-save seed
1A44: 21771A   [235]    	LD	HL,RNDTAB-4	; Addition table
1A47: 87       [239]    	ADD	A,A		; 4 bytes
1A48: 87       [243]    	ADD	A,A		; per entry
1A49: 4F       [247]    	LD	C,A		; BC = Offset into table
1A4A: 09       [258]    	ADD	HL,BC		; Point to value
1A4B: CD4514   [275]    	CALL	ADDPHL		; Add value to FPREG
1A4E: CDE616   [17]     RND1:	CALL	BCDEFP		; Move FPREG to BCDE
1A51: 7B       [21]     	LD	A,E		; Get LSB
1A52: 59       [25]     	LD	E,C		; LSB = MSB
1A53: EE4F     [32]     	XOR	01001111B	; Fiddle around
1A55: 4F       [36]     	LD	C,A		; New MSB
1A56: 3680     [46]     	LD	(HL),80H	; Set exponent
1A58: 2B       [52]     	DEC	HL		; Point to MSB
1A59: 46       [59]     	LD	B,(HL)		; Get MSB
1A5A: 3680     [69]     	LD	(HL),80H	; Make value -0.5
1A5C: 215C80   [79]     	LD	HL,SEED		; Random number seed
1A5F: 34       [90]     	INC	(HL)		; Count seed
1A60: 7E       [97]     	LD	A,(HL)		; Get seed
1A61: D6AB     [104]    	SUB	171		; Do it modulo 171
1A63: C26A1A   [114|114]	JP	NZ,RND2		; Non-zero - Ok
1A66: 77       [121]    	LD	(HL),A		; Zero seed
1A67: 0C       [125]    	INC	C		; Fillde about
1A68: 15       [129]    	DEC	D		; with the
1A69: 1C       [133]    	INC	E		; number
1A6A: CDA514   [17]     RND2:	CALL	BNORM		; Normalise number
1A6D: 217F80   [27]     	LD	HL,LSTRND	; Save random number
1A70: C3F216   [37]     	JP	FPTHL		; Move FPREG to last and return
                        ;
1A73: 77       [ 7]     RESEED: LD	(HL),A		; Re-seed random numbers
1A74: 2B       [13]     	DEC	HL
1A75: 77       [20]     	LD	(HL),A
1A76: 2B       [26]     	DEC	HL
1A77: 77       [33]     	LD	(HL),A
1A78: C34E1A   [43]     	JP	RND1		; Return RND seed
                        ;
1A7B: 68B14668          RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
1A7F: 99E99269          	DB	099H,0E9H,092H,069H
1A83: 10D17568          	DB	010H,0D1H,075H,068H
                        ;
1A87: 21D11A   [10]     COS:	LD	HL,HALFPI	; Point to PI/2
1A8A: CD4514   [27]     	CALL	ADDPHL		; Add it to PPREG
1A8D: CDCB16   [17]     SIN:	CALL	STAKFP		; Put angle on stack
1A90: 014983   [27]     	LD	BC,8349H	; BCDE = 2 PI
1A93: 11DB0F   [37]     	LD	DE,0FDBH
1A96: CDDB16   [54]     	CALL	FPBCDE		; Move 2 PI to FPREG
1A99: C1       [64]     	POP	BC		; Restore angle
1A9A: D1       [74]     	POP	DE
1A9B: CDF015   [91]     	CALL	DVBCDE		; Divide angle by 2 PI
1A9E: CDCB16   [108]    	CALL	STAKFP		; Put it on stack
1AA1: CD6D17   [125]    	CALL	INT		; Get INT of result
1AA4: C1       [135]    	POP	BC		; Restore number
1AA5: D1       [145]    	POP	DE
1AA6: CD5114   [162]    	CALL	SUBCDE		; Make it 0 <= value < 1
1AA9: 21D51A   [172]    	LD	HL,QUARTR	; Point to 0.25
1AAC: CD4B14   [189]    	CALL	SUBPHL		; Subtract value from 0.25
1AAF: CD9A16   [206]    	CALL	TSTSGN		; Test sign of value
1AB2: 37       [210]    	SCF			; Flag positive
1AB3: F2BD1A   [220|220]	JP	P,SIN1		; Positive - Ok
1AB6: CD4214   [237]    	CALL	ROUND		; Add 0.5 to value
1AB9: CD9A16   [254]    	CALL	TSTSGN		; Test sign of value
1ABC: B7       [258]    	OR	A		; Flag negative
1ABD: F5       [11]     SIN1:	PUSH	AF		; Save sign
1ABE: F4C316   [21|28]  	CALL	P,INVSGN	; Negate value if positive
1AC1: 21D51A   [31]     	LD	HL,QUARTR	; Point to 0.25
1AC4: CD4514   [48]     	CALL	ADDPHL		; Add 0.25 to value
1AC7: F1       [58]     	POP	AF		; Restore sign
1AC8: D4C316   [68|75]  	CALL	NC,INVSGN	; Negative - Make positive
1ACB: 21D91A   [78]     	LD	HL,SINTAB	; Coefficient table
1ACE: C3E219   [88]     	JP	SUMSER		; Evaluate sum of series
                        ;
1AD1: DB0F4981          HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
                        ;
1AD5: 0000007F          QUARTR: DB	000H,000H,000H,07FH	; 0.25
                        ;
1AD9: 05                SINTAB: DB	5			; Table used by SIN
1ADA: BAD71E86          	DB	0BAH,0D7H,01EH,086H	; 39.711
1ADE: 64269987          	DB	064H,026H,099H,087H	;-76.575
1AE2: 58342387          	DB	058H,034H,023H,087H	; 81.602
1AE6: E05DA586          	DB	0E0H,05DH,0A5H,086H	;-41.342
1AEA: DA0F4983          	DB	0DAH,00FH,049H,083H	; 6.2832
                        ;
1AEE: CDCB16   [17]     TAN:	CALL	STAKFP		; Put angle on stack
1AF1: CD8D1A   [34]     	CALL	SIN		; Get SIN of angle
1AF4: C1       [44]     	POP	BC		; Restore angle
1AF5: E1       [54]     	POP	HL
1AF6: CDCB16   [71]     	CALL	STAKFP		; Save SIN of angle
1AF9: EB       [75]     	EX	DE,HL		; BCDE = Angle
1AFA: CDDB16   [92]     	CALL	FPBCDE		; Angle to FPREG
1AFD: CD871A   [109]    	CALL	COS		; Get COS of angle
1B00: C3EE15   [119]    	JP	DIV		; TAN = SIN / COS
                        ;
1B03: CD9A16   [17]     ATN:	CALL	TSTSGN		; Test sign of value
1B06: FC2E19   [27|34]  	CALL	M,NEGAFT	; Negate result after if -ve
1B09: FCC316   [37|44]  	CALL	M,INVSGN	; Negate value if -ve
1B0C: 3A2C81   [50]     	LD	A,(FPEXP)	; Get exponent
1B0F: FE81     [57]     	CP	81H		; Number less than 1?
1B11: DA201B   [67|67]  	JP	C,ATN1		; Yes - Get arc tangnt
1B14: 010081   [77]     	LD	BC,8100H	; BCDE = 1
1B17: 51       [81]     	LD	D,C
1B18: 59       [85]     	LD	E,C
1B19: CDF015   [102]    	CALL	DVBCDE		; Get reciprocal of number
1B1C: 214B14   [112]    	LD	HL,SUBPHL	; Sub angle from PI/2
1B1F: E5       [123]    	PUSH	HL		; Save for angle > 1
1B20: 212A1B   [10]     ATN1:	LD	HL,ATNTAB	; Coefficient table
1B23: CDE219   [27]     	CALL	SUMSER		; Evaluate sum of series
1B26: 21D11A   [37]     	LD	HL,HALFPI	; PI/2 - angle in case > 1
1B29: C9       [47]     	RET			; Number > 1 - Sub from PI/2
                        ;
1B2A: 09                ATNTAB: DB	9			; Table used by ATN
1B2B: 4AD73B78          	DB	04AH,0D7H,03BH,078H	; 1/17
1B2F: 026E847B          	DB	002H,06EH,084H,07BH	;-1/15
1B33: FEC12F7C          	DB	0FEH,0C1H,02FH,07CH	; 1/13
1B37: 74319A7D          	DB	074H,031H,09AH,07DH	;-1/11
1B3B: 843D5A7D          	DB	084H,03DH,05AH,07DH	; 1/9
1B3F: C87F917E          	DB	0C8H,07FH,091H,07EH	;-1/7
1B43: E4BB4C7E          	DB	0E4H,0BBH,04CH,07EH	; 1/5
1B47: 6CAAAA7F          	DB	06CH,0AAH,0AAH,07FH	;-1/3
1B4B: 00000081          	DB	000H,000H,000H,081H	; 1/1
                        ;
                        
1B4F: C9       [10]     ARET:	RET			; A RETurn instruction
                        ;
1B50: D7       [11]     GETINP: RST	10H		;input a character
1B51: C9       [21]     	RET
                        ;
1B52:                   CLS: 
1B52: 3E0C     [ 7]     	LD	A,CS		; ASCII Clear screen
1B54: C3881C   [17]     	JP	MONOUT		; Output character
                        ;
1B57: CD1914   [17]     WIDTH:	CALL	GETINT		; Get integer 0-255
1B5A: 7B       [21]     	LD	A,E		; Width to A
1B5B: 328780   [34]     	LD	(LWIDTH),A	; Set width
1B5E: C9       [44]     	RET
                        ;
1B5F: CDB80C   [17]     LINES:	CALL	GETNUM		; Get a number
1B62: CDFD08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B65: ED538B80 [54]     	LD	(LINESC),DE	; Set lines counter
1B69: ED538D80 [74]     	LD	(LINESN),DE	; Set lines number
1B6D: C9       [84]     	RET
                        ;
1B6E: CDFD08   [17]     DEEK:	CALL	DEINT		; Get integer -32768 to 32767
1B71: D5       [28]     	PUSH	DE		; Save number
1B72: E1       [38]     	POP	HL		; Number to HL
1B73: 46       [45]     	LD	B,(HL)		; Get LSB of contents
1B74: 23       [51]     	INC	HL
1B75: 7E       [58]     	LD	A,(HL)		; Get MSB of contents
1B76: C37310   [68]     	JP	ABPASS		; Return integer AB
                        ;
1B79: CDB80C   [17]     DOKE:	CALL	GETNUM		; Get a number
1B7C: CDFD08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B7F: D5       [45]     	PUSH	DE		; Save address
1B80: CDC106   [62]     	CALL	CHKSYN		; Make sure ',' follows
1B83: 2C                	DB	','
1B84: CDB80C   [79]     	CALL	GETNUM		; Get a number
1B87: CDFD08   [96]     	CALL	DEINT		; Get integer -32768 to 32767
1B8A: E3       [115]    	EX	(SP),HL		; Save value,get address
1B8B: 73       [122]    	LD	(HL),E		; Save LSB of value
1B8C: 23       [128]    	INC	HL
1B8D: 72       [135]    	LD	(HL),D		; Save MSB of value
1B8E: E1       [145]    	POP	HL		; Restore code string address
1B8F: C9       [155]    	RET
                        ;
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        ;
1B90: CDBB0C   [17]     HEX: 	CALL	TSTNUM		; Verify it's a number
1B93: CDFD08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B96: C5       [45]     	PUSH	BC		; Save contents of BC
1B97: 212E81   [55]     	LD	HL,PBUFF
1B9A: 7A       [59]     	LD	A,D		; Get high order into A
1B9B: FE00     [66]     	CP	0
1B9D: 280C     [73|78]  	JR	Z,HEX2		; Skip output if both high digits are zero
1B9F: CDC81B   [90]     	CALL	BYT2ASC		; Convert D to ASCII
1BA2: 78       [94]     	LD	A,B
1BA3: FE30     [101]    	CP	'0'
1BA5: 2802     [108|113]	JR	Z,HEX1		; Don't store high digit if zero
1BA7: 70       [115]    	LD	(HL),B		; Store it to PBUFF
1BA8: 23       [121]    	INC	HL		; Next location
1BA9: 71       [ 7]     HEX1:	LD	(HL),C		; Store C to PBUFF+1
1BAA: 23       [13]     	INC	HL		; Next location
1BAB: 7B       [ 4]     HEX2:	LD	A,E		; Get lower byte
1BAC: CDC81B   [21]     	CALL	BYT2ASC		; Convert E to ASCII
1BAF: 7A       [25]     	LD	A,D
1BB0: FE00     [32]     	CP	0
1BB2: 2005     [39|44]  	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
1BB4: 78       [43]     	LD	A,B
1BB5: FE30     [50]     	CP	'0'		; If high digit of lower byte is zero then don't print
1BB7: 2802     [57|62]  	JR	Z,HEX4
1BB9: 70       [ 7]     HEX3:	LD	(HL),B		; to PBUFF+2
1BBA: 23       [13]     	INC	HL		; Next location
1BBB: 71       [ 7]     HEX4:	LD	(HL),C		; to PBUFF+3
1BBC: 23       [13]     	INC	HL		; PBUFF+4 to zero
1BBD: AF       [17]     	XOR	A		; Terminating character
1BBE: 77       [24]     	LD	(HL),A		; Store zero to terminate
1BBF: 23       [30]     	INC	HL		; Make sure PBUFF is terminated
1BC0: 77       [37]     	LD	(HL),A		; Store the double zero there
1BC1: C1       [47]     	POP	BC		; Get BC back
1BC2: 212E81   [57]     	LD	HL,PBUFF	; Reset to start of PBUFF
1BC5: C32111   [67]     	JP	STR1		; Convert the PBUFF to a string and return it
                        ;
1BC8: 47       [ 4]     BYT2ASC	LD	B,A		; Save original value
1BC9: E60F     [11]     	AND	0FH		; Strip off upper nybble
1BCB: FE0A     [18]     	CP	0AH		; 0-9?
1BCD: 3802     [25|30]  	JR	C,ADD30		; If A-F, add 7 more
1BCF: C607     [32]     	ADD	A,07H		; Bring value up to ASCII A-F
1BD1: C630     [ 7]     ADD30	ADD	A,30H		; And make ASCII
1BD3: 4F       [11]     	LD	C,A		; Save converted char to C
1BD4: 78       [15]     	LD	A,B		; Retrieve original value
1BD5: 0F       [19]     	RRCA			; and Rotate it right
1BD6: 0F       [23]     	RRCA
1BD7: 0F       [27]     	RRCA
1BD8: 0F       [31]     	RRCA
1BD9: E60F     [38]     	AND	0FH		; Mask off upper nybble
1BDB: FE0A     [45]     	CP	0AH		; 0-9? < A hex?
1BDD: 3802     [52|57]  	JR	C,ADD301	; Skip Add 7
1BDF: C607     [59]     	ADD	A,07H		; Bring it up to ASCII A-F
1BE1: C630     [ 7]     ADD301	ADD	A,30H		; And make it full ASCII
1BE3: 47       [11]     	LD	B,A		; Store high order byte
1BE4: C9       [21]     	RET	
                        ;
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
1BE5: EB       [ 4]     HEXTFP	EX	DE,HL		; Move code string pointer to DE
1BE6: 210000   [14]     	LD	HL,0000H	; Zero out the value
1BE9: CDFE1B   [31]     	CALL	GETHEX		; Check the number for valid hex
1BEC: DA1E1C   [41|41]  	JP	C,HXERR		; First value wasn't hex, HX error
1BEF: 1805     [53]     	JR	HEXLP1		; Convert first character
1BF1: CDFE1B   [17]     HEXLP	CALL	GETHEX		; Get second and addtional characters
1BF4: 381F     [24|29]  	JR	C,HEXIT		; Exit if not a hex character
1BF6: 29       [11]     HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
1BF7: 29       [22]     	ADD	HL,HL
1BF8: 29       [33]     	ADD	HL,HL
1BF9: 29       [44]     	ADD	HL,HL
1BFA: B5       [48]     	OR	L		; Add in D0-D3 into L
1BFB: 6F       [52]     	LD	L,A		; Save new value
1BFC: 18F3     [64]     	JR	HEXLP		; And continue until all hex characters are in
                        ;
1BFE: 13       [ 6]     GETHEX	INC	DE		; Next location
1BFF: 1A       [13]     	LD	A,(DE)		; Load character at pointer
1C00: FE20     [20]     	CP	' '
1C02: CAFE1B   [30|30]  	JP	Z,GETHEX	; Skip spaces
1C05: D630     [37]     	SUB	30H		; Get absolute value
1C07: D8       [42|48]  	RET	C		; < "0", error
1C08: FE0A     [49]     	CP	0AH
1C0A: 3805     [56|61]  	JR	C,NOSUB7	; Is already in the range 0-9
1C0C: D607     [63]     	SUB	07H		; Reduce to A-F
1C0E: FE0A     [70]     	CP	0AH		; Value should be $0A-$0F at this point
1C10: D8       [75|81]  	RET	C		; CY set if was :		; < = > ? @
1C11: FE10     [ 7]     NOSUB7	CP	10H		; > Greater than "F"?
1C13: 3F       [11]     	CCF
1C14: C9       [21]     	RET			; CY set if it wasn't valid hex
                        	
1C15: EB       [ 4]     HEXIT	EX	DE,HL		; Value into DE, Code string into HL
1C16: 7A       [ 8]     	LD	A,D		; Load DE into AC
1C17: 4B       [12]     	LD	C,E		; For prep to 
1C18: E5       [23]     	PUSH	HL
1C19: CD7210   [40]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C1C: E1       [50]     	POP	HL
1C1D: C9       [60]     	RET
                        ;
1C1E: 1E26     [ 7]     HXERR:	LD	E,HX		; ?HEX Error
1C20: C30704   [17]     	JP	ERROR
                        ;
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1C23: CDBB0C   [17]     BIN:	CALL	TSTNUM		; Verify it's a number
1C26: CDFD08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1C29: C5       [11]     BIN2:	PUSH	BC		; Save contents of BC
1C2A: 212E81   [21]     	LD	HL,PBUFF
1C2D: 0611     [28]     	LD	B,17		; One higher than max char count
1C2F:                   ZEROSUP:			; Suppress leading zeros
1C2F: 05       [ 4]     	DEC	B		; Max 16 chars
1C30: 78       [ 8]     	LD	A,B
1C31: FE01     [15]     	CP	01H
1C33: 2808     [22|27]  	JR	Z,BITOUT	; Always output at least one character
1C35: CB13     [30]     	RL	E
1C37: CB12     [38]     	RL	D
1C39: 30F4     [45|50]  	JR	NC,ZEROSUP
1C3B: 1804     [57]     	JR	BITOUT2
1C3D:                   BITOUT:	
1C3D: CB13     [ 8]     	RL	E
1C3F: CB12     [16]     	RL	D		; Top bit now in carry
1C41:                   BITOUT2:
1C41: 3E30     [ 7]     	LD	A,'0'		; Char for '0'
1C43: CE00     [14]     	ADC	A,0		; If carry set then '0' --> '1'
1C45: 77       [21]     	LD	(HL),A
1C46: 23       [27]     	INC	HL
1C47: 05       [31]     	DEC	B
1C48: 20F3     [38|43]  	JR	NZ,BITOUT
1C4A: AF       [42]     	XOR	A		; Terminating character
1C4B: 77       [49]     	LD	(HL),A		; Store zero to terminate
1C4C: 23       [55]     	INC	HL		; Make sure PBUFF is terminated
1C4D: 77       [62]     	LD	(HL),A		; Store the double zero there
1C4E: C1       [72]     	POP	BC
1C4F: 212E81   [82]     	LD	HL,PBUFF
1C52: C32111   [92]     	JP	STR1
                        ;
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1C55: EB       [ 4]     BINTFP: EX	DE,HL		; Move code string pointer to DE
1C56: 210000   [14]     	LD	HL,0000H	; Zero out the value
1C59: CD721C   [31]     	CALL	CHKBIN		; Check the number for valid bin
1C5C: DA801C   [41|41]  	JP	C,BINERR	; First value wasn't bin, HX error
1C5F: D630     [ 7]     BINIT:	SUB	'0'
1C61: 29       [18]     	ADD	HL,HL		; Rotate HL left
1C62: B5       [22]     	OR	L
1C63: 6F       [26]     	LD	L,A
1C64: CD721C   [43]     	CALL	CHKBIN		; Get second and addtional characters
1C67: 30F6     [50|55]  	JR	NC,BINIT	; Process if a bin character
1C69: EB       [54]     	EX	DE,HL		; Value into DE, Code string into HL
1C6A: 7A       [58]     	LD	A,D		; Load DE into AC
1C6B: 4B       [62]     	LD	C,E		; For prep to 
1C6C: E5       [73]     	PUSH	HL
1C6D: CD7210   [90]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C70: E1       [100]    	POP	HL
1C71: C9       [110]    	RET
                        ;
                        ; Char is in A, NC if char is 0 or 1
1C72: 13       [ 6]     CHKBIN: INC	DE
1C73: 1A       [13]     	LD	A,(DE)
1C74: FE20     [20]     	CP	' '
1C76: CA721C   [30|30]  	JP	Z,CHKBIN	; Skip spaces
1C79: FE30     [37]     	CP	'0'		; Set C if < '0'
1C7B: D8       [42|48]  	RET	C
1C7C: FE32     [49]     	CP	'2'
1C7E: 3F       [53]     	CCF			; Set C if > '1'
1C7F: C9       [63]     	RET
                        ;
1C80: 1E28     [ 7]     BINERR: LD	E,BN		; ?BIN Error
1C82: C30704   [17]     	JP	ERROR
                        ;
1C85: C34C00   [10]     JJUMP1: JP	CSTART		; Go and initialise
                        ;
1C88: C30800   [10]     MONOUT: JP	0008H		; output a char
                        ;
1C8B: C30000   [10]     MONITR: JP	0000H		; Restart (Normally Monitor Start)
                        ;
1C8E: 3E00     [ 7]     INITST: LD	A,0		; Clear break flag
1C90: 329280   [20]     	LD	(BRKFLG),A
1C93: C35300   [30]     	JP	INIT
                        ;
1C96: F5       [11]     TSTBIT: PUSH	AF		; Save bit mask
1C97: A0       [15]     	AND	B		; Get common bits
1C98: C1       [25]     	POP	BC		; Restore bit mask
1C99: B8       [29]     	CP	B		; Same bit set?
1C9A: 3E00     [36]     	LD	A,0		; Return 0 in A
1C9C: C9       [46]     	RET
                        ;
1C9D: CDCC06   [17]     OUTNCR: CALL	OUTC		; Output character in A
1CA0: C3F30A   [27]     	JP	PRCRLF		; Output CRLF
                        ;
                        	END


; +++ segments +++

#CODE          = $0000 =     0,  size = $1CA3 =  7331

; +++ global symbols +++

ABPASS  = $1073 =  4211          EMUZ80BASIC.ASM:2472
ABS     = $16BF =  5823          EMUZ80BASIC.ASM:3495
ACCSUM  = $08DC =  2268          EMUZ80BASIC.ASM:1374 (unused)
ACPASS  = $1072 =  4210          EMUZ80BASIC.ASM:2471
ADD30   = $1BD1 =  7121          EMUZ80BASIC.ASM:4243
ADD301  = $1BE1 =  7137          EMUZ80BASIC.ASM:4254
ADDEXP  = $1658 =  5720          EMUZ80BASIC.ASM:3430
ADDIG   = $17FE =  6142          EMUZ80BASIC.ASM:3718
ADDPHL  = $1445 =  5189          EMUZ80BASIC.ASM:3077
ALLFOL  = $1341 =  4929          EMUZ80BASIC.ASM:2919
ANTVLU  = $0BDC =  3036          EMUZ80BASIC.ASM:1781
ARET    = $1B4F =  6991          EMUZ80BASIC.ASM:4158 (unused)
ARLDSV  = $0F93 =  3987          EMUZ80BASIC.ASM:2327
ARREND  = $811F = 33055          EMUZ80BASIC.ASM:171
ARRLP   = $120C =  4620          EMUZ80BASIC.ASM:2710
ASC     = $1312 =  4882          EMUZ80BASIC.ASM:2889
ASCTFP  = $17A1 =  6049          EMUZ80BASIC.ASM:3664
ASPCS   = $0B3E =  2878          EMUZ80BASIC.ASM:1704
ATN     = $1B03 =  6915          EMUZ80BASIC.ASM:4129
ATN1    = $1B20 =  6944          EMUZ80BASIC.ASM:4141
ATNTAB  = $1B2A =  6954          EMUZ80BASIC.ASM:4146
ATOH    = $0917 =  2327          EMUZ80BASIC.ASM:1407
BADINP  = $0B63 =  2915          EMUZ80BASIC.ASM:1716
BAKSTK  = $039C =   924          EMUZ80BASIC.ASM:582
BAKTMP  = $12F2 =  4850          EMUZ80BASIC.ASM:2867
BASTXT  = $80A3 = 32931          EMUZ80BASIC.ASM:147
BCDEFP  = $16E6 =  5862          EMUZ80BASIC.ASM:3522
BFREE   = $00CC =   204          EMUZ80BASIC.ASM:280
BIN     = $1C23 =  7203          EMUZ80BASIC.ASM:4303
BIN2    = $1C29 =  7209          EMUZ80BASIC.ASM:4305 (unused)
BINERR  = $1C80 =  7296          EMUZ80BASIC.ASM:4366
BINIT   = $1C5F =  7263          EMUZ80BASIC.ASM:4341
BINTFP  = $1C55 =  7253          EMUZ80BASIC.ASM:4337
BITOUT  = $1C3D =  7229          EMUZ80BASIC.ASM:4317
BITOUT2 = $1C41 =  7233          EMUZ80BASIC.ASM:4320
BKSP    = $0008 =     8          EMUZ80BASIC.ASM:104
BN      = $0028 =    40          EMUZ80BASIC.ASM:205
BNORM   = $14A5 =  5285          EMUZ80BASIC.ASM:3136
BNRMLP  = $14A8 =  5288          EMUZ80BASIC.ASM:3139
BRK     = $088E =  2190          EMUZ80BASIC.ASM:1329
BRKFLG  = $8092 = 32914          EMUZ80BASIC.ASM:140
BRKLIN  = $8113 = 33043          EMUZ80BASIC.ASM:165
BRKMSG  = $0396 =   918          EMUZ80BASIC.ASM:580
BRKRET  = $00BD =   189          EMUZ80BASIC.ASM:273
BS      = $0010 =    16          EMUZ80BASIC.ASM:193
BSERR   = $0FC6 =  4038          EMUZ80BASIC.ASM:2358
BUFFER  = $80A6 = 32934          EMUZ80BASIC.ASM:148
BYT2ASC = $1BC8 =  7112          EMUZ80BASIC.ASM:4238
BYTSFT  = $15DD =  5597          EMUZ80BASIC.ASM:3347
CFEVAL  = $0F29 =  3881          EMUZ80BASIC.ASM:2258
CHARTY  = $0ED7 =  3799          EMUZ80BASIC.ASM:2214
CHEKFN  = $110A =  4362          EMUZ80BASIC.ASM:2563
CHKBIN  = $1C72 =  7282          EMUZ80BASIC.ASM:4356
CHKLTR  = $08E9 =  2281          EMUZ80BASIC.ASM:1383
CHKSTK  = $03D0 =   976          EMUZ80BASIC.ASM:619
CHKSUM  = $808F = 32911          EMUZ80BASIC.ASM:138
CHKSYN  = $06C1 =  1729          EMUZ80BASIC.ASM:1053
CHKTYP  = $0CBD =  3261          EMUZ80BASIC.ASM:1896
CHR     = $1323 =  4899          EMUZ80BASIC.ASM:2901
CLEAR   = $093C =  2364          EMUZ80BASIC.ASM:1431
CLOTST  = $06F6 =  1782          EMUZ80BASIC.ASM:1085
CLREG   = $0525 =  1317          EMUZ80BASIC.ASM:825
CLRPTR  = $0500 =  1280          EMUZ80BASIC.ASM:805
CLS     = $1B52 =  6994          EMUZ80BASIC.ASM:4163
CMPFP   = $172F =  5935          EMUZ80BASIC.ASM:3580
CMPLG1  = $0E3D =  3645          EMUZ80BASIC.ASM:2120
CMPLOG  = $0E3B =  3643          EMUZ80BASIC.ASM:2119
CMPNUM  = $1715 =  5909          EMUZ80BASIC.ASM:3563
CMPRES  = $0E7F =  3711          EMUZ80BASIC.ASM:2168
CMPSTR  = $0E67 =  3687          EMUZ80BASIC.ASM:2148
CN      = $0020 =    32          EMUZ80BASIC.ASM:201
CNVNUM  = $17AD =  6061          EMUZ80BASIC.ASM:3670
COLD    = $003F =    63          EMUZ80BASIC.ASM:207
COMMAN  = $8088 = 32904          EMUZ80BASIC.ASM:133
COMPL   = $1505 =  5381          EMUZ80BASIC.ASM:3210
CONCAT  = $1287 =  4743          EMUZ80BASIC.ASM:2800
CONEXP  = $17DD =  6109          EMUZ80BASIC.ASM:3694
CONIO   = $0001 =     1          EMUZ80BASIC.ASM:20
CONPOS  = $14A2 =  5282          EMUZ80BASIC.ASM:3134
CONST   = $0000 =     0          EMUZ80BASIC.ASM:19
CONT    = $08C1 =  2241          EMUZ80BASIC.ASM:1357
CONTAD  = $8119 = 33049          EMUZ80BASIC.ASM:168
CONVAR  = $0DA8 =  3496          EMUZ80BASIC.ASM:2020
COPY    = $005B =    91          EMUZ80BASIC.ASM:221
COS     = $1A87 =  6791          EMUZ80BASIC.ASM:4077
COUNT   = $0766 =  1894          EMUZ80BASIC.ASM:1151
CPDEHL  = $06BB =  1723          EMUZ80BASIC.ASM:1046
CPYLIT  = $05F7 =  1527          EMUZ80BASIC.ASM:943
CR      = $000D =    13          EMUZ80BASIC.ASM:107
CRARLP  = $0FE6 =  4070          EMUZ80BASIC.ASM:2378
CREARY  = $0FCB =  4043          EMUZ80BASIC.ASM:2361
CRESTR  = $0A3B =  2619          EMUZ80BASIC.ASM:1570
CRNCLP  = $0558 =  1368          EMUZ80BASIC.ASM:851
CRTMST  = $1143 =  4419          EMUZ80BASIC.ASM:2596
CRTST   = $114F =  4431          EMUZ80BASIC.ASM:2607
CRTSTE  = $1165 =  4453          EMUZ80BASIC.ASM:2621
CRUNCH  = $054F =  1359          EMUZ80BASIC.ASM:847
CS      = $000C =    12          EMUZ80BASIC.ASM:106
CSTART  = $004C =    76          EMUZ80BASIC.ASM:214
CTLOFG  = $808A = 32906          EMUZ80BASIC.ASM:135
CTRLC   = $0003 =     3          EMUZ80BASIC.ASM:102
CTRLG   = $0007 =     7          EMUZ80BASIC.ASM:103
CTRLO   = $000F =    15          EMUZ80BASIC.ASM:108
CTRLQ   = $0011 =    17          EMUZ80BASIC.ASM:109
CTRLR   = $0012 =    18          EMUZ80BASIC.ASM:110
CTRLS   = $0013 =    19          EMUZ80BASIC.ASM:111
CTRLU   = $0015 =    21          EMUZ80BASIC.ASM:112
CUROPR  = $810A = 33034          EMUZ80BASIC.ASM:159
CURPOS  = $80F0 = 33008          EMUZ80BASIC.ASM:150
DATA    = $09E2 =  2530          EMUZ80BASIC.ASM:1522
DATFLG  = $80F3 = 33011          EMUZ80BASIC.ASM:153
DATLIN  = $810E = 33038          EMUZ80BASIC.ASM:161
DATSNR  = $03ED =  1005          EMUZ80BASIC.ASM:639
DCBCDE  = $1766 =  5990          EMUZ80BASIC.ASM:3623
DDERR   = $03FC =  1020          EMUZ80BASIC.ASM:647
DEEK    = $1B6E =  7022          EMUZ80BASIC.ASM:4178
DEF     = $1087 =  4231          EMUZ80BASIC.ASM:2484
DEFSIZ  = $0FEE =  4078          EMUZ80BASIC.ASM:2382
DEINT   = $08FD =  2301          EMUZ80BASIC.ASM:1394
DEL     = $007F =   127          EMUZ80BASIC.ASM:114
DELCHR  = $0627 =  1575          EMUZ80BASIC.ASM:973
DEPINT  = $08F7 =  2295          EMUZ80BASIC.ASM:1392
DETHL4  = $16F5 =  5877          EMUZ80BASIC.ASM:3534
DETHLB  = $16F7 =  5879          EMUZ80BASIC.ASM:3535
DIGTXT  = $18A7 =  6311          EMUZ80BASIC.ASM:3816
DIM     = $0EA9 =  3753          EMUZ80BASIC.ASM:2194
DIMRET  = $0EA0 =  3744          EMUZ80BASIC.ASM:2189
DINPOS  = $06F0 =  1776          EMUZ80BASIC.ASM:1080
DIV     = $15EE =  5614          EMUZ80BASIC.ASM:3358
DIV1    = $804F = 32847          EMUZ80BASIC.ASM:123
DIV10   = $15E2 =  5602          EMUZ80BASIC.ASM:3353
DIV2    = $8053 = 32851          EMUZ80BASIC.ASM:124
DIV3    = $8057 = 32855          EMUZ80BASIC.ASM:125
DIV4    = $805A = 32858          EMUZ80BASIC.ASM:126
DIVLP   = $1615 =  5653          EMUZ80BASIC.ASM:3382
DIVSUP  = $804E = 32846          EMUZ80BASIC.ASM:122
DOAGN   = $053E =  1342          EMUZ80BASIC.ASM:838
DOCOM   = $0B0F =  2831          EMUZ80BASIC.ASM:1680
DODEL   = $0607 =  1543          EMUZ80BASIC.ASM:957
DOEBIT  = $18E7 =  6375          EMUZ80BASIC.ASM:3859
DOFN    = $10B4 =  4276          EMUZ80BASIC.ASM:2512
DOKE    = $1B79 =  7033          EMUZ80BASIC.ASM:4186
DONULL  = $0AFD =  2813          EMUZ80BASIC.ASM:1669
DOSPC   = $0B39 =  2873          EMUZ80BASIC.ASM:1701
DOTAB   = $0B26 =  2854          EMUZ80BASIC.ASM:1691
DPOINT  = $17D9 =  6105          EMUZ80BASIC.ASM:3692
DTSTR   = $1153 =  4435          EMUZ80BASIC.ASM:2610
DVBCDE  = $15F0 =  5616          EMUZ80BASIC.ASM:3360
DZ      = $0014 =    20          EMUZ80BASIC.ASM:195
DZERR   = $03F6 =  1014          EMUZ80BASIC.ASM:643
ECHDEL  = $061B =  1563          EMUZ80BASIC.ASM:966
EDIGIT  = $1820 =  6176          EMUZ80BASIC.ASM:3741
ENDBUF  = $05FE =  1534          EMUZ80BASIC.ASM:949
ENDCON  = $17EC =  6124          EMUZ80BASIC.ASM:3704
ENDDIM  = $104D =  4173          EMUZ80BASIC.ASM:2451
ENDINP  = $0AEE =  2798          EMUZ80BASIC.ASM:1663
ENDNAM  = $0ECB =  3787          EMUZ80BASIC.ASM:2210
ENDPRG  = $089D =  2205          EMUZ80BASIC.ASM:1340
ENFMEM  = $03D9 =   985          EMUZ80BASIC.ASM:625
ERRIN   = $0427 =  1063          EMUZ80BASIC.ASM:668
ERRLIN  = $8117 = 33047          EMUZ80BASIC.ASM:167
ERRMSG  = $0384 =   900          EMUZ80BASIC.ASM:576
ERROR   = $0407 =  1031          EMUZ80BASIC.ASM:655
ERRORS  = $02FA =   762          EMUZ80BASIC.ASM:505
ESC     = $001B =    27          EMUZ80BASIC.ASM:113
EVAL    = $0CCA =  3274          EMUZ80BASIC.ASM:1904
EVAL1   = $0CCD =  3277          EMUZ80BASIC.ASM:1906
EVAL2   = $0CD6 =  3286          EMUZ80BASIC.ASM:1910
EVAL3   = $0CD9 =  3289          EMUZ80BASIC.ASM:1911
EVLPAR  = $0D8F =  3471          EMUZ80BASIC.ASM:2006
EVNOT   = $0E89 =  3721          EMUZ80BASIC.ASM:2176
EXCUTE  = $082B =  2091          EMUZ80BASIC.ASM:1262
EXP     = $1981 =  6529          EMUZ80BASIC.ASM:3946
EXPLP   = $17CB =  6091          EMUZ80BASIC.ASM:3684
EXPTAB  = $19C1 =  6593          EMUZ80BASIC.ASM:3974
EXPTEN  = $18F9 =  6393          EMUZ80BASIC.ASM:3869
EXTIG   = $0C38 =  3128          EMUZ80BASIC.ASM:1829
FANDT   = $0C62 =  3170          EMUZ80BASIC.ASM:1847
FC      = $0008 =     8          EMUZ80BASIC.ASM:189
FCERR   = $0912 =  2322          EMUZ80BASIC.ASM:1404
FDTLP   = $0C49 =  3145          EMUZ80BASIC.ASM:1831
FINDEL  = $1029 =  4137          EMUZ80BASIC.ASM:2423
FLGDIF  = $16A5 =  5797          EMUZ80BASIC.ASM:3478
FLGREL  = $16AC =  5804          EMUZ80BASIC.ASM:3484
FNARG   = $8125 = 33061          EMUZ80BASIC.ASM:174
FNCTAB  = $0144 =   324          EMUZ80BASIC.ASM:291
FNDARY  = $0F99 =  3993          EMUZ80BASIC.ASM:2331
FNDELP  = $102E =  4142          EMUZ80BASIC.ASM:2428
FNDEND  = $04D3 =  1235          EMUZ80BASIC.ASM:768
FNDNUM  = $1416 =  5142          EMUZ80BASIC.ASM:3051
FNDTOK  = $0745 =  1861          EMUZ80BASIC.ASM:1131
FNDVAR  = $0F10 =  3856          EMUZ80BASIC.ASM:2242
FNDWRD  = $0582 =  1410          EMUZ80BASIC.ASM:871
FNOFST  = $0DB9 =  3513          EMUZ80BASIC.ASM:2030
FNRGNM  = $8123 = 33059          EMUZ80BASIC.ASM:173
FNTHR   = $0F1E =  3870          EMUZ80BASIC.ASM:2250
FNVAL   = $0DE0 =  3552          EMUZ80BASIC.ASM:2052
FOPRND  = $0D02 =  3330          EMUZ80BASIC.ASM:1932
FOR     = $0792 =  1938          EMUZ80BASIC.ASM:1173
FORFLG  = $8110 = 33040          EMUZ80BASIC.ASM:162
FORFND  = $07C2 =  1986          EMUZ80BASIC.ASM:1201
FORSLP  = $07A6 =  1958          EMUZ80BASIC.ASM:1182
FPADD   = $1454 =  5204          EMUZ80BASIC.ASM:3085
FPBCDE  = $16DB =  5851          EMUZ80BASIC.ASM:3514
FPEXP   = $812C = 33068          EMUZ80BASIC.ASM:176
FPINT   = $1742 =  5954          EMUZ80BASIC.ASM:3600
FPMULT  = $158F =  5519          EMUZ80BASIC.ASM:3296
FPREG   = $8129 = 33065          EMUZ80BASIC.ASM:175
FPROND  = $14EC =  5356          EMUZ80BASIC.ASM:3186
FPSINT  = $08F1 =  2289          EMUZ80BASIC.ASM:1390
FPTHL   = $16F2 =  5874          EMUZ80BASIC.ASM:3533
FRE     = $1051 =  4177          EMUZ80BASIC.ASM:2454
FRENUM  = $106D =  4205          EMUZ80BASIC.ASM:2466
FRMEVL  = $0DAB =  3499          EMUZ80BASIC.ASM:2021
GARBGE  = $11D4 =  4564          EMUZ80BASIC.ASM:2683
GARBLP  = $11D7 =  4567          EMUZ80BASIC.ASM:2684
GETCHR  = $084B =  2123          EMUZ80BASIC.ASM:1282
GETCMD  = $044B =  1099          EMUZ80BASIC.ASM:685
GETHEX  = $1BFE =  7166          EMUZ80BASIC.ASM:4276
GETINP  = $1B50 =  6992          EMUZ80BASIC.ASM:4160
GETINT  = $1419 =  5145          EMUZ80BASIC.ASM:3052
GETLEN  = $1307 =  4871          EMUZ80BASIC.ASM:2881
GETLIN  = $0638 =  1592          EMUZ80BASIC.ASM:981
GETLN   = $0918 =  2328          EMUZ80BASIC.ASM:1408
GETNUM  = $0CB8 =  3256          EMUZ80BASIC.ASM:1893
GETNXT  = $059D =  1437          EMUZ80BASIC.ASM:886
GETSTR  = $12D1 =  4817          EMUZ80BASIC.ASM:2847
GETVAR  = $0EAE =  3758          EMUZ80BASIC.ASM:2197
GNXARY  = $120B =  4619          EMUZ80BASIC.ASM:2709
GOFUNC  = $0DE8 =  3560          EMUZ80BASIC.ASM:2056
GOSUB   = $098E =  2446          EMUZ80BASIC.ASM:1473
GOTO    = $099F =  2463          EMUZ80BASIC.ASM:1485
GRBARY  = $122B =  4651          EMUZ80BASIC.ASM:2728
GRBDON  = $11AC =  4524          EMUZ80BASIC.ASM:2658
GRBLP   = $11E5 =  4581          EMUZ80BASIC.ASM:2690
GSTRCU  = $12D4 =  4820          EMUZ80BASIC.ASM:2848
GSTRDE  = $12D8 =  4824          EMUZ80BASIC.ASM:2850
GSTRHL  = $12D7 =  4823          EMUZ80BASIC.ASM:2849
GTFLNM  = $1316 =  4886          EMUZ80BASIC.ASM:2891 (unused)
GTFNAM  = $0EB3 =  3763          EMUZ80BASIC.ASM:2200
GTLNLP  = $091B =  2331          EMUZ80BASIC.ASM:1409
GTSIXD  = $1871 =  6257          EMUZ80BASIC.ASM:3785
GTVLUS  = $0BB4 =  2996          EMUZ80BASIC.ASM:1759
HALF    = $1918 =  6424          EMUZ80BASIC.ASM:3890
HALFPI  = $1AD1 =  6865          EMUZ80BASIC.ASM:4108
HEX     = $1B90 =  7056          EMUZ80BASIC.ASM:4203
HEX1    = $1BA9 =  7081          EMUZ80BASIC.ASM:4216
HEX2    = $1BAB =  7083          EMUZ80BASIC.ASM:4218
HEX3    = $1BB9 =  7097          EMUZ80BASIC.ASM:4226
HEX4    = $1BBB =  7099          EMUZ80BASIC.ASM:4228
HEXIT   = $1C15 =  7189          EMUZ80BASIC.ASM:4291
HEXLP   = $1BF1 =  7153          EMUZ80BASIC.ASM:4266
HEXLP1  = $1BF6 =  7158          EMUZ80BASIC.ASM:4268
HEXTFP  = $1BE5 =  7141          EMUZ80BASIC.ASM:4261
HX      = $0026 =    38          EMUZ80BASIC.ASM:204
HXERR   = $1C1E =  7198          EMUZ80BASIC.ASM:4299
ID      = $0016 =    22          EMUZ80BASIC.ASM:196
IDTEST  = $10FC =  4348          EMUZ80BASIC.ASM:2553
IF      = $0A71 =  2673          EMUZ80BASIC.ASM:1603
IFGO    = $0A7F =  2687          EMUZ80BASIC.ASM:1610
IFJMP   = $0832 =  2098          EMUZ80BASIC.ASM:1265
INCHL   = $16F0 =  5872          EMUZ80BASIC.ASM:3530
INCLEN  = $06EC =  1772          EMUZ80BASIC.ASM:1078
INDFND  = $03B6 =   950          EMUZ80BASIC.ASM:601
INEWLN  = $049B =  1179          EMUZ80BASIC.ASM:728
INIT    = $0053 =    83          EMUZ80BASIC.ASM:218
INITAB  = $0324 =   804          EMUZ80BASIC.ASM:529
INITBE  = $0384 =   900          EMUZ80BASIC.ASM:572
INITST  = $1C8E =  7310          EMUZ80BASIC.ASM:4375
INMSG   = $038B =   907          EMUZ80BASIC.ASM:577
INP     = $13D6 =  5078          EMUZ80BASIC.ASM:3020
INPBIN  = $0C06 =  3078          EMUZ80BASIC.ASM:1803
INPBRK  = $089A =  2202          EMUZ80BASIC.ASM:1338
INPORT  = $8084 = 32900          EMUZ80BASIC.ASM:130
INPSUB  = $8083 = 32899          EMUZ80BASIC.ASM:129
INPUT   = $0B74 =  2932          EMUZ80BASIC.ASM:1724
INRNG   = $187A =  6266          EMUZ80BASIC.ASM:3790
INT     = $176D =  5997          EMUZ80BASIC.ASM:3631
INTVAR  = $050F =  1295          EMUZ80BASIC.ASM:816
INVSGN  = $16C3 =  5827          EMUZ80BASIC.ASM:3497
ITMSEP  = $0BF7 =  3063          EMUZ80BASIC.ASM:1794
JJUMP1  = $1C85 =  7301          EMUZ80BASIC.ASM:4369 (unused)
JSTZER  = $1903 =  6403          EMUZ80BASIC.ASM:3875
KBHIT   = $002C =    44          EMUZ80BASIC.ASM:56
KILFOR  = $0CA8 =  3240          EMUZ80BASIC.ASM:1884
KILIN   = $0632 =  1586          EMUZ80BASIC.ASM:978
LCRFLG  = $80F1 = 33009          EMUZ80BASIC.ASM:151
LEFT    = $1333 =  4915          EMUZ80BASIC.ASM:2909
LEN     = $1303 =  4867          EMUZ80BASIC.ASM:2879
LET     = $09F9 =  2553          EMUZ80BASIC.ASM:1538
LETNUM  = $0A4C =  2636          EMUZ80BASIC.ASM:1580
LETSTR  = $0A14 =  2580          EMUZ80BASIC.ASM:1551
LF      = $000A =    10          EMUZ80BASIC.ASM:105
LFRGNM  = $13CC =  5068          EMUZ80BASIC.ASM:3011
LINEAT  = $80A1 = 32929          EMUZ80BASIC.ASM:146
LINEIN  = $182C =  6188          EMUZ80BASIC.ASM:3751
LINES   = $1B5F =  7007          EMUZ80BASIC.ASM:4172
LINESC  = $808B = 32907          EMUZ80BASIC.ASM:136
LINESN  = $808D = 32909          EMUZ80BASIC.ASM:137
LINFND  = $0484 =  1156          EMUZ80BASIC.ASM:714
LIST    = $0707 =  1799          EMUZ80BASIC.ASM:1095
LISTLP  = $0713 =  1811          EMUZ80BASIC.ASM:1101
LOADFP  = $16E9 =  5865          EMUZ80BASIC.ASM:3523
LOG     = $154E =  5454          EMUZ80BASIC.ASM:3264
LOGTAB  = $1541 =  5441          EMUZ80BASIC.ASM:3259
LOKFOR  = $03A0 =   928          EMUZ80BASIC.ASM:584
LOOPST  = $810C = 33036          EMUZ80BASIC.ASM:160
LS      = $001C =    28          EMUZ80BASIC.ASM:199
LSTBIN  = $8111 = 33041          EMUZ80BASIC.ASM:163
LSTLP2  = $0733 =  1843          EMUZ80BASIC.ASM:1122
LSTLP3  = $0736 =  1846          EMUZ80BASIC.ASM:1123
LSTRAM  = $80F4 = 33012          EMUZ80BASIC.ASM:154
LSTRND  = $807F = 32895          EMUZ80BASIC.ASM:128
LTSTND  = $0C11 =  3089          EMUZ80BASIC.ASM:1808
LWIDTH  = $8087 = 32903          EMUZ80BASIC.ASM:132
MAKINT  = $141C =  5148          EMUZ80BASIC.ASM:3053
MAKNUM  = $1896 =  6294          EMUZ80BASIC.ASM:3805
MANLP   = $17B5 =  6069          EMUZ80BASIC.ASM:3676
MATCH   = $05CF =  1487          EMUZ80BASIC.ASM:918
MEMMSG  = $0112 =   274          EMUZ80BASIC.ASM:286
MID     = $136D =  4973          EMUZ80BASIC.ASM:2949
MID1    = $1339 =  4921          EMUZ80BASIC.ASM:2913
MIDNUM  = $13D1 =  5073          EMUZ80BASIC.ASM:3014
MINCDE  = $1494 =  5268          EMUZ80BASIC.ASM:3120
MINUS   = $0D97 =  3479          EMUZ80BASIC.ASM:2011
MKTMST  = $1140 =  4416          EMUZ80BASIC.ASM:2595
MLDBLP  = $178E =  6030          EMUZ80BASIC.ASM:3652
MLDEBC  = $1786 =  6022          EMUZ80BASIC.ASM:3647
MLOOP   = $0073 =   115          EMUZ80BASIC.ASM:233
MLSP10  = $1683 =  5763          EMUZ80BASIC.ASM:3458
MO      = $0024 =    36          EMUZ80BASIC.ASM:203
MONITR  = $1C8B =  7307          EMUZ80BASIC.ASM:4373
MONOUT  = $1C88 =  7304          EMUZ80BASIC.ASM:4371
MORDT   = $0C1D =  3101          EMUZ80BASIC.ASM:1813
MORINP  = $0641 =  1601          EMUZ80BASIC.ASM:986
MOVBUF  = $04BA =  1210          EMUZ80BASIC.ASM:749
MOVDIR  = $05D7 =  1495          EMUZ80BASIC.ASM:926
MOVLP   = $03C5 =   965          EMUZ80BASIC.ASM:611
MOVSTR  = $03C2 =   962          EMUZ80BASIC.ASM:608
MOVUP   = $03BF =   959          EMUZ80BASIC.ASM:607
MRPRNT  = $0A91 =  2705          EMUZ80BASIC.ASM:1617
MSIZE   = $0070 =   112          EMUZ80BASIC.ASM:232 (unused)
MUL8LP  = $15BA =  5562          EMUZ80BASIC.ASM:3319
MULLN2  = $1586 =  5510          EMUZ80BASIC.ASM:3290
MULT    = $158D =  5517          EMUZ80BASIC.ASM:3294
MULT8   = $15B1 =  5553          EMUZ80BASIC.ASM:3313
MULTEN  = $17F7 =  6135          EMUZ80BASIC.ASM:3712
MULVAL  = $813B = 33083          EMUZ80BASIC.ASM:179
MVSTPT  = $0A43 =  2627          EMUZ80BASIC.ASM:1574
NEDMOR  = $0BB0 =  2992          EMUZ80BASIC.ASM:1757
NEGAFT  = $192E =  6446          EMUZ80BASIC.ASM:3899
NEMEM   = $00C3 =   195          EMUZ80BASIC.ASM:276
NEW     = $04FF =  1279          EMUZ80BASIC.ASM:804
NEXITM  = $0B49 =  2889          EMUZ80BASIC.ASM:1710
NEXT    = $0C6D =  3181          EMUZ80BASIC.ASM:1852
NEXT1   = $0C70 =  3184          EMUZ80BASIC.ASM:1853
NF      = $0000 =     0          EMUZ80BASIC.ASM:185
NFERR   = $03F9 =  1017          EMUZ80BASIC.ASM:645
NMIFLG  = $8091 = 32913          EMUZ80BASIC.ASM:139 (unused)
NOCHNG  = $05C7 =  1479          EMUZ80BASIC.ASM:913
NOENED  = $1906 =  6406          EMUZ80BASIC.ASM:3878
NOLIN   = $08B0 =  2224          EMUZ80BASIC.ASM:1349
NOMADD  = $15CB =  5579          EMUZ80BASIC.ASM:3330
NOMLAD  = $179C =  6044          EMUZ80BASIC.ASM:3660
NOPMPT  = $0B8E =  2958          EMUZ80BASIC.ASM:1736
NORMAL  = $14BF =  5311          EMUZ80BASIC.ASM:3155
NOSPC   = $05BE =  1470          EMUZ80BASIC.ASM:908
NOSUB7  = $1C11 =  7185          EMUZ80BASIC.ASM:4287
NOSWAP  = $146E =  5230          EMUZ80BASIC.ASM:3101
NOTAMP  = $0D6C =  3436          EMUZ80BASIC.ASM:1992
NOTSTR  = $0EE6 =  3814          EMUZ80BASIC.ASM:2222
NOXOR   = $13FC =  5116          EMUZ80BASIC.ASM:3037
NSCFOR  = $0EF6 =  3830          EMUZ80BASIC.ASM:2230
NULFLG  = $8089 = 32905          EMUZ80BASIC.ASM:134
NULL    = $08D4 =  2260          EMUZ80BASIC.ASM:1368
NULLP   = $0B04 =  2820          EMUZ80BASIC.ASM:1672
NULLS   = $8086 = 32902          EMUZ80BASIC.ASM:131
NUMASC  = $183F =  6207          EMUZ80BASIC.ASM:3761
NXTARY  = $0FAD =  4013          EMUZ80BASIC.ASM:2343
NXTBYT  = $05AD =  1453          EMUZ80BASIC.ASM:898
NXTCHR  = $05EE =  1518          EMUZ80BASIC.ASM:938
NXTDAT  = $8121 = 33057          EMUZ80BASIC.ASM:172
NXTDTA  = $09E1 =  2529          EMUZ80BASIC.ASM:1520
NXTITM  = $0BA8 =  2984          EMUZ80BASIC.ASM:1752
NXTOPR  = $8115 = 33045          EMUZ80BASIC.ASM:166
NXTSTL  = $09E8 =  2536          EMUZ80BASIC.ASM:1525
NXTSTT  = $09EB =  2539          EMUZ80BASIC.ASM:1528
OD      = $0006 =     6          EMUZ80BASIC.ASM:188
OKMSG   = $0390 =   912          EMUZ80BASIC.ASM:579
OM      = $000C =    12          EMUZ80BASIC.ASM:191
OMERR   = $03E8 =  1000          EMUZ80BASIC.ASM:636
ON      = $0A53 =  2643          EMUZ80BASIC.ASM:1586
ONGO    = $0A62 =  2658          EMUZ80BASIC.ASM:1594
ONGOLP  = $0A63 =  2659          EMUZ80BASIC.ASM:1595
ONJMP   = $0833 =  2099          EMUZ80BASIC.ASM:1266
OPNPAR  = $0CC6 =  3270          EMUZ80BASIC.ASM:1902
OPRND   = $0D41 =  3393          EMUZ80BASIC.ASM:1975
OS      = $001A =    26          EMUZ80BASIC.ASM:198
OTKLN   = $062F =  1583          EMUZ80BASIC.ASM:977
OTPORT  = $804C = 32844          EMUZ80BASIC.ASM:121
OUTC    = $06CC =  1740          EMUZ80BASIC.ASM:1061
OUTEXP  = $18F7 =  6391          EMUZ80BASIC.ASM:3868
OUTIT   = $06AD =  1709          EMUZ80BASIC.ASM:1039
OUTNBS  = $06B3 =  1715          EMUZ80BASIC.ASM:1042
OUTNCR  = $1C9D =  7325          EMUZ80BASIC.ASM:4386
OUTSUB  = $804B = 32843          EMUZ80BASIC.ASM:120
OUTWRD  = $074F =  1871          EMUZ80BASIC.ASM:1137
OV      = $000A =    10          EMUZ80BASIC.ASM:190
OVERR   = $0402 =  1026          EMUZ80BASIC.ASM:651
OVTST1  = $1676 =  5750          EMUZ80BASIC.ASM:3450
OVTST2  = $167B =  5755          EMUZ80BASIC.ASM:3453
OVTST3  = $167C =  5756          EMUZ80BASIC.ASM:3454
PADD    = $181B =  6171          EMUZ80BASIC.ASM:3737
PAND    = $0E02 =  3586          EMUZ80BASIC.ASM:2078
PASSA   = $1082 =  4226          EMUZ80BASIC.ASM:2480
PBUFF   = $812E = 33070          EMUZ80BASIC.ASM:178
PEEK    = $142A =  5162          EMUZ80BASIC.ASM:3062
PEND    = $0895 =  2197          EMUZ80BASIC.ASM:1335
PHLTFP  = $16D8 =  5848          EMUZ80BASIC.ASM:3513
PLUCDE  = $14F9 =  5369          EMUZ80BASIC.ASM:3197
PNORM   = $14C7 =  5319          EMUZ80BASIC.ASM:3163
POINT   = $8096 = 32918          EMUZ80BASIC.ASM:142
POKE    = $1431 =  5169          EMUZ80BASIC.ASM:3066
POPAF   = $11C6 =  4550          EMUZ80BASIC.ASM:2673
POPHL   = $12F0 =  4848          EMUZ80BASIC.ASM:2864
POPHRT  = $15DB =  5595          EMUZ80BASIC.ASM:3344
POPNOK  = $043D =  1085          EMUZ80BASIC.ASM:678
POR     = $0E01 =  3585          EMUZ80BASIC.ASM:2077
POR1    = $0E24 =  3620          EMUZ80BASIC.ASM:2101
POS     = $107F =  4223          EMUZ80BASIC.ASM:2479
POSINT  = $08F4 =  2292          EMUZ80BASIC.ASM:1391
POUT    = $13E2 =  5090          EMUZ80BASIC.ASM:3025
POWER   = $193C =  6460          EMUZ80BASIC.ASM:3907
POWER1  = $194C =  6476          EMUZ80BASIC.ASM:3915
POWER2  = $1969 =  6505          EMUZ80BASIC.ASM:3933
POWERS  = $191C =  6428          EMUZ80BASIC.ASM:3892
PRCRLF  = $0AF3 =  2803          EMUZ80BASIC.ASM:1665
PRINT   = $0A95 =  2709          EMUZ80BASIC.ASM:1619
PRITAB  = $02E5 =   741          EMUZ80BASIC.ASM:482
PRNTHL  = $1834 =  6196          EMUZ80BASIC.ASM:3755
PRNTLP  = $0A98 =  2712          EMUZ80BASIC.ASM:1620
PRNTNB  = $0ADB =  2779          EMUZ80BASIC.ASM:1652
PRNTOK  = $043E =  1086          EMUZ80BASIC.ASM:680
PRNTST  = $0ADF =  2783          EMUZ80BASIC.ASM:1654
PRNUMS  = $1190 =  4496          EMUZ80BASIC.ASM:2642
PROCES  = $065A =  1626          EMUZ80BASIC.ASM:997
PROGND  = $811B = 33051          EMUZ80BASIC.ASM:169
PROGST  = $813E = 33086          EMUZ80BASIC.ASM:180
PROMPT  = $0542 =  1346          EMUZ80BASIC.ASM:841
PRS     = $1191 =  4497          EMUZ80BASIC.ASM:2643
PRS1    = $1194 =  4500          EMUZ80BASIC.ASM:2644
PRSLP   = $119B =  4507          EMUZ80BASIC.ASM:2647
PSET    = $8099 = 32921          EMUZ80BASIC.ASM:143
PSUB    = $144F =  5199          EMUZ80BASIC.ASM:3082
PTRLP   = $04C7 =  1223          EMUZ80BASIC.ASM:758
PUTBUF  = $0699 =  1689          EMUZ80BASIC.ASM:1028
PUTCTL  = $069E =  1694          EMUZ80BASIC.ASM:1030
PUTFID  = $0807 =  2055          EMUZ80BASIC.ASM:1239
QTSTLP  = $1156 =  4438          EMUZ80BASIC.ASM:2612
QTSTR   = $1150 =  4432          EMUZ80BASIC.ASM:2608
QUARTR  = $1AD5 =  6869          EMUZ80BASIC.ASM:4110
RAMSIZ  = $1000 =  4096          EMUZ80BASIC.ASM:12 (unused)
RAMTOP  = $8000 = 32768          EMUZ80BASIC.ASM:11 (unused)
RD      = $0012 =    18          EMUZ80BASIC.ASM:194
READ    = $0BA3 =  2979          EMUZ80BASIC.ASM:1749
READFG  = $8112 = 33042          EMUZ80BASIC.ASM:164
REDO    = $0B50 =  2896          EMUZ80BASIC.ASM:1714
REM     = $09E4 =  2532          EMUZ80BASIC.ASM:1523
RESDIV  = $1628 =  5672          EMUZ80BASIC.ASM:3395
RESEED  = $1A73 =  6771          EMUZ80BASIC.ASM:4066
RESET   = $809C = 32924          EMUZ80BASIC.ASM:144
RESTNL  = $0870 =  2160          EMUZ80BASIC.ASM:1305
RESTOR  = $085B =  2139          EMUZ80BASIC.ASM:1294
RESZER  = $14BA =  5306          EMUZ80BASIC.ASM:3151
RETADR  = $0F5D =  3933          EMUZ80BASIC.ASM:2290
RETINT  = $16B1 =  5809          EMUZ80BASIC.ASM:3486
RETLIN  = $09DC =  2524          EMUZ80BASIC.ASM:1517
RETNAD  = $05D3 =  1491          EMUZ80BASIC.ASM:922
RETNUL  = $0F60 =  3936          EMUZ80BASIC.ASM:2294
RETNUM  = $0DA3 =  3491          EMUZ80BASIC.ASM:2016
RETREL  = $16A3 =  5795          EMUZ80BASIC.ASM:3476
RETURN  = $09BD =  2493          EMUZ80BASIC.ASM:1501
RG      = $0004 =     4          EMUZ80BASIC.ASM:187
RIGHT   = $1363 =  4963          EMUZ80BASIC.ASM:2942
RIGHT1  = $1337 =  4919          EMUZ80BASIC.ASM:2911
RINPUT  = $8093 = 32915          EMUZ80BASIC.ASM:141
RLTLP   = $0CE6 =  3302          EMUZ80BASIC.ASM:1918
RND     = $1A12 =  6674          EMUZ80BASIC.ASM:4013
RND1    = $1A4E =  6734          EMUZ80BASIC.ASM:4044
RND2    = $1A6A =  6762          EMUZ80BASIC.ASM:4062
RNDTAB  = $1A7B =  6779          EMUZ80BASIC.ASM:4073
RNGTST  = $1909 =  6409          EMUZ80BASIC.ASM:3882
ROMTOP  = $0000 =     0          EMUZ80BASIC.ASM:10
RONDB   = $14DB =  5339          EMUZ80BASIC.ASM:3175
RONDUP  = $14DA =  5338          EMUZ80BASIC.ASM:3174
ROUND   = $1442 =  5186          EMUZ80BASIC.ASM:3076
RSCALE  = $1815 =  6165          EMUZ80BASIC.ASM:3735
RSLNBK  = $0789 =  1929          EMUZ80BASIC.ASM:1169
RSTSTR  = $1386 =  4998          EMUZ80BASIC.ASM:2962
RUN     = $0982 =  2434          EMUZ80BASIC.ASM:1468
RUNCNT  = $080B =  2059          EMUZ80BASIC.ASM:1243
RUNFST  = $050B =  1291          EMUZ80BASIC.ASM:813
RUNLIN  = $099E =  2462          EMUZ80BASIC.ASM:1484
RXA     = $001B =    27          EMUZ80BASIC.ASM:41
SAVEXP  = $14BB =  5307          EMUZ80BASIC.ASM:3152
SAVSTP  = $07FE =  2046          EMUZ80BASIC.ASM:1232
SAVSTR  = $112B =  4395          EMUZ80BASIC.ASM:2579
SBSCPT  = $0F6B =  3947          EMUZ80BASIC.ASM:2300
SCALE   = $1519 =  5401          EMUZ80BASIC.ASM:3229
SCALLP  = $151B =  5403          EMUZ80BASIC.ASM:3230
SCALMI  = $17E0 =  6112          EMUZ80BASIC.ASM:3697
SCALPL  = $17F6 =  6134          EMUZ80BASIC.ASM:3711
SCNEND  = $1262 =  4706          EMUZ80BASIC.ASM:2769
SCPTLP  = $0F71 =  3953          EMUZ80BASIC.ASM:2304
SEARCH  = $059B =  1435          EMUZ80BASIC.ASM:884
SEED    = $805C = 32860          EMUZ80BASIC.ASM:127
SETIO   = $1406 =  5126          EMUZ80BASIC.ASM:3044
SETLIN  = $075D =  1885          EMUZ80BASIC.ASM:1145
SETLIT  = $05E5 =  1509          EMUZ80BASIC.ASM:934
SETPTR  = $04C2 =  1218          EMUZ80BASIC.ASM:755
SETTOP  = $0082 =   130          EMUZ80BASIC.ASM:245
SFTPRG  = $048C =  1164          EMUZ80BASIC.ASM:718
SGN     = $16A9 =  5801          EMUZ80BASIC.ASM:3483
SGNEXP  = $0DF1 =  3569          EMUZ80BASIC.ASM:2064
SGNRES  = $812D = 33069          EMUZ80BASIC.ASM:177
SHRITE  = $1528 =  5416          EMUZ80BASIC.ASM:3238
SHRLP   = $152B =  5419          EMUZ80BASIC.ASM:3240
SHRT1   = $152F =  5423          EMUZ80BASIC.ASM:3244
SIGNON  = $00DB =   219          EMUZ80BASIC.ASM:282
SIGNS   = $1700 =  5888          EMUZ80BASIC.ASM:3543
SIN     = $1A8D =  6797          EMUZ80BASIC.ASM:4079
SIN1    = $1ABD =  6845          EMUZ80BASIC.ASM:4099
SINIT   = $003C =    60          EMUZ80BASIC.ASM:76
SINTAB  = $1AD9 =  6873          EMUZ80BASIC.ASM:4112
SIXDIG  = $185C =  6236          EMUZ80BASIC.ASM:3775
SMPVAR  = $11F6 =  4598          EMUZ80BASIC.ASM:2697
SMSER1  = $19F1 =  6641          EMUZ80BASIC.ASM:3991
SN      = $0002 =     2          EMUZ80BASIC.ASM:186
SNERR   = $03F3 =  1011          EMUZ80BASIC.ASM:641
SPCFST  = $184D =  6221          EMUZ80BASIC.ASM:3767
SPCLP   = $0B42 =  2882          EMUZ80BASIC.ASM:1707
SQR     = $1933 =  6451          EMUZ80BASIC.ASM:3903
SRCHLN  = $04DF =  1247          EMUZ80BASIC.ASM:777
SRCHLP  = $04E2 =  1250          EMUZ80BASIC.ASM:778
SSTSA   = $12BE =  4798          EMUZ80BASIC.ASM:2829
ST      = $001E =    30          EMUZ80BASIC.ASM:200
STACK   = $80AB = 32939          EMUZ80BASIC.ASM:149
STAKFP  = $16CB =  5835          EMUZ80BASIC.ASM:3503
STALL   = $0884 =  2180          EMUZ80BASIC.ASM:1322
STARTB  = $0045 =    69          EMUZ80BASIC.ASM:209
STKTHS  = $0D2A =  3370          EMUZ80BASIC.ASM:1959
STLOOK  = $81A2 = 33186          EMUZ80BASIC.ASM:181
STOP    = $0893 =  2195          EMUZ80BASIC.ASM:1333
STORED  = $095F =  2399          EMUZ80BASIC.ASM:1448
STPOOL  = $1239 =  4665          EMUZ80BASIC.ASM:2734
STR     = $111B =  4379          EMUZ80BASIC.ASM:2572
STR1    = $1121 =  4385          EMUZ80BASIC.ASM:2574
STRADD  = $123C =  4668          EMUZ80BASIC.ASM:2736
STRBOT  = $8108 = 33032          EMUZ80BASIC.ASM:158
STRENT  = $0BFA =  3066          EMUZ80BASIC.ASM:1796
STRSPC  = $809F = 32927          EMUZ80BASIC.ASM:145
STTLIN  = $0AE6 =  2790          EMUZ80BASIC.ASM:1658
SUBCDE  = $1451 =  5201          EMUZ80BASIC.ASM:3084
SUBPHL  = $144B =  5195          EMUZ80BASIC.ASM:3080
SUMLP   = $19FA =  6650          EMUZ80BASIC.ASM:3996
SUMSER  = $19E2 =  6626          EMUZ80BASIC.ASM:3984
SUPTLZ  = $18DB =  6363          EMUZ80BASIC.ASM:3852
SVNAM2  = $0ECA =  3786          EMUZ80BASIC.ASM:2209
SVSTAD  = $1149 =  4425          EMUZ80BASIC.ASM:2600
TAN     = $1AEE =  6894          EMUZ80BASIC.ASM:4119
TESTOS  = $11C8 =  4552          EMUZ80BASIC.ASM:2676
TESTR   = $11AA =  4522          EMUZ80BASIC.ASM:2656
TM      = $0018 =    24          EMUZ80BASIC.ASM:197
TMERR   = $0405 =  1029          EMUZ80BASIC.ASM:653
TMPSTR  = $8104 = 33028          EMUZ80BASIC.ASM:157
TMSTPL  = $80F8 = 33016          EMUZ80BASIC.ASM:156
TMSTPT  = $80F6 = 33014          EMUZ80BASIC.ASM:155
TOPOOL  = $132F =  4911          EMUZ80BASIC.ASM:2906
TOSTRA  = $12C7 =  4807          EMUZ80BASIC.ASM:2838
TRYAGN  = $18B6 =  6326          EMUZ80BASIC.ASM:3825
TSALP   = $12C8 =  4808          EMUZ80BASIC.ASM:2839
TSTACK  = $80ED = 33005          EMUZ80BASIC.ASM:13
TSTBIT  = $1C96 =  7318          EMUZ80BASIC.ASM:4379 (unused)
TSTBRK  = $0876 =  2166          EMUZ80BASIC.ASM:1311
TSTNUM  = $0CBB =  3259          EMUZ80BASIC.ASM:1894
TSTOPL  = $1171 =  4465          EMUZ80BASIC.ASM:2628
TSTRED  = $0E29 =  3625          EMUZ80BASIC.ASM:2107
TSTREM  = $05E8 =  1512          EMUZ80BASIC.ASM:935
TSTSGN  = $169A =  5786          EMUZ80BASIC.ASM:3471
TSTSTR  = $0CBC =  3260          EMUZ80BASIC.ASM:1895
TTYLIN  = $0638 =  1592          EMUZ80BASIC.ASM:982
TXA     = $0031 =    49          EMUZ80BASIC.ASM:63
TXAST1  = $0032 =    50          EMUZ80BASIC.ASM:64
TYPE    = $80F2 = 33010          EMUZ80BASIC.ASM:152
UF      = $0022 =    34          EMUZ80BASIC.ASM:202
UFERR   = $03FF =  1023          EMUZ80BASIC.ASM:649
UL      = $000E =    14          EMUZ80BASIC.ASM:192
ULERR   = $09B8 =  2488          EMUZ80BASIC.ASM:1498
UNITY   = $153D =  5437          EMUZ80BASIC.ASM:3257
UPDATA  = $0871 =  2161          EMUZ80BASIC.ASM:1306
USR     = $8048 = 32840          EMUZ80BASIC.ASM:119
VAL     = $139D =  5021          EMUZ80BASIC.ASM:2981
VAL1    = $13BB =  5051          EMUZ80BASIC.ASM:3001
VAL2    = $13C5 =  5061          EMUZ80BASIC.ASM:3005
VAL3    = $13C8 =  5064          EMUZ80BASIC.ASM:3006
VAREND  = $811D = 33053          EMUZ80BASIC.ASM:170
WAIT    = $13E8 =  5096          EMUZ80BASIC.ASM:3028
WAITLP  = $13FD =  5117          EMUZ80BASIC.ASM:3038
WARM    = $0042 =    66          EMUZ80BASIC.ASM:208 (unused)
WARMST  = $00BA =   186          EMUZ80BASIC.ASM:272
WIDTH   = $1B57 =  6999          EMUZ80BASIC.ASM:4167
WORDS   = $017C =   380          EMUZ80BASIC.ASM:322
WORDTB  = $029B =   667          EMUZ80BASIC.ASM:411
WRKSPC  = $8045 = 32837          EMUZ80BASIC.ASM:118
XXXXX   = $00C9 =   201          EMUZ80BASIC.ASM:278
ZDATA   = $0083 =   131          EMUZ80BASIC.ASM:453
ZDIV    = $00AF =   175          EMUZ80BASIC.ASM:471 (unused)
ZEND    = $0080 =   128          EMUZ80BASIC.ASM:451
ZEQUAL  = $00B4 =   180          EMUZ80BASIC.ASM:474
ZERARY  = $100C =  4108          EMUZ80BASIC.ASM:2403
ZERBYT  = $038F =   911          EMUZ80BASIC.ASM:578
ZEROLP  = $0F4F =  3919          EMUZ80BASIC.ASM:2281
ZEROSUP = $1C2F =  7215          EMUZ80BASIC.ASM:4308
ZFN     = $00A7 =   167          EMUZ80BASIC.ASM:462
ZFOR    = $0081 =   129          EMUZ80BASIC.ASM:452
ZGOSUB  = $008C =   140          EMUZ80BASIC.ASM:455
ZGOTO   = $0088 =   136          EMUZ80BASIC.ASM:454
ZGTR    = $00B3 =   179          EMUZ80BASIC.ASM:473
ZLEFT   = $00CF =   207          EMUZ80BASIC.ASM:478
ZLTH    = $00B5 =   181          EMUZ80BASIC.ASM:475
ZMINUS  = $00AD =   173          EMUZ80BASIC.ASM:469
ZNEW    = $00A4 =   164          EMUZ80BASIC.ASM:458
ZNOT    = $00AA =   170          EMUZ80BASIC.ASM:465
ZONELP  = $0B1D =  2845          EMUZ80BASIC.ASM:1686
ZOR     = $00B2 =   178          EMUZ80BASIC.ASM:472
ZPLUS   = $00AC =   172          EMUZ80BASIC.ASM:468
ZPOINT  = $00C7 =   199          EMUZ80BASIC.ASM:477 (unused)
ZPRINT  = $009E =   158          EMUZ80BASIC.ASM:457
ZREM    = $008E =   142          EMUZ80BASIC.ASM:456
ZSGN    = $00B6 =   182          EMUZ80BASIC.ASM:476
ZSPC    = $00A8 =   168          EMUZ80BASIC.ASM:463
ZSTEP   = $00AB =   171          EMUZ80BASIC.ASM:466
ZTAB    = $00A5 =   165          EMUZ80BASIC.ASM:460
ZTHEN   = $00A9 =   169          EMUZ80BASIC.ASM:464
ZTIMES  = $00AE =   174          EMUZ80BASIC.ASM:470 (unused)
ZTO     = $00A6 =   166          EMUZ80BASIC.ASM:461
_end    = $1CA3 =  7331          EMUZ80BASIC.ASM:23 (unused)
_size   = $1CA3 =  7331          EMUZ80BASIC.ASM:23 (unused)


total time: 0.0120 sec.
no errors
