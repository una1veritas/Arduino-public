                        ; --------------------------------------
                        ; zasm: assemble "EMUZ80BASIC.ASM"
                        ; date: 2025-10-20 12:09:02
                        ; --------------------------------------


                        ;	EMUBASIC based on GRANT's BASIC
                        ;	TARGET: EMUZ80
                        ;	ASSEMBLER: ARCPIT XZ80.EXE
                        ;
                        ;	START UP ROUTINE
                        ;	VERSION 1.0, 2022/02/15
                        ;	WRITTEN by TETSUYA SUZUKI
                        ;
                        ;	MEMORY ASIGN
0000:                   ROMTOP	EQU	0000H
                        ;RAMTOP	EQU	8000H
                        ;RAMSIZ	EQU	1000H
F000:                   TSTACK	EQU	0F000H ;80EDH
                        ;
                        ;	UART REGISTER ADDRESS
                        ; UARTDR	EQU	0E000H	; UART DATA REGISTOR  --> out (CONIO), a / out (CONIN), a
                        ; UARTCR	EQU	0E001H	; UART CONTROL REGISTOR. --> in a, (CONST)
                        ;
0000:                   CONSTA	EQU 	$00
0001:                   CONIO	EQU 	$01
                        
                        ;	RESET (RST 00H)
0000:                   	ORG	ROMTOP
0000: F3       [ 4]     	DI
0001: 3100F0   [14]     	LD	SP,TSTACK
0004: C33900   [24]     	JP	SINIT
                        ;
                        ;	PUT 1CHAR (RST 08H)
                        	ORG	ROMTOP+08H
0008: C32F00   [34]     	JP	TXA
                        ;
                        ;	GET 1CHAR (RST 10H)
                        	ORG	ROMTOP+10H
0010: C31B00   [44]     	JP	RXA
                        ;
                        ;	KBHIT (RST 18H)
                        	ORG	ROMTOP+18H
0018: C32B00   [54]     	JP	KBHIT
                        ;
                        ;	UART -> A
001B:                   RXA:
001B: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
                        	; BIT	0,A
001D: A7       [15]     	and a
001E: 28FB     [22|27]  	JR	Z,RXA
0020: DB01     [33]     	in 	a, (CONIO)
                        	;LD	A,(UARTDR)
0022: FE61     [40]     	CP	'a'
0024: D8       [45|51]  	RET	C
0025: FE7B     [52]     	CP	'z'+1
0027: D0       [57|63]  	RET	NC
0028: E6DF     [64]     	AND	0DFH  ; to upper case
002A: C9       [74]     	RET
                        ;
                        ;	CHECK RECEIVE STATUS
002B:                   KBHIT:	
002B: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
                        	;BIT	0,A ; --> set Z if the least sig bit is zero
002D: A7       [15]     	and a 	; set Z if a == 0
002E: C9       [25]     	RET
                        ;
                        ;	A -> UART
002F: F5       [11]     TXA:	PUSH	AF
0030:                   TXAST1:	
0030: DB00     [11]     	in 	a, (CONSTA)
                        	;LD	A,(UARTCR)
                        	; BIT	1,A
0032: A7       [15]     	and a
0033: 28FB     [22|27]  	JR	Z,TXAST1
0035: F1       [32]     	POP	AF
0036: D301     [43]     	out (CONIO), a 	;echo back?
                        	;LD	(UARTDR),A
0038: C9       [53]     	RET
                        ;
                        ;
                        ;	SYSTEM INITIALIZE
0039:                   SINIT:
0039: C33C00   [10]     	JP	COLD
                        ;
                        ;==================================================================================
                        ; The updates to the original BASIC within this file are copyright Grant Searle
                        ;
                        ; You have permission to use this for NON COMMERCIAL USE ONLY
                        ; If you wish to use it elsewhere, please include an acknowledgement to myself.
                        ;
                        ; http://searle.hostei.com/grant/index.html
                        ;
                        ; eMail: home.micros01@btinternet.com
                        ;
                        ; If the above don't work, please perform an Internet search to see if I have
                        ; updated the web page hosting service.
                        ;
                        ;==================================================================================
                        ;
                        ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
                        ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
                        ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
                        ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
                        ; the original ROM code (checksum A934H). PA
                        ;
                        ; GENERAL EQUATES
                        ;
0003:                   CTRLC	EQU	03H		; Control "C"
0007:                   CTRLG	EQU	07H		; Control "G"
0008:                   BKSP	EQU	08H		; Back space
000A:                   LF	EQU	0AH		; Line feed
000C:                   CS	EQU	0CH		; Clear screen
000D:                   CR	EQU	0DH		; Carriage return
000F:                   CTRLO	EQU	0FH		; Control "O"
0011:                   CTRLQ	EQU	11H		; Control "Q"
0012:                   CTRLR	EQU	12H		; Control "R"
0013:                   CTRLS	EQU	13H		; Control "S"
0015:                   CTRLU	EQU	15H		; Control "U"
001B:                   ESC	EQU	1BH		; Escape
007F:                   DEL	EQU	7FH		; Delete
                        ;
                        ; BASIC WORK SPACE LOCATIONS
                        ;
8045:                   WRKSPC	EQU	8045H		; BASIC Work space
8048:                   USR	EQU	WRKSPC+3H	; "USR (x)" jump
804B:                   OUTSUB	EQU	WRKSPC+6H	; "OUT p,n"
804C:                   OTPORT	EQU	WRKSPC+7H	; Port (p)
804E:                   DIVSUP	EQU	WRKSPC+9H	; Division support routine
804F:                   DIV1	EQU	WRKSPC+0AH	; <- Values
8053:                   DIV2	EQU	WRKSPC+0EH	; <- to
8057:                   DIV3	EQU	WRKSPC+12H	; <- be
805A:                   DIV4	EQU	WRKSPC+15H	; <- inserted
805C:                   SEED	EQU	WRKSPC+17H	; Random number seed
807F:                   LSTRND	EQU	WRKSPC+3AH	; Last random number
8083:                   INPSUB	EQU	WRKSPC+3EH	; #INP (x)" Routine
8084:                   INPORT	EQU	WRKSPC+3FH	; PORT (x)
8086:                   NULLS	EQU	WRKSPC+41H	; Number of nulls
8087:                   LWIDTH	EQU	WRKSPC+42H	; Terminal width
8088:                   COMMAN	EQU	WRKSPC+43H	; Width for commas
8089:                   NULFLG	EQU	WRKSPC+44H	; Null after input byte flag
808A:                   CTLOFG	EQU	WRKSPC+45H	; Control "O" flag
808B:                   LINESC	EQU	WRKSPC+46H	; Lines counter
808D:                   LINESN	EQU	WRKSPC+48H	; Lines number
808F:                   CHKSUM	EQU	WRKSPC+4AH	; Array load/save check sum
8091:                   NMIFLG	EQU	WRKSPC+4CH	; Flag for NMI break routine
8092:                   BRKFLG	EQU	WRKSPC+4DH	; Break flag
8093:                   RINPUT	EQU	WRKSPC+4EH	; Input reflection
8096:                   POINT	EQU	WRKSPC+51H	; "POINT" reflection (unused)
8099:                   PSET	EQU	WRKSPC+54H	; "SET"	reflection
809C:                   RESET	EQU	WRKSPC+57H	; "RESET" reflection
809F:                   STRSPC	EQU	WRKSPC+5AH	; Bottom of string space
80A1:                   LINEAT	EQU	WRKSPC+5CH	; Current line number
80A3:                   BASTXT	EQU	WRKSPC+5EH	; Pointer to start of program
80A6:                   BUFFER	EQU	WRKSPC+61H	; Input buffer
80AB:                   STACK	EQU	WRKSPC+66H	; Initial stack
80F0:                   CURPOS	EQU	WRKSPC+0ABH	; Character position on line
80F1:                   LCRFLG	EQU	WRKSPC+0ACH	; Locate/Create flag
80F2:                   TYPE	EQU	WRKSPC+0ADH	; Data type flag
80F3:                   DATFLG	EQU	WRKSPC+0AEH	; Literal statement flag
80F4:                   LSTRAM	EQU	WRKSPC+0AFH	; Last available RAM
80F6:                   TMSTPT	EQU	WRKSPC+0B1H	; Temporary string pointer
80F8:                   TMSTPL	EQU	WRKSPC+0B3H	; Temporary string pool
8104:                   TMPSTR	EQU	WRKSPC+0BFH	; Temporary string
8108:                   STRBOT	EQU	WRKSPC+0C3H	; Bottom of string space
810A:                   CUROPR	EQU	WRKSPC+0C5H	; Current operator in EVAL
810C:                   LOOPST	EQU	WRKSPC+0C7H	; First statement of loop
810E:                   DATLIN	EQU	WRKSPC+0C9H	; Line of current DATA item
8110:                   FORFLG	EQU	WRKSPC+0CBH	; "FOR" loop flag
8111:                   LSTBIN	EQU	WRKSPC+0CCH	; Last byte entered
8112:                   READFG	EQU	WRKSPC+0CDH	; Read/Input flag
8113:                   BRKLIN	EQU	WRKSPC+0CEH	; Line of break
8115:                   NXTOPR	EQU	WRKSPC+0D0H	; Next operator in EVAL
8117:                   ERRLIN	EQU	WRKSPC+0D2H	; Line of error
8119:                   CONTAD	EQU	WRKSPC+0D4H	; Where to CONTinue
811B:                   PROGND	EQU	WRKSPC+0D6H	; End of program
811D:                   VAREND	EQU	WRKSPC+0D8H	; End of variables
811F:                   ARREND	EQU	WRKSPC+0DAH	; End of arrays
8121:                   NXTDAT	EQU	WRKSPC+0DCH	; Next data item
8123:                   FNRGNM	EQU	WRKSPC+0DEH	; Name of FN argument
8125:                   FNARG	EQU	WRKSPC+0E0H	; FN argument value
8129:                   FPREG	EQU	WRKSPC+0E4H	; Floating point register
812C:                   FPEXP	EQU	FPREG+3		; Floating point exponent
812D:                   SGNRES	EQU	WRKSPC+0E8H	; Sign of result
812E:                   PBUFF	EQU	WRKSPC+0E9H	; Number print buffer
813B:                   MULVAL	EQU	WRKSPC+0F6H	; Multiplier
813E:                   PROGST	EQU	WRKSPC+0F9H	; Start of program text area
81A2:                   STLOOK	EQU	WRKSPC+15DH	; Start of memory test
                        ;
                        ; BASIC ERROR CODE VALUES
                        ;
0000:                   NF	EQU	00H		; NEXT without FOR
0002:                   SN	EQU	02H		; Syntax error
0004:                   RG	EQU	04H		; RETURN without GOSUB
0006:                   OD	EQU	06H		; Out of DATA
0008:                   FC	EQU	08H		; Function call error
000A:                   OV	EQU	0AH		; Overflow
000C:                   OM	EQU	0CH		; Out of memory
000E:                   UL	EQU	0EH		; Undefined line number
0010:                   BS	EQU	10H		; Bad subscript
0012:                   RD	EQU	12H		; Re-DIMensioned array
0014:                   DZ	EQU	14H		; Division by zero (/0)
0016:                   ID	EQU	16H		; Illegal direct
0018:                   TM	EQU	18H		; Type miss-match
001A:                   OS	EQU	1AH		; Out of string space
001C:                   LS	EQU	1CH		; String too long
001E:                   ST	EQU	1EH		; String formula too complex
0020:                   CN	EQU	20H		; Can't CONTinue
0022:                   UF	EQU	22H		; UnDEFined FN function
0024:                   MO	EQU	24H		; Missing operand
0026:                   HX	EQU	26H		; HEX error
0028:                   BN	EQU	28H		; BIN error
                        ;
003C: C34200   [10]     COLD:	JP	STARTB		; Jump for cold start
003F: C3B700   [10]     WARM:	JP	WARMST		; Jump for warm start
0042: C34900   [10]     STARTB: JP	CSTART		; Jump to initialise
                        ;
0045: FA08              	DW	DEINT		; Get integer -32768 to 32767
0047: 7010              	DW	ABPASS		; Return integer in AB
                        ;
0049: 214580   [10]     CSTART: LD	HL,WRKSPC	; Start of workspace RAM
004C: F9       [16]     	LD	SP,HL		; Set up a temporary stack
004D: C38B1C   [26]     	JP	INITST		; Go to initialise
                        ;
0050: 112103   [10]     INIT:	LD	DE,INITAB	; Initialise workspace
0053: 0663     [17]     	LD	B,INITBE-INITAB+3; Bytes to copy
0055: 214580   [27]     	LD	HL,WRKSPC	; Into workspace RAM
0058: 1A       [ 7]     COPY:	LD	A,(DE)		; Get source
0059: 77       [14]     	LD	(HL),A		; To destination
005A: 23       [20]     	INC	HL		; Next destination
005B: 13       [26]     	INC	DE		; Next source
005C: 05       [30]     	DEC	B		; Count bytes
005D: C25800   [40|40]  	JP	NZ,COPY		; More to move
0060: F9       [46]     	LD	SP,HL		; Temporary stack
0061: CD2205   [63]     	CALL	CLREG		; Clear registers and stack
0064: CDF00A   [80]     	CALL	PRCRLF		; Output CRLF
0067: 32EF80   [93]     	LD	(BUFFER+72+1),A	; Mark end of buffer
006A: 323E81   [106]    	LD	(PROGST),A	; Initialise program area
006D: 21A281   [10]     MSIZE:	LD	HL,STLOOK	; Point to start of RAM
0070: 23       [ 6]     MLOOP:	INC	HL		; Next byte
0071: 7C       [10]     	LD	A,H		; Above address FFFF ?
0072: B5       [14]     	OR	L
0073: CA7F00   [24|24]  	JP	Z,SETTOP	; Yes - 64K RAM
0076: 7E       [31]     	LD	A,(HL)		; Get contents
0077: 47       [35]     	LD	B,A		; Save it
0078: 2F       [39]     	CPL			; Flip all bits
0079: 77       [46]     	LD	(HL),A		; Put it back
007A: BE       [53]     	CP	(HL)		; RAM there if same
007B: 70       [60]     	LD	(HL),B		; Restore old contents
007C: CA7000   [70|70]  	JP	Z,MLOOP		; If RAM - test next byte
                        ;
007F: 2B       [ 6]     SETTOP: DEC	HL		; Back one byte
0080: 11A181   [16]     	LD	DE,STLOOK-1	; See if enough RAM
0083: CDB806   [33]     	CALL	CPDEHL		; Compare DE with HL
0086: DAC000   [43|43]  	JP	C,NEMEM		; If not enough RAM
0089: 11CEFF   [53]     	LD	DE,0-50		; 50 Bytes string space
008C: 22F480   [69]     	LD	(LSTRAM),HL	; Save last available RAM
008F: 19       [80]     	ADD	HL,DE		; Allocate string space
0090: 229F80   [96]     	LD	(STRSPC),HL	; Save string space
0093: CDFD04   [113]    	CALL	CLRPTR		; Clear program area
0096: 2A9F80   [129]    	LD	HL,(STRSPC)	; Get end of memory
0099: 11EFFF   [139]    	LD	DE,0-17		; Offset for free bytes
009C: 19       [150]    	ADD	HL,DE		; Adjust HL
009D: 113E81   [160]    	LD	DE,PROGST	; Start of program text
00A0: 7D       [164]    	LD	A,L		; Get LSB
00A1: 93       [168]    	SUB	E		; Adjust it
00A2: 6F       [172]    	LD	L,A		; Re-save
00A3: 7C       [176]    	LD	A,H		; Get MSB
00A4: 9A       [180]    	SBC	A,D		; Adjust it
00A5: 67       [184]    	LD	H,A		; Re-save
00A6: E5       [195]    	PUSH	HL		; Save bytes free
00A7: 21D800   [205]    	LD	HL,SIGNON	; Sign-on message
00AA: CD8E11   [222]    	CALL	PRS		; Output string
00AD: E1       [232]    	POP	HL		; Get bytes free back
00AE: CD3118   [249]    	CALL	PRNTHL		; Output amount of free memory
00B1: 21C900   [259]    	LD	HL,BFREE	; " Bytes free" message
00B4: CD8E11   [276]    	CALL	PRS		; Output string
                        ;
00B7: 31AB80   [10]     WARMST: LD	SP,STACK	; Temporary stack
00BA: CD2205   [17]     BRKRET: CALL	CLREG		; Clear registers and stack
00BD: C33B04   [27]     	JP	PRNTOK		; Go to get command line
                        ;
00C0: 210F01   [10]     NEMEM:	LD	HL,MEMMSG	; Memory size not enough
00C3: CD8E11   [27]     	CALL	PRS		; Print it
00C6: C3C600   [10]     XXXXX:	JP	XXXXX		; Stop
                        ;
00C9: 20427974          BFREE:	DB	" Bytes free",CR,LF,0,0
00CD: 65732066          
00D1: 7265650D          
00D5: 0A0000            
                        ;
00D8: 5A383020          SIGNON: DB	"Z80 BASIC Ver 4.7b",CR,LF
00DC: 42415349          
00E0: 43205665          
00E4: 7220342E          
00E8: 37620D0A          
00EC: 436F7079          	DB	"Copyright ",40,"C",41
00F0: 72696768          
00F4: 74202843          
00F8: 29                
00F9: 20313937          	DB	" 1978 by Microsoft",CR,LF,0,0
00FD: 38206279          
0101: 204D6963          
0105: 726F736F          
0109: 66740D0A          
010D: 0000              
                        ;
010F: 4D656D6F          MEMMSG: DB	"Memory size not enough",CR,LF
0113: 72792073          
0117: 697A6520          
011B: 6E6F7420          
011F: 656E6F75          
0123: 67680D0A          
0127: 54686520          	DB	"The system is stopped.",CR,LF,0,0
012B: 73797374          
012F: 656D2069          
0133: 73207374          
0137: 6F707065          
013B: 642E0D0A          
013F: 0000              
                        ;
                        ; FUNCTION ADDRESS TABLE
                        ;
0141: A616              FNCTAB: DW	SGN
0143: 6A17              	DW	INT
0145: BC16              	DW	ABS
0147: 4880              	DW	USR
0149: 4E10              	DW	FRE
014B: D313              	DW	INP
014D: 7C10              	DW	POS
014F: 3019              	DW	SQR
0151: 0F1A              	DW	RND
0153: 4B15              	DW	LOG
0155: 7E19              	DW	EXP
0157: 841A              	DW	COS
0159: 8A1A              	DW	SIN
015B: EB1A              	DW	TAN
015D: 001B              	DW	ATN
015F: 2714              	DW	PEEK
0161: 6B1B              	DW	DEEK
0163: 9680              	DW	POINT
0165: 0013              	DW	LEN
0167: 1811              	DW	STR
0169: 9A13              	DW	VAL
016B: 0F13              	DW	ASC
016D: 2013              	DW	CHR
016F: 8D1B              	DW	HEX
0171: 201C              	DW	BIN
0173: 3013              	DW	LEFT
0175: 6013              	DW	RIGHT
0177: 6A13              	DW	MID
                        ;
                        ; RESERVED WORD LIST
                        ;
0179: C54E44            WORDS:	DB	0C5H,"ND"
017C: C64F52            	DB	0C6H,"OR"
017F: CE455854          	DB	0CEH,"EXT"
0183: C4415441          	DB	0C4H,"ATA"
0187: C94E5055          	DB	0C9H,"NPUT"
018B: 54                
018C: C4494D            	DB	0C4H,"IM"
018F: D2454144          	DB	0D2H,"EAD"
0193: CC4554            	DB	0CCH,"ET"
0196: C74F544F          	DB	0C7H,"OTO"
019A: D2554E            	DB	0D2H,"UN"
019D: C946              	DB	0C9H,"F"
019F: D2455354          	DB	0D2H,"ESTORE"
01A3: 4F5245            
01A6: C74F5355          	DB	0C7H,"OSUB"
01AA: 42                
01AB: D2455455          	DB	0D2H,"ETURN"
01AF: 524E              
01B1: D2454D            	DB	0D2H,"EM"
01B4: D3544F50          	DB	0D3H,"TOP"
01B8: CF5554            	DB	0CFH,"UT"
01BB: CF4E              	DB	0CFH,"N"
01BD: CE554C4C          	DB	0CEH,"ULL"
01C1: D7414954          	DB	0D7H,"AIT"
01C5: C44546            	DB	0C4H,"EF"
01C8: D04F4B45          	DB	0D0H,"OKE"
01CC: C44F4B45          	DB	0C4H,"OKE"
01D0: D3435245          	DB	0D3H,"CREEN"
01D4: 454E              
01D6: CC494E45          	DB	0CCH,"INES"
01DA: 53                
01DB: C34C53            	DB	0C3H,"LS"
01DE: D7494454          	DB	0D7H,"IDTH"
01E2: 48                
01E3: CD4F4E49          	DB	0CDH,"ONITOR"
01E7: 544F52            
01EA: D34554            	DB	0D3H,"ET"
01ED: D2455345          	DB	0D2H,"ESET"
01F1: 54                
01F2: D052494E          	DB	0D0H,"RINT"
01F6: 54                
01F7: C34F4E54          	DB	0C3H,"ONT"
01FB: CC495354          	DB	0CCH,"IST"
01FF: C34C4541          	DB	0C3H,"LEAR"
0203: 52                
0204: C34C4F41          	DB	0C3H,"LOAD"
0208: 44                
0209: C3534156          	DB	0C3H,"SAVE"
020D: 45                
020E: CE4557            	DB	0CEH,"EW"
                        ;
0211: D4414228          	DB	0D4H,"AB("
0215: D44F              	DB	0D4H,"O"
0217: C64E              	DB	0C6H,"N"
0219: D3504328          	DB	0D3H,"PC("
021D: D448454E          	DB	0D4H,"HEN"
0221: CE4F54            	DB	0CEH,"OT"
0224: D3544550          	DB	0D3H,"TEP"
                        ;
0228: AB                	DB	0ABH
0229: AD                	DB	0ADH
022A: AA                	DB	0AAH
022B: AF                	DB	0AFH
022C: DE                	DB	0DEH
022D: C14E44            	DB	0C1H,"ND"
0230: CF52              	DB	0CFH,"R"
0232: BE                	DB	0BEH
0233: BD                	DB	0BDH
0234: BC                	DB	0BCH
                        ;
0235: D3474E            	DB	0D3H,"GN"
0238: C94E54            	DB	0C9H,"NT"
023B: C14253            	DB	0C1H,"BS"
023E: D55352            	DB	0D5H,"SR"
0241: C65245            	DB	0C6H,"RE"
0244: C94E50            	DB	0C9H,"NP"
0247: D04F53            	DB	0D0H,"OS"
024A: D35152            	DB	0D3H,"QR"
024D: D24E44            	DB	0D2H,"ND"
0250: CC4F47            	DB	0CCH,"OG"
0253: C55850            	DB	0C5H,"XP"
0256: C34F53            	DB	0C3H,"OS"
0259: D3494E            	DB	0D3H,"IN"
025C: D4414E            	DB	0D4H,"AN"
025F: C1544E            	DB	0C1H,"TN"
0262: D045454B          	DB	0D0H,"EEK"
0266: C445454B          	DB	0C4H,"EEK"
026A: D04F494E          	DB	0D0H,"OINT"
026E: 54                
026F: CC454E            	DB	0CCH,"EN"
0272: D3545224          	DB	0D3H,"TR$"
0276: D6414C            	DB	0D6H,"AL"
0279: C15343            	DB	0C1H,"SC"
027C: C3485224          	DB	0C3H,"HR$"
0280: C8455824          	DB	0C8H,"EX$"
0284: C2494E24          	DB	0C2H,"IN$"
0288: CC454654          	DB	0CCH,"EFT$"
028C: 24                
028D: D2494748          	DB	0D2H,"IGHT$"
0291: 5424              
0293: CD494424          	DB	0CDH,"ID$"
0297: 80                	DB	80H		; End of list marker
                        ;
                        ; KEYWORD ADDRESS TABLE
                        ;
0298: 9208              WORDTB: DW	PEND
029A: 8F07              	DW	FOR
029C: 6A0C              	DW	NEXT
029E: DF09              	DW	DATA
02A0: 710B              	DW	INPUT
02A2: A60E              	DW	DIM
02A4: A00B              	DW	READ
02A6: F609              	DW	LET
02A8: 9C09              	DW	GOTO
02AA: 7F09              	DW	RUN
02AC: 6E0A              	DW	IF
02AE: 5808              	DW	RESTOR
02B0: 8B09              	DW	GOSUB
02B2: BA09              	DW	RETURN
02B4: E109              	DW	REM
02B6: 9008              	DW	STOP
02B8: DF13              	DW	POUT
02BA: 500A              	DW	ON
02BC: D108              	DW	NULL
02BE: E513              	DW	WAIT
02C0: 8410              	DW	DEF
02C2: 2E14              	DW	POKE
02C4: 761B              	DW	DOKE
02C6: E109              	DW	REM
02C8: 5C1B              	DW	LINES
02CA: 4F1B              	DW	CLS
02CC: 541B              	DW	WIDTH
02CE: 881C              	DW	MONITR
02D0: 9980              	DW	PSET
02D2: 9C80              	DW	RESET
02D4: 920A              	DW	PRINT
02D6: BE08              	DW	CONT
02D8: 0407              	DW	LIST
02DA: 3909              	DW	CLEAR
02DC: E109              	DW	REM
02DE: E109              	DW	REM
02E0: FC04              	DW	NEW
                        ;
                        ; RESERVED WORD TOKEN VALUES
                        ;
0080:                   ZEND	EQU	080H		; END
0081:                   ZFOR	EQU	081H		; FOR
0083:                   ZDATA	EQU	083H		; DATA
0088:                   ZGOTO	EQU	088H		; GOTO
008C:                   ZGOSUB	EQU	08CH		; GOSUB
008E:                   ZREM	EQU	08EH		; REM
009E:                   ZPRINT	EQU	09EH		; PRINT
00A4:                   ZNEW	EQU	0A4H		; NEW
                        ;
00A5:                   ZTAB	EQU	0A5H		; TAB
00A6:                   ZTO	EQU	0A6H		; TO
00A7:                   ZFN	EQU	0A7H		; FN
00A8:                   ZSPC	EQU	0A8H		; SPC
00A9:                   ZTHEN	EQU	0A9H		; THEN
00AA:                   ZNOT	EQU	0AAH		; NOT
00AB:                   ZSTEP	EQU	0ABH		; STEP
                        ;
00AC:                   ZPLUS	EQU	0ACH		; +
00AD:                   ZMINUS	EQU	0ADH		; -
00AE:                   ZTIMES	EQU	0AEH		; *
00AF:                   ZDIV	EQU	0AFH		; /
00B2:                   ZOR	EQU	0B2H		; OR
00B3:                   ZGTR	EQU	0B3H		; >
00B4:                   ZEQUAL	EQU	0B4H		; M
00B5:                   ZLTH	EQU	0B5H		; <
00B6:                   ZSGN	EQU	0B6H		; SGN
00C7:                   ZPOINT	EQU	0C7H		; POINT
00CF:                   ZLEFT	EQU	0CDH +2		; LEFT$
                        ;
                        ; ARITHMETIC PRECEDENCE TABLE
                        ;
02E2: 79                PRITAB: DB	79H		; Precedence value
02E3: 1818              	DW	PADD		; FPREG = <last> + FPREG
                        ;
02E5: 79                	DB	79H		; Precedence value
02E6: 4C14              	DW	PSUB		; FPREG = <last> - FPREG
                        ;
02E8: 7C                	DB	7CH		; Precedence value
02E9: 8A15              	DW	MULT		; PPREG = <last> * FPREG
                        ;
02EB: 7C                	DB	7CH		; Precedence value
02EC: EB15              	DW	DIV		; FPREG = <last> / FPREG
                        ;
02EE: 7F                	DB	7FH		; Precedence value
02EF: 3919              	DW	POWER		; FPREG = <last> ^ FPREG
                        ;
02F1: 50                	DB	50H		; Precedence value
02F2: FF0D              	DW	PAND		; FPREG = <last> AND FPREG
                        ;
02F4: 46                	DB	46H		; Precedence value
02F5: FE0D              	DW	POR		; FPREG = <last> OR FPREG
                        ;
                        ; BASIC ERROR CODE LIST
                        ;
02F7: 4E46              ERRORS: DB	"NF"		; NEXT without FOR
02F9: 534E              	DB	"SN"		; Syntax error
02FB: 5247              	DB	"RG"		; RETURN without GOSUB
02FD: 4F44              	DB	"OD"		; Out of DATA
02FF: 4643              	DB	"FC"		; Illegal function call
0301: 4F56              	DB	"OV"		; Overflow error
0303: 4F4D              	DB	"OM"		; Out of memory
0305: 554C              	DB	"UL"		; Undefined line
0307: 4253              	DB	"BS"		; Bad subscript
0309: 4444              	DB	"DD"		; Re-DIMensioned array
030B: 2F30              	DB	"/0"		; Division by zero
030D: 4944              	DB	"ID"		; Illegal direct
030F: 544D              	DB	"TM"		; Type mis-match
0311: 4F53              	DB	"OS"		; Out of string space
0313: 4C53              	DB	"LS"		; String too long
0315: 5354              	DB	"ST"		; String formula too complex
0317: 434E              	DB	"CN"		; Can't CONTinue
0319: 5546              	DB	"UF"		; Undefined FN function
031B: 4D4F              	DB	"MO"		; Missing operand
031D: 4858              	DB	"HX"		; HEX error
031F: 424E              	DB	"BN"		; BIN error
                        ;
                        ; INITIALISATION TABLE -------------------------------------------------------
                        ;
0321: C3B700   [10]     INITAB: JP	WARMST		; Warm start jump
0324: C30F09   [20]     	JP	FCERR		; "USR (X)" jump (Set to Error)
0327: D300     [31]     	OUT	(0),A		; "OUT p,n" skeleton
0329: C9       [41]     	RET
032A: D600     [48]     	SUB	0		; Division support routine
032C: 6F       [52]     	LD	L,A
032D: 7C       [56]     	LD	A,H
032E: DE00     [63]     	SBC	A,0
0330: 67       [67]     	LD	H,A
0331: 78       [71]     	LD	A,B
0332: DE00     [78]     	SBC	A,0
0334: 47       [82]     	LD	B,A
0335: 3E00     [89]     	LD	A,0
0337: C9       [99]     	RET
0338: 000000            	DB	0,0,0			; Random number seed table used by RND
033B: 354ACA99          	DB	035H,04AH,0CAH,099H	;-2.65145E+07
033F: 391C7698          	DB	039H,01CH,076H,098H	; 1.61291E+07
0343: 2295B398          	DB	022H,095H,0B3H,098H	;-1.17691E+07
0347: 0ADD4798          	DB	00AH,0DDH,047H,098H	; 1.30983E+07
034B: 53D19999          	DB	053H,0D1H,099H,099H	;-2-01612E+07
034F: 0A1A9F98          	DB	00AH,01AH,09FH,098H	;-1.04269E+07
0353: 65BCCD98          	DB	065H,0BCH,0CDH,098H	;-1.34831E+07
0357: D6773E98          	DB	0D6H,077H,03EH,098H	; 1.24825E+07
035B: 52C74F80          	DB	052H,0C7H,04FH,080H	; Last random number
035F: DB00     [110]    	IN	A,(0)		; INP (x) skeleton
0361: C9       [120]    	RET
0362: 01                	DB	1		; POS (x) number (1)
0363: FF                	DB	255		; Terminal width (255 = no auto CRLF)
0364: 1C                	DB	28		; Width for commas (3 columns)
0365: 00                	DB	0		; No nulls after input bytes
0366: 00                	DB	0		; Output enabled (^O off)
0367: 1400              	DW	20		; Initial lines counter
0369: 1400              	DW	20		; Initial lines number
036B: 0000              	DW	0		; Array load/save check sum
036D: 00                	DB	0		; Break not by NMI
036E: 00                	DB	0		; Break flag
036F: C33506   [130]    	JP	TTYLIN		; Input reflection (set to TTY)
0372: C30000   [140]    	JP	0000H		; POINT reflection unused
0375: C30000   [150]    	JP	0000H		; SET reflection
0378: C30000   [160]    	JP	0000H			; RESET reflection
037B: A281              	DW	STLOOK		; Temp string space
037D: FEFF              	DW	-2		; Current line number (cold)
037F: 3F81              	DW	PROGST+1	; Start of program text
0381:                   INITBE:			 
                        ;
                        ; END OF INITIALISATION TABLE ---------------------------------------------------
                        ;
0381: 20457272          ERRMSG: DB	" Error",0
0385: 6F7200            
0388: 20696E20          INMSG:	DB	" in ",0
038C: 00                
038C:                   ZERBYT	EQU	$-1		; A zero byte
038D: 4F6B0D0A          OKMSG:	DB	"Ok",CR,LF,0,0
0391: 0000              
0393: 42726561          BRKMSG: DB	"Break",0
0397: 6B00              
                        ;
0399: 210400   [10]     BAKSTK: LD	HL,4		; Look for "FOR" block with
039C: 39       [21]     	ADD	HL,SP		; same index as specified
039D: 7E       [ 7]     LOKFOR: LD	A,(HL)		; Get block ID
039E: 23       [13]     	INC	HL		; Point to index address
039F: FE81     [20]     	CP	ZFOR		; Is it a "FOR" token
03A1: C0       [25|31]  	RET	NZ		; No - exit
03A2: 4E       [32]     	LD	C,(HL)		; BC = Address of "FOR" index
03A3: 23       [38]     	INC	HL
03A4: 46       [45]     	LD	B,(HL)
03A5: 23       [51]     	INC	HL		; Point to sign of STEP
03A6: E5       [62]     	PUSH	HL		; Save pointer to sign
03A7: 69       [66]     	LD	L,C		; HL = address of "FOR" index
03A8: 60       [70]     	LD	H,B
03A9: 7A       [74]     	LD	A,D		; See if an index was specified
03AA: B3       [78]     	OR	E		; DE = 0 if no index specified
03AB: EB       [82]     	EX	DE,HL		; Specified index into HL
03AC: CAB303   [92|92]  	JP	Z,INDFND	; Skip if no index given
03AF: EB       [96]     	EX	DE,HL		; Index back into DE
03B0: CDB806   [113]    	CALL	CPDEHL		; Compare index with one given
03B3: 010D00   [10]     INDFND: LD	BC,16-3		; Offset to next block
03B6: E1       [20]     	POP	HL		; Restore pointer to sign
03B7: C8       [25|31]  	RET	Z		; Return if block found
03B8: 09       [36]     	ADD	HL,BC		; Point to next block
03B9: C39D03   [46]     	JP	LOKFOR		; Keep on looking
                        ;
03BC: CDD603   [17]     MOVUP:	CALL	ENFMEM		; See if enough memory
03BF: C5       [11]     MOVSTR: PUSH	BC		; Save end of source
03C0: E3       [30]     	EX	(SP),HL		; Swap source and dest" end
03C1: C1       [40]     	POP	BC		; Get end of destination
03C2: CDB806   [17]     MOVLP:	CALL	CPDEHL		; See if list moved
03C5: 7E       [24]     	LD	A,(HL)		; Get byte
03C6: 02       [31]     	LD	(BC),A		; Move it
03C7: C8       [36|42]  	RET	Z		; Exit if all done
03C8: 0B       [42]     	DEC	BC		; Next byte to move to
03C9: 2B       [48]     	DEC	HL		; Next byte to move
03CA: C3C203   [58]     	JP	MOVLP		; Loop until all bytes moved
                        ;
03CD: E5       [11]     CHKSTK: PUSH	HL		; Save code string address
03CE: 2A1F81   [27]     	LD	HL,(ARREND)	; Lowest free memory
03D1: 0600     [34]     	LD	B,0		; BC = Number of levels to test
03D3: 09       [45]     	ADD	HL,BC		; 2 Bytes for each level
03D4: 09       [56]     	ADD	HL,BC
03D5: 3E                	DB	3EH		; Skip "PUSH HL"
03D6: E5       [11]     ENFMEM: PUSH	HL		; Save code string address
03D7: 3ED0     [18]     	LD	A,0D0H		; LOW -48; 48 Bytes minimum RAM
03D9: 95       [22]     	SUB	L
03DA: 6F       [26]     	LD	L,A
03DB: 3EFF     [33]     	LD	A,0FFH		; HIGH (-48); 48 Bytes minimum RAM
03DD: 9C       [37]     	SBC	A,H
03DE: DAE503   [47|47]  	JP	C,OMERR		; Not enough - ?OM Error
03E1: 67       [51]     	LD	H,A
03E2: 39       [62]     	ADD	HL,SP		; Test if stack is overflowed
03E3: E1       [72]     	POP	HL		; Restore code string address
03E4: D8       [77|83]  	RET	C		; Return if enough mmory
03E5: 1E0C     [ 7]     OMERR:	LD	E,OM		; ?OM Error
03E7: C30404   [17]     	JP	ERROR
                        ;
03EA: 2A0E81   [16]     DATSNR: LD	HL,(DATLIN)	; Get line of current DATA item
03ED: 22A180   [32]     	LD	(LINEAT),HL	; Save as current line
03F0: 1E02     [ 7]     SNERR:	LD	E,SN		; ?SN Error
03F2: 01                	DB	01H		; Skip "LD E,DZ"
03F3: 1E14     [ 7]     DZERR:	LD	E,DZ		; ?/0 Error
03F5: 01                	DB	01H		; Skip "LD E,NF"
03F6: 1E00     [ 7]     NFERR:	LD	E,NF		; ?NF Error
03F8: 01                	DB	01H		; Skip "LD E,RD"
03F9: 1E12     [ 7]     DDERR:	LD	E,RD		; ?DD Error
03FB: 01                	DB	01H		; Skip "LD E,UF"
03FC: 1E22     [ 7]     UFERR:	LD	E,UF		; ?UF Error
03FE: 01                	DB	01H		; Skip "LD E,OV
03FF: 1E0A     [ 7]     OVERR:	LD	E,OV		; ?OV Error
0401: 01                	DB	01H		; Skip "LD E,TM"
0402: 1E18     [ 7]     TMERR:	LD	E,TM		; ?TM Error
                        ;
0404: CD2205   [17]     ERROR:	CALL	CLREG		; Clear registers and stack
0407: 328A80   [30]     	LD	(CTLOFG),A	; Enable output (A is 0)
040A: CDE30A   [47]     	CALL	STTLIN		; Start new line
040D: 21F702   [57]     	LD	HL,ERRORS	; Point to error codes
0410: 57       [61]     	LD	D,A		; D = 0 (A is 0)
0411: 3E3F     [68]     	LD	A,'?'
0413: CDC906   [85]     	CALL	OUTC		; Output '?'
0416: 19       [96]     	ADD	HL,DE		; Offset to correct error code
0417: 7E       [103]    	LD	A,(HL)		; First character
0418: CDC906   [120]    	CALL	OUTC		; Output it
041B: CD4808   [137]    	CALL	GETCHR		; Get next character
041E: CDC906   [154]    	CALL	OUTC		; Output it
0421: 218103   [164]    	LD	HL,ERRMSG	; "Error" message
0424: CD8E11   [17]     ERRIN:	CALL	PRS		; Output message
0427: 2AA180   [33]     	LD	HL,(LINEAT)	; Get line of error
042A: 11FEFF   [43]     	LD	DE,-2		; Cold start error if -2
042D: CDB806   [60]     	CALL	CPDEHL		; See if cold start error
0430: CA4900   [70|70]  	JP	Z,CSTART	; Cold start error - Restart
0433: 7C       [74]     	LD	A,H		; Was it a direct error?
0434: A5       [78]     	AND	L		; Line = -1 if direct error
0435: 3C       [82]     	INC	A
0436: C42918   [92|99]  	CALL	NZ,LINEIN	; No - output line of error
0439: 3E                	DB	3EH		; Skip "POP BC"
043A: C1       [10]     POPNOK: POP	BC		; Drop address in input buffer
                        ;
043B: AF       [ 4]     PRNTOK: XOR	A		; Output "Ok" and get command
043C: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
043F: CDE30A   [34]     	CALL	STTLIN		; Start new line
0442: 218D03   [44]     	LD	HL,OKMSG	; "Ok" message
0445: CD8E11   [61]     	CALL	PRS		; Output "Ok"
0448: 21FFFF   [10]     GETCMD: LD	HL,-1		; Flag direct mode
044B: 22A180   [26]     	LD	(LINEAT),HL	; Save as current line
044E: CD3506   [43]     	CALL	GETLIN		; Get an input line
0451: DA4804   [53|53]  	JP	C,GETCMD	; Get line again if break
0454: CD4808   [70]     	CALL	GETCHR		; Get first character
0457: 3C       [74]     	INC	A		; Test if end of line
0458: 3D       [78]     	DEC	A		; Without affecting Carry
0459: CA4804   [88|88]  	JP	Z,GETCMD	; Nothing entered - Get another
045C: F5       [99]     	PUSH	AF		; Save Carry status
045D: CD1409   [116]    	CALL	ATOH		; Get line number into DE
0460: D5       [127]    	PUSH	DE		; Save line number
0461: CD4C05   [144]    	CALL	CRUNCH		; Tokenise rest of line
0464: 47       [148]    	LD	B,A		; Length of tokenised line
0465: D1       [158]    	POP	DE		; Restore line number
0466: F1       [168]    	POP	AF		; Restore Carry
0467: D22808   [178|178]	JP	NC,EXCUTE	; No line number - Direct mode
046A: D5       [189]    	PUSH	DE		; Save line number
046B: C5       [200]    	PUSH	BC		; Save length of tokenised line
046C: AF       [204]    	XOR	A
046D: 321181   [217]    	LD	(LSTBIN),A	; Clear last byte input
0470: CD4808   [234]    	CALL	GETCHR		; Get next character
0473: B7       [238]    	OR	A		; Set flags
0474: F5       [249]    	PUSH	AF		; And save them
0475: CDDC04   [266]    	CALL	SRCHLN		; Search for line number in DE
0478: DA8104   [276|276]	JP	C,LINFND	; Jump if line found
047B: F1       [286]    	POP	AF		; Get status
047C: F5       [297]    	PUSH	AF		; And re-save
047D: CAB509   [307|307]	JP	Z,ULERR	; Nothing after number - Error
0480: B7       [311]    	OR	A		; Clear Carry
0481: C5       [11]     LINFND: PUSH	BC		; Save address of line in prog
0482: D29804   [21|21]  	JP	NC,INEWLN	; Line not found - Insert new
0485: EB       [25]     	EX	DE,HL		; Next line address in DE
0486: 2A1B81   [41]     	LD	HL,(PROGND)	; End of program
0489: 1A       [ 7]     SFTPRG: LD	A,(DE)		; Shift rest of program down
048A: 02       [14]     	LD	(BC),A
048B: 03       [20]     	INC	BC		; Next destination
048C: 13       [26]     	INC	DE		; Next source
048D: CDB806   [43]     	CALL	CPDEHL		; All done?
0490: C28904   [53|53]  	JP	NZ,SFTPRG	; More to do
0493: 60       [57]     	LD	H,B		; HL - New end of program
0494: 69       [61]     	LD	L,C
0495: 221B81   [77]     	LD	(PROGND),HL	; Update end of program
                        ;
0498: D1       [10]     INEWLN: POP	DE		; Get address of line,
0499: F1       [20]     	POP	AF		; Get status
049A: CABF04   [30|30]  	JP	Z,SETPTR	; No text - Set up pointers
049D: 2A1B81   [46]     	LD	HL,(PROGND)	; Get end of program
04A0: E3       [65]     	EX	(SP),HL		; Get length of input line
04A1: C1       [75]     	POP	BC		; End of program to BC
04A2: 09       [86]     	ADD	HL,BC		; Find new end
04A3: E5       [97]     	PUSH	HL		; Save new end
04A4: CDBC03   [114]    	CALL	MOVUP		; Make space for line
04A7: E1       [124]    	POP	HL		; Restore new end
04A8: 221B81   [140]    	LD	(PROGND),HL	; Update end of program pointer
04AB: EB       [144]    	EX	DE,HL		; Get line to move up in HL
04AC: 74       [151]    	LD	(HL),H		; Save MSB
04AD: D1       [161]    	POP	DE		; Get new line number
04AE: 23       [167]    	INC	HL		; Skip pointer
04AF: 23       [173]    	INC	HL
04B0: 73       [180]    	LD	(HL),E		; Save LSB of line number
04B1: 23       [186]    	INC	HL
04B2: 72       [193]    	LD	(HL),D		; Save MSB of line number
04B3: 23       [199]    	INC	HL		; To first byte in line
04B4: 11A680   [209]    	LD	DE,BUFFER	; Copy buffer to program
04B7: 1A       [ 7]     MOVBUF: LD	A,(DE)		; Get source
04B8: 77       [14]     	LD	(HL),A		; Save destinations
04B9: 23       [20]     	INC	HL		; Next source
04BA: 13       [26]     	INC	DE		; Next destination
04BB: B7       [30]     	OR	A		; Done?
04BC: C2B704   [40|40]  	JP	NZ,MOVBUF	; No - Repeat
04BF: CD0805   [17]     SETPTR: CALL	RUNFST		; Set line pointers
04C2: 23       [23]     	INC	HL		; To LSB of pointer
04C3: EB       [27]     	EX	DE,HL		; Address to DE
04C4: 62       [ 4]     PTRLP:	LD	H,D		; Address to HL
04C5: 6B       [ 8]     	LD	L,E
04C6: 7E       [15]     	LD	A,(HL)		; Get LSB of pointer
04C7: 23       [21]     	INC	HL		; To MSB of pointer
04C8: B6       [28]     	OR	(HL)		; Compare with MSB pointer
04C9: CA4804   [38|38]  	JP	Z,GETCMD	; Get command line if end
04CC: 23       [44]     	INC	HL		; To LSB of line number
04CD: 23       [50]     	INC	HL		; Skip line number
04CE: 23       [56]     	INC	HL		; Point to first byte in line
04CF: AF       [60]     	XOR	A		; Looking for 00 byte
04D0: BE       [ 7]     FNDEND: CP	(HL)		; Found end of line?
04D1: 23       [13]     	INC	HL		; Move to next byte
04D2: C2D004   [23|23]  	JP	NZ,FNDEND	; No - Keep looking
04D5: EB       [27]     	EX	DE,HL		; Next line address to HL
04D6: 73       [34]     	LD	(HL),E		; Save LSB of pointer
04D7: 23       [40]     	INC	HL
04D8: 72       [47]     	LD	(HL),D		; Save MSB of pointer
04D9: C3C404   [57]     	JP	PTRLP		; Do next line
                        ;
04DC: 2AA380   [16]     SRCHLN: LD	HL,(BASTXT)	; Start of program text
04DF: 44       [ 4]     SRCHLP: LD	B,H		; BC = Address to look at
04E0: 4D       [ 8]     	LD	C,L
04E1: 7E       [15]     	LD	A,(HL)		; Get address of next line
04E2: 23       [21]     	INC	HL
04E3: B6       [28]     	OR	(HL)		; End of program found?
04E4: 2B       [34]     	DEC	HL
04E5: C8       [39|45]  	RET	Z		; Yes - Line not found
04E6: 23       [45]     	INC	HL
04E7: 23       [51]     	INC	HL
04E8: 7E       [58]     	LD	A,(HL)		; Get LSB of line number
04E9: 23       [64]     	INC	HL
04EA: 66       [71]     	LD	H,(HL)		; Get MSB of line number
04EB: 6F       [75]     	LD	L,A
04EC: CDB806   [92]     	CALL	CPDEHL		; Compare with line in DE
04EF: 60       [96]     	LD	H,B		; HL = Start of this line
04F0: 69       [100]    	LD	L,C
04F1: 7E       [107]    	LD	A,(HL)		; Get LSB of next line address
04F2: 23       [113]    	INC	HL
04F3: 66       [120]    	LD	H,(HL)		; Get MSB of next line address
04F4: 6F       [124]    	LD	L,A		; Next line to HL
04F5: 3F       [128]    	CCF
04F6: C8       [133|139]	RET	Z		; Lines found - Exit
04F7: 3F       [137]    	CCF
04F8: D0       [142|148]	RET	NC		; Line not found,at line after
04F9: C3DF04   [152]    	JP	SRCHLP		; Keep looking
                        ;
04FC: C0       [ 5|11]  NEW:	RET	NZ		; Return if any more on line
04FD: 2AA380   [16]     CLRPTR: LD	HL,(BASTXT)	; Point to start of program
0500: AF       [20]     	XOR	A		; Set program area to empty
0501: 77       [27]     	LD	(HL),A		; Save LSB = 00
0502: 23       [33]     	INC	HL
0503: 77       [40]     	LD	(HL),A		; Save MSB = 00
0504: 23       [46]     	INC	HL
0505: 221B81   [62]     	LD	(PROGND),HL	; Set program end
                        ;
0508: 2AA380   [16]     RUNFST: LD	HL,(BASTXT)	; Clear all variables
050B: 2B       [22]     	DEC	HL
                        ;
050C: 221381   [16]     INTVAR: LD	(BRKLIN),HL	; Initialise RUN variables
050F: 2AF480   [32]     	LD	HL,(LSTRAM)	; Get end of RAM
0512: 220881   [48]     	LD	(STRBOT),HL	; Clear string space
0515: AF       [52]     	XOR	A
0516: CD5808   [69]     	CALL	RESTOR		; Reset DATA pointers
0519: 2A1B81   [85]     	LD	HL,(PROGND)	; Get end of program
051C: 221D81   [101]    	LD	(VAREND),HL	; Clear variables
051F: 221F81   [117]    	LD	(ARREND),HL	; Clear arrays
                        ;
0522: C1       [10]     CLREG:	POP	BC		; Save return address
0523: 2A9F80   [26]     	LD	HL,(STRSPC)	; Get end of working RAN
0526: F9       [32]     	LD	SP,HL		; Set stack
0527: 21F880   [42]     	LD	HL,TMSTPL	; Temporary string pool
052A: 22F680   [58]     	LD	(TMSTPT),HL	; Reset temporary string ptr
052D: AF       [62]     	XOR	A		; A = 00
052E: 6F       [66]     	LD	L,A		; HL = 0000
052F: 67       [70]     	LD	H,A
0530: 221981   [86]     	LD	(CONTAD),HL	; No CONTinue
0533: 321081   [99]     	LD	(FORFLG),A	; Clear FOR flag
0536: 222381   [115]    	LD	(FNRGNM),HL	; Clear FN argument
0539: E5       [126]    	PUSH	HL		; HL = 0000
053A: C5       [137]    	PUSH	BC		; Put back return
053B: 2A1381   [16]     DOAGN:	LD	HL,(BRKLIN)	; Get address of code to RUN
053E: C9       [26]     	RET			; Return to execution driver
                        ;
053F: 3E3F     [ 7]     PROMPT: LD	A,'?'		; '?'
0541: CDC906   [24]     	CALL	OUTC		; Output character
0544: 3E20     [31]     	LD	A,' '		; Space
0546: CDC906   [48]     	CALL	OUTC		; Output character
0549: C39380   [58]     	JP	RINPUT		; Get input line
                        ;
054C: AF       [ 4]     CRUNCH: XOR	A		; Tokenise line @ HL to BUFFER
054D: 32F380   [17]     	LD	(DATFLG),A	; Reset literal flag
0550: 0E05     [24]     	LD	C,2+3		; 2 byte number and 3 nulls
0552: 11A680   [34]     	LD	DE,BUFFER	; Start of input buffer
0555: 7E       [ 7]     CRNCLP: LD	A,(HL)		; Get byte
0556: FE20     [14]     	CP	' '		; Is it a space?
0558: CAD405   [24|24]  	JP	Z,MOVDIR	; Yes - Copy direct
055B: 47       [28]     	LD	B,A		; Save character
055C: FE22     [35]     	CP	'"'		; Is it a quote?
055E: CAF405   [45|45]  	JP	Z,CPYLIT	; Yes - Copy literal string
0561: B7       [49]     	OR	A		; Is it end of buffer?
0562: CAFB05   [59|59]  	JP	Z,ENDBUF	; Yes - End buffer
0565: 3AF380   [72]     	LD	A,(DATFLG)	; Get data type
0568: B7       [76]     	OR	A		; Literal?
0569: 7E       [83]     	LD	A,(HL)		; Get byte to copy
056A: C2D405   [93|93]  	JP	NZ,MOVDIR	; Literal - Copy direct
056D: FE3F     [100]    	CP	'?'		; Is it '?' short for PRINT
056F: 3E9E     [107]    	LD	A,ZPRINT	; "PRINT" token
0571: CAD405   [117|117]	JP	Z,MOVDIR	; Yes - replace it
0574: 7E       [124]    	LD	A,(HL)		; Get byte again
0575: FE30     [131]    	CP	'0'		; Is it less than '0'
0577: DA7F05   [141|141]	JP	C,FNDWRD	; Yes - Look for reserved words
057A: FE3C     [148]    	CP	60		; ";"+1; Is it "0123456789:;" ?
057C: DAD405   [158|158]	JP	C,MOVDIR	; Yes - copy it direct
057F: D5       [11]     FNDWRD: PUSH	DE		; Look for reserved words
0580: 117801   [21]     	LD	DE,WORDS-1	; Point to table
0583: C5       [32]     	PUSH	BC		; Save count
0584: 01D005   [42]     	LD	BC,RETNAD	; Where to return to
0587: C5       [53]     	PUSH	BC		; Save return address
0588: 067F     [60]     	LD	B,ZEND-1	; First token value -1
058A: 7E       [67]     	LD	A,(HL)		; Get byte
058B: FE61     [74]     	CP	'a'		; Less than 'a' ?
058D: DA9805   [84|84]  	JP	C,SEARCH	; Yes - search for words
0590: FE7B     [91]     	CP	'z'+1		; Greater than 'z' ?
0592: D29805   [101|101]	JP	NC,SEARCH	; Yes - search for words
0595: E65F     [108]    	AND	01011111B	; Force upper case
0597: 77       [115]    	LD	(HL),A		; Replace byte
0598: 4E       [ 7]     SEARCH: LD	C,(HL)		; Search for a word
0599: EB       [11]     	EX	DE,HL
059A: 23       [ 6]     GETNXT: INC	HL		; Get next reserved word
059B: B6       [13]     	OR	(HL)		; Start of word?
059C: F29A05   [23|23]  	JP	P,GETNXT	; No - move on
059F: 04       [27]     	INC	B		; Increment token value
05A0: 7E       [34]     	LD	A, (HL)		; Get byte from table
05A1: E67F     [41]     	AND	01111111B	; Strip bit 7
05A3: C8       [46|52]  	RET	Z		; Return if end of list
05A4: B9       [50]     	CP	C		; Same character as in buffer?
05A5: C29A05   [60|60]  	JP	NZ,GETNXT	; No - get next word
05A8: EB       [64]     	EX	DE,HL
05A9: E5       [75]     	PUSH	HL		; Save start of word
                        ;
05AA: 13       [ 6]     NXTBYT: INC	DE		; Look through rest of word
05AB: 1A       [13]     	LD	A,(DE)		; Get byte from table
05AC: B7       [17]     	OR	A		; End of word ?
05AD: FACC05   [27|27]  	JP	M,MATCH		; Yes - Match found
05B0: 4F       [31]     	LD	C,A		; Save it
05B1: 78       [35]     	LD	A,B		; Get token value
05B2: FE88     [42]     	CP	ZGOTO		; Is it "GOTO" token ?
05B4: C2BB05   [52|52]  	JP	NZ,NOSPC	; No - Don't allow spaces
05B7: CD4808   [69]     	CALL	GETCHR		; Get next character
05BA: 2B       [75]     	DEC	HL		; Cancel increment from GETCHR
05BB: 23       [ 6]     NOSPC:	INC	HL		; Next byte
05BC: 7E       [13]     	LD	A,(HL)		; Get byte
05BD: FE61     [20]     	CP	'a'		; Less than 'a' ?
05BF: DAC405   [30|30]  	JP	C,NOCHNG	; Yes - don't change
05C2: E65F     [37]     	AND	01011111B	; Make upper case
05C4: B9       [ 4]     NOCHNG: CP	C		; Same as in buffer ?
05C5: CAAA05   [14|14]  	JP	Z,NXTBYT	; Yes - keep testing
05C8: E1       [24]     	POP	HL		; Get back start of word
05C9: C39805   [34]     	JP	SEARCH		; Look at next word
                        ;
05CC: 48       [ 4]     MATCH:	LD	C,B		; Word found - Save token value
05CD: F1       [14]     	POP	AF		; Throw away return
05CE: EB       [18]     	EX	DE,HL
05CF: C9       [28]     	RET			; Return to "RETNAD"
05D0: EB       [ 4]     RETNAD: EX	DE,HL		; Get address in string
05D1: 79       [ 8]     	LD	A,C		; Get token value
05D2: C1       [18]     	POP	BC		; Restore buffer length
05D3: D1       [28]     	POP	DE		; Get destination address
05D4: 23       [ 6]     MOVDIR: INC	HL		; Next source in buffer
05D5: 12       [13]     	LD	(DE),A		; Put byte in buffer
05D6: 13       [19]     	INC	DE		; Move up buffer
05D7: 0C       [23]     	INC	C		; Increment length of buffer
05D8: D63A     [30]     	SUB	':'		; End of statement?
05DA: CAE205   [40|40]  	JP	Z,SETLIT	; Jump if multi-statement line
05DD: FE49     [47]     	CP	ZDATA-3AH	; Is it DATA statement ?
05DF: C2E505   [57|57]  	JP	NZ,TSTREM	; No - see if REM
05E2: 32F380   [13]     SETLIT: LD	(DATFLG),A	; Set literal flag
05E5: D654     [ 7]     TSTREM: SUB	ZREM-3AH	; Is it REM?
05E7: C25505   [17|17]  	JP	NZ,CRNCLP	; No - Leave flag
05EA: 47       [21]     	LD	B,A		; Copy rest of buffer
05EB: 7E       [ 7]     NXTCHR: LD	A,(HL)		; Get byte
05EC: B7       [11]     	OR	A		; End of line ?
05ED: CAFB05   [21|21]  	JP	Z,ENDBUF	; Yes - Terminate buffer
05F0: B8       [25]     	CP	B		; End of statement ?
05F1: CAD405   [35|35]  	JP	Z,MOVDIR	; Yes - Get next one
05F4: 23       [ 6]     CPYLIT: INC	HL		; Move up source string
05F5: 12       [13]     	LD	(DE),A		; Save in destination
05F6: 0C       [17]     	INC	C		; Increment length
05F7: 13       [23]     	INC	DE		; Move up destination
05F8: C3EB05   [33]     	JP	NXTCHR		; Repeat
                        ;
05FB: 21A580   [10]     ENDBUF: LD	HL,BUFFER-1	; Point to start of buffer
05FE: 12       [17]     	LD	(DE),A		; Mark end of buffer (A = 00)
05FF: 13       [23]     	INC	DE
0600: 12       [30]     	LD	(DE),A		; A = 00
0601: 13       [36]     	INC	DE
0602: 12       [43]     	LD	(DE),A		; A = 00
0603: C9       [53]     	RET
                        ;
0604: 3A8980   [13]     DODEL:	LD	A,(NULFLG)	; Get null flag status
0607: B7       [17]     	OR	A		; Is it zero?
0608: 3E00     [24]     	LD	A,0		; Zero A - Leave flags
060A: 328980   [37]     	LD	(NULFLG),A	; Zero null flag
060D: C21806   [47|47]  	JP	NZ,ECHDEL	; Set - Echo it
0610: 05       [51]     	DEC	B		; Decrement length
0611: CA3506   [61|61]  	JP	Z,GETLIN	; Get line again if empty
0614: CDC906   [78]     	CALL	OUTC		; Output null character
0617: 3E                	DB	3EH		; Skip "DEC B"
0618: 05       [ 4]     ECHDEL: DEC	B		; Count bytes in buffer
0619: 2B       [10]     	DEC	HL		; Back space buffer
061A: CA2C06   [20|20]  	JP	Z,OTKLN		; No buffer - Try again
061D: 7E       [27]     	LD	A,(HL)		; Get deleted byte
061E: CDC906   [44]     	CALL	OUTC		; Echo it
0621: C33E06   [54]     	JP	MORINP		; Get more input
                        ;
0624: 05       [ 4]     DELCHR: DEC	B		; Count bytes in buffer
0625: 2B       [10]     	DEC	HL		; Back space buffer
0626: CDC906   [27]     	CALL	OUTC		; Output character in A
0629: C23E06   [37|37]  	JP	NZ,MORINP	; Not end - Get more
062C: CDC906   [17]     OTKLN:	CALL	OUTC		; Output character in A
062F: CDF00A   [17]     KILIN:	CALL	PRCRLF		; Output CRLF
0632: C33506   [27]     	JP	TTYLIN		; Get line again
                        ;
0635:                   GETLIN:
0635: 21A680   [10]     TTYLIN: LD	HL,BUFFER	; Get a line by character
0638: 0601     [17]     	LD	B,1		; Set buffer as empty
063A: AF       [21]     	XOR	A
063B: 328980   [34]     	LD	(NULFLG),A	; Clear null flag
063E: CDF306   [17]     MORINP: CALL	CLOTST		; Get character and test ^O
0641: 4F       [21]     	LD	C,A		; Save character in C
0642: FE7F     [28]     	CP	DEL		; Delete character?
0644: CA0406   [38|38]  	JP	Z,DODEL	; Yes - Process it
0647: 3A8980   [51]     	LD	A,(NULFLG)	; Get null flag
064A: B7       [55]     	OR	A		; Test null flag status
064B: CA5706   [65|65]  	JP	Z,PROCES	; Reset - Process character
064E: 3E00     [72]     	LD	A,0		; Set a null
0650: CDC906   [89]     	CALL	OUTC		; Output null
0653: AF       [93]     	XOR	A		; Clear A
0654: 328980   [106]    	LD	(NULFLG),A	; Reset null flag
0657: 79       [ 4]     PROCES: LD	A,C		; Get character
0658: FE07     [11]     	CP	CTRLG		; Bell?
065A: CA9B06   [21|21]  	JP	Z,PUTCTL	; Yes - Save it
065D: FE03     [28]     	CP	CTRLC		; Is it control "C"?
065F: CCF00A   [38|45]  	CALL	Z,PRCRLF	; Yes - Output CRLF
0662: 37       [42]     	SCF			; Flag break
0663: C8       [47|53]  	RET	Z		; Return if control "C"
0664: FE0D     [54]     	CP	CR		; Is it enter?
0666: CAEB0A   [64|64]  	JP	Z,ENDINP	; Yes - Terminate input
0669: FE15     [71]     	CP	CTRLU		; Is it control "U"?
066B: CA2F06   [81|81]  	JP	Z,KILIN		; Yes - Get another line
066E: FE40     [88]     	CP	'@'		; Is it "kill line"?
0670: CA2C06   [98|98]  	JP	Z,OTKLN		; Yes - Kill line
0673: FE5F     [105]    	CP	'_'		; Is it delete?
0675: CA2406   [115|115]	JP	Z,DELCHR	; Yes - Delete character
0678: FE08     [122]    	CP	BKSP		; Is it backspace?
067A: CA2406   [132|132]	JP	Z,DELCHR	; Yes - Delete character
067D: FE12     [139]    	CP	CTRLR		; Is it control "R"?
067F: C29606   [149|149]	JP	NZ,PUTBUF	; No - Put in buffer
0682: C5       [160]    	PUSH	BC		; Save buffer length
0683: D5       [171]    	PUSH	DE		; Save DE
0684: E5       [182]    	PUSH	HL		; Save buffer address
0685: 3600     [192]    	LD	(HL),0		; Mark end of buffer
0687: CD9A1C   [209]    	CALL	OUTNCR		; Output and do CRLF
068A: 21A680   [219]    	LD	HL,BUFFER	; Point to buffer start
068D: CD8E11   [236]    	CALL	PRS		; Output buffer
0690: E1       [246]    	POP	HL		; Restore buffer address
0691: D1       [256]    	POP	DE		; Restore DE
0692: C1       [266]    	POP	BC		; Restore buffer length
0693: C33E06   [276]    	JP	MORINP		; Get another character
                        ;
0696: FE20     [ 7]     PUTBUF: CP	' '		; Is it a control code?
0698: DA3E06   [17|17]  	JP	C,MORINP	; Yes - Ignore
069B: 78       [ 4]     PUTCTL: LD	A,B		; Get number of bytes in buffer
069C: FE49     [11]     	CP	72+1		; Test for line overflow
069E: 3E07     [18]     	LD	A,CTRLG		; Set a bell
06A0: D2B006   [28|28]  	JP	NC,OUTNBS	; Ring bell if buffer full
06A3: 79       [32]     	LD	A,C		; Get character
06A4: 71       [39]     	LD	(HL),C		; Save in buffer
06A5: 321181   [52]     	LD	(LSTBIN),A	; Save last input byte
06A8: 23       [58]     	INC	HL		; Move up buffer
06A9: 04       [62]     	INC	B		; Increment length
06AA: CDC906   [17]     OUTIT:	CALL	OUTC		; Output the character entered
06AD: C33E06   [27]     	JP	MORINP		; Get another character
                        ;
06B0: CDC906   [17]     OUTNBS: CALL	OUTC		; Output bell and back over it
06B3: 3E08     [24]     	LD	A,BKSP		; Set back space
06B5: C3AA06   [34]     	JP	OUTIT		; Output it and get more
                        ;
06B8: 7C       [ 4]     CPDEHL: LD	A,H		; Get H
06B9: 92       [ 8]     	SUB	D		; Compare with D
06BA: C0       [13|19]  	RET	NZ		; Different - Exit
06BB: 7D       [17]     	LD	A,L		; Get L
06BC: 93       [21]     	SUB	E		; Compare with E
06BD: C9       [31]     	RET			; Return status
                        ;
06BE: 7E       [ 7]     CHKSYN: LD	A,(HL)		; Check syntax of character
06BF: E3       [26]     	EX	(SP),HL		; Address of test byte
06C0: BE       [33]     	CP	(HL)		; Same as in code string?
06C1: 23       [39]     	INC	HL		; Return address
06C2: E3       [58]     	EX	(SP),HL		; Put it back
06C3: CA4808   [68|68]  	JP	Z,GETCHR	; Yes - Get next character
06C6: C3F003   [78]     	JP	SNERR		; Different - ?SN Error
                        ;
06C9: F5       [11]     OUTC:	PUSH	AF		; Save character
06CA: 3A8A80   [24]     	LD	A,(CTLOFG)	; Get control "O" flag
06CD: B7       [28]     	OR	A		; Is it set?
06CE: C2C311   [38|38]  	JP	NZ,POPAF	; Yes - don't output
06D1: F1       [48]     	POP	AF		; Restore character
06D2: C5       [59]     	PUSH	BC		; Save buffer length
06D3: F5       [70]     	PUSH	AF		; Save character
06D4: FE20     [77]     	CP	' '		; Is it a control code?
06D6: DAED06   [87|87]  	JP	C,DINPOS	; Yes - Don't INC POS(X)
06D9: 3A8780   [100]    	LD	A,(LWIDTH)	; Get line width
06DC: 47       [104]    	LD	B,A		; To B
06DD: 3AF080   [117]    	LD	A,(CURPOS)	; Get cursor position
06E0: 04       [121]    	INC	B		; Width 255?
06E1: CAE906   [131|131]	JP	Z,INCLEN	; Yes - No width limit
06E4: 05       [135]    	DEC	B		; Restore width
06E5: B8       [139]    	CP	B		; At end of line?
06E6: CCF00A   [149|156]	CALL	Z,PRCRLF	; Yes - output CRLF
06E9: 3C       [ 4]     INCLEN: INC	A		; Move on one character
06EA: 32F080   [17]     	LD	(CURPOS),A	; Save new position
06ED: F1       [10]     DINPOS: POP	AF		; Restore character
06EE: C1       [20]     	POP	BC		; Restore buffer length
06EF: CD851C   [37]     	CALL	MONOUT		; Send it
06F2: C9       [47]     	RET
                        ;
06F3: CD4D1B   [17]     CLOTST: CALL	GETINP		; Get input character
06F6: E67F     [24]     	AND	01111111B	; Strip bit 7
06F8: FE0F     [31]     	CP	CTRLO		; Is it control "O"?
06FA: C0       [36|42]  	RET	NZ		; No don't flip flag
06FB: 3A8A80   [49]     	LD	A,(CTLOFG)	; Get flag
06FE: 2F       [53]     	CPL			; Flip it
06FF: 328A80   [66]     	LD	(CTLOFG),A	; Put it back
0702: AF       [70]     	XOR	A		; Null character
0703: C9       [80]     	RET
                        ;
0704: CD1409   [17]     LIST:	CALL	ATOH		; ASCII number to DE
0707: C0       [22|28]  	RET	NZ		; Return if anything extra
0708: C1       [32]     	POP	BC		; Rubbish - Not needed
0709: CDDC04   [49]     	CALL	SRCHLN		; Search for line number in DE
070C: C5       [60]     	PUSH	BC		; Save address of line
070D: CD5A07   [77]     	CALL	SETLIN		; Set up lines counter
0710: E1       [10]     LISTLP: POP	HL		; Restore address of line
0711: 4E       [17]     	LD	C,(HL)		; Get LSB of next line
0712: 23       [23]     	INC	HL
0713: 46       [30]     	LD	B,(HL)		; Get MSB of next line
0714: 23       [36]     	INC	HL
0715: 78       [40]     	LD	A,B		; BC = 0 (End of program)?
0716: B1       [44]     	OR	C
0717: CA3B04   [54|54]  	JP	Z,PRNTOK	; Yes - Go to command mode
071A: CD6307   [71]     	CALL	COUNT		; Count lines
071D: CD7308   [88]     	CALL	TSTBRK		; Test for break key
0720: C5       [99]     	PUSH	BC		; Save address of next line
0721: CDF00A   [116]    	CALL	PRCRLF		; Output CRLF
0724: 5E       [123]    	LD	E,(HL)		; Get LSB of line number
0725: 23       [129]    	INC	HL
0726: 56       [136]    	LD	D,(HL)		; Get MSB of line number
0727: 23       [142]    	INC	HL
0728: E5       [153]    	PUSH	HL		; Save address of line start
0729: EB       [157]    	EX	DE,HL		; Line number to HL
072A: CD3118   [174]    	CALL	PRNTHL		; Output line number in decimal
072D: 3E20     [181]    	LD	A,' '		; Space after line number
072F: E1       [191]    	POP	HL		; Restore start of line address
0730: CDC906   [17]     LSTLP2: CALL	OUTC		; Output character in A
0733: 7E       [ 7]     LSTLP3: LD	A,(HL)		; Get next byte in line
0734: B7       [11]     	OR	A		; End of line?
0735: 23       [17]     	INC	HL		; To next byte in line
0736: CA1007   [27|27]  	JP	Z,LISTLP	; Yes - get next line
0739: F23007   [37|37]  	JP	P,LSTLP2	; No token - output it
073C: D67F     [44]     	SUB	ZEND-1		; Find and output word
073E: 4F       [48]     	LD	C,A		; Token offset+1 to C
073F: 117901   [58]     	LD	DE,WORDS	; Reserved word list
0742: 1A       [ 7]     FNDTOK: LD	A,(DE)		; Get character in list
0743: 13       [13]     	INC	DE		; Move on to next
0744: B7       [17]     	OR	A		; Is it start of word?
0745: F24207   [27|27]  	JP	P,FNDTOK	; No - Keep looking for word
0748: 0D       [31]     	DEC	C		; Count words
0749: C24207   [41|41]  	JP	NZ,FNDTOK	; Not there - keep looking
074C: E67F     [ 7]     OUTWRD: AND	01111111B	; Strip bit 7
074E: CDC906   [24]     	CALL	OUTC		; Output first character
0751: 1A       [31]     	LD	A,(DE)		; Get next character
0752: 13       [37]     	INC	DE		; Move on to next
0753: B7       [41]     	OR	A		; Is it end of word?
0754: F24C07   [51|51]  	JP	P,OUTWRD	; No - output the rest
0757: C33307   [61]     	JP	LSTLP3		; Next byte in line
                        ;
075A: E5       [11]     SETLIN: PUSH	HL		; Set up LINES counter
075B: 2A8D80   [27]     	LD	HL,(LINESN)	; Get LINES number
075E: 228B80   [43]     	LD	(LINESC),HL	; Save in LINES counter
0761: E1       [53]     	POP	HL
0762: C9       [63]     	RET
                        ;
0763: E5       [11]     COUNT:	PUSH	HL		; Save code string address
0764: D5       [22]     	PUSH	DE
0765: 2A8B80   [38]     	LD	HL,(LINESC)	; Get LINES counter
0768: 11FFFF   [48]     	LD	DE,-1
076B: ED5A     [63]     	ADC	HL,DE		; Decrement
076D: 228B80   [79]     	LD	(LINESC),HL	; Put it back
0770: D1       [89]     	POP	DE
0771: E1       [99]     	POP	HL		; Restore code string address
0772: F0       [104|110]	RET	P		; Return if more lines to go
0773: E5       [115]    	PUSH	HL		; Save code string address
0774: 2A8D80   [131]    	LD	HL,(LINESN)	; Get LINES number
0777: 228B80   [147]    	LD	(LINESC),HL	; Reset LINES counter
077A: CD4D1B   [164]    	CALL	GETINP		; Get input character
077D: FE03     [171]    	CP	CTRLC		; Is it control "C"?
077F: CA8607   [181|181]	JP	Z,RSLNBK	; Yes - Reset LINES and break
0782: E1       [191]    	POP	HL		; Restore code string address
0783: C36307   [201]    	JP	COUNT		; Keep on counting
                        ;
0786: 2A8D80   [16]     RSLNBK: LD	HL,(LINESN)	; Get LINES number
0789: 228B80   [32]     	LD	(LINESC),HL	; Reset LINES counter
078C: C3BA00   [42]     	JP	BRKRET		; Go and output "Break"
                        ;
078F: 3E64     [ 7]     FOR:	LD	A,64H		; Flag "FOR" assignment
0791: 321081   [20]     	LD	(FORFLG),A	; Save "FOR" flag
0794: CDF609   [37]     	CALL	LET		; Set up initial index
0797: C1       [47]     	POP	BC		; Drop RETurn address
0798: E5       [58]     	PUSH	HL		; Save code string address
0799: CDDF09   [75]     	CALL	DATA		; Get next statement address
079C: 220C81   [91]     	LD	(LOOPST),HL	; Save it for start of loop
079F: 210200   [101]    	LD	HL,2		; Offset for "FOR" block
07A2: 39       [112]    	ADD	HL,SP		; Point to it
07A3: CD9D03   [17]     FORSLP: CALL	LOKFOR		; Look for existing "FOR" block
07A6: D1       [27]     	POP	DE		; Get code string address
07A7: C2BF07   [37|37]  	JP	NZ,FORFND	; No nesting found
07AA: 09       [48]     	ADD	HL,BC		; Move into "FOR" block
07AB: D5       [59]     	PUSH	DE		; Save code string address
07AC: 2B       [65]     	DEC	HL
07AD: 56       [72]     	LD	D,(HL)		; Get MSB of loop statement
07AE: 2B       [78]     	DEC	HL
07AF: 5E       [85]     	LD	E,(HL)		; Get LSB of loop statement
07B0: 23       [91]     	INC	HL
07B1: 23       [97]     	INC	HL
07B2: E5       [108]    	PUSH	HL		; Save block address
07B3: 2A0C81   [124]    	LD	HL,(LOOPST)	; Get address of loop statement
07B6: CDB806   [141]    	CALL	CPDEHL		; Compare the FOR loops
07B9: E1       [151]    	POP	HL		; Restore block address
07BA: C2A307   [161|161]	JP	NZ,FORSLP	; Different FORs - Find another
07BD: D1       [171]    	POP	DE		; Restore code string address
07BE: F9       [177]    	LD	SP,HL		; Remove all nested loops
                        ;
07BF: EB       [ 4]     FORFND: EX	DE,HL		; Code string address to HL
07C0: 0E08     [11]     	LD	C,8
07C2: CDCD03   [28]     	CALL	CHKSTK		; Check for 8 levels of stack
07C5: E5       [39]     	PUSH	HL		; Save code string address
07C6: 2A0C81   [55]     	LD	HL,(LOOPST)	; Get first statement of loop
07C9: E3       [74]     	EX	(SP),HL		; Save and restore code string
07CA: E5       [85]     	PUSH	HL		; Re-save code string address
07CB: 2AA180   [101]    	LD	HL,(LINEAT)	; Get current line number
07CE: E3       [120]    	EX	(SP),HL		; Save and restore code string
07CF: CDB80C   [137]    	CALL	TSTNUM		; Make sure it's a number
07D2: CDBE06   [154]    	CALL	CHKSYN		; Make sure "TO" is next
07D5: A6                	DB	ZTO		; "TO" token
07D6: CDB50C   [171]    	CALL	GETNUM		; Get "TO" expression value
07D9: E5       [182]    	PUSH	HL		; Save code string address
07DA: CDE316   [199]    	CALL	BCDEFP		; Move "TO" value to BCDE
07DD: E1       [209]    	POP	HL		; Restore code string address
07DE: C5       [220]    	PUSH	BC		; Save "TO" value in block
07DF: D5       [231]    	PUSH	DE
07E0: 010081   [241]    	LD	BC,8100H	; BCDE - 1 (default STEP)
07E3: 51       [245]    	LD	D,C		; C=0
07E4: 5A       [249]    	LD	E,D		; D=0
07E5: 7E       [256]    	LD	A,(HL)		; Get next byte in code string
07E6: FEAB     [263]    	CP	ZSTEP		; See if "STEP" is stated
07E8: 3E01     [270]    	LD	A,1		; Sign of step = 1
07EA: C2FB07   [280|280]	JP	NZ,SAVSTP	; No STEP given - Default to 1
07ED: CD4808   [297]    	CALL	GETCHR		; Jump over "STEP" token
07F0: CDB50C   [314]    	CALL	GETNUM		; Get step value
07F3: E5       [325]    	PUSH	HL		; Save code string address
07F4: CDE316   [342]    	CALL	BCDEFP		; Move STEP to BCDE
07F7: CD9716   [359]    	CALL	TSTSGN		; Test sign of FPREG
07FA: E1       [369]    	POP	HL		; Restore code string address
07FB: C5       [11]     SAVSTP: PUSH	BC		; Save the STEP value in block
07FC: D5       [22]     	PUSH	DE
07FD: F5       [33]     	PUSH	AF		; Save sign of STEP
07FE: 33       [39]     	INC	SP		; Don't save flags
07FF: E5       [50]     	PUSH	HL		; Save code string address
0800: 2A1381   [66]     	LD	HL,(BRKLIN)	; Get address of index variable
0803: E3       [85]     	EX	(SP),HL		; Save and restore code string
0804: 0681     [ 7]     PUTFID: LD	B,ZFOR		; "FOR" block marker
0806: C5       [18]     	PUSH	BC		; Save it
0807: 33       [24]     	INC	SP		; Don't save C
                        ;
0808: CD7308   [17]     RUNCNT: CALL	TSTBRK		; Execution driver - Test break
080B: 221381   [33]     	LD	(BRKLIN),HL	; Save code address for break
080E: 7E       [40]     	LD	A,(HL)		; Get next byte in code string
080F: FE3A     [47]     	CP	':'		; Multi statement line?
0811: CA2808   [57|57]  	JP	Z,EXCUTE	; Yes - Execute it
0814: B7       [61]     	OR	A		; End of line?
0815: C2F003   [71|71]  	JP	NZ,SNERR	; No - Syntax error
0818: 23       [77]     	INC	HL		; Point to address of next line
0819: 7E       [84]     	LD	A,(HL)		; Get LSB of line pointer
081A: 23       [90]     	INC	HL
081B: B6       [97]     	OR	(HL)		; Is it zero (End of prog)?
081C: CA9A08   [107|107]	JP	Z,ENDPRG	; Yes - Terminate execution
081F: 23       [113]    	INC	HL		; Point to line number
0820: 5E       [120]    	LD	E,(HL)		; Get LSB of line number
0821: 23       [126]    	INC	HL
0822: 56       [133]    	LD	D,(HL)		; Get MSB of line number
0823: EB       [137]    	EX	DE,HL		; Line number to HL
0824: 22A180   [153]    	LD	(LINEAT),HL	; Save as current line number
0827: EB       [157]    	EX	DE,HL		; Line number back to DE
0828: CD4808   [17]     EXCUTE: CALL	GETCHR		; Get key word
082B: 110808   [27]     	LD	DE,RUNCNT	; Where to RETurn to
082E: D5       [38]     	PUSH	DE		; Save for RETurn
082F: C8       [ 5|11]  IFJMP:	RET	Z		; Go to RUNCNT if end of STMT
0830: D680     [ 7]     ONJMP:	SUB	ZEND		; Is it a token?
0832: DAF609   [17|17]  	JP	C,LET		; No - try to assign it
0835: FE25     [24]     	CP	ZNEW+1-ZEND	; END to NEW ?
0837: D2F003   [34|34]  	JP	NC,SNERR	; Not a key word - ?SN Error
083A: 07       [38]     	RLCA			; Double it
083B: 4F       [42]     	LD	C,A		; BC = Offset into table
083C: 0600     [49]     	LD	B,0
083E: EB       [53]     	EX	DE,HL		; Save code string address
083F: 219802   [63]     	LD	HL,WORDTB	; Keyword address table
0842: 09       [74]     	ADD	HL,BC		; Point to routine address
0843: 4E       [81]     	LD	C,(HL)		; Get LSB of routine address
0844: 23       [87]     	INC	HL
0845: 46       [94]     	LD	B,(HL)		; Get MSB of routine address
0846: C5       [105]    	PUSH	BC		; Save routine address
0847: EB       [109]    	EX	DE,HL		; Restore code string address
                        ;
0848: 23       [ 6]     GETCHR: INC	HL		; Point to next character
0849: 7E       [13]     	LD	A,(HL)		; Get next code string byte
084A: FE3A     [20]     	CP	':'		; Z if ':'
084C: D0       [25|31]  	RET	NC		; NC if > "9"
084D: FE20     [32]     	CP	' '
084F: CA4808   [42|42]  	JP	Z,GETCHR	; Skip over spaces
0852: FE30     [49]     	CP	'0'
0854: 3F       [53]     	CCF			; NC if < '0'
0855: 3C       [57]     	INC	A		; Test for zero - Leave carry
0856: 3D       [61]     	DEC	A		; Z if Null
0857: C9       [71]     	RET
                        ;
0858: EB       [ 4]     RESTOR: EX	DE,HL		; Save code string address
0859: 2AA380   [20]     	LD	HL,(BASTXT)	; Point to start of program
085C: CA6D08   [30|30]  	JP	Z,RESTNL	; Just RESTORE - reset pointer
085F: EB       [34]     	EX	DE,HL		; Restore code string address
0860: CD1409   [51]     	CALL	ATOH		; Get line number to DE
0863: E5       [62]     	PUSH	HL		; Save code string address
0864: CDDC04   [79]     	CALL	SRCHLN		; Search for line number in DE
0867: 60       [83]     	LD	H,B		; HL = Address of line
0868: 69       [87]     	LD	L,C
0869: D1       [97]     	POP	DE		; Restore code string address
086A: D2B509   [107|107]	JP	NC,ULERR	; ?UL Error if not found
086D: 2B       [ 6]     RESTNL: DEC	HL		; Byte before DATA statement
086E: 222181   [16]     UPDATA: LD	(NXTDAT),HL	; Update DATA pointer
0871: EB       [20]     	EX	DE,HL		; Restore code string address
0872: C9       [30]     	RET
                        ;
                        
0873: DF       [11]     TSTBRK: RST	18H		; Check input status
0874: C8       [16|22]  	RET	Z		; No key, go back
0875: D7       [27]     	RST	10H		; Get the key into A
0876: FE1B     [34]     	CP	ESC		; Escape key?
0878: 2811     [41|46]  	JR	Z,BRK		; Yes, break
087A: FE03     [48]     	CP	CTRLC		; <Ctrl-C>
087C: 280D     [55|60]  	JR	Z,BRK		; Yes, break
087E: FE13     [62]     	CP	CTRLS		; Stop scrolling?
0880: C0       [67|73]  	RET	NZ		; Other key, ignore
                        ;
                        
0881: D7       [11]     STALL:	RST	10H		; Wait for key
0882: FE11     [18]     	CP	CTRLQ		; Resume scrolling?
0884: C8       [23|29]  	RET	Z		; Release the chokehold
0885: FE03     [30]     	CP	CTRLC		; Second break?
0887: 2807     [37|42]  	JR	Z,STOP		; Break during hold exits prog
0889: 18F6     [49]     	JR	STALL		; Loop until <Ctrl-Q> or <brk>
                        ;
088B: 3EFF     [ 7]     BRK	LD	A,0FFH		; Set BRKFLG
088D: 329280   [20]     	LD	(BRKFLG),A	; Store it
                        ;
                        
0890: C0       [ 5|11]  STOP:	RET	NZ		; Exit if anything else
0891: F6                	DB	0F6H		; Flag "STOP"
0892: C0       [ 5|11]  PEND:	RET	NZ		; Exit if anything else
0893: 221381   [21]     	LD	(BRKLIN),HL	; Save point of break
0896: 21                	DB	21H		; Skip "OR 11111111B"
0897: F6FF     [ 7]     INPBRK: OR	11111111B	; Flag "Break" wanted
0899: C1       [17]     	POP	BC		; Return not needed and more
089A: 2AA180   [16]     ENDPRG: LD	HL,(LINEAT)	; Get current line number
089D: F5       [27]     	PUSH	AF		; Save STOP / END status
089E: 7D       [31]     	LD	A,L		; Is it direct break?
089F: A4       [35]     	AND	H
08A0: 3C       [39]     	INC	A		; Line is -1 if direct break
08A1: CAAD08   [49|49]  	JP	Z,NOLIN		; Yes - No line number
08A4: 221781   [65]     	LD	(ERRLIN),HL	; Save line of break
08A7: 2A1381   [81]     	LD	HL,(BRKLIN)	; Get point of break
08AA: 221981   [97]     	LD	(CONTAD),HL	; Save point to CONTinue
08AD: AF       [ 4]     NOLIN:	XOR	A
08AE: 328A80   [17]     	LD	(CTLOFG),A	; Enable output
08B1: CDE30A   [34]     	CALL	STTLIN		; Start a new line
08B4: F1       [44]     	POP	AF		; Restore STOP / END status
08B5: 219303   [54]     	LD	HL,BRKMSG	; "Break" message
08B8: C22404   [64|64]  	JP	NZ,ERRIN	; "in line" wanted?
08BB: C33B04   [74]     	JP	PRNTOK		; Go to command mode
                        ;
08BE: 2A1981   [16]     CONT:	LD	HL,(CONTAD)	; Get CONTinue address
08C1: 7C       [20]     	LD	A,H		; Is it zero?
08C2: B5       [24]     	OR	L
08C3: 1E20     [31]     	LD	E,CN		; ?CN Error
08C5: CA0404   [41|41]  	JP	Z,ERROR		; Yes - output "?CN Error"
08C8: EB       [45]     	EX	DE,HL		; Save code string address
08C9: 2A1781   [61]     	LD	HL,(ERRLIN)	; Get line of last break
08CC: 22A180   [77]     	LD	(LINEAT),HL	; Set up current line number
08CF: EB       [81]     	EX	DE,HL		; Restore code string address
08D0: C9       [91]     	RET			; CONTinue where left off
                        ;
08D1: CD1614   [17]     NULL:	CALL	GETINT		; Get integer 0-255
08D4: C0       [22|28]  	RET	NZ		; Return if bad value
08D5: 328680   [35]     	LD	(NULLS),A	; Set nulls number
08D8: C9       [45]     	RET
                        ;
                        
08D9: E5       [11]     ACCSUM: PUSH	HL		; Save address in array
08DA: 2A8F80   [27]     	LD	HL,(CHKSUM)	; Get check sum
08DD: 0600     [34]     	LD	B,0		; BC - Value of byte
08DF: 4F       [38]     	LD	C,A
08E0: 09       [49]     	ADD	HL,BC		; Add byte to check sum
08E1: 228F80   [65]     	LD	(CHKSUM),HL	; Re-save check sum
08E4: E1       [75]     	POP	HL		; Restore address in array
08E5: C9       [85]     	RET
                        ;
08E6: 7E       [ 7]     CHKLTR: LD	A,(HL)		; Get byte
08E7: FE41     [14]     	CP	'A'		; < 'a' ?
08E9: D8       [19|25]  	RET	C		; Carry set if not letter
08EA: FE5B     [26]     	CP	'Z'+1		; > 'z' ?
08EC: 3F       [30]     	CCF
08ED: C9       [40]     	RET			; Carry set if not letter
                        ;
08EE: CD4808   [17]     FPSINT: CALL	GETCHR		; Get next character
08F1: CDB50C   [17]     POSINT: CALL	GETNUM		; Get integer 0 to 32767
08F4: CD9716   [17]     DEPINT: CALL	TSTSGN		; Test sign of FPREG
08F7: FA0F09   [27|27]  	JP	M,FCERR		; Negative - ?FC Error
08FA: 3A2C81   [13]     DEINT:	LD	A,(FPEXP)	; Get integer value to DE
08FD: FE90     [20]     	CP	80H+16		; Exponent in range (16 bits)?
08FF: DA3F17   [30|30]  	JP	C,FPINT		; Yes - convert it
0902: 018090   [40]     	LD	BC,9080H	; BCDE = -32768
0905: 110000   [50]     	LD	DE,0000
0908: E5       [61]     	PUSH	HL		; Save code string address
0909: CD1217   [78]     	CALL	CMPNUM		; Compare FPREG with BCDE
090C: E1       [88]     	POP	HL		; Restore code string address
090D: 51       [92]     	LD	D,C		; MSB to D
090E: C8       [97|103] 	RET	Z		; Return if in range
090F: 1E08     [ 7]     FCERR:	LD	E,FC		; ?FC Error
0911: C30404   [17]     	JP	ERROR		; Output error-
                        ;
0914: 2B       [ 6]     ATOH:	DEC	HL		; ASCII number to DE binary
0915: 110000   [10]     GETLN:	LD	DE,0		; Get number to DE
0918: CD4808   [17]     GTLNLP: CALL	GETCHR		; Get next character
091B: D0       [22|28]  	RET	NC		; Exit if not a digit
091C: E5       [33]     	PUSH	HL		; Save code string address
091D: F5       [44]     	PUSH	AF		; Save digit
091E: 219819   [54]     	LD	HL,65529/10	; Largest number 65529
0921: CDB806   [71]     	CALL	CPDEHL		; Number in range?
0924: DAF003   [81|81]  	JP	C,SNERR		; No - ?SN Error
0927: 62       [85]     	LD	H,D		; HL = Number
0928: 6B       [89]     	LD	L,E
0929: 19       [100]    	ADD	HL,DE		; Times 2
092A: 29       [111]    	ADD	HL,HL		; Times 4
092B: 19       [122]    	ADD	HL,DE		; Times 5
092C: 29       [133]    	ADD	HL,HL		; Times 10
092D: F1       [143]    	POP	AF		; Restore digit
092E: D630     [150]    	SUB	'0'		; Make it 0 to 9
0930: 5F       [154]    	LD	E,A		; DE = Value of digit
0931: 1600     [161]    	LD	D,0
0933: 19       [172]    	ADD	HL,DE		; Add to number
0934: EB       [176]    	EX	DE,HL		; Number to DE
0935: E1       [186]    	POP	HL		; Restore code string address
0936: C31809   [196]    	JP	GTLNLP		; Go to next character
                        ;
0939: CA0C05   [10|10]  CLEAR:	JP	Z,INTVAR	; Just "CLEAR" Keep parameters
093C: CDF108   [27]     	CALL	POSINT		; Get integer 0 to 32767 to DE
093F: 2B       [33]     	DEC	HL		; Cancel increment
0940: CD4808   [50]     	CALL	GETCHR		; Get next character
0943: E5       [61]     	PUSH	HL		; Save code string address
0944: 2AF480   [77]     	LD	HL,(LSTRAM)	; Get end of RAM
0947: CA5C09   [87|87]  	JP	Z,STORED	; No value given - Use stored
094A: E1       [97]     	POP	HL		; Restore code string address
094B: CDBE06   [114]    	CALL	CHKSYN		; Check for comma
094E: 2C                	DB	','
094F: D5       [125]    	PUSH	DE		; Save number
0950: CDF108   [142]    	CALL	POSINT		; Get integer 0 to 32767
0953: 2B       [148]    	DEC	HL		; Cancel increment
0954: CD4808   [165]    	CALL	GETCHR		; Get next character
0957: C2F003   [175|175]	JP	NZ,SNERR	; ?SN Error if more on line
095A: E3       [194]    	EX	(SP),HL		; Save code string address
095B: EB       [198]    	EX	DE,HL		; Number to DE
095C: 7D       [ 4]     STORED: LD	A,L		; Get LSB of new RAM top
095D: 93       [ 8]     	SUB	E		; Subtract LSB of string space
095E: 5F       [12]     	LD	E,A		; Save LSB
095F: 7C       [16]     	LD	A,H		; Get MSB of new RAM top
0960: 9A       [20]     	SBC	A,D		; Subtract MSB of string space
0961: 57       [24]     	LD	D,A		; Save MSB
0962: DAE503   [34|34]  	JP	C,OMERR		; ?OM Error if not enough mem
0965: E5       [45]     	PUSH	HL		; Save RAM top
0966: 2A1B81   [61]     	LD	HL,(PROGND)	; Get program end
0969: 012800   [71]     	LD	BC,40		; 40 Bytes minimum working RAM
096C: 09       [82]     	ADD	HL,BC		; Get lowest address
096D: CDB806   [99]     	CALL	CPDEHL		; Enough memory?
0970: D2E503   [109|109]	JP	NC,OMERR	; No - ?OM Error
0973: EB       [113]    	EX	DE,HL		; RAM top to HL
0974: 229F80   [129]    	LD	(STRSPC),HL	; Set new string space
0977: E1       [139]    	POP	HL		; End of memory to use
0978: 22F480   [155]    	LD	(LSTRAM),HL	; Set new top of RAM
097B: E1       [165]    	POP	HL		; Restore code string address
097C: C30C05   [175]    	JP	INTVAR		; Initialise variables
                        ;
097F: CA0805   [10|10]  RUN:	JP	Z,RUNFST	; RUN from start if just RUN
0982: CD0C05   [27]     	CALL	INTVAR		; Initialise variables
0985: 010808   [37]     	LD	BC,RUNCNT	; Execution driver loop
0988: C39B09   [47]     	JP	RUNLIN		; RUN from line number
                        ;
098B: 0E03     [ 7]     GOSUB:	LD	C,3		; 3 Levels of stack needed
098D: CDCD03   [24]     	CALL	CHKSTK		; Check for 3 levels of stack
0990: C1       [34]     	POP	BC		; Get return address
0991: E5       [45]     	PUSH	HL		; Save code string for RETURN
0992: E5       [56]     	PUSH	HL		; And for GOSUB routine
0993: 2AA180   [72]     	LD	HL,(LINEAT)	; Get current line
0996: E3       [91]     	EX	(SP),HL		; Into stack - Code string out
0997: 3E8C     [98]     	LD	A,ZGOSUB	; "GOSUB" token
0999: F5       [109]    	PUSH	AF		; Save token
099A: 33       [115]    	INC	SP		; Don't save flags
                        ;
099B: C5       [11]     RUNLIN: PUSH	BC		; Save return address
099C: CD1409   [17]     GOTO:	CALL	ATOH		; ASCII number to DE binary
099F: CDE109   [34]     	CALL	REM		; Get end of line
09A2: E5       [45]     	PUSH	HL		; Save end of line
09A3: 2AA180   [61]     	LD	HL,(LINEAT)	; Get current line
09A6: CDB806   [78]     	CALL	CPDEHL		; Line after current?
09A9: E1       [88]     	POP	HL		; Restore end of line
09AA: 23       [94]     	INC	HL		; Start of next line
09AB: DCDF04   [104|111]	CALL	C,SRCHLP	; Line is after current line
09AE: D4DC04   [114|121]	CALL	NC,SRCHLN	; Line is before current line
09B1: 60       [118]    	LD	H,B		; Set up code string address
09B2: 69       [122]    	LD	L,C
09B3: 2B       [128]    	DEC	HL		; Incremented after
09B4: D8       [133|139]	RET	C		; Line found
09B5: 1E0E     [ 7]     ULERR:	LD	E,UL		; ?UL Error
09B7: C30404   [17]     	JP	ERROR		; Output error message
                        ;
09BA: C0       [ 5|11]  RETURN: RET	NZ		; Return if not just RETURN
09BB: 16FF     [12]     	LD	D,-1		; Flag "GOSUB" search
09BD: CD9903   [29]     	CALL	BAKSTK		; Look "GOSUB" block
09C0: F9       [35]     	LD	SP,HL		; Kill all FORs in subroutine
09C1: FE8C     [42]     	CP	ZGOSUB		; Test for "GOSUB" token
09C3: 1E04     [49]     	LD	E,RG		; ?RG Error
09C5: C20404   [59|59]  	JP	NZ,ERROR	; Error if no "GOSUB" found
09C8: E1       [69]     	POP	HL		; Get RETURN line number
09C9: 22A180   [85]     	LD	(LINEAT),HL	; Save as current
09CC: 23       [91]     	INC	HL		; Was it from direct statement?
09CD: 7C       [95]     	LD	A,H
09CE: B5       [99]     	OR	L		; Return to line
09CF: C2D909   [109|109]	JP	NZ,RETLIN	; No - Return to line
09D2: 3A1181   [122]    	LD	A,(LSTBIN)	; Any INPUT in subroutine?
09D5: B7       [126]    	OR	A		; If so buffer is corrupted
09D6: C23A04   [136|136]	JP	NZ,POPNOK	; Yes - Go to command mode
09D9: 210808   [10]     RETLIN: LD	HL,RUNCNT	; Execution driver loop
09DC: E3       [29]     	EX	(SP),HL		; Into stack - Code string out
09DD: 3E                	DB	3EH		; Skip "POP HL"
09DE: E1       [10]     NXTDTA: POP	HL		; Restore code string address
                        ;
09DF: 013A              DATA:	DB	01H,3AH		; ':' End of statement
09E1: 0E00     [ 7]     REM:	LD	C,0		; 00	End of statement
09E3: 0600     [14]     	LD	B,0
09E5: 79       [ 4]     NXTSTL: LD	A,C		; Statement and byte
09E6: 48       [ 8]     	LD	C,B
09E7: 47       [12]     	LD	B,A		; Statement end byte
09E8: 7E       [ 7]     NXTSTT: LD	A,(HL)		; Get byte
09E9: B7       [11]     	OR	A		; End of line?
09EA: C8       [16|22]  	RET	Z		; Yes - Exit
09EB: B8       [20]     	CP	B		; End of statement?
09EC: C8       [25|31]  	RET	Z		; Yes - Exit
09ED: 23       [31]     	INC	HL		; Next byte
09EE: FE22     [38]     	CP	'"'		; Literal string?
09F0: CAE509   [48|48]  	JP	Z,NXTSTL	; Yes - Look for another '"'
09F3: C3E809   [58]     	JP	NXTSTT		; Keep looking
                        ;
09F6: CDAB0E   [17]     LET:	CALL	GETVAR		; Get variable name
09F9: CDBE06   [34]     	CALL	CHKSYN		; Make sure "=" follows
09FC: B4                	DB	ZEQUAL		; "=" token
09FD: D5       [45]     	PUSH	DE		; Save address of variable
09FE: 3AF280   [58]     	LD	A,(TYPE)	; Get data type
0A01: F5       [69]     	PUSH	AF		; Save type
0A02: CDC70C   [86]     	CALL	EVAL		; Evaluate expression
0A05: F1       [96]     	POP	AF		; Restore type
0A06: E3       [115]    	EX	(SP),HL		; Save code - Get var addr
0A07: 221381   [131]    	LD	(BRKLIN),HL	; Save address of variable
0A0A: 1F       [135]    	RRA			; Adjust type
0A0B: CDBA0C   [152]    	CALL	CHKTYP		; Check types are the same
0A0E: CA490A   [162|162]	JP	Z,LETNUM	; Numeric - Move value
0A11: E5       [11]     LETSTR: PUSH	HL		; Save address of string var
0A12: 2A2981   [27]     	LD	HL,(FPREG)	; Pointer to string entry
0A15: E5       [38]     	PUSH	HL		; Save it on stack
0A16: 23       [44]     	INC	HL		; Skip over length
0A17: 23       [50]     	INC	HL
0A18: 5E       [57]     	LD	E,(HL)		; LSB of string address
0A19: 23       [63]     	INC	HL
0A1A: 56       [70]     	LD	D,(HL)		; MSB of string address
0A1B: 2AA380   [86]     	LD	HL,(BASTXT)	; Point to start of program
0A1E: CDB806   [103]    	CALL	CPDEHL		; Is string before program?
0A21: D2380A   [113|113]	JP	NC,CRESTR	; Yes - Create string entry
0A24: 2A9F80   [129]    	LD	HL,(STRSPC)	; Point to string space
0A27: CDB806   [146]    	CALL	CPDEHL		; Is string literal in program?
0A2A: D1       [156]    	POP	DE		; Restore address of string
0A2B: D2400A   [166|166]	JP	NC,MVSTPT	; Yes - Set up pointer
0A2E: 210481   [176]    	LD	HL,TMPSTR	; Temporary string pool
0A31: CDB806   [193]    	CALL	CPDEHL		; Is string in temporary pool?
0A34: D2400A   [203|203]	JP	NC,MVSTPT	; No - Set up pointer
0A37: 3E                	DB	3EH		; Skip "POP DE"
0A38: D1       [10]     CRESTR: POP	DE		; Restore address of string
0A39: CDEF12   [27]     	CALL	BAKTMP		; Back to last tmp-str entry
0A3C: EB       [31]     	EX	DE,HL		; Address of string entry
0A3D: CD2811   [48]     	CALL	SAVSTR		; Save string in string area
0A40: CDEF12   [17]     MVSTPT: CALL	BAKTMP		; Back to last tmp-str entry
0A43: E1       [27]     	POP	HL		; Get string pointer
0A44: CDF216   [44]     	CALL	DETHL4		; Move string pointer to var
0A47: E1       [54]     	POP	HL		; Restore code string address
0A48: C9       [64]     	RET
                        ;
0A49: E5       [11]     LETNUM: PUSH	HL		; Save address of variable
0A4A: CDEF16   [28]     	CALL	FPTHL		; Move value to variable
0A4D: D1       [38]     	POP	DE		; Restore address of variable
0A4E: E1       [48]     	POP	HL		; Restore code string address
0A4F: C9       [58]     	RET
                        ;
0A50: CD1614   [17]     ON:	CALL	GETINT		; Get integer 0-255
0A53: 7E       [24]     	LD	A,(HL)		; Get "GOTO" or "GOSUB" token
0A54: 47       [28]     	LD	B,A		; Save in B
0A55: FE8C     [35]     	CP	ZGOSUB		; "GOSUB" token?
0A57: CA5F0A   [45|45]  	JP	Z,ONGO		; Yes - Find line number
0A5A: CDBE06   [62]     	CALL	CHKSYN		; Make sure it's "GOTO"
0A5D: 88                	DB	ZGOTO		; "GOTO" token
0A5E: 2B       [68]     	DEC	HL		; Cancel increment
0A5F: 4B       [ 4]     ONGO:	LD	C,E		; Integer of branch value
0A60: 0D       [ 4]     ONGOLP: DEC	C		; Count branches
0A61: 78       [ 8]     	LD	A,B		; Get "GOTO" or "GOSUB" token
0A62: CA3008   [18|18]  	JP	Z,ONJMP		; Go to that line if right one
0A65: CD1509   [35]     	CALL	GETLN		; Get line number to DE
0A68: FE2C     [42]     	CP	','		; Another line number?
0A6A: C0       [47|53]  	RET	NZ		; No - Drop through
0A6B: C3600A   [57]     	JP	ONGOLP		; Yes - loop
                        ;
0A6E: CDC70C   [17]     IF:	CALL	EVAL		; Evaluate expression
0A71: 7E       [24]     	LD	A,(HL)		; Get token
0A72: FE88     [31]     	CP	ZGOTO		; "GOTO" token?
0A74: CA7C0A   [41|41]  	JP	Z,IFGO		; Yes - Get line
0A77: CDBE06   [58]     	CALL	CHKSYN		; Make sure it's "THEN"
0A7A: A9                	DB	ZTHEN		; "THEN" token
0A7B: 2B       [64]     	DEC	HL		; Cancel increment
0A7C: CDB80C   [17]     IFGO:	CALL	TSTNUM		; Make sure it's numeric
0A7F: CD9716   [34]     	CALL	TSTSGN		; Test state of expression
0A82: CAE109   [44|44]  	JP	Z,REM		; False - Drop through
0A85: CD4808   [61]     	CALL	GETCHR		; Get next character
0A88: DA9C09   [71|71]  	JP	C,GOTO		; Number - GOTO that line
0A8B: C32F08   [81]     	JP	IFJMP		; Otherwise do statement
                        ;
0A8E: 2B       [ 6]     MRPRNT: DEC	HL		; DEC 'cos GETCHR INCs
0A8F: CD4808   [23]     	CALL	GETCHR		; Get next character
0A92: CAF00A   [10|10]  PRINT:	JP	Z,PRCRLF	; CRLF if just PRINT
0A95: C8       [ 5|11]  PRNTLP: RET	Z		; End of list - Exit
0A96: FEA5     [12]     	CP	ZTAB		; "TAB(" token?
0A98: CA230B   [22|22]  	JP	Z,DOTAB		; Yes - Do TAB routine
0A9B: FEA8     [29]     	CP	ZSPC		; "SPC(" token?
0A9D: CA230B   [39|39]  	JP	Z,DOTAB		; Yes - Do SPC routine
0AA0: E5       [50]     	PUSH	HL		; Save code string address
0AA1: FE2C     [57]     	CP	','		; Comma?
0AA3: CA0C0B   [67|67]  	JP	Z,DOCOM		; Yes - Move to next zone
0AA6: FE3B     [74]     	CP	59;";"		; Semi-colon?
0AA8: CA460B   [84|84]  	JP	Z,NEXITM	; Do semi-colon routine
0AAB: C1       [94]     	POP	BC		; Code string address to BC
0AAC: CDC70C   [111]    	CALL	EVAL		; Evaluate expression
0AAF: E5       [122]    	PUSH	HL		; Save code string address
0AB0: 3AF280   [135]    	LD	A,(TYPE)	; Get variable type
0AB3: B7       [139]    	OR	A		; Is it a string variable?
0AB4: C2DC0A   [149|149]	JP	NZ,PRNTST	; Yes - Output string contents
0AB7: CD3C18   [166]    	CALL	NUMASC		; Convert number to text
0ABA: CD4C11   [183]    	CALL	CRTST		; Create temporary string
0ABD: 3620     [193]    	LD	(HL),' '	; Followed by a space
0ABF: 2A2981   [209]    	LD	HL,(FPREG)	; Get length of output
0AC2: 34       [220]    	INC	(HL)		; Plus 1 for the space
0AC3: 2A2981   [236]    	LD	HL,(FPREG)	; < Not needed >
0AC6: 3A8780   [249]    	LD	A,(LWIDTH)	; Get width of line
0AC9: 47       [253]    	LD	B,A		; To B
0ACA: 04       [257]    	INC	B		; Width 255 (No limit)?
0ACB: CAD80A   [267|267]	JP	Z,PRNTNB	; Yes - Output number string
0ACE: 04       [271]    	INC	B		; Adjust it
0ACF: 3AF080   [284]    	LD	A,(CURPOS)	; Get cursor position
0AD2: 86       [291]    	ADD	A,(HL)		; Add length of string
0AD3: 3D       [295]    	DEC	A		; Adjust it
0AD4: B8       [299]    	CP	B		; Will output fit on this line?
0AD5: D4F00A   [309|316]	CALL	NC,PRCRLF	; No - CRLF first
0AD8: CD9111   [17]     PRNTNB: CALL	PRS1		; Output string at (HL)
0ADB: AF       [21]     	XOR	A		; Skip CALL by setting 'z' flag
0ADC: C49111   [10|17]  PRNTST: CALL	NZ,PRS1		; Output string at (HL)
0ADF: E1       [20]     	POP	HL		; Restore code string address
0AE0: C38E0A   [30]     	JP	MRPRNT		; See if more to PRINT
                        ;
0AE3: 3AF080   [13]     STTLIN: LD	A,(CURPOS)	; Make sure on new line
0AE6: B7       [17]     	OR	A		; Already at start?
0AE7: C8       [22|28]  	RET	Z		; Yes - Do nothing
0AE8: C3F00A   [32]     	JP	PRCRLF		; Start a new line
                        ;
0AEB: 3600     [10]     ENDINP: LD	(HL),0		; Mark end of buffer
0AED: 21A580   [20]     	LD	HL,BUFFER-1	; Point to buffer
0AF0: 3E0D     [ 7]     PRCRLF: LD	A,CR		; Load a CR
0AF2: CDC906   [24]     	CALL	OUTC		; Output character
0AF5: 3E0A     [31]     	LD	A,LF		; Load a LF
0AF7: CDC906   [48]     	CALL	OUTC		; Output character
0AFA: AF       [ 4]     DONULL: XOR	A		; Set to position 0
0AFB: 32F080   [17]     	LD	(CURPOS),A	; Store it
0AFE: 3A8680   [30]     	LD	A,(NULLS)	; Get number of nulls
0B01: 3D       [ 4]     NULLP:	DEC	A		; Count them
0B02: C8       [ 9|15]  	RET	Z		; Return if done
0B03: F5       [20]     	PUSH	AF		; Save count
0B04: AF       [24]     	XOR	A		; Load a null
0B05: CDC906   [41]     	CALL	OUTC		; Output it
0B08: F1       [51]     	POP	AF		; Restore count
0B09: C3010B   [61]     	JP	NULLP		; Keep counting
                        ;
0B0C: 3A8880   [13]     DOCOM:	LD	A,(COMMAN)	; Get comma width
0B0F: 47       [17]     	LD	B,A		; Save in B
0B10: 3AF080   [30]     	LD	A,(CURPOS)	; Get current position
0B13: B8       [34]     	CP	B		; Within the limit?
0B14: D4F00A   [44|51]  	CALL	NC,PRCRLF	; No - output CRLF
0B17: D2460B   [54|54]  	JP	NC,NEXITM	; Get next item
0B1A: D60E     [ 7]     ZONELP: SUB	14		; Next zone of 14 characters
0B1C: D21A0B   [17|17]  	JP	NC,ZONELP	; Repeat if more zones
0B1F: 2F       [21]     	CPL			; Number of spaces to output
0B20: C33B0B   [31]     	JP	ASPCS		; Output them
                        ;
0B23: F5       [11]     DOTAB:	PUSH	AF		; Save token
0B24: CD1314   [28]     	CALL	FNDNUM		; Evaluate expression
0B27: CDBE06   [45]     	CALL	CHKSYN		; Make sure ")" follows
0B2A: 29                	DB	")"
0B2B: 2B       [51]     	DEC	HL		; Back space on to ")"
0B2C: F1       [61]     	POP	AF		; Restore token
0B2D: D6A8     [68]     	SUB	ZSPC		; Was it "SPC(" ?
0B2F: E5       [79]     	PUSH	HL		; Save code string address
0B30: CA360B   [89|89]  	JP	Z,DOSPC	; Yes - Do 'E' spaces
0B33: 3AF080   [102]    	LD	A,(CURPOS)	; Get current position
0B36: 2F       [ 4]     DOSPC:	CPL			; Number of spaces to print to
0B37: 83       [ 8]     	ADD	A,E		; Total number to print
0B38: D2460B   [18|18]  	JP	NC,NEXITM	; TAB < Current POS(X)
0B3B: 3C       [ 4]     ASPCS:	INC	A		; Output A spaces
0B3C: 47       [ 8]     	LD	B,A		; Save number to print
0B3D: 3E20     [15]     	LD	A,' '		; Space
0B3F: CDC906   [17]     SPCLP:	CALL	OUTC		; Output character in A
0B42: 05       [21]     	DEC	B		; Count them
0B43: C23F0B   [31|31]  	JP	NZ,SPCLP	; Repeat if more
0B46: E1       [10]     NEXITM: POP	HL		; Restore code string address
0B47: CD4808   [27]     	CALL	GETCHR		; Get next character
0B4A: C3950A   [37]     	JP	PRNTLP		; More to print
                        ;
0B4D: 3F526564          REDO:	DB	"?Redo from start",CR,LF,0
0B51: 6F206672          
0B55: 6F6D2073          
0B59: 74617274          
0B5D: 0D0A00            
                        ;
0B60: 3A1281   [13]     BADINP: LD	A,(READFG)	; READ or INPUT?
0B63: B7       [17]     	OR	A
0B64: C2EA03   [27|27]  	JP	NZ,DATSNR	; READ - ?SN Error
0B67: C1       [37]     	POP	BC		; Throw away code string addr
0B68: 214D0B   [47]     	LD	HL,REDO		; "Redo from start" message
0B6B: CD8E11   [64]     	CALL	PRS		; Output string
0B6E: C33B05   [74]     	JP	DOAGN		; Do last INPUT again
                        ;
0B71: CDF910   [17]     INPUT:	CALL	IDTEST		; Test for illegal direct
0B74: 7E       [24]     	LD	A,(HL)		; Get character after "INPUT"
0B75: FE22     [31]     	CP	'"'		; Is there a prompt string?
0B77: 3E00     [38]     	LD	A,0		; Clear A and leave flags
0B79: 328A80   [51]     	LD	(CTLOFG),A	; Enable output
0B7C: C28B0B   [61|61]  	JP	NZ,NOPMPT	; No prompt - get input
0B7F: CD4D11   [78]     	CALL	QTSTR		; Get string terminated by '"'
0B82: CDBE06   [95]     	CALL	CHKSYN		; Check for ';' after prompt
0B85: 3B                	DB	';'
0B86: E5       [106]    	PUSH	HL		; Save code string address
0B87: CD9111   [123]    	CALL	PRS1		; Output prompt string
0B8A: 3E                	DB	3EH		; Skip "PUSH HL"
0B8B: E5       [11]     NOPMPT: PUSH	HL		; Save code string address
0B8C: CD3F05   [28]     	CALL	PROMPT		; Get input with "? " prompt
0B8F: C1       [38]     	POP	BC		; Restore code string address
0B90: DA9708   [48|48]  	JP	C,INPBRK	; Break pressed - Exit
0B93: 23       [54]     	INC	HL		; Next byte
0B94: 7E       [61]     	LD	A,(HL)		; Get it
0B95: B7       [65]     	OR	A		; End of line?
0B96: 2B       [71]     	DEC	HL		; Back again
0B97: C5       [82]     	PUSH	BC		; Re-save code string address
0B98: CADE09   [92|92]  	JP	Z,NXTDTA	; Yes - Find next DATA stmt
0B9B: 362C     [102]    	LD	(HL),','	; Store comma as separator
0B9D: C3A50B   [112]    	JP	NXTITM		; Get next item
                        ;
0BA0: E5       [11]     READ:	PUSH	HL		; Save code string address
0BA1: 2A2181   [27]     	LD	HL,(NXTDAT)	; Next DATA statement
0BA4: F6                	DB	0F6H		; Flag "READ"
0BA5: AF       [ 4]     NXTITM: XOR	A		; Flag "INPUT"
0BA6: 321281   [17]     	LD	(READFG),A	; Save "READ"/"INPUT" flag
0BA9: E3       [36]     	EX	(SP),HL		; Get code str' , Save pointer
0BAA: C3B10B   [46]     	JP	GTVLUS		; Get values
                        ;
0BAD: CDBE06   [17]     NEDMOR: CALL	CHKSYN		; Check for comma between items
0BB0: 2C                	DB	','
0BB1: CDAB0E   [17]     GTVLUS: CALL	GETVAR		; Get variable name
0BB4: E3       [36]     	EX	(SP),HL		; Save code str" , Get pointer
0BB5: D5       [47]     	PUSH	DE		; Save variable address
0BB6: 7E       [54]     	LD	A,(HL)		; Get next "INPUT"/"DATA" byte
0BB7: FE2C     [61]     	CP	','		; Comma?
0BB9: CAD90B   [71|71]  	JP	Z,ANTVLU	; Yes - Get another value
0BBC: 3A1281   [84]     	LD	A,(READFG)	; Is it READ?
0BBF: B7       [88]     	OR	A
0BC0: C2460C   [98|98]  	JP	NZ,FDTLP	; Yes - Find next DATA stmt
0BC3: 3E3F     [105]    	LD	A,'?'		; More INPUT needed
0BC5: CDC906   [122]    	CALL	OUTC		; Output character
0BC8: CD3F05   [139]    	CALL	PROMPT		; Get INPUT with prompt
0BCB: D1       [149]    	POP	DE		; Variable address
0BCC: C1       [159]    	POP	BC		; Code string address
0BCD: DA9708   [169|169]	JP	C,INPBRK	; Break pressed
0BD0: 23       [175]    	INC	HL		; Point to next DATA byte
0BD1: 7E       [182]    	LD	A,(HL)		; Get byte
0BD2: B7       [186]    	OR	A		; Is it zero (No input) ?
0BD3: 2B       [192]    	DEC	HL		; Back space INPUT pointer
0BD4: C5       [203]    	PUSH	BC		; Save code string address
0BD5: CADE09   [213|213]	JP	Z,NXTDTA	; Find end of buffer
0BD8: D5       [224]    	PUSH	DE		; Save variable address
0BD9: 3AF280   [13]     ANTVLU: LD	A,(TYPE)	; Check data type
0BDC: B7       [17]     	OR	A		; Is it numeric?
0BDD: CA030C   [27|27]  	JP	Z,INPBIN	; Yes - Convert to binary
0BE0: CD4808   [44]     	CALL	GETCHR		; Get next character
0BE3: 57       [48]     	LD	D,A		; Save input character
0BE4: 47       [52]     	LD	B,A		; Again
0BE5: FE22     [59]     	CP	'"'		; Start of literal sting?
0BE7: CAF70B   [69|69]  	JP	Z,STRENT	; Yes - Create string entry
0BEA: 3A1281   [82]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0BED: B7       [86]     	OR	A
0BEE: 57       [90]     	LD	D,A		; Save 00 if "INPUT"
0BEF: CAF40B   [100|100]	JP	Z,ITMSEP	; "INPUT" - End with 00
0BF2: 163A     [107]    	LD	D,':'		; "DATA" - End with 00 or ':'
0BF4: 062C     [ 7]     ITMSEP: LD	B,','		; Item separator
0BF6: 2B       [13]     	DEC	HL		; Back space for DTSTR
0BF7: CD5011   [17]     STRENT: CALL	DTSTR		; Get string terminated by D
0BFA: EB       [21]     	EX	DE,HL		; String address to DE
0BFB: 210E0C   [31]     	LD	HL,LTSTND	; Where to go after LETSTR
0BFE: E3       [50]     	EX	(SP),HL		; Save HL , get input pointer
0BFF: D5       [61]     	PUSH	DE		; Save address of string
0C00: C3110A   [71]     	JP	LETSTR		; Assign string to variable
                        ;
0C03: CD4808   [17]     INPBIN: CALL	GETCHR		; Get next character
0C06: CD9E17   [34]     	CALL	ASCTFP		; Convert ASCII to FP number
0C09: E3       [53]     	EX	(SP),HL		; Save input ptr, Get var addr
0C0A: CDEF16   [70]     	CALL	FPTHL		; Move FPREG to variable
0C0D: E1       [80]     	POP	HL		; Restore input pointer
0C0E: 2B       [ 6]     LTSTND: DEC	HL		; DEC 'cos GETCHR INCs
0C0F: CD4808   [23]     	CALL	GETCHR		; Get next character
0C12: CA1A0C   [33|33]  	JP	Z,MORDT		; End of line - More needed?
0C15: FE2C     [40]     	CP	','		; Another value?
0C17: C2600B   [50|50]  	JP	NZ,BADINP	; No - Bad input
0C1A: E3       [19]     MORDT:	EX	(SP),HL		; Get code string address
0C1B: 2B       [25]     	DEC	HL		; DEC 'cos GETCHR INCs
0C1C: CD4808   [42]     	CALL	GETCHR		; Get next character
0C1F: C2AD0B   [52|52]  	JP	NZ,NEDMOR	; More needed - Get it
0C22: D1       [62]     	POP	DE		; Restore DATA pointer
0C23: 3A1281   [75]     	LD	A,(READFG)	; "READ" or "INPUT" ?
0C26: B7       [79]     	OR	A
0C27: EB       [83]     	EX	DE,HL		; DATA pointer to HL
0C28: C26E08   [93|93]  	JP	NZ,UPDATA	; Update DATA pointer if "READ"
0C2B: D5       [104]    	PUSH	DE		; Save code string address
0C2C: B6       [111]    	OR	(HL)		; More input given?
0C2D: 21350C   [121]    	LD	HL,EXTIG	; "?Extra ignored" message
0C30: C48E11   [131|138]	CALL	NZ,PRS		; Output string if extra given
0C33: E1       [141]    	POP	HL		; Restore code string address
0C34: C9       [151]    	RET
                        ;
0C35: 3F457874          EXTIG:	DB	"?Extra ignored",CR,LF,0
0C39: 72612069          
0C3D: 676E6F72          
0C41: 65640D0A          
0C45: 00                
                        ;
0C46: CDDF09   [17]     FDTLP:	CALL	DATA		; Get next statement
0C49: B7       [21]     	OR	A		; End of line?
0C4A: C25F0C   [31|31]  	JP	NZ,FANDT	; No - See if DATA statement
0C4D: 23       [37]     	INC	HL
0C4E: 7E       [44]     	LD	A,(HL)		; End of program?
0C4F: 23       [50]     	INC	HL
0C50: B6       [57]     	OR	(HL)		; 00 00 Ends program
0C51: 1E06     [64]     	LD	E,OD		; ?OD Error
0C53: CA0404   [74|74]  	JP	Z,ERROR		; Yes - Out of DATA
0C56: 23       [80]     	INC	HL
0C57: 5E       [87]     	LD	E,(HL)		; LSB of line number
0C58: 23       [93]     	INC	HL
0C59: 56       [100]    	LD	D,(HL)		; MSB of line number
0C5A: EB       [104]    	EX	DE,HL
0C5B: 220E81   [120]    	LD	(DATLIN),HL	; Set line of current DATA item
0C5E: EB       [124]    	EX	DE,HL
0C5F: CD4808   [17]     FANDT:	CALL	GETCHR		; Get next character
0C62: FE83     [24]     	CP	ZDATA		; "DATA" token
0C64: C2460C   [34|34]  	JP	NZ,FDTLP	; No "DATA" - Keep looking
0C67: C3D90B   [44]     	JP	ANTVLU		; Found - Convert input
                        ;
0C6A: 110000   [10]     NEXT:	LD	DE,0		; In case no index given
0C6D: C4AB0E   [10|17]  NEXT1:	CALL	NZ,GETVAR	; Get index address
0C70: 221381   [26]     	LD	(BRKLIN),HL	; Save code string address
0C73: CD9903   [43]     	CALL	BAKSTK		; Look for "FOR" block
0C76: C2F603   [53|53]  	JP	NZ,NFERR	; No "FOR" - ?NF Error
0C79: F9       [59]     	LD	SP,HL		; Clear nested loops
0C7A: D5       [70]     	PUSH	DE		; Save index address
0C7B: 7E       [77]     	LD	A,(HL)		; Get sign of STEP
0C7C: 23       [83]     	INC	HL
0C7D: F5       [94]     	PUSH	AF		; Save sign of STEP
0C7E: D5       [105]    	PUSH	DE		; Save index address
0C7F: CDD516   [122]    	CALL	PHLTFP		; Move index value to FPREG
0C82: E3       [141]    	EX	(SP),HL		; Save address of TO value
0C83: E5       [152]    	PUSH	HL		; Save address of index
0C84: CD4214   [169]    	CALL	ADDPHL		; Add STEP to index value
0C87: E1       [179]    	POP	HL		; Restore address of index
0C88: CDEF16   [196]    	CALL	FPTHL		; Move value to index variable
0C8B: E1       [206]    	POP	HL		; Restore address of TO value
0C8C: CDE616   [223]    	CALL	LOADFP		; Move TO value to BCDE
0C8F: E5       [234]    	PUSH	HL		; Save address of line of FOR
0C90: CD1217   [251]    	CALL	CMPNUM		; Compare index with TO value
0C93: E1       [261]    	POP	HL		; Restore address of line num
0C94: C1       [271]    	POP	BC		; Address of sign of STEP
0C95: 90       [275]    	SUB	B		; Compare with expected sign
0C96: CDE616   [292]    	CALL	LOADFP		; BC = Loop stmt,DE = Line num
0C99: CAA50C   [302|302]	JP	Z,KILFOR	; Loop finished - Terminate it
0C9C: EB       [306]    	EX	DE,HL		; Loop statement line number
0C9D: 22A180   [322]    	LD	(LINEAT),HL	; Set loop line number
0CA0: 69       [326]    	LD	L,C		; Set code string to loop
0CA1: 60       [330]    	LD	H,B
0CA2: C30408   [340]    	JP	PUTFID		; Put back "FOR" and continue
                        ;
0CA5: F9       [ 6]     KILFOR: LD	SP,HL		; Remove "FOR" block
0CA6: 2A1381   [22]     	LD	HL,(BRKLIN)	; Code string after "NEXT"
0CA9: 7E       [29]     	LD	A,(HL)		; Get next byte in code string
0CAA: FE2C     [36]     	CP	','		; More NEXTs ?
0CAC: C20808   [46|46]  	JP	NZ,RUNCNT	; No - Do next statement
0CAF: CD4808   [63]     	CALL	GETCHR		; Position to index name
0CB2: CD6D0C   [80]     	CALL	NEXT1		; Re-enter NEXT routine
                        ; < will not RETurn to here , Exit to RUNCNT or Loop >
                        ;
0CB5: CDC70C   [17]     GETNUM: CALL	EVAL		; Get a numeric expression
0CB8: F6                TSTNUM: DB	0F6H		; Clear carry (numeric)
0CB9: 37       [ 4]     TSTSTR: SCF			; Set carry (string)
0CBA: 3AF280   [13]     CHKTYP: LD	A,(TYPE)	; Check types match
0CBD: 8F       [17]     	ADC	A,A		; Expected + actual
0CBE: B7       [21]     	OR	A		; Clear carry , set parity
0CBF: E8       [26|32]  	RET	PE		; Even parity - Types match
0CC0: C30204   [36]     	JP	TMERR		; Different types - Error
                        ;
0CC3: CDBE06   [17]     OPNPAR: CALL	CHKSYN		; Make sure "(" follows
0CC6: 28                	DB	"("
0CC7: 2B       [ 6]     EVAL:	DEC	HL		; Evaluate expression & save
0CC8: 1600     [13]     	LD	D,0		; Precedence value
0CCA: D5       [11]     EVAL1:	PUSH	DE		; Save precedence
0CCB: 0E01     [18]     	LD	C,1
0CCD: CDCD03   [35]     	CALL	CHKSTK		; Check for 1 level of stack
0CD0: CD3E0D   [52]     	CALL	OPRND		; Get next expression value
0CD3: 221581   [16]     EVAL2:	LD	(NXTOPR),HL	; Save address of next operator
0CD6: 2A1581   [16]     EVAL3:	LD	HL,(NXTOPR)	; Restore address of next opr
0CD9: C1       [26]     	POP	BC		; Precedence value and operator
0CDA: 78       [30]     	LD	A,B		; Get precedence value
0CDB: FE78     [37]     	CP	78H		; "AND" or "OR" ?
0CDD: D4B80C   [47|54]  	CALL	NC,TSTNUM	; No - Make sure it's a number
0CE0: 7E       [54]     	LD	A,(HL)		; Get next operator / function
0CE1: 1600     [61]     	LD	D,0		; Clear Last relation
0CE3: D6B3     [ 7]     RLTLP:	SUB	ZGTR		; ">" Token
0CE5: DAFF0C   [17|17]  	JP	C,FOPRND	; + - * / ^ AND OR - Test it
0CE8: FE03     [24]     	CP	ZLTH+1-ZGTR	; < = >
0CEA: D2FF0C   [34|34]  	JP	NC,FOPRND	; Function - Call it
0CED: FE01     [41]     	CP	ZEQUAL-ZGTR	; "="
0CEF: 17       [45]     	RLA			; <- Test for legal
0CF0: AA       [49]     	XOR	D		; <- combinations of < = >
0CF1: BA       [53]     	CP	D		; <- by combining last token
0CF2: 57       [57]     	LD	D,A		; <- with current one
0CF3: DAF003   [67|67]  	JP	C,SNERR		; Error if "<<' '==" or ">>"
0CF6: 220A81   [83]     	LD	(CUROPR),HL	; Save address of current token
0CF9: CD4808   [100]    	CALL	GETCHR		; Get next character
0CFC: C3E30C   [110]    	JP	RLTLP		; Treat the two as one
                        ;
0CFF: 7A       [ 4]     FOPRND: LD	A,D		; < = > found ?
0D00: B7       [ 8]     	OR	A
0D01: C2260E   [18|18]  	JP	NZ,TSTRED	; Yes - Test for reduction
0D04: 7E       [25]     	LD	A,(HL)		; Get operator token
0D05: 220A81   [41]     	LD	(CUROPR),HL	; Save operator address
0D08: D6AC     [48]     	SUB	ZPLUS		; Operator or function?
0D0A: D8       [53|59]  	RET	C		; Neither - Exit
0D0B: FE07     [60]     	CP	ZOR+1-ZPLUS	; Is it + - * / ^ AND OR ?
0D0D: D0       [65|71]  	RET	NC		; No - Exit
0D0E: 5F       [69]     	LD	E,A		; Coded operator
0D0F: 3AF280   [82]     	LD	A,(TYPE)	; Get data type
0D12: 3D       [86]     	DEC	A		; FF = numeric , 00 = string
0D13: B3       [90]     	OR	E		; Combine with coded operator
0D14: 7B       [94]     	LD	A,E		; Get coded operator
0D15: CA8412   [104|104]	JP	Z,CONCAT	; String concatenation
0D18: 07       [108]    	RLCA			; Times 2
0D19: 83       [112]    	ADD	A,E		; Times 3
0D1A: 5F       [116]    	LD	E,A		; To DE (D is 0)
0D1B: 21E202   [126]    	LD	HL,PRITAB	; Precedence table
0D1E: 19       [137]    	ADD	HL,DE		; To the operator concerned
0D1F: 78       [141]    	LD	A,B		; Last operator precedence
0D20: 56       [148]    	LD	D,(HL)		; Get evaluation precedence
0D21: BA       [152]    	CP	D		; Compare with eval precedence
0D22: D0       [157|163]	RET	NC		; Exit if higher precedence
0D23: 23       [163]    	INC	HL		; Point to routine address
0D24: CDB80C   [180]    	CALL	TSTNUM		; Make sure it's a number
                        ;
0D27: C5       [11]     STKTHS: PUSH	BC		; Save last precedence & token
0D28: 01D60C   [21]     	LD	BC,EVAL3	; Where to go on prec' break
0D2B: C5       [32]     	PUSH	BC		; Save on stack for return
0D2C: 43       [36]     	LD	B,E		; Save operator
0D2D: 4A       [40]     	LD	C,D		; Save precedence
0D2E: CDC816   [57]     	CALL	STAKFP		; Move value to stack
0D31: 58       [61]     	LD	E,B		; Restore operator
0D32: 51       [65]     	LD	D,C		; Restore precedence
0D33: 4E       [72]     	LD	C,(HL)		; Get LSB of routine address
0D34: 23       [78]     	INC	HL
0D35: 46       [85]     	LD	B,(HL)		; Get MSB of routine address
0D36: 23       [91]     	INC	HL
0D37: C5       [102]    	PUSH	BC		; Save routine address
0D38: 2A0A81   [118]    	LD	HL,(CUROPR)	; Address of current operator
0D3B: C3CA0C   [128]    	JP	EVAL1		; Loop until prec' break
                        ;
0D3E: AF       [ 4]     OPRND:	XOR	A		; Get operand routine
0D3F: 32F280   [17]     	LD	(TYPE),A	; Set numeric expected
0D42: CD4808   [34]     	CALL	GETCHR		; Get next character
0D45: 1E24     [41]     	LD	E,MO		; ?MO Error
0D47: CA0404   [51|51]  	JP	Z,ERROR		; No operand - Error
0D4A: DA9E17   [61|61]  	JP	C,ASCTFP	; Number - Get value
0D4D: CDE608   [78]     	CALL	CHKLTR		; See if a letter
0D50: D2A50D   [88|88]  	JP	NC,CONVAR	; Letter - Find variable
0D53: FE26     [95]     	CP	'&'		; &H = HEX, &B = BINARY
0D55: 2012     [102|107]	JR	NZ, NOTAMP
0D57: CD4808   [119]    	CALL	GETCHR		; Get next character
0D5A: FE48     [126]    	CP	'H'		; Hex number indicated? [function added]
0D5C: CAE21B   [136|136]	JP	Z,HEXTFP	; Convert Hex to FPREG
0D5F: FE42     [143]    	CP	'B'		; Binary number indicated? [function added]
0D61: CA521C   [153|153]	JP	Z,BINTFP	; Convert Bin to FPREG
0D64: 1E02     [160]    	LD	E,SN		; If neither then a ?SN Error
0D66: CA0404   [170|170]	JP	Z,ERROR
0D69: FEAC     [ 7]     NOTAMP: CP	ZPLUS		; '+' Token ?
0D6B: CA3E0D   [17|17]  	JP	Z,OPRND		; Yes - Look for operand
0D6E: FE2E     [24]     	CP	'.'		; '.' ?
0D70: CA9E17   [34|34]  	JP	Z,ASCTFP	; Yes - Create FP number
0D73: FEAD     [41]     	CP	ZMINUS		; '-' Token ?
0D75: CA940D   [51|51]  	JP	Z,MINUS		; Yes - Do minus
0D78: FE22     [58]     	CP	'"'		; Literal string ?
0D7A: CA4D11   [68|68]  	JP	Z,QTSTR		; Get string terminated by '"'
0D7D: FEAA     [75]     	CP	ZNOT		; "NOT" Token ?
0D7F: CA860E   [85|85]  	JP	Z,EVNOT		; Yes - Eval NOT expression
0D82: FEA7     [92]     	CP	ZFN		; "FN" Token ?
0D84: CAB110   [102|102]	JP	Z,DOFN		; Yes - Do FN routine
0D87: D6B6     [109]    	SUB	ZSGN		; Is it a function?
0D89: D2B60D   [119|119]	JP	NC,FNOFST	; Yes - Evaluate function
0D8C: CDC30C   [17]     EVLPAR: CALL	OPNPAR		; Evaluate expression in "()"
0D8F: CDBE06   [34]     	CALL	CHKSYN		; Make sure ")" follows
0D92: 29                	DB	")"
0D93: C9       [44]     	RET
                        ;
0D94: 167D     [ 7]     MINUS:	LD	D,7DH		; '-' precedence
0D96: CDCA0C   [24]     	CALL	EVAL1		; Evaluate until prec' break
0D99: 2A1581   [40]     	LD	HL,(NXTOPR)	; Get next operator address
0D9C: E5       [51]     	PUSH	HL		; Save next operator address
0D9D: CDC016   [68]     	CALL	INVSGN		; Negate value
0DA0: CDB80C   [17]     RETNUM: CALL	TSTNUM		; Make sure it's a number
0DA3: E1       [27]     	POP	HL		; Restore next operator address
0DA4: C9       [37]     	RET
                        ;
0DA5: CDAB0E   [17]     CONVAR: CALL	GETVAR		; Get variable address to DE
0DA8: E5       [11]     FRMEVL: PUSH	HL		; Save code string address
0DA9: EB       [15]     	EX	DE,HL		; Variable address to HL
0DAA: 222981   [31]     	LD	(FPREG),HL	; Save address of variable
0DAD: 3AF280   [44]     	LD	A,(TYPE)	; Get type
0DB0: B7       [48]     	OR	A		; Numeric?
0DB1: CCD516   [58|65]  	CALL	Z,PHLTFP	; Yes - Move contents to FPREG
0DB4: E1       [68]     	POP	HL		; Restore code string address
0DB5: C9       [78]     	RET
                        ;
0DB6: 0600     [ 7]     FNOFST: LD	B,0		; Get address of function
0DB8: 07       [11]     	RLCA			; Double function offset
0DB9: 4F       [15]     	LD	C,A		; BC = Offset in function table
0DBA: C5       [26]     	PUSH	BC		; Save adjusted token value
0DBB: CD4808   [43]     	CALL	GETCHR		; Get next character
0DBE: 79       [47]     	LD	A,C		; Get adjusted token value
0DBF: FE31     [54]     	CP	2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
0DC1: DADD0D   [64|64]  	JP	C,FNVAL		; No - Do function
0DC4: CDC30C   [81]     	CALL	OPNPAR		; Evaluate expression	(X,...
0DC7: CDBE06   [98]     	CALL	CHKSYN		; Make sure ',' follows
0DCA: 2C                	DB	','
0DCB: CDB90C   [115]    	CALL	TSTSTR		; Make sure it's a string
0DCE: EB       [119]    	EX	DE,HL		; Save code string address
0DCF: 2A2981   [135]    	LD	HL,(FPREG)	; Get address of string
0DD2: E3       [154]    	EX	(SP),HL		; Save address of string
0DD3: E5       [165]    	PUSH	HL		; Save adjusted token value
0DD4: EB       [169]    	EX	DE,HL		; Restore code string address
0DD5: CD1614   [186]    	CALL	GETINT		; Get integer 0-255
0DD8: EB       [190]    	EX	DE,HL		; Save code string address
0DD9: E3       [209]    	EX	(SP),HL		; Save integer,HL = adj' token
0DDA: C3E50D   [219]    	JP	GOFUNC		; Jump to string function
                        ;
0DDD: CD8C0D   [17]     FNVAL:	CALL	EVLPAR		; Evaluate expression
0DE0: E3       [36]     	EX	(SP),HL		; HL = Adjusted token value
0DE1: 11A00D   [46]     	LD	DE,RETNUM	; Return number from function
0DE4: D5       [57]     	PUSH	DE		; Save on stack
0DE5: 014101   [10]     GOFUNC: LD	BC,FNCTAB	; Function routine addresses
0DE8: 09       [21]     	ADD	HL,BC		; Point to right address
0DE9: 4E       [28]     	LD	C,(HL)		; Get LSB of address
0DEA: 23       [34]     	INC	HL		;
0DEB: 66       [41]     	LD	H,(HL)		; Get MSB of address
0DEC: 69       [45]     	LD	L,C		; Address to HL
0DED: E9       [49]     	JP	(HL)		; Jump to function
                        ;
0DEE: 15       [ 4]     SGNEXP: DEC	D		; Dee to flag negative exponent
0DEF: FEAD     [11]     	CP	ZMINUS		; '-' token ?
0DF1: C8       [16|22]  	RET	Z		; Yes - Return
0DF2: FE2D     [23]     	CP	'-'		; '-' ASCII ?
0DF4: C8       [28|34]  	RET	Z		; Yes - Return
0DF5: 14       [32]     	INC	D		; Inc to flag positive exponent
0DF6: FE2B     [39]     	CP	'+'		; '+' ASCII ?
0DF8: C8       [44|50]  	RET	Z		; Yes - Return
0DF9: FEAC     [51]     	CP	ZPLUS		; '+' token ?
0DFB: C8       [56|62]  	RET	Z		; Yes - Return
0DFC: 2B       [62]     	DEC	HL		; DEC 'cos GETCHR INCs
0DFD: C9       [72]     	RET			; Return "NZ"
                        ;
0DFE: F6                POR:	DB	0F6H		; Flag "OR"
0DFF: AF       [ 4]     PAND:	XOR	A		; Flag "AND"
0E00: F5       [15]     	PUSH	AF		; Save "AND" / "OR" flag
0E01: CDB80C   [32]     	CALL	TSTNUM		; Make sure it's a number
0E04: CDFA08   [49]     	CALL	DEINT		; Get integer -32768 to 32767
0E07: F1       [59]     	POP	AF		; Restore "AND" / "OR" flag
0E08: EB       [63]     	EX	DE,HL		; <- Get last
0E09: C1       [73]     	POP	BC		; <- value
0E0A: E3       [92]     	EX	(SP),HL		; <- from
0E0B: EB       [96]     	EX	DE,HL		; <- stack
0E0C: CDD816   [113]    	CALL	FPBCDE		; Move last value to FPREG
0E0F: F5       [124]    	PUSH	AF		; Save "AND" / "OR" flag
0E10: CDFA08   [141]    	CALL	DEINT		; Get integer -32768 to 32767
0E13: F1       [151]    	POP	AF		; Restore "AND" / "OR" flag
0E14: C1       [161]    	POP	BC		; Get value
0E15: 79       [165]    	LD	A,C		; Get LSB
0E16: 216F10   [175]    	LD	HL,ACPASS	; Address of save AC as current
0E19: C2210E   [185|185]	JP	NZ,POR1		; Jump if OR
0E1C: A3       [189]    	AND	E		; "AND" LSBs
0E1D: 4F       [193]    	LD	C,A		; Save LSB
0E1E: 78       [197]    	LD	A,B		; Get MBS
0E1F: A2       [201]    	AND	D		; "AND" MSBs
0E20: E9       [205]    	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E21: B3       [ 4]     POR1:	OR	E		; "OR" LSBs
0E22: 4F       [ 8]     	LD	C,A		; Save LSB
0E23: 78       [12]     	LD	A,B		; Get MSB
0E24: B2       [16]     	OR	D		; "OR" MSBs
0E25: E9       [20]     	JP	(HL)		; Save AC as current (ACPASS)
                        ;
0E26: 21380E   [10]     TSTRED: LD	HL,CMPLOG	; Logical compare routine
0E29: 3AF280   [23]     	LD	A,(TYPE)	; Get data type
0E2C: 1F       [27]     	RRA			; Carry set = string
0E2D: 7A       [31]     	LD	A,D		; Get last precedence value
0E2E: 17       [35]     	RLA			; Times 2 plus carry
0E2F: 5F       [39]     	LD	E,A		; To E
0E30: 1664     [46]     	LD	D,64H		; Relational precedence
0E32: 78       [50]     	LD	A,B		; Get current precedence
0E33: BA       [54]     	CP	D		; Compare with last
0E34: D0       [59|65]  	RET	NC		; Eval if last was rel' or log'
0E35: C3270D   [69]     	JP	STKTHS		; Stack this one and get next
                        ;
0E38: 3A0E              CMPLOG: DW	CMPLG1		; Compare two values / strings
0E3A: 79       [ 4]     CMPLG1: LD	A,C		; Get data type
0E3B: B7       [ 8]     	OR	A
0E3C: 1F       [12]     	RRA
0E3D: C1       [22]     	POP	BC		; Get last expression to BCDE
0E3E: D1       [32]     	POP	DE
0E3F: F5       [43]     	PUSH	AF		; Save status
0E40: CDBA0C   [60]     	CALL	CHKTYP		; Check that types match
0E43: 217C0E   [70]     	LD	HL,CMPRES	; Result to comparison
0E46: E5       [81]     	PUSH	HL		; Save for RETurn
0E47: CA1217   [91|91]  	JP	Z,CMPNUM	; Compare values if numeric
0E4A: AF       [95]     	XOR	A		; Compare two strings
0E4B: 32F280   [108]    	LD	(TYPE),A	; Set type to numeric
0E4E: D5       [119]    	PUSH	DE		; Save string name
0E4F: CDD112   [136]    	CALL	GSTRCU		; Get current string
0E52: 7E       [143]    	LD	A,(HL)		; Get length of string
0E53: 23       [149]    	INC	HL
0E54: 23       [155]    	INC	HL
0E55: 4E       [162]    	LD	C,(HL)		; Get LSB of address
0E56: 23       [168]    	INC	HL
0E57: 46       [175]    	LD	B,(HL)		; Get MSB of address
0E58: D1       [185]    	POP	DE		; Restore string name
0E59: C5       [196]    	PUSH	BC		; Save address of string
0E5A: F5       [207]    	PUSH	AF		; Save length of string
0E5B: CDD512   [224]    	CALL	GSTRDE		; Get second string
0E5E: CDE616   [241]    	CALL	LOADFP		; Get address of second string
0E61: F1       [251]    	POP	AF		; Restore length of string 1
0E62: 57       [255]    	LD	D,A		; Length to D
0E63: E1       [265]    	POP	HL		; Restore address of string 1
0E64: 7B       [ 4]     CMPSTR: LD	A,E		; Bytes of string 2 to do
0E65: B2       [ 8]     	OR	D		; Bytes of string 1 to do
0E66: C8       [13|19]  	RET	Z		; Exit if all bytes compared
0E67: 7A       [17]     	LD	A,D		; Get bytes of string 1 to do
0E68: D601     [24]     	SUB	1
0E6A: D8       [29|35]  	RET	C		; Exit if end of string 1
0E6B: AF       [33]     	XOR	A
0E6C: BB       [37]     	CP	E		; Bytes of string 2 to do
0E6D: 3C       [41]     	INC	A
0E6E: D0       [46|52]  	RET	NC		; Exit if end of string 2
0E6F: 15       [50]     	DEC	D		; Count bytes in string 1
0E70: 1D       [54]     	DEC	E		; Count bytes in string 2
0E71: 0A       [61]     	LD	A,(BC)		; Byte in string 2
0E72: BE       [68]     	CP	(HL)		; Compare to byte in string 1
0E73: 23       [74]     	INC	HL		; Move up string 1
0E74: 03       [80]     	INC	BC		; Move up string 2
0E75: CA640E   [90|90]  	JP	Z,CMPSTR	; Same - Try next bytes
0E78: 3F       [94]     	CCF			; Flag difference (">" or "<")
0E79: C3A216   [104]    	JP	FLGDIF		; "<" gives -1 , ">" gives +1
                        ;
0E7C: 3C       [ 4]     CMPRES: INC	A		; Increment current value
0E7D: 8F       [ 8]     	ADC	A,A		; Double plus carry
0E7E: C1       [18]     	POP	BC		; Get other value
0E7F: A0       [22]     	AND	B		; Combine them
0E80: C6FF     [29]     	ADD	A,-1		; Carry set if different
0E82: 9F       [33]     	SBC	A,A		; 00 - Equal , FF - Different
0E83: C3A916   [43]     	JP	FLGREL		; Set current value & continue
                        ;
0E86: 165A     [ 7]     EVNOT:	LD	D,5AH		; Precedence value for "NOT"
0E88: CDCA0C   [24]     	CALL	EVAL1		; Eval until precedence break
0E8B: CDB80C   [41]     	CALL	TSTNUM		; Make sure it's a number
0E8E: CDFA08   [58]     	CALL	DEINT		; Get integer -32768 - 32767
0E91: 7B       [62]     	LD	A,E		; Get LSB
0E92: 2F       [66]     	CPL			; Invert LSB
0E93: 4F       [70]     	LD	C,A		; Save "NOT" of LSB
0E94: 7A       [74]     	LD	A,D		; Get MSB
0E95: 2F       [78]     	CPL			; Invert MSB
0E96: CD6F10   [95]     	CALL	ACPASS		; Save AC as current
0E99: C1       [105]    	POP	BC		; Clean up stack
0E9A: C3D60C   [115]    	JP	EVAL3		; Continue evaluation
                        ;
0E9D: 2B       [ 6]     DIMRET: DEC	HL		; DEC 'cos GETCHR INCs
0E9E: CD4808   [23]     	CALL	GETCHR		; Get next character
0EA1: C8       [28|34]  	RET	Z		; End of DIM statement
0EA2: CDBE06   [45]     	CALL	CHKSYN		; Make sure ',' follows
0EA5: 2C                	DB	','
0EA6: 019D0E   [10]     DIM:	LD	BC,DIMRET	; Return to "DIMRET"
0EA9: C5       [21]     	PUSH	BC		; Save on stack
0EAA: F6                	DB	0F6H		; Flag "Create" variable
0EAB: AF       [ 4]     GETVAR: XOR	A		; Find variable address,to DE
0EAC: 32F180   [17]     	LD	(LCRFLG),A	; Set locate / create flag
0EAF: 46       [24]     	LD	B,(HL)		; Get First byte of name
0EB0: CDE608   [17]     GTFNAM: CALL	CHKLTR		; See if a letter
0EB3: DAF003   [27|27]  	JP	C,SNERR		; ?SN Error if not a letter
0EB6: AF       [31]     	XOR	A
0EB7: 4F       [35]     	LD	C,A		; Clear second byte of name
0EB8: 32F280   [48]     	LD	(TYPE),A	; Set type to numeric
0EBB: CD4808   [65]     	CALL	GETCHR		; Get next character
0EBE: DAC70E   [75|75]  	JP	C,SVNAM2	; Numeric - Save in name
0EC1: CDE608   [92]     	CALL	CHKLTR		; See if a letter
0EC4: DAD40E   [102|102]	JP	C,CHARTY	; Not a letter - Check type
0EC7: 4F       [ 4]     SVNAM2: LD	C,A		; Save second byte of name
0EC8: CD4808   [17]     ENDNAM: CALL	GETCHR		; Get next character
0ECB: DAC80E   [27|27]  	JP	C,ENDNAM	; Numeric - Get another
0ECE: CDE608   [44]     	CALL	CHKLTR		; See if a letter
0ED1: D2C80E   [54|54]  	JP	NC,ENDNAM	; Letter - Get another
0ED4: D624     [ 7]     CHARTY: SUB	'$'		; String variable?
0ED6: C2E30E   [17|17]  	JP	NZ,NOTSTR	; No - Numeric variable
0ED9: 3C       [21]     	INC	A		; A = 1 (string type)
0EDA: 32F280   [34]     	LD	(TYPE),A	; Set type to string
0EDD: 0F       [38]     	RRCA			; A = 80H , Flag for string
0EDE: 81       [42]     	ADD	A,C		; 2nd byte of name has bit 7 on
0EDF: 4F       [46]     	LD	C,A		; Resave second byte on name
0EE0: CD4808   [63]     	CALL	GETCHR		; Get next character
0EE3: 3A1081   [13]     NOTSTR: LD	A,(FORFLG)	; Array name needed ?
0EE6: 3D       [17]     	DEC	A
0EE7: CA900F   [27|27]  	JP	Z,ARLDSV	; Yes - Get array name
0EEA: F2F30E   [37|37]  	JP	P,NSCFOR	; No array with "FOR" or "FN"
0EED: 7E       [44]     	LD	A,(HL)		; Get byte again
0EEE: D628     [51]     	SUB	'('		; Subscripted variable?
0EF0: CA680F   [61|61]  	JP	Z,SBSCPT	; Yes - Sort out subscript
                        ;
0EF3: AF       [ 4]     NSCFOR: XOR	A		; Simple variable
0EF4: 321081   [17]     	LD	(FORFLG),A	; Clear "FOR" flag
0EF7: E5       [28]     	PUSH	HL		; Save code string address
0EF8: 50       [32]     	LD	D,B		; DE = Variable name to find
0EF9: 59       [36]     	LD	E,C
0EFA: 2A2381   [52]     	LD	HL,(FNRGNM)	; FN argument name
0EFD: CDB806   [69]     	CALL	CPDEHL		; Is it the FN argument?
0F00: 112581   [79]     	LD	DE,FNARG	; Point to argument value
0F03: CAD815   [89|89]  	JP	Z,POPHRT	; Yes - Return FN argument value
0F06: 2A1D81   [105]    	LD	HL,(VAREND)	; End of variables
0F09: EB       [109]    	EX	DE,HL		; Address of end of search
0F0A: 2A1B81   [125]    	LD	HL,(PROGND)	; Start of variables address
0F0D: CDB806   [17]     FNDVAR: CALL	CPDEHL		; End of variable list table?
0F10: CA260F   [27|27]  	JP	Z,CFEVAL	; Yes - Called from EVAL?
0F13: 79       [31]     	LD	A,C		; Get second byte of name
0F14: 96       [38]     	SUB	(HL)		; Compare with name in list
0F15: 23       [44]     	INC	HL		; Move on to first byte
0F16: C21B0F   [54|54]  	JP	NZ,FNTHR	; Different - Find another
0F19: 78       [58]     	LD	A,B		; Get first byte of name
0F1A: 96       [65]     	SUB	(HL)		; Compare with name in list
0F1B: 23       [ 6]     FNTHR:	INC	HL		; Move on to LSB of value
0F1C: CA5A0F   [16|16]  	JP	Z,RETADR	; Found - Return address
0F1F: 23       [22]     	INC	HL		; <- Skip
0F20: 23       [28]     	INC	HL		; <- over
0F21: 23       [34]     	INC	HL		; <- F.P.
0F22: 23       [40]     	INC	HL		; <- value
0F23: C30D0F   [50]     	JP	FNDVAR		; Keep looking
                        ;
0F26: E1       [10]     CFEVAL: POP	HL		; Restore code string address
0F27: E3       [29]     	EX	(SP),HL		; Get return address
0F28: D5       [40]     	PUSH	DE		; Save address of variable
0F29: 11A80D   [50]     	LD	DE,FRMEVL	; Return address in EVAL
0F2C: CDB806   [67]     	CALL	CPDEHL		; Called from EVAL ?
0F2F: D1       [77]     	POP	DE		; Restore address of variable
0F30: CA5D0F   [87|87]  	JP	Z,RETNUL	; Yes - Return null variable
0F33: E3       [106]    	EX	(SP),HL		; Put back return
0F34: E5       [117]    	PUSH	HL		; Save code string address
0F35: C5       [128]    	PUSH	BC		; Save variable name
0F36: 010600   [138]    	LD	BC,6		; 2 byte name plus 4 byte data
0F39: 2A1F81   [154]    	LD	HL,(ARREND)	; End of arrays
0F3C: E5       [165]    	PUSH	HL		; Save end of arrays
0F3D: 09       [176]    	ADD	HL,BC		; Move up 6 bytes
0F3E: C1       [186]    	POP	BC		; Source address in BC
0F3F: E5       [197]    	PUSH	HL		; Save new end address
0F40: CDBC03   [214]    	CALL	MOVUP		; Move arrays up
0F43: E1       [224]    	POP	HL		; Restore new end address
0F44: 221F81   [240]    	LD	(ARREND),HL	; Set new end address
0F47: 60       [244]    	LD	H,B		; End of variables to HL
0F48: 69       [248]    	LD	L,C
0F49: 221D81   [264]    	LD	(VAREND),HL	; Set new end address
                        ;
0F4C: 2B       [ 6]     ZEROLP: DEC	HL		; Back through to zero variable
0F4D: 3600     [16]     	LD	(HL),0		; Zero byte in variable
0F4F: CDB806   [33]     	CALL	CPDEHL		; Done them all?
0F52: C24C0F   [43|43]  	JP	NZ,ZEROLP	; No - Keep on going
0F55: D1       [53]     	POP	DE		; Get variable name
0F56: 73       [60]     	LD	(HL),E		; Store second character
0F57: 23       [66]     	INC	HL
0F58: 72       [73]     	LD	(HL),D		; Store first character
0F59: 23       [79]     	INC	HL
0F5A: EB       [ 4]     RETADR: EX	DE,HL		; Address of variable in DE
0F5B: E1       [14]     	POP	HL		; Restore code string address
0F5C: C9       [24]     	RET
                        ;
0F5D: 322C81   [13]     RETNUL: LD	(FPEXP),A	; Set result to zero
0F60: 218C03   [23]     	LD	HL,ZERBYT	; Also set a null string
0F63: 222981   [39]     	LD	(FPREG),HL	; Save for EVAL
0F66: E1       [49]     	POP	HL		; Restore code string address
0F67: C9       [59]     	RET
                        ;
0F68: E5       [11]     SBSCPT: PUSH	HL		; Save code string address
0F69: 2AF180   [27]     	LD	HL,(LCRFLG)	; Locate/Create and Type
0F6C: E3       [46]     	EX	(SP),HL		; Save and get code string
0F6D: 57       [50]     	LD	D,A		; Zero number of dimensions
0F6E: D5       [11]     SCPTLP: PUSH	DE		; Save number of dimensions
0F6F: C5       [22]     	PUSH	BC		; Save array name
0F70: CDEE08   [39]     	CALL	FPSINT		; Get subscript (0-32767)
0F73: C1       [49]     	POP	BC		; Restore array name
0F74: F1       [59]     	POP	AF		; Get number of dimensions
0F75: EB       [63]     	EX	DE,HL
0F76: E3       [82]     	EX	(SP),HL		; Save subscript value
0F77: E5       [93]     	PUSH	HL		; Save LCRFLG and TYPE
0F78: EB       [97]     	EX	DE,HL
0F79: 3C       [101]    	INC	A		; Count dimensions
0F7A: 57       [105]    	LD	D,A		; Save in D
0F7B: 7E       [112]    	LD	A,(HL)		; Get next byte in code string
0F7C: FE2C     [119]    	CP	','		; Comma (more to come)?
0F7E: CA6E0F   [129|129]	JP	Z,SCPTLP	; Yes - More subscripts
0F81: CDBE06   [146]    	CALL	CHKSYN		; Make sure ")" follows
0F84: 29                	DB	")"
0F85: 221581   [162]    	LD	(NXTOPR),HL	; Save code string address
0F88: E1       [172]    	POP	HL		; Get LCRFLG and TYPE
0F89: 22F180   [188]    	LD	(LCRFLG),HL	; Restore Locate/create & type
0F8C: 1E00     [195]    	LD	E,0		; Flag not CSAVE* or CLOAD*
0F8E: D5       [206]    	PUSH	DE		; Save number of dimensions (D)
0F8F: 11                	DB	11H		; Skip "PUSH HL" and "PUSH AF'
                        ;
0F90: E5       [11]     ARLDSV: PUSH	HL		; Save code string address
0F91: F5       [22]     	PUSH	AF		; A = 00 , Flags set = Z,N
0F92: 2A1D81   [38]     	LD	HL,(VAREND)	; Start of arrays
0F95: 3E                	DB	3EH		; Skip "ADD HL,DE"
0F96: 19       [11]     FNDARY: ADD	HL,DE		; Move to next array start
0F97: EB       [15]     	EX	DE,HL
0F98: 2A1F81   [31]     	LD	HL,(ARREND)	; End of arrays
0F9B: EB       [35]     	EX	DE,HL		; Current array pointer
0F9C: CDB806   [52]     	CALL	CPDEHL		; End of arrays found?
0F9F: CAC80F   [62|62]  	JP	Z,CREARY	; Yes - Create array
0FA2: 7E       [69]     	LD	A,(HL)		; Get second byte of name
0FA3: B9       [73]     	CP	C		; Compare with name given
0FA4: 23       [79]     	INC	HL		; Move on
0FA5: C2AA0F   [89|89]  	JP	NZ,NXTARY	; Different - Find next array
0FA8: 7E       [96]     	LD	A,(HL)		; Get first byte of name
0FA9: B8       [100]    	CP	B		; Compare with name given
0FAA: 23       [ 6]     NXTARY: INC	HL		; Move on
0FAB: 5E       [13]     	LD	E,(HL)		; Get LSB of next array address
0FAC: 23       [19]     	INC	HL
0FAD: 56       [26]     	LD	D,(HL)		; Get MSB of next array address
0FAE: 23       [32]     	INC	HL
0FAF: C2960F   [42|42]  	JP	NZ,FNDARY	; Not found - Keep looking
0FB2: 3AF180   [55]     	LD	A,(LCRFLG)	; Found Locate or Create it?
0FB5: B7       [59]     	OR	A
0FB6: C2F903   [69|69]  	JP	NZ,DDERR	; Create - ?DD Error
0FB9: F1       [79]     	POP	AF		; Locate - Get number of dim'ns
0FBA: 44       [83]     	LD	B,H		; BC Points to array dim'ns
0FBB: 4D       [87]     	LD	C,L
0FBC: CAD815   [97|97]  	JP	Z,POPHRT	; Jump if array load/save
0FBF: 96       [104]    	SUB	(HL)		; Same number of dimensions?
0FC0: CA2610   [114|114]	JP	Z,FINDEL	; Yes - Find element
0FC3: 1E10     [ 7]     BSERR:	LD	E,BS		; ?BS Error
0FC5: C30404   [17]     	JP	ERROR		; Output error
                        ;
0FC8: 110400   [10]     CREARY: LD	DE,4		; 4 Bytes per entry
0FCB: F1       [20]     	POP	AF		; Array to save or 0 dim'ns?
0FCC: CA0F09   [30|30]  	JP	Z,FCERR		; Yes - ?FC Error
0FCF: 71       [37]     	LD	(HL),C		; Save second byte of name
0FD0: 23       [43]     	INC	HL
0FD1: 70       [50]     	LD	(HL),B		; Save first byte of name
0FD2: 23       [56]     	INC	HL
0FD3: 4F       [60]     	LD	C,A		; Number of dimensions to C
0FD4: CDCD03   [77]     	CALL	CHKSTK		; Check if enough memory
0FD7: 23       [83]     	INC	HL		; Point to number of dimensions
0FD8: 23       [89]     	INC	HL
0FD9: 220A81   [105]    	LD	(CUROPR),HL	; Save address of pointer
0FDC: 71       [112]    	LD	(HL),C		; Set number of dimensions
0FDD: 23       [118]    	INC	HL
0FDE: 3AF180   [131]    	LD	A,(LCRFLG)	; Locate of Create?
0FE1: 17       [135]    	RLA			; Carry set = Create
0FE2: 79       [139]    	LD	A,C		; Get number of dimensions
0FE3: 010B00   [10]     CRARLP: LD	BC,10+1		; Default dimension size 10
0FE6: D2EB0F   [20|20]  	JP	NC,DEFSIZ	; Locate - Set default size
0FE9: C1       [30]     	POP	BC		; Get specified dimension size
0FEA: 03       [36]     	INC	BC		; Include zero element
0FEB: 71       [ 7]     DEFSIZ: LD	(HL),C		; Save LSB of dimension size
0FEC: 23       [13]     	INC	HL
0FED: 70       [20]     	LD	(HL),B		; Save MSB of dimension size
0FEE: 23       [26]     	INC	HL
0FEF: F5       [37]     	PUSH	AF		; Save num' of dim'ns an status
0FF0: E5       [48]     	PUSH	HL		; Save address of dim'n size
0FF1: CD8317   [65]     	CALL	MLDEBC		; Multiply DE by BC to find
0FF4: EB       [69]     	EX	DE,HL		; amount of mem needed (to DE)
0FF5: E1       [79]     	POP	HL		; Restore address of dimension
0FF6: F1       [89]     	POP	AF		; Restore number of dimensions
0FF7: 3D       [93]     	DEC	A		; Count them
0FF8: C2E30F   [103|103]	JP	NZ,CRARLP	; Do next dimension if more
0FFB: F5       [114]    	PUSH	AF		; Save locate/create flag
0FFC: 42       [118]    	LD	B,D		; MSB of memory needed
0FFD: 4B       [122]    	LD	C,E		; LSB of memory needed
0FFE: EB       [126]    	EX	DE,HL
0FFF: 19       [137]    	ADD	HL,DE		; Add bytes to array start
1000: DAE503   [147|147]	JP	C,OMERR		; Too big - Error
1003: CDD603   [164]    	CALL	ENFMEM		; See if enough memory
1006: 221F81   [180]    	LD	(ARREND),HL	; Save new end of array
                        ;
1009: 2B       [ 6]     ZERARY: DEC	HL		; Back through array data
100A: 3600     [16]     	LD	(HL),0		; Set array element to zero
100C: CDB806   [33]     	CALL	CPDEHL		; All elements zeroed?
100F: C20910   [43|43]  	JP	NZ,ZERARY	; No - Keep on going
1012: 03       [49]     	INC	BC		; Number of bytes + 1
1013: 57       [53]     	LD	D,A		; A=0
1014: 2A0A81   [69]     	LD	HL,(CUROPR)	; Get address of array
1017: 5E       [76]     	LD	E,(HL)		; Number of dimensions
1018: EB       [80]     	EX	DE,HL		; To HL
1019: 29       [91]     	ADD	HL,HL		; Two bytes per dimension size
101A: 09       [102]    	ADD	HL,BC		; Add number of bytes
101B: EB       [106]    	EX	DE,HL		; Bytes needed to DE
101C: 2B       [112]    	DEC	HL
101D: 2B       [118]    	DEC	HL
101E: 73       [125]    	LD	(HL),E		; Save LSB of bytes needed
101F: 23       [131]    	INC	HL
1020: 72       [138]    	LD	(HL),D		; Save MSB of bytes needed
1021: 23       [144]    	INC	HL
1022: F1       [154]    	POP	AF		; Locate / Create?
1023: DA4A10   [164|164]	JP	C,ENDDIM	; A is 0 , End if create
1026: 47       [ 4]     FINDEL: LD	B,A		; Find array element
1027: 4F       [ 8]     	LD	C,A
1028: 7E       [15]     	LD	A,(HL)		; Number of dimensions
1029: 23       [21]     	INC	HL
102A: 16                	DB	16H		; Skip "POP HL"
102B: E1       [10]     FNDELP: POP	HL		; Address of next dim' size
102C: 5E       [17]     	LD	E,(HL)		; Get LSB of dim'n size
102D: 23       [23]     	INC	HL
102E: 56       [30]     	LD	D,(HL)		; Get MSB of dim'n size
102F: 23       [36]     	INC	HL
1030: E3       [55]     	EX	(SP),HL		; Save address - Get index
1031: F5       [66]     	PUSH	AF		; Save number of dim'ns
1032: CDB806   [83]     	CALL	CPDEHL		; Dimension too large?
1035: D2C30F   [93|93]  	JP	NC,BSERR	; Yes - ?BS Error
1038: E5       [104]    	PUSH	HL		; Save index
1039: CD8317   [121]    	CALL	MLDEBC		; Multiply previous by size
103C: D1       [131]    	POP	DE		; Index supplied to DE
103D: 19       [142]    	ADD	HL,DE		; Add index to pointer
103E: F1       [152]    	POP	AF		; Number of dimensions
103F: 3D       [156]    	DEC	A		; Count them
1040: 44       [160]    	LD	B,H		; MSB of pointer
1041: 4D       [164]    	LD	C,L		; LSB of pointer
1042: C22B10   [174|174]	JP	NZ,FNDELP	; More - Keep going
1045: 29       [185]    	ADD	HL,HL		; 4 Bytes per element
1046: 29       [196]    	ADD	HL,HL
1047: C1       [206]    	POP	BC		; Start of array
1048: 09       [217]    	ADD	HL,BC		; Point to element
1049: EB       [221]    	EX	DE,HL		; Address of element to DE
104A: 2A1581   [16]     ENDDIM: LD	HL,(NXTOPR)	; Got code string address
104D: C9       [26]     	RET
                        ;
104E: 2A1F81   [16]     FRE:	LD	HL,(ARREND)	; Start of free memory
1051: EB       [20]     	EX	DE,HL		; To DE
1052: 210000   [30]     	LD	HL,0		; End of free memory
1055: 39       [41]     	ADD	HL,SP		; Current stack value
1056: 3AF280   [54]     	LD	A,(TYPE)	; Dummy argument type
1059: B7       [58]     	OR	A
105A: CA6A10   [68|68]  	JP	Z,FRENUM	; Numeric - Free variable space
105D: CDD112   [85]     	CALL	GSTRCU		; Current string to pool
1060: CDD111   [102]    	CALL	GARBGE		; Garbage collection
1063: 2A9F80   [118]    	LD	HL,(STRSPC)	; Bottom of string space in use
1066: EB       [122]    	EX	DE,HL		; To DE
1067: 2A0881   [138]    	LD	HL,(STRBOT)	; Bottom of string space
106A: 7D       [ 4]     FRENUM: LD	A,L		; Get LSB of end
106B: 93       [ 8]     	SUB	E		; Subtract LSB of beginning
106C: 4F       [12]     	LD	C,A		; Save difference if C
106D: 7C       [16]     	LD	A,H		; Get MSB of end
106E: 9A       [20]     	SBC	A,D		; Subtract MSB of beginning
106F: 41       [ 4]     ACPASS: LD	B,C		; Return integer AC
1070: 50       [ 4]     ABPASS: LD	D,B		; Return integer AB
1071: 1E00     [11]     	LD	E,0
1073: 21F280   [21]     	LD	HL,TYPE		; Point to type
1076: 73       [28]     	LD	(HL),E		; Set type to numeric
1077: 0690     [35]     	LD	B,80H+16	; 16 bit integer
1079: C3AE16   [45]     	JP	RETINT		; Return the integr
                        ;
107C: 3AF080   [13]     POS:	LD	A,(CURPOS)	; Get cursor position
107F: 47       [ 4]     PASSA:	LD	B,A		; Put A into AB
1080: AF       [ 8]     	XOR	A		; Zero A
1081: C37010   [18]     	JP	ABPASS		; Return integer AB
                        ;
1084: CD0711   [17]     DEF:	CALL	CHEKFN		; Get "FN" and name
1087: CDF910   [34]     	CALL	IDTEST		; Test for illegal direct
108A: 01DF09   [44]     	LD	BC,DATA		; To get next statement
108D: C5       [55]     	PUSH	BC		; Save address for RETurn
108E: D5       [66]     	PUSH	DE		; Save address of function ptr
108F: CDBE06   [83]     	CALL	CHKSYN		; Make sure "(" follows
1092: 28                	DB	"("
1093: CDAB0E   [100]    	CALL	GETVAR		; Get argument variable name
1096: E5       [111]    	PUSH	HL		; Save code string address
1097: EB       [115]    	EX	DE,HL		; Argument address to HL
1098: 2B       [121]    	DEC	HL
1099: 56       [128]    	LD	D,(HL)		; Get first byte of arg name
109A: 2B       [134]    	DEC	HL
109B: 5E       [141]    	LD	E,(HL)		; Get second byte of arg name
109C: E1       [151]    	POP	HL		; Restore code string address
109D: CDB80C   [168]    	CALL	TSTNUM		; Make sure numeric argument
10A0: CDBE06   [185]    	CALL	CHKSYN		; Make sure ")" follows
10A3: 29                	DB	")"
10A4: CDBE06   [202]    	CALL	CHKSYN		; Make sure "=" follows
10A7: B4                	DB	ZEQUAL		; "=" token
10A8: 44       [206]    	LD	B,H		; Code string address to BC
10A9: 4D       [210]    	LD	C,L
10AA: E3       [229]    	EX	(SP),HL		; Save code str , Get FN ptr
10AB: 71       [236]    	LD	(HL),C		; Save LSB of FN code string
10AC: 23       [242]    	INC	HL
10AD: 70       [249]    	LD	(HL),B		; Save MSB of FN code string
10AE: C34611   [259]    	JP	SVSTAD		; Save address and do function
                        ;
10B1: CD0711   [17]     DOFN:	CALL	CHEKFN		; Make sure FN follows
10B4: D5       [28]     	PUSH	DE		; Save function pointer address
10B5: CD8C0D   [45]     	CALL	EVLPAR		; Evaluate expression in "()"
10B8: CDB80C   [62]     	CALL	TSTNUM		; Make sure numeric result
10BB: E3       [81]     	EX	(SP),HL		; Save code str , Get FN ptr
10BC: 5E       [88]     	LD	E,(HL)		; Get LSB of FN code string
10BD: 23       [94]     	INC	HL
10BE: 56       [101]    	LD	D,(HL)		; Get MSB of FN code string
10BF: 23       [107]    	INC	HL
10C0: 7A       [111]    	LD	A,D		; And function DEFined?
10C1: B3       [115]    	OR	E
10C2: CAFC03   [125|125]	JP	Z,UFERR		; No - ?UF Error
10C5: 7E       [132]    	LD	A,(HL)		; Get LSB of argument address
10C6: 23       [138]    	INC	HL
10C7: 66       [145]    	LD	H,(HL)		; Get MSB of argument address
10C8: 6F       [149]    	LD	L,A		; HL = Arg variable address
10C9: E5       [160]    	PUSH	HL		; Save it
10CA: 2A2381   [176]    	LD	HL,(FNRGNM)	; Get old argument name
10CD: E3       [195]    	EX	(SP),HL;	; Save old , Get new
10CE: 222381   [211]    	LD	(FNRGNM),HL	; Set new argument name
10D1: 2A2781   [227]    	LD	HL,(FNARG+2)	; Get LSB,NLSB of old arg value
10D4: E5       [238]    	PUSH	HL		; Save it
10D5: 2A2581   [254]    	LD	HL,(FNARG)	; Get MSB,EXP of old arg value
10D8: E5       [265]    	PUSH	HL		; Save it
10D9: 212581   [275]    	LD	HL,FNARG	; HL = Value of argument
10DC: D5       [286]    	PUSH	DE		; Save FN code string address
10DD: CDEF16   [303]    	CALL	FPTHL		; Move FPREG to argument
10E0: E1       [313]    	POP	HL		; Get FN code string address
10E1: CDB50C   [330]    	CALL	GETNUM		; Get value from function
10E4: 2B       [336]    	DEC	HL		; DEC 'cos GETCHR INCs
10E5: CD4808   [353]    	CALL	GETCHR		; Get next character
10E8: C2F003   [363|363]	JP	NZ,SNERR	; Bad character in FN - Error
10EB: E1       [373]    	POP	HL		; Get MSB,EXP of old arg
10EC: 222581   [389]    	LD	(FNARG),HL	; Restore it
10EF: E1       [399]    	POP	HL		; Get LSB,NLSB of old arg
10F0: 222781   [415]    	LD	(FNARG+2),HL	; Restore it
10F3: E1       [425]    	POP	HL		; Get name of old arg
10F4: 222381   [441]    	LD	(FNRGNM),HL	; Restore it
10F7: E1       [451]    	POP	HL		; Restore code string address
10F8: C9       [461]    	RET
                        ;
10F9: E5       [11]     IDTEST: PUSH	HL		; Save code string address
10FA: 2AA180   [27]     	LD	HL,(LINEAT)	; Get current line number
10FD: 23       [33]     	INC	HL		; -1 means direct statement
10FE: 7C       [37]     	LD	A,H
10FF: B5       [41]     	OR	L
1100: E1       [51]     	POP	HL		; Restore code string address
1101: C0       [56|62]  	RET	NZ		; Return if in program
1102: 1E16     [63]     	LD	E,ID		; ?ID Error
1104: C30404   [73]     	JP	ERROR
                        ;
1107: CDBE06   [17]     CHEKFN: CALL	CHKSYN		; Make sure FN follows
110A: A7                	DB	ZFN		; "FN" token
110B: 3E80     [24]     	LD	A,80H
110D: 321081   [37]     	LD	(FORFLG),A	; Flag FN name to find
1110: B6       [44]     	OR	(HL)		; FN name has bit 7 set
1111: 47       [48]     	LD	B,A		; in first byte of name
1112: CDB00E   [65]     	CALL	GTFNAM		; Get FN name
1115: C3B80C   [75]     	JP	TSTNUM		; Make sure numeric function
                        ;
1118: CDB80C   [17]     STR:	CALL	TSTNUM		; Make sure it's a number
111B: CD3C18   [34]     	CALL	NUMASC		; Turn number into text
111E: CD4C11   [17]     STR1:	CALL	CRTST		; Create string entry for it
1121: CDD112   [34]     	CALL	GSTRCU		; Current string to pool
1124: 012C13   [44]     	LD	BC,TOPOOL	; Save in string pool
1127: C5       [55]     	PUSH	BC		; Save address on stack
                        ;
1128: 7E       [ 7]     SAVSTR: LD	A,(HL)		; Get string length
1129: 23       [13]     	INC	HL
112A: 23       [19]     	INC	HL
112B: E5       [30]     	PUSH	HL		; Save pointer to string
112C: CDA711   [47]     	CALL	TESTR		; See if enough string space
112F: E1       [57]     	POP	HL		; Restore pointer to string
1130: 4E       [64]     	LD	C,(HL)		; Get LSB of address
1131: 23       [70]     	INC	HL
1132: 46       [77]     	LD	B,(HL)		; Get MSB of address
1133: CD4011   [94]     	CALL	CRTMST		; Create string entry
1136: E5       [105]    	PUSH	HL		; Save pointer to MSB of addr
1137: 6F       [109]    	LD	L,A		; Length of string
1138: CDC412   [126]    	CALL	TOSTRA		; Move to string area
113B: D1       [136]    	POP	DE		; Restore pointer to MSB
113C: C9       [146]    	RET
                        ;
113D: CDA711   [17]     MKTMST: CALL	TESTR		; See if enough string space
1140: 210481   [10]     CRTMST: LD	HL,TMPSTR	; Temporary string
1143: E5       [21]     	PUSH	HL		; Save it
1144: 77       [28]     	LD	(HL),A		; Save length of string
1145: 23       [34]     	INC	HL
1146: 23       [ 6]     SVSTAD: INC	HL
1147: 73       [13]     	LD	(HL),E		; Save LSB of address
1148: 23       [19]     	INC	HL
1149: 72       [26]     	LD	(HL),D		; Save MSB of address
114A: E1       [36]     	POP	HL		; Restore pointer
114B: C9       [46]     	RET
                        ;
114C: 2B       [ 6]     CRTST:	DEC	HL		; DEC - INCed after
114D: 0622     [ 7]     QTSTR:	LD	B,'"'		; Terminating quote
114F: 50       [11]     	LD	D,B		; Quote to D
1150: E5       [11]     DTSTR:	PUSH	HL		; Save start
1151: 0EFF     [18]     	LD	C,-1		; Set counter to -1
1153: 23       [ 6]     QTSTLP: INC	HL		; Move on
1154: 7E       [13]     	LD	A,(HL)		; Get byte
1155: 0C       [17]     	INC	C		; Count bytes
1156: B7       [21]     	OR	A		; End of line?
1157: CA6211   [31|31]  	JP	Z,CRTSTE	; Yes - Create string entry
115A: BA       [35]     	CP	D		; Terminator D found?
115B: CA6211   [45|45]  	JP	Z,CRTSTE	; Yes - Create string entry
115E: B8       [49]     	CP	B		; Terminator B found?
115F: C25311   [59|59]  	JP	NZ,QTSTLP	; No - Keep looking
1162: FE22     [ 7]     CRTSTE: CP	'"'		; End with '"'?
1164: CC4808   [17|24]  	CALL	Z,GETCHR	; Yes - Get next character
1167: E3       [36]     	EX	(SP),HL		; Starting quote
1168: 23       [42]     	INC	HL		; First byte of string
1169: EB       [46]     	EX	DE,HL		; To DE
116A: 79       [50]     	LD	A,C		; Get length
116B: CD4011   [67]     	CALL	CRTMST		; Create string entry
116E: 110481   [10]     TSTOPL: LD	DE,TMPSTR	; Temporary string
1171: 2AF680   [26]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
1174: 222981   [42]     	LD	(FPREG),HL	; Save address of string ptr
1177: 3E01     [49]     	LD	A,1
1179: 32F280   [62]     	LD	(TYPE),A	; Set type to string
117C: CDF216   [79]     	CALL	DETHL4		; Move string to pool
117F: CDB806   [96]     	CALL	CPDEHL		; Out of string pool?
1182: 22F680   [112]    	LD	(TMSTPT),HL	; Save new pointer
1185: E1       [122]    	POP	HL		; Restore code string address
1186: 7E       [129]    	LD	A,(HL)		; Get next code byte
1187: C0       [134|140]	RET	NZ		; Return if pool OK
1188: 1E1E     [141]    	LD	E,ST		; ?ST Error
118A: C30404   [151]    	JP	ERROR		; String pool overflow
                        ;
118D: 23       [ 6]     PRNUMS: INC	HL		; Skip leading space
118E: CD4C11   [17]     PRS:	CALL	CRTST		; Create string entry for it
1191: CDD112   [17]     PRS1:	CALL	GSTRCU		; Current string to pool
1194: CDE616   [34]     	CALL	LOADFP		; Move string block to BCDE
1197: 1C       [38]     	INC	E		; Length + 1
1198: 1D       [ 4]     PRSLP:	DEC	E		; Count characters
1199: C8       [ 9|15]  	RET	Z		; End of string
119A: 0A       [16]     	LD	A,(BC)		; Get byte to output
119B: CDC906   [33]     	CALL	OUTC		; Output character in A
119E: FE0D     [40]     	CP	CR		; Return?
11A0: CCFA0A   [50|57]  	CALL	Z,DONULL	; Yes - Do nulls
11A3: 03       [56]     	INC	BC		; Next byte in string
11A4: C39811   [66]     	JP	PRSLP		; More characters to output
                        ;
11A7: B7       [ 4]     TESTR:	OR	A		; Test if enough room
11A8: 0E                	DB	0EH		; No garbage collection done
11A9: F1       [10]     GRBDON: POP	AF		; Garbage collection done
11AA: F5       [21]     	PUSH	AF		; Save status
11AB: 2A9F80   [37]     	LD	HL,(STRSPC)	; Bottom of string space in use
11AE: EB       [41]     	EX	DE,HL		; To DE
11AF: 2A0881   [57]     	LD	HL,(STRBOT)	; Bottom of string area
11B2: 2F       [61]     	CPL			; Negate length (Top down)
11B3: 4F       [65]     	LD	C,A		; -Length to BC
11B4: 06FF     [72]     	LD	B,-1		; BC = -ve length of string
11B6: 09       [83]     	ADD	HL,BC		; Add to bottom of space in use
11B7: 23       [89]     	INC	HL		; Plus one for 2's complement
11B8: CDB806   [106]    	CALL	CPDEHL		; Below string RAM area?
11BB: DAC511   [116|116]	JP	C,TESTOS	; Tidy up if not done else err
11BE: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of area
11C1: 23       [138]    	INC	HL		; Point to first byte of string
11C2: EB       [142]    	EX	DE,HL		; Address to DE
11C3: F1       [10]     POPAF:	POP	AF		; Throw away status push
11C4: C9       [20]     	RET
                        ;
11C5: F1       [10]     TESTOS: POP	AF		; Garbage collect been done?
11C6: 1E1A     [17]     	LD	E,OS		; ?OS Error
11C8: CA0404   [27|27]  	JP	Z,ERROR		; Yes - Not enough string apace
11CB: BF       [31]     	CP	A		; Flag garbage collect done
11CC: F5       [42]     	PUSH	AF		; Save status
11CD: 01A911   [52]     	LD	BC,GRBDON	; Garbage collection done
11D0: C5       [63]     	PUSH	BC		; Save for RETurn
11D1: 2AF480   [16]     GARBGE: LD	HL,(LSTRAM)	; Get end of RAM pointer
11D4: 220881   [16]     GARBLP: LD	(STRBOT),HL	; Reset string pointer
11D7: 210000   [26]     	LD	HL,0
11DA: E5       [37]     	PUSH	HL		; Flag no string found
11DB: 2A9F80   [53]     	LD	HL,(STRSPC)	; Get bottom of string space
11DE: E5       [64]     	PUSH	HL		; Save bottom of string space
11DF: 21F880   [74]     	LD	HL,TMSTPL	; Temporary string pool
11E2: EB       [ 4]     GRBLP:	EX	DE,HL
11E3: 2AF680   [20]     	LD	HL,(TMSTPT)	; Temporary string pool pointer
11E6: EB       [24]     	EX	DE,HL
11E7: CDB806   [41]     	CALL	CPDEHL		; Temporary string pool done?
11EA: 01E211   [51]     	LD	BC,GRBLP	; Loop until string pool done
11ED: C23612   [61|61]  	JP	NZ,STPOOL	; No - See if in string area
11F0: 2A1B81   [77]     	LD	HL,(PROGND)	; Start of simple variables
11F3: EB       [ 4]     SMPVAR: EX	DE,HL
11F4: 2A1D81   [20]     	LD	HL,(VAREND)	; End of simple variables
11F7: EB       [24]     	EX	DE,HL
11F8: CDB806   [41]     	CALL	CPDEHL		; All simple strings done?
11FB: CA0912   [51|51]  	JP	Z,ARRLP		; Yes - Do string arrays
11FE: 7E       [58]     	LD	A,(HL)		; Get type of variable
11FF: 23       [64]     	INC	HL
1200: 23       [70]     	INC	HL
1201: B7       [74]     	OR	A		; "S" flag set if string
1202: CD3912   [91]     	CALL	STRADD		; See if string in string area
1205: C3F311   [101]    	JP	SMPVAR		; Loop until simple ones done
                        ;
1208: C1       [10]     GNXARY: POP	BC		; Scrap address of this array
1209: EB       [ 4]     ARRLP:	EX	DE,HL
120A: 2A1F81   [20]     	LD	HL,(ARREND)	; End of string arrays
120D: EB       [24]     	EX	DE,HL
120E: CDB806   [41]     	CALL	CPDEHL		; All string arrays done?
1211: CA5F12   [51|51]  	JP	Z,SCNEND	; Yes - Move string if found
1214: CDE616   [68]     	CALL	LOADFP		; Get array name to BCDE
1217: 7B       [72]     	LD	A,E		; Get type of array	
1218: E5       [83]     	PUSH	HL		; Save address of num of dim'ns
1219: 09       [94]     	ADD	HL,BC		; Start of next array
121A: B7       [98]     	OR	A		; Test type of array
121B: F20812   [108|108]	JP	P,GNXARY	; Numeric array - Ignore it
121E: 220A81   [124]    	LD	(CUROPR),HL	; Save address of next array
1221: E1       [134]    	POP	HL		; Get address of num of dim'ns
1222: 4E       [141]    	LD	C,(HL)		; BC = Number of dimensions
1223: 0600     [148]    	LD	B,0
1225: 09       [159]    	ADD	HL,BC		; Two bytes per dimension size
1226: 09       [170]    	ADD	HL,BC
1227: 23       [176]    	INC	HL		; Plus one for number of dim'ns
1228: EB       [ 4]     GRBARY: EX	DE,HL
1229: 2A0A81   [20]     	LD	HL,(CUROPR)	; Get address of next array
122C: EB       [24]     	EX	DE,HL
122D: CDB806   [41]     	CALL	CPDEHL		; Is this array finished?
1230: CA0912   [51|51]  	JP	Z,ARRLP		; Yes - Get next one
1233: 012812   [61]     	LD	BC,GRBARY	; Loop until array all done
1236: C5       [11]     STPOOL: PUSH	BC		; Save return address
1237: F680     [18]     	OR	80H		; Flag string type
1239: 7E       [ 7]     STRADD: LD	A,(HL)		; Get string length
123A: 23       [13]     	INC	HL
123B: 23       [19]     	INC	HL
123C: 5E       [26]     	LD	E,(HL)		; Get LSB of string address
123D: 23       [32]     	INC	HL
123E: 56       [39]     	LD	D,(HL)		; Get MSB of string address
123F: 23       [45]     	INC	HL
1240: F0       [50|56]  	RET	P		; Not a string - Return
1241: B7       [54]     	OR	A		; Set flags on string length
1242: C8       [59|65]  	RET	Z		; Null string - Return
1243: 44       [63]     	LD	B,H		; Save variable pointer
1244: 4D       [67]     	LD	C,L
1245: 2A0881   [83]     	LD	HL,(STRBOT)	; Bottom of new area
1248: CDB806   [100]    	CALL	CPDEHL		; String been done?
124B: 60       [104]    	LD	H,B		; Restore variable pointer
124C: 69       [108]    	LD	L,C
124D: D8       [113|119]	RET	C		; String done - Ignore
124E: E1       [123]    	POP	HL		; Return address
124F: E3       [142]    	EX	(SP),HL		; Lowest available string area
1250: CDB806   [159]    	CALL	CPDEHL		; String within string area?
1253: E3       [178]    	EX	(SP),HL		; Lowest available string area
1254: E5       [189]    	PUSH	HL		; Re-save return address
1255: 60       [193]    	LD	H,B		; Restore variable pointer
1256: 69       [197]    	LD	L,C
1257: D0       [202|208]	RET	NC		; Outside string area - Ignore
1258: C1       [212]    	POP	BC		; Get return , Throw 2 away
1259: F1       [222]    	POP	AF		; 
125A: F1       [232]    	POP	AF		; 
125B: E5       [243]    	PUSH	HL		; Save variable pointer
125C: D5       [254]    	PUSH	DE		; Save address of current
125D: C5       [265]    	PUSH	BC		; Put back return address
125E: C9       [275]    	RET			; Go to it
                        ;
125F: D1       [10]     SCNEND: POP	DE		; Addresses of strings
1260: E1       [20]     	POP	HL		; 
1261: 7D       [24]     	LD	A,L		; HL = 0 if no more to do
1262: B4       [28]     	OR	H
1263: C8       [33|39]  	RET	Z		; No more to do - Return
1264: 2B       [39]     	DEC	HL
1265: 46       [46]     	LD	B,(HL)		; MSB of address of string
1266: 2B       [52]     	DEC	HL
1267: 4E       [59]     	LD	C,(HL)		; LSB of address of string
1268: E5       [70]     	PUSH	HL		; Save variable address
1269: 2B       [76]     	DEC	HL
126A: 2B       [82]     	DEC	HL
126B: 6E       [89]     	LD	L,(HL)		; HL = Length of string
126C: 2600     [96]     	LD	H,0
126E: 09       [107]    	ADD	HL,BC		; Address of end of string+1
126F: 50       [111]    	LD	D,B		; String address to DE
1270: 59       [115]    	LD	E,C
1271: 2B       [121]    	DEC	HL		; Last byte in string
1272: 44       [125]    	LD	B,H		; Address to BC
1273: 4D       [129]    	LD	C,L
1274: 2A0881   [145]    	LD	HL,(STRBOT)	; Current bottom of string area
1277: CDBF03   [162]    	CALL	MOVSTR		; Move string to new address
127A: E1       [172]    	POP	HL		; Restore variable address
127B: 71       [179]    	LD	(HL),C		; Save new LSB of address
127C: 23       [185]    	INC	HL
127D: 70       [192]    	LD	(HL),B		; Save new MSB of address
127E: 69       [196]    	LD	L,C		; Next string area+1 to HL
127F: 60       [200]    	LD	H,B
1280: 2B       [206]    	DEC	HL		; Next string area address
1281: C3D411   [216]    	JP	GARBLP		; Look for more strings
                        ;
1284: C5       [11]     CONCAT: PUSH	BC		; Save prec' opr & code string
1285: E5       [22]     	PUSH	HL		; 
1286: 2A2981   [38]     	LD	HL,(FPREG)	; Get first string
1289: E3       [57]     	EX	(SP),HL		; Save first string
128A: CD3E0D   [74]     	CALL	OPRND		; Get second string
128D: E3       [93]     	EX	(SP),HL		; Restore first string
128E: CDB90C   [110]    	CALL	TSTSTR		; Make sure it's a string
1291: 7E       [117]    	LD	A,(HL)		; Get length of second string
1292: E5       [128]    	PUSH	HL		; Save first string
1293: 2A2981   [144]    	LD	HL,(FPREG)	; Get second string
1296: E5       [155]    	PUSH	HL		; Save second string
1297: 86       [162]    	ADD	A,(HL)		; Add length of second string
1298: 1E1C     [169]    	LD	E,LS		; ?LS Error
129A: DA0404   [179|179]	JP	C,ERROR		; String too long - Error
129D: CD3D11   [196]    	CALL	MKTMST		; Make temporary string
12A0: D1       [206]    	POP	DE		; Get second string to DE
12A1: CDD512   [223]    	CALL	GSTRDE		; Move to string pool if needed
12A4: E3       [242]    	EX	(SP),HL		; Get first string
12A5: CDD412   [259]    	CALL	GSTRHL		; Move to string pool if needed
12A8: E5       [270]    	PUSH	HL		; Save first string
12A9: 2A0681   [286]    	LD	HL,(TMPSTR+2)	; Temporary string address
12AC: EB       [290]    	EX	DE,HL		; To DE
12AD: CDBB12   [307]    	CALL	SSTSA		; First string to string area
12B0: CDBB12   [324]    	CALL	SSTSA		; Second string to string area
12B3: 21D30C   [334]    	LD	HL,EVAL2	; Return to evaluation loop
12B6: E3       [353]    	EX	(SP),HL		; Save return,get code string
12B7: E5       [364]    	PUSH	HL		; Save code string address
12B8: C36E11   [374]    	JP	TSTOPL		; To temporary string to pool
                        ;
12BB: E1       [10]     SSTSA:	POP	HL		; Return address
12BC: E3       [29]     	EX	(SP),HL		; Get string block,save return
12BD: 7E       [36]     	LD	A,(HL)		; Get length of string
12BE: 23       [42]     	INC	HL
12BF: 23       [48]     	INC	HL
12C0: 4E       [55]     	LD	C,(HL)		; Get LSB of string address
12C1: 23       [61]     	INC	HL
12C2: 46       [68]     	LD	B,(HL)		; Get MSB of string address
12C3: 6F       [72]     	LD	L,A		; Length to L
12C4: 2C       [ 4]     TOSTRA: INC	L		; INC - DECed after
12C5: 2D       [ 4]     TSALP:	DEC	L		; Count bytes moved
12C6: C8       [ 9|15]  	RET	Z		; End of string - Return
12C7: 0A       [16]     	LD	A,(BC)		; Get source
12C8: 12       [23]     	LD	(DE),A		; Save destination
12C9: 03       [29]     	INC	BC		; Next source
12CA: 13       [35]     	INC	DE		; Next destination
12CB: C3C512   [45]     	JP	TSALP		; Loop until string moved
                        ;
12CE: CDB90C   [17]     GETSTR: CALL	TSTSTR		; Make sure it's a string
12D1: 2A2981   [16]     GSTRCU: LD	HL,(FPREG)	; Get current string
12D4: EB       [ 4]     GSTRHL: EX	DE,HL		; Save DE
12D5: CDEF12   [17]     GSTRDE: CALL	BAKTMP		; Was it last tmp-str?
12D8: EB       [21]     	EX	DE,HL		; Restore DE
12D9: C0       [26|32]  	RET	NZ		; No - Return
12DA: D5       [37]     	PUSH	DE		; Save string
12DB: 50       [41]     	LD	D,B		; String block address to DE
12DC: 59       [45]     	LD	E,C
12DD: 1B       [51]     	DEC	DE		; Point to length
12DE: 4E       [58]     	LD	C,(HL)		; Get string length
12DF: 2A0881   [74]     	LD	HL,(STRBOT)	; Current bottom of string area
12E2: CDB806   [91]     	CALL	CPDEHL		; Last one in string area?
12E5: C2ED12   [101|101]	JP	NZ,POPHL	; No - Return
12E8: 47       [105]    	LD	B,A		; Clear B (A=0)
12E9: 09       [116]    	ADD	HL,BC		; Remove string from str' area
12EA: 220881   [132]    	LD	(STRBOT),HL	; Save new bottom of str' area
12ED: E1       [10]     POPHL:	POP	HL		; Restore string
12EE: C9       [20]     	RET
                        ;
12EF: 2AF680   [16]     BAKTMP: LD	HL,(TMSTPT)	; Get temporary string pool top
12F2: 2B       [22]     	DEC	HL		; Back
12F3: 46       [29]     	LD	B,(HL)		; Get MSB of address
12F4: 2B       [35]     	DEC	HL		; Back
12F5: 4E       [42]     	LD	C,(HL)		; Get LSB of address
12F6: 2B       [48]     	DEC	HL		; Back
12F7: 2B       [54]     	DEC	HL		; Back
12F8: CDB806   [71]     	CALL	CPDEHL		; String last in string pool?
12FB: C0       [76|82]  	RET	NZ		; Yes - Leave it
12FC: 22F680   [92]     	LD	(TMSTPT),HL	; Save new string pool top
12FF: C9       [102]    	RET
                        ;
1300: 017F10   [10]     LEN:	LD	BC,PASSA	; To return integer A
1303: C5       [21]     	PUSH	BC		; Save address
1304: CDCE12   [17]     GETLEN: CALL	GETSTR		; Get string and its length
1307: AF       [21]     	XOR	A
1308: 57       [25]     	LD	D,A		; Clear D
1309: 32F280   [38]     	LD	(TYPE),A	; Set type to numeric
130C: 7E       [45]     	LD	A,(HL)		; Get length of string
130D: B7       [49]     	OR	A		; Set status flags
130E: C9       [59]     	RET
                        ;
130F: 017F10   [10]     ASC:	LD	BC,PASSA	; To return integer A
1312: C5       [21]     	PUSH	BC		; Save address
1313: CD0413   [17]     GTFLNM: CALL	GETLEN		; Get length of string
1316: CA0F09   [27|27]  	JP	Z,FCERR		; Null string - Error
1319: 23       [33]     	INC	HL
131A: 23       [39]     	INC	HL
131B: 5E       [46]     	LD	E,(HL)		; Get LSB of address
131C: 23       [52]     	INC	HL
131D: 56       [59]     	LD	D,(HL)		; Get MSB of address
131E: 1A       [66]     	LD	A,(DE)		; Get first byte of string
131F: C9       [76]     	RET
                        ;
1320: 3E01     [ 7]     CHR:	LD	A,1		; One character string
1322: CD3D11   [24]     	CALL	MKTMST		; Make a temporary string
1325: CD1914   [41]     	CALL	MAKINT		; Make it integer A
1328: 2A0681   [57]     	LD	HL,(TMPSTR+2)	; Get address of string
132B: 73       [64]     	LD	(HL),E		; Save character
132C: C1       [10]     TOPOOL: POP	BC		; Clean up stack
132D: C36E11   [20]     	JP	TSTOPL		; Temporary string to pool
                        ;
1330: CDC913   [17]     LEFT:	CALL	LFRGNM		; Get number and ending ")"
1333: AF       [21]     	XOR	A		; Start at first byte in string
1334: E3       [19]     RIGHT1: EX	(SP),HL		; Save code string,Get string
1335: 4F       [23]     	LD	C,A		; Starting position in string
1336: E5       [11]     MID1:	PUSH	HL		; Save string block address
1337: 7E       [18]     	LD	A,(HL)		; Get length of string
1338: B8       [22]     	CP	B		; Compare with number given
1339: DA3E13   [32|32]  	JP	C,ALLFOL	; All following bytes required
133C: 78       [36]     	LD	A,B		; Get new length
133D: 11                	DB	11H		; Skip "LD C,0"
133E: 0E00     [ 7]     ALLFOL: LD	C,0		; First byte of string
1340: C5       [18]     	PUSH	BC		; Save position in string
1341: CDA711   [35]     	CALL	TESTR		; See if enough string space
1344: C1       [45]     	POP	BC		; Get position in string
1345: E1       [55]     	POP	HL		; Restore string block address
1346: E5       [66]     	PUSH	HL		; And re-save it
1347: 23       [72]     	INC	HL
1348: 23       [78]     	INC	HL
1349: 46       [85]     	LD	B,(HL)		; Get LSB of address
134A: 23       [91]     	INC	HL
134B: 66       [98]     	LD	H,(HL)		; Get MSB of address
134C: 68       [102]    	LD	L,B		; HL = address of string
134D: 0600     [109]    	LD	B,0		; BC = starting address
134F: 09       [120]    	ADD	HL,BC		; Point to that byte
1350: 44       [124]    	LD	B,H		; BC = source string
1351: 4D       [128]    	LD	C,L
1352: CD4011   [145]    	CALL	CRTMST		; Create a string entry
1355: 6F       [149]    	LD	L,A		; Length of new string
1356: CDC412   [166]    	CALL	TOSTRA		; Move string to string area
1359: D1       [176]    	POP	DE		; Clear stack
135A: CDD512   [193]    	CALL	GSTRDE		; Move to string pool if needed
135D: C36E11   [203]    	JP	TSTOPL		; Temporary string to pool
                        ;
1360: CDC913   [17]     RIGHT:	CALL	LFRGNM		; Get number and ending ")"
1363: D1       [27]     	POP	DE		; Get string length
1364: D5       [38]     	PUSH	DE		; And re-save
1365: 1A       [45]     	LD	A,(DE)		; Get length
1366: 90       [49]     	SUB	B		; Move back N bytes
1367: C33413   [59]     	JP	RIGHT1		; Go and get sub-string
                        ;
136A: EB       [ 4]     MID:	EX	DE,HL		; Get code string address
136B: 7E       [11]     	LD	A,(HL)		; Get next byte ',' or ")"
136C: CDCE13   [28]     	CALL	MIDNUM		; Get number supplied
136F: 04       [32]     	INC	B		; Is it character zero?
1370: 05       [36]     	DEC	B
1371: CA0F09   [46|46]  	JP	Z,FCERR		; Yes - Error
1374: C5       [57]     	PUSH	BC		; Save starting position
1375: 1EFF     [64]     	LD	E,255		; All of string
1377: FE29     [71]     	CP	')'		; Any length given?
1379: CA8313   [81|81]  	JP	Z,RSTSTR	; No - Rest of string
137C: CDBE06   [98]     	CALL	CHKSYN		; Make sure ',' follows
137F: 2C                	DB	','
1380: CD1614   [115]    	CALL	GETINT		; Get integer 0-255
1383: CDBE06   [17]     RSTSTR: CALL	CHKSYN		; Make sure ")" follows
1386: 29                	DB	")"
1387: F1       [27]     	POP	AF		; Restore starting position
1388: E3       [46]     	EX	(SP),HL		; Get string,8ave code string
1389: 013613   [56]     	LD	BC,MID1		; Continuation of MID$ routine
138C: C5       [67]     	PUSH	BC		; Save for return
138D: 3D       [71]     	DEC	A		; Starting position-1
138E: BE       [78]     	CP	(HL)		; Compare with length
138F: 0600     [85]     	LD	B,0		; Zero bytes length
1391: D0       [90|96]  	RET	NC		; Null string if start past end
1392: 4F       [94]     	LD	C,A		; Save starting position-1
1393: 7E       [101]    	LD	A,(HL)		; Get length of string
1394: 91       [105]    	SUB	C		; Subtract start
1395: BB       [109]    	CP	E		; Enough string for it?
1396: 47       [113]    	LD	B,A		; Save maximum length available
1397: D8       [118|124]	RET	C		; Truncate string if needed
1398: 43       [122]    	LD	B,E		; Set specified length
1399: C9       [132]    	RET			; Go and create string
                        ;
139A: CD0413   [17]     VAL:	CALL	GETLEN		; Get length of string
139D: CAB714   [27|27]  	JP	Z,RESZER	; Result zero
13A0: 5F       [31]     	LD	E,A		; Save length
13A1: 23       [37]     	INC	HL
13A2: 23       [43]     	INC	HL
13A3: 7E       [50]     	LD	A,(HL)		; Get LSB of address
13A4: 23       [56]     	INC	HL
13A5: 66       [63]     	LD	H,(HL)		; Get MSB of address
13A6: 6F       [67]     	LD	L,A		; HL = String address
13A7: E5       [78]     	PUSH	HL		; Save string address
13A8: 19       [89]     	ADD	HL,DE
13A9: 46       [96]     	LD	B,(HL)		; Get end of string+1 byte
13AA: 72       [103]    	LD	(HL),D		; Zero it to terminate
13AB: E3       [122]    	EX	(SP),HL		; Save string end,get start
13AC: C5       [133]    	PUSH	BC		; Save end+1 byte
13AD: 7E       [140]    	LD	A,(HL)		; Get starting byte
13AE: FE24     [147]    	CP	'$'		; Hex number indicated? [function added]
13B0: C2B813   [157|157]	JP	NZ,VAL1
13B3: CDE21B   [174]    	CALL	HEXTFP		; Convert Hex to FPREG
13B6: 180D     [186]    	JR	VAL3
13B8: FE25     [ 7]     VAL1:	CP	'%'		; Binary number indicated? [function added]
13BA: C2C213   [17|17]  	JP	NZ,VAL2
13BD: CD521C   [34]     	CALL	BINTFP		; Convert Bin to FPREG
13C0: 1803     [46]     	JR	VAL3
13C2: CD9E17   [17]     VAL2:	CALL	ASCTFP		; Convert ASCII string to FP
13C5: C1       [10]     VAL3:	POP	BC		; Restore end+1 byte
13C6: E1       [20]     	POP	HL		; Restore end+1 address
13C7: 70       [27]     	LD	(HL),B		; Put back original byte
13C8: C9       [37]     	RET
                        ;
13C9: EB       [ 4]     LFRGNM: EX	DE,HL		; Code string address to HL
13CA: CDBE06   [21]     	CALL	CHKSYN		; Make sure ")" follows
13CD: 29                	DB	")"
13CE: C1       [10]     MIDNUM: POP	BC		; Get return address
13CF: D1       [20]     	POP	DE		; Get number supplied
13D0: C5       [31]     	PUSH	BC		; Re-save return address
13D1: 43       [35]     	LD	B,E		; Number to B
13D2: C9       [45]     	RET
                        ;
13D3: CD1914   [17]     INP:	CALL	MAKINT		; Make it integer A
13D6: 328480   [30]     	LD	(INPORT),A	; Set input port
13D9: CD8380   [47]     	CALL	INPSUB		; Get input from port
13DC: C37F10   [57]     	JP	PASSA		; Return integer A
                        ;
13DF: CD0314   [17]     POUT:	CALL	SETIO		; Set up port number
13E2: C34B80   [27]     	JP	OUTSUB		; Output data and return
                        ;
13E5: CD0314   [17]     WAIT:	CALL	SETIO		; Set up port number
13E8: F5       [28]     	PUSH	AF		; Save AND mask
13E9: 1E00     [35]     	LD	E,0		; Assume zero if none given
13EB: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
13EC: CD4808   [58]     	CALL	GETCHR		; Get next character
13EF: CAF913   [68|68]  	JP	Z,NOXOR		; No XOR byte given
13F2: CDBE06   [85]     	CALL	CHKSYN		; Make sure ',' follows
13F5: 2C                	DB	','
13F6: CD1614   [102]    	CALL	GETINT		; Get integer 0-255 to XOR with
13F9: C1       [10]     NOXOR:	POP	BC		; Restore AND mask
13FA: CD8380   [17]     WAITLP: CALL	INPSUB		; Get input
13FD: AB       [21]     	XOR	E		; Flip selected bits
13FE: A0       [25]     	AND	B		; Result non-zero?
13FF: CAFA13   [35|35]  	JP	Z,WAITLP	; No = keep waiting
1402: C9       [45]     	RET
                        ;
1403: CD1614   [17]     SETIO:	CALL	GETINT		; Get integer 0-255
1406: 328480   [30]     	LD	(INPORT),A	; Set input port
1409: 324C80   [43]     	LD	(OTPORT),A	; Set output port
140C: CDBE06   [60]     	CALL	CHKSYN		; Make sure ',' follows
140F: 2C                	DB	','
1410: C31614   [70]     	JP	GETINT		; Get integer 0-255 and return
                        ;
1413: CD4808   [17]     FNDNUM: CALL	GETCHR		; Get next character
1416: CDB50C   [17]     GETINT: CALL	GETNUM		; Get a number from 0 to 255
1419: CDF408   [17]     MAKINT: CALL	DEPINT		; Make sure value 0 - 255
141C: 7A       [21]     	LD	A,D		; Get MSB of number
141D: B7       [25]     	OR	A		; Zero?
141E: C20F09   [35|35]  	JP	NZ,FCERR	; No - Error
1421: 2B       [41]     	DEC	HL		; DEC 'cos GETCHR INCs
1422: CD4808   [58]     	CALL	GETCHR		; Get next character
1425: 7B       [62]     	LD	A,E		; Get number to A
1426: C9       [72]     	RET
                        ;
1427: CDFA08   [17]     PEEK:	CALL	DEINT		; Get memory address
142A: 1A       [24]     	LD	A,(DE)		; Get byte in memory
142B: C37F10   [34]     	JP	PASSA		; Return integer A
                        ;
142E: CDB50C   [17]     POKE:	CALL	GETNUM		; Get memory address
1431: CDFA08   [34]     	CALL	DEINT		; Get integer -32768 to 3276
1434: D5       [45]     	PUSH	DE		; Save memory address
1435: CDBE06   [62]     	CALL	CHKSYN		; Make sure ',' follows
1438: 2C                	DB	','
1439: CD1614   [79]     	CALL	GETINT		; Get integer 0-255
143C: D1       [89]     	POP	DE		; Restore memory address
143D: 12       [96]     	LD	(DE),A		; Load it into memory
143E: C9       [106]    	RET
                        ;
143F: 211519   [10]     ROUND:	LD	HL,HALF		; Add 0.5 to FPREG
1442: CDE616   [17]     ADDPHL: CALL	LOADFP		; Load FP at (HL) to BCDE
1445: C35114   [27]     	JP	FPADD		; Add BCDE to FPREG
                        ;
1448: CDE616   [17]     SUBPHL: CALL	LOADFP		; FPREG = -FPREG + number at HL
144B: 21                	DB	21H		; Skip "POP BC" and "POP DE"
144C: C1       [10]     PSUB:	POP	BC		; Get FP number from stack
144D: D1       [20]     	POP	DE
144E: CDC016   [17]     SUBCDE: CALL	INVSGN		; Negate FPREG
1451: 78       [ 4]     FPADD:	LD	A,B		; Get FP exponent
1452: B7       [ 8]     	OR	A		; Is number zero?
1453: C8       [13|19]  	RET	Z		; Yes - Nothing to add
1454: 3A2C81   [26]     	LD	A,(FPEXP)	; Get FPREG exponent
1457: B7       [30]     	OR	A		; Is this number zero?
1458: CAD816   [40|40]  	JP	Z,FPBCDE	; Yes - Move BCDE to FPREG
145B: 90       [44]     	SUB	B		; BCDE number larger?
145C: D26B14   [54|54]  	JP	NC,NOSWAP	; No - Don't swap them
145F: 2F       [58]     	CPL			; Two's complement
1460: 3C       [62]     	INC	A		;	FP exponent
1461: EB       [66]     	EX	DE,HL
1462: CDC816   [83]     	CALL	STAKFP		; Put FPREG on stack
1465: EB       [87]     	EX	DE,HL
1466: CDD816   [104]    	CALL	FPBCDE		; Move BCDE to FPREG
1469: C1       [114]    	POP	BC		; Restore number from stack
146A: D1       [124]    	POP	DE
146B: FE19     [ 7]     NOSWAP: CP	24+1		; Second number insignificant?
146D: D0       [12|18]  	RET	NC		; Yes - First number is result
146E: F5       [23]     	PUSH	AF		; Save number of bits to scale
146F: CDFD16   [40]     	CALL	SIGNS		; Set MSBs & sign of result
1472: 67       [44]     	LD	H,A		; Save sign of result
1473: F1       [54]     	POP	AF		; Restore scaling factor
1474: CD1615   [71]     	CALL	SCALE		; Scale BCDE to same exponent
1477: B4       [75]     	OR	H		; Result to be positive?
1478: 212981   [85]     	LD	HL,FPREG	; Point to FPREG
147B: F29114   [95|95]  	JP	P,MINCDE	; No - Subtract FPREG from CDE
147E: CDF614   [112]    	CALL	PLUCDE		; Add FPREG to CDE
1481: D2D714   [122|122]	JP	NC,RONDUP	; No overflow - Round it up
1484: 23       [128]    	INC	HL		; Point to exponent
1485: 34       [139]    	INC	(HL)		; Increment it
1486: CAFF03   [149|149]	JP	Z,OVERR		; Number overflowed - Error
1489: 2E01     [156]    	LD	L,1		; 1 bit to shift right
148B: CD2C15   [173]    	CALL	SHRT1		; Shift result right
148E: C3D714   [183]    	JP	RONDUP		; Round it up
                        ;
1491: AF       [ 4]     MINCDE: XOR	A		; Clear A and carry
1492: 90       [ 8]     	SUB	B		; Negate exponent
1493: 47       [12]     	LD	B,A		; Re-save exponent
1494: 7E       [19]     	LD	A,(HL)		; Get LSB of FPREG
1495: 9B       [23]     	SBC	A, E		; Subtract LSB of BCDE
1496: 5F       [27]     	LD	E,A		; Save LSB of BCDE
1497: 23       [33]     	INC	HL
1498: 7E       [40]     	LD	A,(HL)		; Get NMSB of FPREG
1499: 9A       [44]     	SBC	A,D		; Subtract NMSB of BCDE
149A: 57       [48]     	LD	D,A		; Save NMSB of BCDE
149B: 23       [54]     	INC	HL
149C: 7E       [61]     	LD	A,(HL)		; Get MSB of FPREG
149D: 99       [65]     	SBC	A,C		; Subtract MSB of BCDE
149E: 4F       [69]     	LD	C,A		; Save MSB of BCDE
149F: DC0215   [10|17]  CONPOS: CALL	C,COMPL		; Overflow - Make it positive
                        ;
14A2: 68       [ 4]     BNORM:	LD	L,B		; L = Exponent
14A3: 63       [ 8]     	LD	H,E		; H = LSB
14A4: AF       [12]     	XOR	A
14A5: 47       [ 4]     BNRMLP: LD	B,A		; Save bit count
14A6: 79       [ 8]     	LD	A,C		; Get MSB
14A7: B7       [12]     	OR	A		; Is it zero?
14A8: C2C414   [22|22]  	JP	NZ,PNORM	; No - Do it bit at a time
14AB: 4A       [26]     	LD	C,D		; MSB = NMSB
14AC: 54       [30]     	LD	D,H		; NMSB= LSB
14AD: 65       [34]     	LD	H,L		; LSB = VLSB
14AE: 6F       [38]     	LD	L,A		; VLSB= 0
14AF: 78       [42]     	LD	A,B		; Get exponent
14B0: D608     [49]     	SUB	8		; Count 8 bits
14B2: FEE0     [56]     	CP	0E0H		; -24-8 Was number zero?
14B4: C2A514   [66|66]  	JP	NZ,BNRMLP	; No - Keep normalising
14B7: AF       [ 4]     RESZER: XOR	A		; Result is zero
14B8: 322C81   [13]     SAVEXP: LD	(FPEXP),A	; Save result as zero
14BB: C9       [23]     	RET
                        ;
14BC: 05       [ 4]     NORMAL: DEC	B		; Count bits
14BD: 29       [15]     	ADD	HL,HL		; Shift HL left
14BE: 7A       [19]     	LD	A,D		; Get NMSB
14BF: 17       [23]     	RLA			; Shift left with last bit
14C0: 57       [27]     	LD	D,A		; Save NMSB
14C1: 79       [31]     	LD	A,C		; Get MSB
14C2: 8F       [35]     	ADC	A,A		; Shift left with last bit
14C3: 4F       [39]     	LD	C,A		; Save MSB
14C4: F2BC14   [10|10]  PNORM:	JP	P,NORMAL	; Not done - Keep going
14C7: 78       [14]     	LD	A,B		; Number of bits shifted
14C8: 5C       [18]     	LD	E,H		; Save HL in EB
14C9: 45       [22]     	LD	B,L
14CA: B7       [26]     	OR	A		; Any shifting done?
14CB: CAD714   [36|36]  	JP	Z,RONDUP	; No - Round it up
14CE: 212C81   [46]     	LD	HL,FPEXP	; Point to exponent
14D1: 86       [53]     	ADD	A,(HL)		; Add shifted bits
14D2: 77       [60]     	LD	(HL),A		; Re-save exponent
14D3: D2B714   [70|70]  	JP	NC,RESZER	; Underflow - Result is zero
14D6: C8       [75|81]  	RET	Z		; Result is zero
14D7: 78       [ 4]     RONDUP: LD	A,B		; Get VLSB of number
14D8: 212C81   [10]     RONDB:	LD	HL,FPEXP	; Point to exponent
14DB: B7       [14]     	OR	A		; Any rounding?
14DC: FCE914   [24|31]  	CALL	M,FPROND	; Yes - Round number up
14DF: 46       [31]     	LD	B,(HL)		; B = Exponent
14E0: 23       [37]     	INC	HL
14E1: 7E       [44]     	LD	A,(HL)		; Get sign of result
14E2: E680     [51]     	AND	10000000B	; Only bit 7 needed
14E4: A9       [55]     	XOR	C		; Set correct sign
14E5: 4F       [59]     	LD	C,A		; Save correct sign in number
14E6: C3D816   [69]     	JP	FPBCDE		; Move BCDE to FPREG
                        ;
14E9: 1C       [ 4]     FPROND: INC	E		; Round LSB
14EA: C0       [ 9|15]  	RET	NZ		; Return if ok
14EB: 14       [13]     	INC	D		; Round NMSB
14EC: C0       [18|24]  	RET	NZ		; Return if ok
14ED: 0C       [22]     	INC	C		; Round MSB
14EE: C0       [27|33]  	RET	NZ		; Return if ok
14EF: 0E80     [34]     	LD	C,80H		; Set normal value
14F1: 34       [45]     	INC	(HL)		; Increment exponent
14F2: C0       [50|56]  	RET	NZ		; Return if ok
14F3: C3FF03   [60]     	JP	OVERR		; Overflow error
                        ;
14F6: 7E       [ 7]     PLUCDE: LD	A,(HL)		; Get LSB of FPREG
14F7: 83       [11]     	ADD	A,E		; Add LSB of BCDE
14F8: 5F       [15]     	LD	E,A		; Save LSB of BCDE
14F9: 23       [21]     	INC	HL
14FA: 7E       [28]     	LD	A,(HL)		; Get NMSB of FPREG
14FB: 8A       [32]     	ADC	A,D		; Add NMSB of BCDE
14FC: 57       [36]     	LD	D,A		; Save NMSB of BCDE
14FD: 23       [42]     	INC	HL
14FE: 7E       [49]     	LD	A,(HL)		; Get MSB of FPREG
14FF: 89       [53]     	ADC	A,C		; Add MSB of BCDE
1500: 4F       [57]     	LD	C,A		; Save MSB of BCDE
1501: C9       [67]     	RET
                        ;
1502: 212D81   [10]     COMPL:	LD	HL,SGNRES	; Sign of result
1505: 7E       [17]     	LD	A,(HL)		; Get sign of result
1506: 2F       [21]     	CPL			; Negate it
1507: 77       [28]     	LD	(HL),A		; Put it back
1508: AF       [32]     	XOR	A
1509: 6F       [36]     	LD	L,A		; Set L to zero
150A: 90       [40]     	SUB	B		; Negate exponent,set carry
150B: 47       [44]     	LD	B,A		; Re-save exponent
150C: 7D       [48]     	LD	A,L		; Load zero
150D: 9B       [52]     	SBC	A,E		; Negate LSB
150E: 5F       [56]     	LD	E,A		; Re-save LSB
150F: 7D       [60]     	LD	A,L		; Load zero
1510: 9A       [64]     	SBC	A,D		; Negate NMSB
1511: 57       [68]     	LD	D,A		; Re-save NMSB
1512: 7D       [72]     	LD	A,L		; Load zero
1513: 99       [76]     	SBC	A,C		; Negate MSB
1514: 4F       [80]     	LD	C,A		; Re-save MSB
1515: C9       [90]     	RET
                        ;
1516: 0600     [ 7]     SCALE:	LD	B,0		; Clear underflow
1518: D608     [ 7]     SCALLP: SUB	8		; 8 bits (a whole byte)?
151A: DA2515   [17|17]  	JP	C,SHRITE	; No - Shift right A bits
151D: 43       [21]     	LD	B,E		; <- Shift
151E: 5A       [25]     	LD	E,D		; <- right
151F: 51       [29]     	LD	D,C		; <- eight
1520: 0E00     [36]     	LD	C,0		; <- bits
1522: C31815   [46]     	JP	SCALLP		; More bits to shift
                        ;
1525: C609     [ 7]     SHRITE: ADD	A,8+1		; Adjust count
1527: 6F       [11]     	LD	L,A		; Save bits to shift
1528: AF       [ 4]     SHRLP:	XOR	A		; Flag for all done
1529: 2D       [ 8]     	DEC	L		; All shifting done?
152A: C8       [13|19]  	RET	Z		; Yes - Return
152B: 79       [17]     	LD	A,C		; Get MSB
152C: 1F       [ 4]     SHRT1:	RRA			; Shift it right
152D: 4F       [ 8]     	LD	C,A		; Re-save
152E: 7A       [12]     	LD	A,D		; Get NMSB
152F: 1F       [16]     	RRA			; Shift right with last bit
1530: 57       [20]     	LD	D,A		; Re-save it
1531: 7B       [24]     	LD	A,E		; Get LSB
1532: 1F       [28]     	RRA			; Shift right with last bit
1533: 5F       [32]     	LD	E,A		; Re-save it
1534: 78       [36]     	LD	A,B		; Get underflow
1535: 1F       [40]     	RRA			; Shift right with last bit
1536: 47       [44]     	LD	B,A		; Re-save underflow
1537: C32815   [54]     	JP	SHRLP		; More bits to do
                        ;
153A: 00000081          UNITY:	DB	 000H,000H,000H,081H	; 1.00000
                        ;
153E: 03                LOGTAB: DB	3			; Table used by LOG
153F: AA561980          	DB	0AAH,056H,019H,080H	; 0.59898
1543: F1227680          	DB	0F1H,022H,076H,080H	; 0.96147
1547: 45AA3882          	DB	045H,0AAH,038H,082H	; 2.88539
                        ;
154B: CD9716   [17]     LOG:	CALL	TSTSGN		; Test sign of value
154E: B7       [21]     	OR	A
154F: EA0F09   [31|31]  	JP	PE,FCERR	; ?FC Error if <= zero
1552: 212C81   [41]     	LD	HL,FPEXP	; Point to exponent
1555: 7E       [48]     	LD	A,(HL)		; Get exponent
1556: 013580   [58]     	LD	BC,8035H	; BCDE = SQR(1/2)
1559: 11F304   [68]     	LD	DE,04F3H
155C: 90       [72]     	SUB	B		; Scale value to be < 1
155D: F5       [83]     	PUSH	AF		; Save scale factor
155E: 70       [90]     	LD	(HL),B		; Save new exponent
155F: D5       [101]    	PUSH	DE		; Save SQR(1/2)
1560: C5       [112]    	PUSH	BC
1561: CD5114   [129]    	CALL	FPADD		; Add SQR(1/2) to value
1564: C1       [139]    	POP	BC		; Restore SQR(1/2)
1565: D1       [149]    	POP	DE
1566: 04       [153]    	INC	B		; Make it SQR(2)
1567: CDED15   [170]    	CALL	DVBCDE		; Divide by SQR(2)
156A: 213A15   [180]    	LD	HL,UNITY	; Point to 1.
156D: CD4814   [197]    	CALL	SUBPHL		; Subtract FPREG from 1
1570: 213E15   [207]    	LD	HL,LOGTAB	; Coefficient table
1573: CDDF19   [224]    	CALL	SUMSER		; Evaluate sum of series
1576: 018080   [234]    	LD	BC,8080H	; BCDE = -0.5
1579: 110000   [244]    	LD	DE,0000H
157C: CD5114   [261]    	CALL	FPADD		; Subtract 0.5 from FPREG
157F: F1       [271]    	POP	AF		; Restore scale factor
1580: CD1218   [288]    	CALL	RSCALE		; Re-scale number
1583: 013180   [10]     MULLN2: LD	BC,8031H	; BCDE = Ln(2)
1586: 111872   [20]     	LD	DE,7218H
1589: 21                	DB	21H		; Skip "POP BC" and "POP DE"
                        ;
158A: C1       [10]     MULT:	POP	BC		; Get number from stack
158B: D1       [20]     	POP	DE
158C: CD9716   [17]     FPMULT: CALL	TSTSGN		; Test sign of FPREG
158F: C8       [22|28]  	RET	Z		; Return zero if zero
1590: 2E00     [29]     	LD	L,0		; Flag add exponents
1592: CD5516   [46]     	CALL	ADDEXP		; Add exponents
1595: 79       [50]     	LD	A,C		; Get MSB of multiplier
1596: 323B81   [63]     	LD	(MULVAL),A	; Save MSB of multiplier
1599: EB       [67]     	EX	DE,HL
159A: 223C81   [83]     	LD	(MULVAL+1),HL	; Save rest of multiplier
159D: 010000   [93]     	LD	BC,0		; Partial product (BCDE) = zero
15A0: 50       [97]     	LD	D,B
15A1: 58       [101]    	LD	E,B
15A2: 21A214   [111]    	LD	HL,BNORM	; Address of normalise
15A5: E5       [122]    	PUSH	HL		; Save for return
15A6: 21AE15   [132]    	LD	HL,MULT8	; Address of 8 bit multiply
15A9: E5       [143]    	PUSH	HL		; Save for NMSB,MSB
15AA: E5       [154]    	PUSH	HL		; 
15AB: 212981   [164]    	LD	HL,FPREG	; Point to number
15AE: 7E       [ 7]     MULT8:	LD	A,(HL)		; Get LSB of number
15AF: 23       [13]     	INC	HL		; Point to NMSB
15B0: B7       [17]     	OR	A		; Test LSB
15B1: CADA15   [27|27]  	JP	Z,BYTSFT	; Zero - shift to next byte
15B4: E5       [38]     	PUSH	HL		; Save address of number
15B5: 2E08     [45]     	LD	L,8		; 8 bits to multiply by
15B7: 1F       [ 4]     MUL8LP: RRA			; Shift LSB right
15B8: 67       [ 8]     	LD	H,A		; Save LSB
15B9: 79       [12]     	LD	A,C		; Get MSB
15BA: D2C815   [22|22]  	JP	NC,NOMADD	; Bit was zero - Don't add
15BD: E5       [33]     	PUSH	HL		; Save LSB and count
15BE: 2A3C81   [49]     	LD	HL,(MULVAL+1)	; Get LSB and NMSB
15C1: 19       [60]     	ADD	HL,DE		; Add NMSB and LSB
15C2: EB       [64]     	EX	DE,HL		; Leave sum in DE
15C3: E1       [74]     	POP	HL		; Restore MSB and count
15C4: 3A3B81   [87]     	LD	A,(MULVAL)	; Get MSB of multiplier
15C7: 89       [91]     	ADC	A,C		; Add MSB
15C8: 1F       [ 4]     NOMADD: RRA			; Shift MSB right
15C9: 4F       [ 8]     	LD	C,A		; Re-save MSB
15CA: 7A       [12]     	LD	A,D		; Get NMSB
15CB: 1F       [16]     	RRA			; Shift NMSB right
15CC: 57       [20]     	LD	D,A		; Re-save NMSB
15CD: 7B       [24]     	LD	A,E		; Get LSB
15CE: 1F       [28]     	RRA			; Shift LSB right
15CF: 5F       [32]     	LD	E,A		; Re-save LSB
15D0: 78       [36]     	LD	A,B		; Get VLSB
15D1: 1F       [40]     	RRA			; Shift VLSB right
15D2: 47       [44]     	LD	B,A		; Re-save VLSB
15D3: 2D       [48]     	DEC	L		; Count bits multiplied
15D4: 7C       [52]     	LD	A,H		; Get LSB of multiplier
15D5: C2B715   [62|62]  	JP	NZ,MUL8LP	; More - Do it
15D8: E1       [10]     POPHRT: POP	HL		; Restore address of number
15D9: C9       [20]     	RET
                        ;
15DA: 43       [ 4]     BYTSFT: LD	B,E		; Shift partial product left
15DB: 5A       [ 8]     	LD	E,D
15DC: 51       [12]     	LD	D,C
15DD: 4F       [16]     	LD	C,A
15DE: C9       [26]     	RET
                        ;
15DF: CDC816   [17]     DIV10:	CALL	STAKFP		; Save FPREG on stack
15E2: 012084   [27]     	LD	BC,8420H	; BCDE = 10.
15E5: 110000   [37]     	LD	DE,0000H
15E8: CDD816   [54]     	CALL	FPBCDE		; Move 10 to FPREG
                        ;
15EB: C1       [10]     DIV:	POP	BC		; Get number from stack
15EC: D1       [20]     	POP	DE
15ED: CD9716   [17]     DVBCDE: CALL	TSTSGN		; Test sign of FPREG
15F0: CAF303   [27|27]  	JP	Z,DZERR		; Error if division by zero
15F3: 2EFF     [34]     	LD	L,-1		; Flag subtract exponents
15F5: CD5516   [51]     	CALL	ADDEXP		; Subtract exponents
15F8: 34       [62]     	INC	(HL)		; Add 2 to exponent to adjust
15F9: 34       [73]     	INC	(HL)
15FA: 2B       [79]     	DEC	HL		; Point to MSB
15FB: 7E       [86]     	LD	A,(HL)		; Get MSB of dividend
15FC: 325780   [99]     	LD	(DIV3),A	; Save for subtraction
15FF: 2B       [105]    	DEC	HL
1600: 7E       [112]    	LD	A,(HL)		; Get NMSB of dividend
1601: 325380   [125]    	LD	(DIV2),A	; Save for subtraction
1604: 2B       [131]    	DEC	HL
1605: 7E       [138]    	LD	A,(HL)		; Get MSB of dividend
1606: 324F80   [151]    	LD	(DIV1),A	; Save for subtraction
1609: 41       [155]    	LD	B,C		; Get MSB
160A: EB       [159]    	EX	DE,HL		; NMSB,LSB to HL
160B: AF       [163]    	XOR	A
160C: 4F       [167]    	LD	C,A		; Clear MSB of quotient
160D: 57       [171]    	LD	D,A		; Clear NMSB of quotient
160E: 5F       [175]    	LD	E,A		; Clear LSB of quotient
160F: 325A80   [188]    	LD	(DIV4),A	; Clear overflow count
1612: E5       [11]     DIVLP:	PUSH	HL		; Save divisor
1613: C5       [22]     	PUSH	BC
1614: 7D       [26]     	LD	A,L		; Get LSB of number
1615: CD4E80   [43]     	CALL	DIVSUP		; Subt' divisor from dividend
1618: DE00     [50]     	SBC	A,0		; Count for overflows
161A: 3F       [54]     	CCF
161B: D22516   [64|64]  	JP	NC,RESDIV	; Restore divisor if borrow
161E: 325A80   [77]     	LD	(DIV4),A	; Re-save overflow count
1621: F1       [87]     	POP	AF		; Scrap divisor
1622: F1       [97]     	POP	AF
1623: 37       [101]    	SCF			; Set carry to
1624: D2                	DB	0D2H		; Skip "POP BC" and "POP HL"
                        ;
1625: C1       [10]     RESDIV: POP	BC		; Restore divisor
1626: E1       [20]     	POP	HL
1627: 79       [24]     	LD	A,C		; Get MSB of quotient
1628: 3C       [28]     	INC	A
1629: 3D       [32]     	DEC	A
162A: 1F       [36]     	RRA			; Bit 0 to bit 7
162B: FAD814   [46|46]  	JP	M,RONDB		; Done - Normalise result
162E: 17       [50]     	RLA			; Restore carry
162F: 7B       [54]     	LD	A,E		; Get LSB of quotient
1630: 17       [58]     	RLA			; Double it
1631: 5F       [62]     	LD	E,A		; Put it back
1632: 7A       [66]     	LD	A,D		; Get NMSB of quotient
1633: 17       [70]     	RLA			; Double it
1634: 57       [74]     	LD	D,A		; Put it back
1635: 79       [78]     	LD	A,C		; Get MSB of quotient
1636: 17       [82]     	RLA			; Double it
1637: 4F       [86]     	LD	C,A		; Put it back
1638: 29       [97]     	ADD	HL,HL		; Double NMSB,LSB of divisor
1639: 78       [101]    	LD	A,B		; Get MSB of divisor
163A: 17       [105]    	RLA			; Double it
163B: 47       [109]    	LD	B,A		; Put it back
163C: 3A5A80   [122]    	LD	A,(DIV4)	; Get VLSB of quotient
163F: 17       [126]    	RLA			; Double it
1640: 325A80   [139]    	LD	(DIV4),A	; Put it back
1643: 79       [143]    	LD	A,C		; Get MSB of quotient
1644: B2       [147]    	OR	D		; Merge NMSB
1645: B3       [151]    	OR	E		; Merge LSB
1646: C21216   [161|161]	JP	NZ,DIVLP	; Not done - Keep dividing
1649: E5       [172]    	PUSH	HL		; Save divisor
164A: 212C81   [182]    	LD	HL,FPEXP	; Point to exponent
164D: 35       [193]    	DEC	(HL)		; Divide by 2
164E: E1       [203]    	POP	HL		; Restore divisor
164F: C21216   [213|213]	JP	NZ,DIVLP	; Ok - Keep going
1652: C3FF03   [223]    	JP	OVERR		; Overflow error
                        ;
1655: 78       [ 4]     ADDEXP: LD	A,B		; Get exponent of dividend
1656: B7       [ 8]     	OR	A		; Test it
1657: CA7916   [18|18]  	JP	Z,OVTST3	; Zero - Result zero
165A: 7D       [22]     	LD	A,L		; Get add/subtract flag
165B: 212C81   [32]     	LD	HL,FPEXP	; Point to exponent
165E: AE       [39]     	XOR	(HL)		; Add or subtract it
165F: 80       [43]     	ADD	A,B		; Add the other exponent
1660: 47       [47]     	LD	B,A		; Save new exponent
1661: 1F       [51]     	RRA			; Test exponent for overflow
1662: A8       [55]     	XOR	B
1663: 78       [59]     	LD	A,B		; Get exponent
1664: F27816   [69|69]  	JP	P,OVTST2	; Positive - Test for overflow
1667: C680     [76]     	ADD	A,80H		; Add excess 128
1669: 77       [83]     	LD	(HL),A		; Save new exponent
166A: CAD815   [93|93]  	JP	Z,POPHRT	; Zero - Result zero
166D: CDFD16   [110]    	CALL	SIGNS		; Set MSBs and sign of result
1670: 77       [117]    	LD	(HL),A		; Save new exponent
1671: 2B       [123]    	DEC	HL		; Point to MSB
1672: C9       [133]    	RET
                        ;
1673: CD9716   [17]     OVTST1: CALL	TSTSGN		; Test sign of FPREG
1676: 2F       [21]     	CPL			; Invert sign
1677: E1       [31]     	POP	HL		; Clean up stack
1678: B7       [ 4]     OVTST2: OR	A		; Test if new exponent zero
1679: E1       [10]     OVTST3: POP	HL		; Clear off return address
167A: F2B714   [20|20]  	JP	P,RESZER	; Result zero
167D: C3FF03   [30]     	JP	OVERR		; Overflow error
                        ;
1680: CDE316   [17]     MLSP10: CALL	BCDEFP		; Move FPREG to BCDE
1683: 78       [21]     	LD	A,B		; Get exponent
1684: B7       [25]     	OR	A		; Is it zero?
1685: C8       [30|36]  	RET	Z		; Yes - Result is zero
1686: C602     [37]     	ADD	A,2		; Multiply by 4
1688: DAFF03   [47|47]  	JP	C,OVERR		; Overflow - ?OV Error
168B: 47       [51]     	LD	B,A		; Re-save exponent
168C: CD5114   [68]     	CALL	FPADD		; Add BCDE to FPREG (Times 5)
168F: 212C81   [78]     	LD	HL,FPEXP	; Point to exponent
1692: 34       [89]     	INC	(HL)		; Double number (Times 10)
1693: C0       [94|100] 	RET	NZ		; Ok - Return
1694: C3FF03   [104]    	JP	OVERR		; Overflow error
                        ;
1697: 3A2C81   [13]     TSTSGN: LD	A,(FPEXP)	; Get sign of FPREG
169A: B7       [17]     	OR	A
169B: C8       [22|28]  	RET	Z		; RETurn if number is zero
169C: 3A2B81   [35]     	LD	A,(FPREG+2)	; Get MSB of FPREG
169F: FE                	DB	0FEH		; Test sign
16A0: 2F       [ 4]     RETREL: CPL			; Invert sign
16A1: 17       [ 8]     	RLA			; Sign bit to carry
16A2: 9F       [ 4]     FLGDIF: SBC	A,A		; Carry to all bits of A
16A3: C0       [ 9|15]  	RET	NZ		; Return -1 if negative
16A4: 3C       [13]     	INC	A		; Bump to +1
16A5: C9       [23]     	RET			; Positive - Return +1
                        ;
16A6: CD9716   [17]     SGN:	CALL	TSTSGN		; Test sign of FPREG
16A9: 0688     [ 7]     FLGREL: LD	B,80H+8		; 8 bit integer in exponent
16AB: 110000   [17]     	LD	DE,0		; Zero NMSB and LSB
16AE: 212C81   [10]     RETINT: LD	HL,FPEXP	; Point to exponent
16B1: 4F       [14]     	LD	C,A		; CDE = MSB,NMSB and LSB
16B2: 70       [21]     	LD	(HL),B		; Save exponent
16B3: 0600     [28]     	LD	B,0		; CDE = integer to normalise
16B5: 23       [34]     	INC	HL		; Point to sign of result
16B6: 3680     [44]     	LD	(HL),80H	; Set sign of result
16B8: 17       [48]     	RLA			; Carry = sign of integer
16B9: C39F14   [58]     	JP	CONPOS		; Set sign of result
                        ;
16BC: CD9716   [17]     ABS:	CALL	TSTSGN		; Test sign of FPREG
16BF: F0       [22|28]  	RET	P		; Return if positive
16C0: 212B81   [10]     INVSGN: LD	HL,FPREG+2	; Point to MSB
16C3: 7E       [17]     	LD	A,(HL)		; Get sign of mantissa
16C4: EE80     [24]     	XOR	80H		; Invert sign of mantissa
16C6: 77       [31]     	LD	(HL),A		; Re-save sign of mantissa
16C7: C9       [41]     	RET
                        ;
16C8: EB       [ 4]     STAKFP: EX	DE,HL		; Save code string address
16C9: 2A2981   [20]     	LD	HL,(FPREG)	; LSB,NLSB of FPREG
16CC: E3       [39]     	EX	(SP),HL		; Stack them,get return
16CD: E5       [50]     	PUSH	HL		; Re-save return
16CE: 2A2B81   [66]     	LD	HL,(FPREG+2)	; MSB and exponent of FPREG
16D1: E3       [85]     	EX	(SP),HL		; Stack them,get return
16D2: E5       [96]     	PUSH	HL		; Re-save return
16D3: EB       [100]    	EX	DE,HL		; Restore code string address
16D4: C9       [110]    	RET
                        ;
16D5: CDE616   [17]     PHLTFP: CALL	LOADFP		; Number at HL to BCDE
16D8: EB       [ 4]     FPBCDE: EX	DE,HL		; Save code string address
16D9: 222981   [20]     	LD	(FPREG),HL	; Save LSB,NLSB of number
16DC: 60       [24]     	LD	H,B		; Exponent of number
16DD: 69       [28]     	LD	L,C		; MSB of number
16DE: 222B81   [44]     	LD	(FPREG+2),HL	; Save MSB and exponent
16E1: EB       [48]     	EX	DE,HL		; Restore code string address
16E2: C9       [58]     	RET
                        ;
16E3: 212981   [10]     BCDEFP: LD	HL,FPREG	; Point to FPREG
16E6: 5E       [ 7]     LOADFP: LD	E,(HL)		; Get LSB of number
16E7: 23       [13]     	INC	HL
16E8: 56       [20]     	LD	D,(HL)		; Get NMSB of number
16E9: 23       [26]     	INC	HL
16EA: 4E       [33]     	LD	C,(HL)		; Get MSB of number
16EB: 23       [39]     	INC	HL
16EC: 46       [46]     	LD	B,(HL)		; Get exponent of number
16ED: 23       [ 6]     INCHL:	INC	HL		; Used for conditional "INC HL"
16EE: C9       [16]     	RET
                        ;
16EF: 112981   [10]     FPTHL:	LD	DE,FPREG	; Point to FPREG
16F2: 0604     [ 7]     DETHL4: LD	B,4		; 4 bytes to move
16F4: 1A       [ 7]     DETHLB: LD	A,(DE)		; Get source
16F5: 77       [14]     	LD	(HL),A		; Save destination
16F6: 13       [20]     	INC	DE		; Next source
16F7: 23       [26]     	INC	HL		; Next destination
16F8: 05       [30]     	DEC	B		; Count bytes
16F9: C2F416   [40|40]  	JP	NZ,DETHLB	; Loop if more
16FC: C9       [50]     	RET
                        ;
16FD: 212B81   [10]     SIGNS:	LD	HL,FPREG+2	; Point to MSB of FPREG
1700: 7E       [17]     	LD	A,(HL)		; Get MSB
1701: 07       [21]     	RLCA			; Old sign to carry
1702: 37       [25]     	SCF			; Set MSBit
1703: 1F       [29]     	RRA			; Set MSBit of MSB
1704: 77       [36]     	LD	(HL),A		; Save new MSB
1705: 3F       [40]     	CCF			; Complement sign
1706: 1F       [44]     	RRA			; Old sign to carry
1707: 23       [50]     	INC	HL
1708: 23       [56]     	INC	HL
1709: 77       [63]     	LD	(HL),A		; Set sign of result
170A: 79       [67]     	LD	A,C		; Get MSB
170B: 07       [71]     	RLCA			; Old sign to carry
170C: 37       [75]     	SCF			; Set MSBit
170D: 1F       [79]     	RRA			; Set MSBit of MSB
170E: 4F       [83]     	LD	C,A		; Save MSB
170F: 1F       [87]     	RRA
1710: AE       [94]     	XOR	(HL)		; New sign of result
1711: C9       [104]    	RET
                        ;
1712: 78       [ 4]     CMPNUM: LD	A,B		; Get exponent of number
1713: B7       [ 8]     	OR	A
1714: CA9716   [18|18]  	JP	Z,TSTSGN	; Zero - Test sign of FPREG
1717: 21A016   [28]     	LD	HL,RETREL	; Return relation routine
171A: E5       [39]     	PUSH	HL		; Save for return
171B: CD9716   [56]     	CALL	TSTSGN		; Test sign of FPREG
171E: 79       [60]     	LD	A,C		; Get MSB of number
171F: C8       [65|71]  	RET	Z		; FPREG zero - Number's MSB
1720: 212B81   [75]     	LD	HL,FPREG+2	; MSB of FPREG
1723: AE       [82]     	XOR	(HL)		; Combine signs
1724: 79       [86]     	LD	A,C		; Get MSB of number
1725: F8       [91|97]  	RET	M		; Exit if signs different
1726: CD2C17   [108]    	CALL	CMPFP		; Compare FP numbers
1729: 1F       [112]    	RRA			; Get carry to sign
172A: A9       [116]    	XOR	C		; Combine with MSB of number
172B: C9       [126]    	RET
                        ;
172C: 23       [ 6]     CMPFP:	INC	HL		; Point to exponent
172D: 78       [10]     	LD	A,B		; Get exponent
172E: BE       [17]     	CP	(HL)		; Compare exponents
172F: C0       [22|28]  	RET	NZ		; Different
1730: 2B       [28]     	DEC	HL		; Point to MBS
1731: 79       [32]     	LD	A,C		; Get MSB
1732: BE       [39]     	CP	(HL)		; Compare MSBs
1733: C0       [44|50]  	RET	NZ		; Different
1734: 2B       [50]     	DEC	HL		; Point to NMSB
1735: 7A       [54]     	LD	A,D		; Get NMSB
1736: BE       [61]     	CP	(HL)		; Compare NMSBs
1737: C0       [66|72]  	RET	NZ		; Different
1738: 2B       [72]     	DEC	HL		; Point to LSB
1739: 7B       [76]     	LD	A,E		; Get LSB
173A: 96       [83]     	SUB	(HL)		; Compare LSBs
173B: C0       [88|94]  	RET	NZ		; Different
173C: E1       [98]     	POP	HL		; Drop RETurn
173D: E1       [108]    	POP	HL		; Drop another RETurn
173E: C9       [118]    	RET
                        ;
173F: 47       [ 4]     FPINT:	LD	B,A		; <- Move
1740: 4F       [ 8]     	LD	C,A		; <- exponent
1741: 57       [12]     	LD	D,A		; <- to all
1742: 5F       [16]     	LD	E,A		; <- bits
1743: B7       [20]     	OR	A		; Test exponent
1744: C8       [25|31]  	RET	Z		; Zero - Return zero
1745: E5       [36]     	PUSH	HL		; Save pointer to number
1746: CDE316   [53]     	CALL	BCDEFP		; Move FPREG to BCDE
1749: CDFD16   [70]     	CALL	SIGNS		; Set MSBs & sign of result
174C: AE       [77]     	XOR	(HL)		; Combine with sign of FPREG
174D: 67       [81]     	LD	H,A		; Save combined signs
174E: FC6317   [91|98]  	CALL	M,DCBCDE	; Negative - Decrement BCDE
1751: 3E98     [98]     	LD	A,80H+24	; 24 bits
1753: 90       [102]    	SUB	B		; Bits to shift
1754: CD1615   [119]    	CALL	SCALE		; Shift BCDE
1757: 7C       [123]    	LD	A,H		; Get combined sign
1758: 17       [127]    	RLA			; Sign to carry
1759: DCE914   [137|144]	CALL	C,FPROND	; Negative - Round number up
175C: 0600     [144]    	LD	B,0		; Zero exponent
175E: DC0215   [154|161]	CALL	C,COMPL		; If negative make positive
1761: E1       [164]    	POP	HL		; Restore pointer to number
1762: C9       [174]    	RET
                        ;
1763: 1B       [ 6]     DCBCDE: DEC	DE		; Decrement BCDE
1764: 7A       [10]     	LD	A,D		; Test LSBs
1765: A3       [14]     	AND	E
1766: 3C       [18]     	INC	A
1767: C0       [23|29]  	RET	NZ		; Exit if LSBs not FFFF
1768: 0B       [29]     	DEC	BC		; Decrement MSBs
1769: C9       [39]     	RET
                        ;
176A: 212C81   [10]     INT:	LD	HL,FPEXP	; Point to exponent
176D: 7E       [17]     	LD	A,(HL)		; Get exponent
176E: FE98     [24]     	CP	80H+24		; Integer accuracy only?
1770: 3A2981   [37]     	LD	A,(FPREG)	; Get LSB
1773: D0       [42|48]  	RET	NC		; Yes - Already integer
1774: 7E       [49]     	LD	A,(HL)		; Get exponent
1775: CD3F17   [66]     	CALL	FPINT		; F.P to integer
1778: 3698     [76]     	LD	(HL),80H+24	; Save 24 bit integer
177A: 7B       [80]     	LD	A,E		; Get LSB of number
177B: F5       [91]     	PUSH	AF		; Save LSB
177C: 79       [95]     	LD	A,C		; Get MSB of number
177D: 17       [99]     	RLA			; Sign to carry
177E: CD9F14   [116]    	CALL	CONPOS		; Set sign of result
1781: F1       [126]    	POP	AF		; Restore LSB of number
1782: C9       [136]    	RET
                        ;
1783: 210000   [10]     MLDEBC: LD	HL,0		; Clear partial product
1786: 78       [14]     	LD	A,B		; Test multiplier
1787: B1       [18]     	OR	C
1788: C8       [23|29]  	RET	Z		; Return zero if zero
1789: 3E10     [30]     	LD	A,16		; 16 bits
178B: 29       [11]     MLDBLP: ADD	HL,HL		; Shift P.P left
178C: DAC30F   [21|21]  	JP	C,BSERR		; ?BS Error if overflow
178F: EB       [25]     	EX	DE,HL
1790: 29       [36]     	ADD	HL,HL		; Shift multiplier left
1791: EB       [40]     	EX	DE,HL
1792: D29917   [50|50]  	JP	NC,NOMLAD	; Bit was zero - No add
1795: 09       [61]     	ADD	HL,BC		; Add multiplicand
1796: DAC30F   [71|71]  	JP	C,BSERR		; ?BS Error if overflow
1799: 3D       [ 4]     NOMLAD: DEC	A		; Count bits
179A: C28B17   [14|14]  	JP	NZ,MLDBLP	; More
179D: C9       [24]     	RET
                        ;
179E: FE2D     [ 7]     ASCTFP: CP	'-'		; Negative?
17A0: F5       [18]     	PUSH	AF		; Save it and flags
17A1: CAAA17   [28|28]  	JP	Z,CNVNUM	; Yes - Convert number
17A4: FE2B     [35]     	CP	'+'		; Positive?
17A6: CAAA17   [45|45]  	JP	Z,CNVNUM	; Yes - Convert number
17A9: 2B       [51]     	DEC	HL		; DEC 'cos GETCHR INCs
17AA: CDB714   [17]     CNVNUM: CALL	RESZER		; Set result to zero
17AD: 47       [21]     	LD	B,A		; Digits after point counter
17AE: 57       [25]     	LD	D,A		; Sign of exponent
17AF: 5F       [29]     	LD	E,A		; Exponent of ten
17B0: 2F       [33]     	CPL
17B1: 4F       [37]     	LD	C,A		; Before or after point flag
17B2: CD4808   [17]     MANLP:	CALL	GETCHR		; Get next character
17B5: DAFB17   [27|27]  	JP	C,ADDIG		; Digit - Add to number
17B8: FE2E     [34]     	CP	'.'
17BA: CAD617   [44|44]  	JP	Z,DPOINT	; '.' - Flag point
17BD: FE45     [51]     	CP	'E'
17BF: C2DA17   [61|61]  	JP	NZ,CONEXP	; Not 'E' - Scale number
17C2: CD4808   [78]     	CALL	GETCHR		; Get next character
17C5: CDEE0D   [95]     	CALL	SGNEXP		; Get sign of exponent
17C8: CD4808   [17]     EXPLP:	CALL	GETCHR		; Get next character
17CB: DA1D18   [27|27]  	JP	C,EDIGIT	; Digit - Add to exponent
17CE: 14       [31]     	INC	D		; Is sign negative?
17CF: C2DA17   [41|41]  	JP	NZ,CONEXP	; No - Scale number
17D2: AF       [45]     	XOR	A
17D3: 93       [49]     	SUB	E		; Negate exponent
17D4: 5F       [53]     	LD	E,A		; And re-save it
17D5: 0C       [57]     	INC	C		; Flag end of number
17D6: 0C       [ 4]     DPOINT: INC	C		; Flag point passed
17D7: CAB217   [14|14]  	JP	Z,MANLP		; Zero - Get another digit
17DA: E5       [11]     CONEXP: PUSH	HL		; Save code string address
17DB: 7B       [15]     	LD	A,E		; Get exponent
17DC: 90       [19]     	SUB	B		; Subtract digits after point
17DD: F4F317   [10|17]  SCALMI: CALL	P,SCALPL	; Positive - Multiply number
17E0: F2E917   [20|20]  	JP	P,ENDCON	; Positive - All done
17E3: F5       [31]     	PUSH	AF		; Save number of times to /10
17E4: CDDF15   [48]     	CALL	DIV10		; Divide by 10
17E7: F1       [58]     	POP	AF		; Restore count
17E8: 3C       [62]     	INC	A		; Count divides
                        ;
17E9: C2DD17   [10|10]  ENDCON: JP	NZ,SCALMI	; More to do
17EC: D1       [20]     	POP	DE		; Restore code string address
17ED: F1       [30]     	POP	AF		; Restore sign of number
17EE: CCC016   [40|47]  	CALL	Z,INVSGN	; Negative - Negate number
17F1: EB       [44]     	EX	DE,HL		; Code string address to HL
17F2: C9       [54]     	RET
                        ;
17F3: C8       [ 5|11]  SCALPL: RET	Z		; Exit if no scaling needed
17F4: F5       [11]     MULTEN: PUSH	AF		; Save count
17F5: CD8016   [28]     	CALL	MLSP10		; Multiply number by 10
17F8: F1       [38]     	POP	AF		; Restore count
17F9: 3D       [42]     	DEC	A		; Count multiplies
17FA: C9       [52]     	RET
                        ;
17FB: D5       [11]     ADDIG:	PUSH	DE		; Save sign of exponent
17FC: 57       [15]     	LD	D,A		; Save digit
17FD: 78       [19]     	LD	A,B		; Get digits after point
17FE: 89       [23]     	ADC	A,C		; Add one if after point
17FF: 47       [27]     	LD	B,A		; Re-save counter
1800: C5       [38]     	PUSH	BC		; Save point flags
1801: E5       [49]     	PUSH	HL		; Save code string address
1802: D5       [60]     	PUSH	DE		; Save digit
1803: CD8016   [77]     	CALL	MLSP10		; Multiply number by 10
1806: F1       [87]     	POP	AF		; Restore digit
1807: D630     [94]     	SUB	'0'		; Make it absolute
1809: CD1218   [111]    	CALL	RSCALE		; Re-scale number
180C: E1       [121]    	POP	HL		; Restore code string address
180D: C1       [131]    	POP	BC		; Restore point flags
180E: D1       [141]    	POP	DE		; Restore sign of exponent
180F: C3B217   [151]    	JP	MANLP		; Get another digit
                        ;
1812: CDC816   [17]     RSCALE: CALL	STAKFP		; Put number on stack
1815: CDA916   [34]     	CALL	FLGREL		; Digit to add to FPREG
1818: C1       [10]     PADD:	POP	BC		; Restore number
1819: D1       [20]     	POP	DE
181A: C35114   [30]     	JP	FPADD		; Add BCDE to FPREG and return
                        ;
181D: 7B       [ 4]     EDIGIT: LD	A,E		; Get digit
181E: 07       [ 8]     	RLCA			; Times 2
181F: 07       [12]     	RLCA			; Times 4
1820: 83       [16]     	ADD	A,E		; Times 5
1821: 07       [20]     	RLCA			; Times 10
1822: 86       [27]     	ADD	A,(HL)		; Add next digit
1823: D630     [34]     	SUB	'0'		; Make it absolute
1825: 5F       [38]     	LD	E,A		; Save new digit
1826: C3C817   [48]     	JP	EXPLP		; Look for another digit
                        ;
1829: E5       [11]     LINEIN: PUSH	HL		; Save code string address
182A: 218803   [21]     	LD	HL,INMSG	; Output " in "
182D: CD8E11   [38]     	CALL	PRS		; Output string at HL
1830: E1       [48]     	POP	HL		; Restore code string address
1831: EB       [ 4]     PRNTHL: EX	DE,HL		; Code string address to DE
1832: AF       [ 8]     	XOR	A
1833: 0698     [15]     	LD	B,80H+24	; 24 bits
1835: CDAE16   [32]     	CALL	RETINT		; Return the integer
1838: 218D11   [42]     	LD	HL,PRNUMS	; Print number string
183B: E5       [53]     	PUSH	HL		; Save for return
183C: 212E81   [10]     NUMASC: LD	HL,PBUFF	; Convert number to ASCII
183F: E5       [21]     	PUSH	HL		; Save for return
1840: CD9716   [38]     	CALL	TSTSGN		; Test sign of FPREG
1843: 3620     [48]     	LD	(HL),' '	; Space at start
1845: F24A18   [58|58]  	JP	P,SPCFST	; Positive - Space to start
1848: 362D     [68]     	LD	(HL),'-'	; '-' sign at start
184A: 23       [ 6]     SPCFST: INC	HL		; First byte of number
184B: 3630     [16]     	LD	(HL),'0'	; '0' if zero
184D: CA0019   [26|26]  	JP	Z,JSTZER	; Return '0' if zero
1850: E5       [37]     	PUSH	HL		; Save buffer address
1851: FCC016   [47|54]  	CALL	M,INVSGN	; Negate FPREG if negative
1854: AF       [51]     	XOR	A		; Zero A
1855: F5       [62]     	PUSH	AF		; Save it
1856: CD0619   [79]     	CALL	RNGTST		; Test number is in range
1859: 014391   [10]     SIXDIG: LD	BC,9143H	; BCDE - 99999.9
185C: 11F84F   [20]     	LD	DE,4FF8H
185F: CD1217   [37]     	CALL	CMPNUM		; Compare numbers
1862: B7       [41]     	OR	A
1863: E27718   [51|51]  	JP	PO,INRNG	; > 99999.9 - Sort it out
1866: F1       [61]     	POP	AF		; Restore count
1867: CDF417   [78]     	CALL	MULTEN		; Multiply by ten
186A: F5       [89]     	PUSH	AF		; Re-save count
186B: C35918   [99]     	JP	SIXDIG		; Test it again
                        ;
186E: CDDF15   [17]     GTSIXD: CALL	DIV10		; Divide by 10
1871: F1       [27]     	POP	AF		; Get count
1872: 3C       [31]     	INC	A		; Count divides
1873: F5       [42]     	PUSH	AF		; Re-save count
1874: CD0619   [59]     	CALL	RNGTST		; Test number is in range
1877: CD3F14   [17]     INRNG:	CALL	ROUND		; Add 0.5 to FPREG
187A: 3C       [21]     	INC	A
187B: CD3F17   [38]     	CALL	FPINT		; F.P to integer
187E: CDD816   [55]     	CALL	FPBCDE		; Move BCDE to FPREG
1881: 010603   [65]     	LD	BC,0306H	; 1E+06 to 1E-03 range
1884: F1       [75]     	POP	AF		; Restore count
1885: 81       [79]     	ADD	A,C		; 6 digits before point
1886: 3C       [83]     	INC	A		; Add one
1887: FA9318   [93|93]  	JP	M,MAKNUM	; Do it in 'E' form if < 1E-02
188A: FE08     [100]    	CP	6+1+1		; More than 999999 ?
188C: D29318   [110|110]	JP	NC,MAKNUM	; Yes - Do it in 'E' form
188F: 3C       [114]    	INC	A		; Adjust for exponent
1890: 47       [118]    	LD	B,A		; Exponent of number
1891: 3E02     [125]    	LD	A,2		; Make it zero after
                        ;
1893: 3D       [ 4]     MAKNUM: DEC	A		; Adjust for digits to do
1894: 3D       [ 8]     	DEC	A
1895: E1       [18]     	POP	HL		; Restore buffer address
1896: F5       [29]     	PUSH	AF		; Save count
1897: 111919   [39]     	LD	DE,POWERS	; Powers of ten
189A: 05       [43]     	DEC	B		; Count digits before point
189B: C2A418   [53|53]  	JP	NZ,DIGTXT	; Not zero - Do number
189E: 362E     [63]     	LD	(HL),'.'	; Save point
18A0: 23       [69]     	INC	HL		; Move on
18A1: 3630     [79]     	LD	(HL),'0'	; Save zero
18A3: 23       [85]     	INC	HL		; Move on
18A4: 05       [ 4]     DIGTXT: DEC	B		; Count digits before point
18A5: 362E     [14]     	LD	(HL),'.'	; Save point in case
18A7: CCED16   [24|31]  	CALL	Z,INCHL		; Last digit - move on
18AA: C5       [35]     	PUSH	BC		; Save digits before point
18AB: E5       [46]     	PUSH	HL		; Save buffer address
18AC: D5       [57]     	PUSH	DE		; Save powers of ten
18AD: CDE316   [74]     	CALL	BCDEFP		; Move FPREG to BCDE
18B0: E1       [84]     	POP	HL		; Powers of ten table
18B1: 062F     [91]     	LD	B, '0'-1	; ASCII '0' - 1
18B3: 04       [ 4]     TRYAGN: INC	B		; Count subtractions
18B4: 7B       [ 8]     	LD	A,E		; Get LSB
18B5: 96       [15]     	SUB	(HL)		; Subtract LSB
18B6: 5F       [19]     	LD	E,A		; Save LSB
18B7: 23       [25]     	INC	HL
18B8: 7A       [29]     	LD	A,D		; Get NMSB
18B9: 9E       [36]     	SBC	A,(HL)		; Subtract NMSB
18BA: 57       [40]     	LD	D,A		; Save NMSB
18BB: 23       [46]     	INC	HL
18BC: 79       [50]     	LD	A,C		; Get MSB
18BD: 9E       [57]     	SBC	A,(HL)		; Subtract MSB
18BE: 4F       [61]     	LD	C,A		; Save MSB
18BF: 2B       [67]     	DEC	HL		; Point back to start
18C0: 2B       [73]     	DEC	HL
18C1: D2B318   [83|83]  	JP	NC,TRYAGN	; No overflow - Try again
18C4: CDF614   [100]    	CALL	PLUCDE		; Restore number
18C7: 23       [106]    	INC	HL		; Start of next number
18C8: CDD816   [123]    	CALL	FPBCDE		; Move BCDE to FPREG
18CB: EB       [127]    	EX	DE,HL		; Save point in table
18CC: E1       [137]    	POP	HL		; Restore buffer address
18CD: 70       [144]    	LD	(HL),B		; Save digit in buffer
18CE: 23       [150]    	INC	HL		; And move on
18CF: C1       [160]    	POP	BC		; Restore digit count
18D0: 0D       [164]    	DEC	C		; Count digits
18D1: C2A418   [174|174]	JP	NZ,DIGTXT	; More - Do them
18D4: 05       [178]    	DEC	B		; Any decimal part?
18D5: CAE418   [188|188]	JP	Z,DOEBIT	; No - Do 'E' bit
18D8: 2B       [ 6]     SUPTLZ: DEC	HL		; Move back through buffer
18D9: 7E       [13]     	LD	A,(HL)		; Get character
18DA: FE30     [20]     	CP	'0'		; '0' character?
18DC: CAD818   [30|30]  	JP	Z,SUPTLZ	; Yes - Look back for more
18DF: FE2E     [37]     	CP	'.'		; A decimal point?
18E1: C4ED16   [47|54]  	CALL	NZ,INCHL	; Move back over digit
                        ;
18E4: F1       [10]     DOEBIT: POP	AF		; Get 'E' flag
18E5: CA0319   [20|20]  	JP	Z,NOENED	; No 'E' needed - End buffer
18E8: 3645     [30]     	LD	(HL),'E'	; Put 'E' in buffer
18EA: 23       [36]     	INC	HL		; And move on
18EB: 362B     [46]     	LD	(HL),'+'	; Put '+' in buffer
18ED: F2F418   [56|56]  	JP	P,OUTEXP	; Positive - Output exponent
18F0: 362D     [66]     	LD	(HL),'-'	; Put '-' in buffer
18F2: 2F       [70]     	CPL			; Negate exponent
18F3: 3C       [74]     	INC	A
18F4: 062F     [ 7]     OUTEXP: LD	B,'0'-1		; ASCII '0' - 1
18F6: 04       [ 4]     EXPTEN: INC	B		; Count subtractions
18F7: D60A     [11]     	SUB	10		; Tens digit
18F9: D2F618   [21|21]  	JP	NC,EXPTEN	; More to do
18FC: C63A     [28]     	ADD	A,'0'+10	; Restore and make ASCII
18FE: 23       [34]     	INC	HL		; Move on
18FF: 70       [41]     	LD	(HL),B		; Save MSB of exponent
1900: 23       [ 6]     JSTZER: INC	HL		;
1901: 77       [13]     	LD	(HL),A		; Save LSB of exponent
1902: 23       [19]     	INC	HL
1903: 71       [ 7]     NOENED: LD	(HL),C		; Mark end of buffer
1904: E1       [17]     	POP	HL		; Restore code string address
1905: C9       [27]     	RET
                        ;
1906: 017494   [10]     RNGTST: LD	BC,9474H	; BCDE = 999999.
1909: 11F723   [20]     	LD	DE,23F7H
190C: CD1217   [37]     	CALL	CMPNUM		; Compare numbers
190F: B7       [41]     	OR	A
1910: E1       [51]     	POP	HL		; Return address to HL
1911: E26E18   [61|61]  	JP	PO,GTSIXD	; Too big - Divide by ten
1914: E9       [65]     	JP	(HL)		; Otherwise return to caller
                        ;
1915: 00000080          HALF:	DB	00H,00H,00H,80H	; 0.5
                        ;
1919: A08601            POWERS: DB	0A0H,086H,001H	; 100000
191C: 102700            	DB	010H,027H,000H	; 10000
191F: E80300            	DB	0E8H,003H,000H	; 1000
1922: 640000            	DB	064H,000H,000H	; 100
1925: 0A0000            	DB	00AH,000H,000H	; 10
1928: 010000            	DB	001H,000H,000H	; 1
                        ;
192B: 21C016   [10]     NEGAFT: LD	HL,INVSGN	; Negate result
192E: E3       [29]     	EX	(SP),HL		; To be done after caller
192F: E9       [33]     	JP	(HL)		; Return to caller
                        ;
1930: CDC816   [17]     SQR:	CALL	STAKFP		; Put value on stack
1933: 211519   [27]     	LD	HL,HALF		; Set power to 1/2
1936: CDD516   [44]     	CALL	PHLTFP		; Move 1/2 to FPREG
                        ;
1939: C1       [10]     POWER:	POP	BC		; Get base
193A: D1       [20]     	POP	DE
193B: CD9716   [37]     	CALL	TSTSGN		; Test sign of power
193E: 78       [41]     	LD	A,B		; Get exponent of base
193F: CA7E19   [51|51]  	JP	Z,EXP		; Make result 1 if zero
1942: F24919   [61|61]  	JP	P,POWER1	; Positive base - Ok
1945: B7       [65]     	OR	A		; Zero to negative power?
1946: CAF303   [75|75]  	JP	Z,DZERR		; Yes - ?/0 Error
1949: B7       [ 4]     POWER1: OR	A		; Base zero?
194A: CAB814   [14|14]  	JP	Z,SAVEXP	; Yes - Return zero
194D: D5       [25]     	PUSH	DE		; Save base
194E: C5       [36]     	PUSH	BC
194F: 79       [40]     	LD	A,C		; Get MSB of base
1950: F67F     [47]     	OR	01111111B	; Get sign status
1952: CDE316   [64]     	CALL	BCDEFP		; Move power to BCDE
1955: F26619   [74|74]  	JP	P,POWER2	; Positive base - Ok
1958: D5       [85]     	PUSH	DE		; Save power
1959: C5       [96]     	PUSH	BC
195A: CD6A17   [113]    	CALL	INT		; Get integer of power
195D: C1       [123]    	POP	BC		; Restore power
195E: D1       [133]    	POP	DE
195F: F5       [144]    	PUSH	AF		; MSB of base
1960: CD1217   [161]    	CALL	CMPNUM		; Power an integer?
1963: E1       [171]    	POP	HL		; Restore MSB of base
1964: 7C       [175]    	LD	A,H		; but don't affect flags
1965: 1F       [179]    	RRA			; Exponent odd or even?
1966: E1       [10]     POWER2: POP	HL		; Restore MSB and exponent
1967: 222B81   [26]     	LD	(FPREG+2),HL	; Save base in FPREG
196A: E1       [36]     	POP	HL		; LSBs of base
196B: 222981   [52]     	LD	(FPREG),HL	; Save in FPREG
196E: DC2B19   [62|69]  	CALL	C,NEGAFT	; Odd power - Negate result
1971: CCC016   [72|79]  	CALL	Z,INVSGN	; Negative base - Negate it
1974: D5       [83]     	PUSH	DE		; Save power
1975: C5       [94]     	PUSH	BC
1976: CD4B15   [111]    	CALL	LOG		; Get LOG of base
1979: C1       [121]    	POP	BC		; Restore power
197A: D1       [131]    	POP	DE
197B: CD8C15   [148]    	CALL	FPMULT		; Multiply LOG by power
                        ;
197E: CDC816   [17]     EXP:	CALL	STAKFP		; Put value on stack
1981: 013881   [27]     	LD	BC,08138H	; BCDE = 1/Ln(2)
1984: 113BAA   [37]     	LD	DE,0AA3BH
1987: CD8C15   [54]     	CALL	FPMULT		; Multiply value by 1/LN(2)
198A: 3A2C81   [67]     	LD	A,(FPEXP)	; Get exponent
198D: FE88     [74]     	CP	80H+8		; Is it in range?
198F: D27316   [84|84]  	JP	NC,OVTST1	; No - Test for overflow
1992: CD6A17   [101]    	CALL	INT		; Get INT of FPREG
1995: C680     [108]    	ADD	A,80H		; For excess 128
1997: C602     [115]    	ADD	A,2		; Exponent > 126?
1999: DA7316   [125|125]	JP	C,OVTST1	; Yes - Test for overflow
199C: F5       [136]    	PUSH	AF		; Save scaling factor
199D: 213A15   [146]    	LD	HL,UNITY	; Point to 1.
19A0: CD4214   [163]    	CALL	ADDPHL		; Add 1 to FPREG
19A3: CD8315   [180]    	CALL	MULLN2		; Multiply by LN(2)
19A6: F1       [190]    	POP	AF		; Restore scaling factor
19A7: C1       [200]    	POP	BC		; Restore exponent
19A8: D1       [210]    	POP	DE
19A9: F5       [221]    	PUSH	AF		; Save scaling factor
19AA: CD4E14   [238]    	CALL	SUBCDE		; Subtract exponent from FPREG
19AD: CDC016   [255]    	CALL	INVSGN		; Negate result
19B0: 21BE19   [265]    	LD	HL,EXPTAB	; Coefficient table
19B3: CDEE19   [282]    	CALL	SMSER1		; Sum the series
19B6: 110000   [292]    	LD	DE,0		; Zero LSBs
19B9: C1       [302]    	POP	BC		; Scaling factor
19BA: 4A       [306]    	LD	C,D		; Zero MSB
19BB: C38C15   [316]    	JP	FPMULT		; Scale result to correct value
                        ;
19BE: 08                EXPTAB: DB	8			; Table used by EXP
19BF: 402E9474          	DB	040H,02EH,094H,074H	; -1/7! (-1/5040)
19C3: 704F2E77          	DB	070H,04FH,02EH,077H	;  1/6! ( 1/720)
19C7: 6E02887A          	DB	06EH,002H,088H,07AH	; -1/5! (-1/120)
19CB: E6A02A7C          	DB	0E6H,0A0H,02AH,07CH	;  1/4! ( 1/24)
19CF: 50AAAA7E          	DB	050H,0AAH,0AAH,07EH	; -1/3! (-1/6)
19D3: FFFF7F7F          	DB	0FFH,0FFH,07FH,07FH	;  1/2! ( 1/2)
19D7: 00008081          	DB	000H,000H,080H,081H	; -1/1! (-1/1)
19DB: 00000081          	DB	000H,000H,000H,081H	;  1/0! ( 1/1)
                        ;
19DF: CDC816   [17]     SUMSER: CALL	STAKFP		; Put FPREG on stack
19E2: 118A15   [27]     	LD	DE,MULT		; Multiply by "X"
19E5: D5       [38]     	PUSH	DE		; To be done after
19E6: E5       [49]     	PUSH	HL		; Save address of table
19E7: CDE316   [66]     	CALL	BCDEFP		; Move FPREG to BCDE
19EA: CD8C15   [83]     	CALL	FPMULT		; Square the value
19ED: E1       [93]     	POP	HL		; Restore address of table
19EE: CDC816   [17]     SMSER1: CALL	STAKFP		; Put value on stack
19F1: 7E       [24]     	LD	A,(HL)		; Get number of coefficients
19F2: 23       [30]     	INC	HL		; Point to start of table
19F3: CDD516   [47]     	CALL	PHLTFP		; Move coefficient to FPREG
19F6: 06                	DB	06H		; Skip "POP AF"
19F7: F1       [10]     SUMLP:	POP	AF		; Restore count
19F8: C1       [20]     	POP	BC		; Restore number
19F9: D1       [30]     	POP	DE
19FA: 3D       [34]     	DEC	A		; Cont coefficients
19FB: C8       [39|45]  	RET	Z		; All done
19FC: D5       [50]     	PUSH	DE		; Save number
19FD: C5       [61]     	PUSH	BC
19FE: F5       [72]     	PUSH	AF		; Save count
19FF: E5       [83]     	PUSH	HL		; Save address in table
1A00: CD8C15   [100]    	CALL	FPMULT		; Multiply FPREG by BCDE
1A03: E1       [110]    	POP	HL		; Restore address in table
1A04: CDE616   [127]    	CALL	LOADFP		; Number at HL to BCDE
1A07: E5       [138]    	PUSH	HL		; Save address in table
1A08: CD5114   [155]    	CALL	FPADD		; Add coefficient to FPREG
1A0B: E1       [165]    	POP	HL		; Restore address in table
1A0C: C3F719   [175]    	JP	SUMLP		; More coefficients
                        ;
1A0F: CD9716   [17]     RND:	CALL	TSTSGN		; Test sign of FPREG
1A12: 215E80   [27]     	LD	HL,SEED+2	; Random number seed
1A15: FA701A   [37|37]  	JP	M,RESEED	; Negative - Re-seed
1A18: 217F80   [47]     	LD	HL,LSTRND	; Last random number
1A1B: CDD516   [64]     	CALL	PHLTFP		; Move last RND to FPREG
1A1E: 215E80   [74]     	LD	HL,SEED+2	; Random number seed
1A21: C8       [79|85]  	RET	Z		; Return if RND(0)
1A22: 86       [86]     	ADD	A,(HL)		; Add (SEED)+2)
1A23: E607     [93]     	AND	00000111B	; 0 to 7
1A25: 0600     [100]    	LD	B,0
1A27: 77       [107]    	LD	(HL),A		; Re-save seed
1A28: 23       [113]    	INC	HL		; Move to coefficient table
1A29: 87       [117]    	ADD	A,A		; 4 bytes
1A2A: 87       [121]    	ADD	A,A		; per entry
1A2B: 4F       [125]    	LD	C,A		; BC = Offset into table
1A2C: 09       [136]    	ADD	HL,BC		; Point to coefficient
1A2D: CDE616   [153]    	CALL	LOADFP		; Coefficient to BCDE
1A30: CD8C15   [170]    	CALL	FPMULT	;	; Multiply FPREG by coefficient
1A33: 3A5D80   [183]    	LD	A,(SEED+1)	; Get (SEED+1)
1A36: 3C       [187]    	INC	A		; Add 1
1A37: E603     [194]    	AND	00000011B	; 0 to 3
1A39: 0600     [201]    	LD	B,0
1A3B: FE01     [208]    	CP	1		; Is it zero?
1A3D: 88       [212]    	ADC	A,B		; Yes - Make it 1
1A3E: 325D80   [225]    	LD	(SEED+1),A	; Re-save seed
1A41: 21741A   [235]    	LD	HL,RNDTAB-4	; Addition table
1A44: 87       [239]    	ADD	A,A		; 4 bytes
1A45: 87       [243]    	ADD	A,A		; per entry
1A46: 4F       [247]    	LD	C,A		; BC = Offset into table
1A47: 09       [258]    	ADD	HL,BC		; Point to value
1A48: CD4214   [275]    	CALL	ADDPHL		; Add value to FPREG
1A4B: CDE316   [17]     RND1:	CALL	BCDEFP		; Move FPREG to BCDE
1A4E: 7B       [21]     	LD	A,E		; Get LSB
1A4F: 59       [25]     	LD	E,C		; LSB = MSB
1A50: EE4F     [32]     	XOR	01001111B	; Fiddle around
1A52: 4F       [36]     	LD	C,A		; New MSB
1A53: 3680     [46]     	LD	(HL),80H	; Set exponent
1A55: 2B       [52]     	DEC	HL		; Point to MSB
1A56: 46       [59]     	LD	B,(HL)		; Get MSB
1A57: 3680     [69]     	LD	(HL),80H	; Make value -0.5
1A59: 215C80   [79]     	LD	HL,SEED		; Random number seed
1A5C: 34       [90]     	INC	(HL)		; Count seed
1A5D: 7E       [97]     	LD	A,(HL)		; Get seed
1A5E: D6AB     [104]    	SUB	171		; Do it modulo 171
1A60: C2671A   [114|114]	JP	NZ,RND2		; Non-zero - Ok
1A63: 77       [121]    	LD	(HL),A		; Zero seed
1A64: 0C       [125]    	INC	C		; Fillde about
1A65: 15       [129]    	DEC	D		; with the
1A66: 1C       [133]    	INC	E		; number
1A67: CDA214   [17]     RND2:	CALL	BNORM		; Normalise number
1A6A: 217F80   [27]     	LD	HL,LSTRND	; Save random number
1A6D: C3EF16   [37]     	JP	FPTHL		; Move FPREG to last and return
                        ;
1A70: 77       [ 7]     RESEED: LD	(HL),A		; Re-seed random numbers
1A71: 2B       [13]     	DEC	HL
1A72: 77       [20]     	LD	(HL),A
1A73: 2B       [26]     	DEC	HL
1A74: 77       [33]     	LD	(HL),A
1A75: C34B1A   [43]     	JP	RND1		; Return RND seed
                        ;
1A78: 68B14668          RNDTAB: DB	068H,0B1H,046H,068H	; Table used by RND
1A7C: 99E99269          	DB	099H,0E9H,092H,069H
1A80: 10D17568          	DB	010H,0D1H,075H,068H
                        ;
1A84: 21CE1A   [10]     COS:	LD	HL,HALFPI	; Point to PI/2
1A87: CD4214   [27]     	CALL	ADDPHL		; Add it to PPREG
1A8A: CDC816   [17]     SIN:	CALL	STAKFP		; Put angle on stack
1A8D: 014983   [27]     	LD	BC,8349H	; BCDE = 2 PI
1A90: 11DB0F   [37]     	LD	DE,0FDBH
1A93: CDD816   [54]     	CALL	FPBCDE		; Move 2 PI to FPREG
1A96: C1       [64]     	POP	BC		; Restore angle
1A97: D1       [74]     	POP	DE
1A98: CDED15   [91]     	CALL	DVBCDE		; Divide angle by 2 PI
1A9B: CDC816   [108]    	CALL	STAKFP		; Put it on stack
1A9E: CD6A17   [125]    	CALL	INT		; Get INT of result
1AA1: C1       [135]    	POP	BC		; Restore number
1AA2: D1       [145]    	POP	DE
1AA3: CD4E14   [162]    	CALL	SUBCDE		; Make it 0 <= value < 1
1AA6: 21D21A   [172]    	LD	HL,QUARTR	; Point to 0.25
1AA9: CD4814   [189]    	CALL	SUBPHL		; Subtract value from 0.25
1AAC: CD9716   [206]    	CALL	TSTSGN		; Test sign of value
1AAF: 37       [210]    	SCF			; Flag positive
1AB0: F2BA1A   [220|220]	JP	P,SIN1		; Positive - Ok
1AB3: CD3F14   [237]    	CALL	ROUND		; Add 0.5 to value
1AB6: CD9716   [254]    	CALL	TSTSGN		; Test sign of value
1AB9: B7       [258]    	OR	A		; Flag negative
1ABA: F5       [11]     SIN1:	PUSH	AF		; Save sign
1ABB: F4C016   [21|28]  	CALL	P,INVSGN	; Negate value if positive
1ABE: 21D21A   [31]     	LD	HL,QUARTR	; Point to 0.25
1AC1: CD4214   [48]     	CALL	ADDPHL		; Add 0.25 to value
1AC4: F1       [58]     	POP	AF		; Restore sign
1AC5: D4C016   [68|75]  	CALL	NC,INVSGN	; Negative - Make positive
1AC8: 21D61A   [78]     	LD	HL,SINTAB	; Coefficient table
1ACB: C3DF19   [88]     	JP	SUMSER		; Evaluate sum of series
                        ;
1ACE: DB0F4981          HALFPI: DB	0DBH,00FH,049H,081H	; 1.5708 (PI/2)
                        ;
1AD2: 0000007F          QUARTR: DB	000H,000H,000H,07FH	; 0.25
                        ;
1AD6: 05                SINTAB: DB	5			; Table used by SIN
1AD7: BAD71E86          	DB	0BAH,0D7H,01EH,086H	; 39.711
1ADB: 64269987          	DB	064H,026H,099H,087H	;-76.575
1ADF: 58342387          	DB	058H,034H,023H,087H	; 81.602
1AE3: E05DA586          	DB	0E0H,05DH,0A5H,086H	;-41.342
1AE7: DA0F4983          	DB	0DAH,00FH,049H,083H	; 6.2832
                        ;
1AEB: CDC816   [17]     TAN:	CALL	STAKFP		; Put angle on stack
1AEE: CD8A1A   [34]     	CALL	SIN		; Get SIN of angle
1AF1: C1       [44]     	POP	BC		; Restore angle
1AF2: E1       [54]     	POP	HL
1AF3: CDC816   [71]     	CALL	STAKFP		; Save SIN of angle
1AF6: EB       [75]     	EX	DE,HL		; BCDE = Angle
1AF7: CDD816   [92]     	CALL	FPBCDE		; Angle to FPREG
1AFA: CD841A   [109]    	CALL	COS		; Get COS of angle
1AFD: C3EB15   [119]    	JP	DIV		; TAN = SIN / COS
                        ;
1B00: CD9716   [17]     ATN:	CALL	TSTSGN		; Test sign of value
1B03: FC2B19   [27|34]  	CALL	M,NEGAFT	; Negate result after if -ve
1B06: FCC016   [37|44]  	CALL	M,INVSGN	; Negate value if -ve
1B09: 3A2C81   [50]     	LD	A,(FPEXP)	; Get exponent
1B0C: FE81     [57]     	CP	81H		; Number less than 1?
1B0E: DA1D1B   [67|67]  	JP	C,ATN1		; Yes - Get arc tangnt
1B11: 010081   [77]     	LD	BC,8100H	; BCDE = 1
1B14: 51       [81]     	LD	D,C
1B15: 59       [85]     	LD	E,C
1B16: CDED15   [102]    	CALL	DVBCDE		; Get reciprocal of number
1B19: 214814   [112]    	LD	HL,SUBPHL	; Sub angle from PI/2
1B1C: E5       [123]    	PUSH	HL		; Save for angle > 1
1B1D: 21271B   [10]     ATN1:	LD	HL,ATNTAB	; Coefficient table
1B20: CDDF19   [27]     	CALL	SUMSER		; Evaluate sum of series
1B23: 21CE1A   [37]     	LD	HL,HALFPI	; PI/2 - angle in case > 1
1B26: C9       [47]     	RET			; Number > 1 - Sub from PI/2
                        ;
1B27: 09                ATNTAB: DB	9			; Table used by ATN
1B28: 4AD73B78          	DB	04AH,0D7H,03BH,078H	; 1/17
1B2C: 026E847B          	DB	002H,06EH,084H,07BH	;-1/15
1B30: FEC12F7C          	DB	0FEH,0C1H,02FH,07CH	; 1/13
1B34: 74319A7D          	DB	074H,031H,09AH,07DH	;-1/11
1B38: 843D5A7D          	DB	084H,03DH,05AH,07DH	; 1/9
1B3C: C87F917E          	DB	0C8H,07FH,091H,07EH	;-1/7
1B40: E4BB4C7E          	DB	0E4H,0BBH,04CH,07EH	; 1/5
1B44: 6CAAAA7F          	DB	06CH,0AAH,0AAH,07FH	;-1/3
1B48: 00000081          	DB	000H,000H,000H,081H	; 1/1
                        ;
                        
1B4C: C9       [10]     ARET:	RET			; A RETurn instruction
                        ;
1B4D: D7       [11]     GETINP: RST	10H		;input a character
1B4E: C9       [21]     	RET
                        ;
1B4F:                   CLS: 
1B4F: 3E0C     [ 7]     	LD	A,CS		; ASCII Clear screen
1B51: C3851C   [17]     	JP	MONOUT		; Output character
                        ;
1B54: CD1614   [17]     WIDTH:	CALL	GETINT		; Get integer 0-255
1B57: 7B       [21]     	LD	A,E		; Width to A
1B58: 328780   [34]     	LD	(LWIDTH),A	; Set width
1B5B: C9       [44]     	RET
                        ;
1B5C: CDB50C   [17]     LINES:	CALL	GETNUM		; Get a number
1B5F: CDFA08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B62: ED538B80 [54]     	LD	(LINESC),DE	; Set lines counter
1B66: ED538D80 [74]     	LD	(LINESN),DE	; Set lines number
1B6A: C9       [84]     	RET
                        ;
1B6B: CDFA08   [17]     DEEK:	CALL	DEINT		; Get integer -32768 to 32767
1B6E: D5       [28]     	PUSH	DE		; Save number
1B6F: E1       [38]     	POP	HL		; Number to HL
1B70: 46       [45]     	LD	B,(HL)		; Get LSB of contents
1B71: 23       [51]     	INC	HL
1B72: 7E       [58]     	LD	A,(HL)		; Get MSB of contents
1B73: C37010   [68]     	JP	ABPASS		; Return integer AB
                        ;
1B76: CDB50C   [17]     DOKE:	CALL	GETNUM		; Get a number
1B79: CDFA08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B7C: D5       [45]     	PUSH	DE		; Save address
1B7D: CDBE06   [62]     	CALL	CHKSYN		; Make sure ',' follows
1B80: 2C                	DB	','
1B81: CDB50C   [79]     	CALL	GETNUM		; Get a number
1B84: CDFA08   [96]     	CALL	DEINT		; Get integer -32768 to 32767
1B87: E3       [115]    	EX	(SP),HL		; Save value,get address
1B88: 73       [122]    	LD	(HL),E		; Save LSB of value
1B89: 23       [128]    	INC	HL
1B8A: 72       [135]    	LD	(HL),D		; Save MSB of value
1B8B: E1       [145]    	POP	HL		; Restore code string address
1B8C: C9       [155]    	RET
                        ;
                        
                        ; HEX$(nn) Convert 16 bit number to Hexadecimal string
                        ;
1B8D: CDB80C   [17]     HEX: 	CALL	TSTNUM		; Verify it's a number
1B90: CDFA08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1B93: C5       [45]     	PUSH	BC		; Save contents of BC
1B94: 212E81   [55]     	LD	HL,PBUFF
1B97: 7A       [59]     	LD	A,D		; Get high order into A
1B98: FE00     [66]     	CP	0
1B9A: 280C     [73|78]  	JR	Z,HEX2		; Skip output if both high digits are zero
1B9C: CDC51B   [90]     	CALL	BYT2ASC		; Convert D to ASCII
1B9F: 78       [94]     	LD	A,B
1BA0: FE30     [101]    	CP	'0'
1BA2: 2802     [108|113]	JR	Z,HEX1		; Don't store high digit if zero
1BA4: 70       [115]    	LD	(HL),B		; Store it to PBUFF
1BA5: 23       [121]    	INC	HL		; Next location
1BA6: 71       [ 7]     HEX1:	LD	(HL),C		; Store C to PBUFF+1
1BA7: 23       [13]     	INC	HL		; Next location
1BA8: 7B       [ 4]     HEX2:	LD	A,E		; Get lower byte
1BA9: CDC51B   [21]     	CALL	BYT2ASC		; Convert E to ASCII
1BAC: 7A       [25]     	LD	A,D
1BAD: FE00     [32]     	CP	0
1BAF: 2005     [39|44]  	JR	NZ,HEX3		; If upper byte was not zero then always print lower byte
1BB1: 78       [43]     	LD	A,B
1BB2: FE30     [50]     	CP	'0'		; If high digit of lower byte is zero then don't print
1BB4: 2802     [57|62]  	JR	Z,HEX4
1BB6: 70       [ 7]     HEX3:	LD	(HL),B		; to PBUFF+2
1BB7: 23       [13]     	INC	HL		; Next location
1BB8: 71       [ 7]     HEX4:	LD	(HL),C		; to PBUFF+3
1BB9: 23       [13]     	INC	HL		; PBUFF+4 to zero
1BBA: AF       [17]     	XOR	A		; Terminating character
1BBB: 77       [24]     	LD	(HL),A		; Store zero to terminate
1BBC: 23       [30]     	INC	HL		; Make sure PBUFF is terminated
1BBD: 77       [37]     	LD	(HL),A		; Store the double zero there
1BBE: C1       [47]     	POP	BC		; Get BC back
1BBF: 212E81   [57]     	LD	HL,PBUFF	; Reset to start of PBUFF
1BC2: C31E11   [67]     	JP	STR1		; Convert the PBUFF to a string and return it
                        ;
1BC5: 47       [ 4]     BYT2ASC	LD	B,A		; Save original value
1BC6: E60F     [11]     	AND	0FH		; Strip off upper nybble
1BC8: FE0A     [18]     	CP	0AH		; 0-9?
1BCA: 3802     [25|30]  	JR	C,ADD30		; If A-F, add 7 more
1BCC: C607     [32]     	ADD	A,07H		; Bring value up to ASCII A-F
1BCE: C630     [ 7]     ADD30	ADD	A,30H		; And make ASCII
1BD0: 4F       [11]     	LD	C,A		; Save converted char to C
1BD1: 78       [15]     	LD	A,B		; Retrieve original value
1BD2: 0F       [19]     	RRCA			; and Rotate it right
1BD3: 0F       [23]     	RRCA
1BD4: 0F       [27]     	RRCA
1BD5: 0F       [31]     	RRCA
1BD6: E60F     [38]     	AND	0FH		; Mask off upper nybble
1BD8: FE0A     [45]     	CP	0AH		; 0-9? < A hex?
1BDA: 3802     [52|57]  	JR	C,ADD301	; Skip Add 7
1BDC: C607     [59]     	ADD	A,07H		; Bring it up to ASCII A-F
1BDE: C630     [ 7]     ADD301	ADD	A,30H		; And make it full ASCII
1BE0: 47       [11]     	LD	B,A		; Store high order byte
1BE1: C9       [21]     	RET	
                        ;
                        ; Convert "&Hnnnn" to FPREG
                        ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
                        ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0-9
1BE2: EB       [ 4]     HEXTFP	EX	DE,HL		; Move code string pointer to DE
1BE3: 210000   [14]     	LD	HL,0000H	; Zero out the value
1BE6: CDFB1B   [31]     	CALL	GETHEX		; Check the number for valid hex
1BE9: DA1B1C   [41|41]  	JP	C,HXERR		; First value wasn't hex, HX error
1BEC: 1805     [53]     	JR	HEXLP1		; Convert first character
1BEE: CDFB1B   [17]     HEXLP	CALL	GETHEX		; Get second and addtional characters
1BF1: 381F     [24|29]  	JR	C,HEXIT		; Exit if not a hex character
1BF3: 29       [11]     HEXLP1	ADD	HL,HL		; Rotate 4 bits to the left
1BF4: 29       [22]     	ADD	HL,HL
1BF5: 29       [33]     	ADD	HL,HL
1BF6: 29       [44]     	ADD	HL,HL
1BF7: B5       [48]     	OR	L		; Add in D0-D3 into L
1BF8: 6F       [52]     	LD	L,A		; Save new value
1BF9: 18F3     [64]     	JR	HEXLP		; And continue until all hex characters are in
                        ;
1BFB: 13       [ 6]     GETHEX	INC	DE		; Next location
1BFC: 1A       [13]     	LD	A,(DE)		; Load character at pointer
1BFD: FE20     [20]     	CP	' '
1BFF: CAFB1B   [30|30]  	JP	Z,GETHEX	; Skip spaces
1C02: D630     [37]     	SUB	30H		; Get absolute value
1C04: D8       [42|48]  	RET	C		; < "0", error
1C05: FE0A     [49]     	CP	0AH
1C07: 3805     [56|61]  	JR	C,NOSUB7	; Is already in the range 0-9
1C09: D607     [63]     	SUB	07H		; Reduce to A-F
1C0B: FE0A     [70]     	CP	0AH		; Value should be $0A-$0F at this point
1C0D: D8       [75|81]  	RET	C		; CY set if was :		; < = > ? @
1C0E: FE10     [ 7]     NOSUB7	CP	10H		; > Greater than "F"?
1C10: 3F       [11]     	CCF
1C11: C9       [21]     	RET			; CY set if it wasn't valid hex
                        	
1C12: EB       [ 4]     HEXIT	EX	DE,HL		; Value into DE, Code string into HL
1C13: 7A       [ 8]     	LD	A,D		; Load DE into AC
1C14: 4B       [12]     	LD	C,E		; For prep to 
1C15: E5       [23]     	PUSH	HL
1C16: CD6F10   [40]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C19: E1       [50]     	POP	HL
1C1A: C9       [60]     	RET
                        ;
1C1B: 1E26     [ 7]     HXERR:	LD	E,HX		; ?HEX Error
1C1D: C30404   [17]     	JP	ERROR
                        ;
                        ; BIN$(NN) Convert integer to a 1-16 char binary string
1C20: CDB80C   [17]     BIN:	CALL	TSTNUM		; Verify it's a number
1C23: CDFA08   [34]     	CALL	DEINT		; Get integer -32768 to 32767
1C26: C5       [11]     BIN2:	PUSH	BC		; Save contents of BC
1C27: 212E81   [21]     	LD	HL,PBUFF
1C2A: 0611     [28]     	LD	B,17		; One higher than max char count
1C2C:                   ZEROSUP:			; Suppress leading zeros
1C2C: 05       [ 4]     	DEC	B		; Max 16 chars
1C2D: 78       [ 8]     	LD	A,B
1C2E: FE01     [15]     	CP	01H
1C30: 2808     [22|27]  	JR	Z,BITOUT	; Always output at least one character
1C32: CB13     [30]     	RL	E
1C34: CB12     [38]     	RL	D
1C36: 30F4     [45|50]  	JR	NC,ZEROSUP
1C38: 1804     [57]     	JR	BITOUT2
1C3A:                   BITOUT:	
1C3A: CB13     [ 8]     	RL	E
1C3C: CB12     [16]     	RL	D		; Top bit now in carry
1C3E:                   BITOUT2:
1C3E: 3E30     [ 7]     	LD	A,'0'		; Char for '0'
1C40: CE00     [14]     	ADC	A,0		; If carry set then '0' --> '1'
1C42: 77       [21]     	LD	(HL),A
1C43: 23       [27]     	INC	HL
1C44: 05       [31]     	DEC	B
1C45: 20F3     [38|43]  	JR	NZ,BITOUT
1C47: AF       [42]     	XOR	A		; Terminating character
1C48: 77       [49]     	LD	(HL),A		; Store zero to terminate
1C49: 23       [55]     	INC	HL		; Make sure PBUFF is terminated
1C4A: 77       [62]     	LD	(HL),A		; Store the double zero there
1C4B: C1       [72]     	POP	BC
1C4C: 212E81   [82]     	LD	HL,PBUFF
1C4F: C31E11   [92]     	JP	STR1
                        ;
                        ; Convert "&Bnnnn" to FPREG
                        ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
1C52: EB       [ 4]     BINTFP: EX	DE,HL		; Move code string pointer to DE
1C53: 210000   [14]     	LD	HL,0000H	; Zero out the value
1C56: CD6F1C   [31]     	CALL	CHKBIN		; Check the number for valid bin
1C59: DA7D1C   [41|41]  	JP	C,BINERR	; First value wasn't bin, HX error
1C5C: D630     [ 7]     BINIT:	SUB	'0'
1C5E: 29       [18]     	ADD	HL,HL		; Rotate HL left
1C5F: B5       [22]     	OR	L
1C60: 6F       [26]     	LD	L,A
1C61: CD6F1C   [43]     	CALL	CHKBIN		; Get second and addtional characters
1C64: 30F6     [50|55]  	JR	NC,BINIT	; Process if a bin character
1C66: EB       [54]     	EX	DE,HL		; Value into DE, Code string into HL
1C67: 7A       [58]     	LD	A,D		; Load DE into AC
1C68: 4B       [62]     	LD	C,E		; For prep to 
1C69: E5       [73]     	PUSH	HL
1C6A: CD6F10   [90]     	CALL	ACPASS		; ACPASS to set AC as integer into FPREG
1C6D: E1       [100]    	POP	HL
1C6E: C9       [110]    	RET
                        ;
                        ; Char is in A, NC if char is 0 or 1
1C6F: 13       [ 6]     CHKBIN: INC	DE
1C70: 1A       [13]     	LD	A,(DE)
1C71: FE20     [20]     	CP	' '
1C73: CA6F1C   [30|30]  	JP	Z,CHKBIN	; Skip spaces
1C76: FE30     [37]     	CP	'0'		; Set C if < '0'
1C78: D8       [42|48]  	RET	C
1C79: FE32     [49]     	CP	'2'
1C7B: 3F       [53]     	CCF			; Set C if > '1'
1C7C: C9       [63]     	RET
                        ;
1C7D: 1E28     [ 7]     BINERR: LD	E,BN		; ?BIN Error
1C7F: C30404   [17]     	JP	ERROR
                        ;
1C82: C34900   [10]     JJUMP1: JP	CSTART		; Go and initialise
                        ;
1C85: C30800   [10]     MONOUT: JP	0008H		; output a char
                        ;
1C88: C30000   [10]     MONITR: JP	0000H		; Restart (Normally Monitor Start)
                        ;
1C8B: 3E00     [ 7]     INITST: LD	A,0		; Clear break flag
1C8D: 329280   [20]     	LD	(BRKFLG),A
1C90: C35000   [30]     	JP	INIT
                        ;
1C93: F5       [11]     TSTBIT: PUSH	AF		; Save bit mask
1C94: A0       [15]     	AND	B		; Get common bits
1C95: C1       [25]     	POP	BC		; Restore bit mask
1C96: B8       [29]     	CP	B		; Same bit set?
1C97: 3E00     [36]     	LD	A,0		; Return 0 in A
1C99: C9       [46]     	RET
                        ;
1C9A: CDC906   [17]     OUTNCR: CALL	OUTC		; Output character in A
1C9D: C3F00A   [27]     	JP	PRCRLF		; Output CRLF
                        ;
                        	END


; +++ segments +++

#CODE          = $0000 =     0,  size = $1CA0 =  7328

; +++ global symbols +++

ABPASS  = $1070 =  4208          EMUZ80BASIC.ASM:2475
ABS     = $16BC =  5820          EMUZ80BASIC.ASM:3498
ACCSUM  = $08D9 =  2265          EMUZ80BASIC.ASM:1377 (unused)
ACPASS  = $106F =  4207          EMUZ80BASIC.ASM:2474
ADD30   = $1BCE =  7118          EMUZ80BASIC.ASM:4246
ADD301  = $1BDE =  7134          EMUZ80BASIC.ASM:4257
ADDEXP  = $1655 =  5717          EMUZ80BASIC.ASM:3433
ADDIG   = $17FB =  6139          EMUZ80BASIC.ASM:3721
ADDPHL  = $1442 =  5186          EMUZ80BASIC.ASM:3080
ALLFOL  = $133E =  4926          EMUZ80BASIC.ASM:2922
ANTVLU  = $0BD9 =  3033          EMUZ80BASIC.ASM:1784
ARET    = $1B4C =  6988          EMUZ80BASIC.ASM:4161 (unused)
ARLDSV  = $0F90 =  3984          EMUZ80BASIC.ASM:2330
ARREND  = $811F = 33055          EMUZ80BASIC.ASM:174
ARRLP   = $1209 =  4617          EMUZ80BASIC.ASM:2713
ASC     = $130F =  4879          EMUZ80BASIC.ASM:2892
ASCTFP  = $179E =  6046          EMUZ80BASIC.ASM:3667
ASPCS   = $0B3B =  2875          EMUZ80BASIC.ASM:1707
ATN     = $1B00 =  6912          EMUZ80BASIC.ASM:4132
ATN1    = $1B1D =  6941          EMUZ80BASIC.ASM:4144
ATNTAB  = $1B27 =  6951          EMUZ80BASIC.ASM:4149
ATOH    = $0914 =  2324          EMUZ80BASIC.ASM:1410
BADINP  = $0B60 =  2912          EMUZ80BASIC.ASM:1719
BAKSTK  = $0399 =   921          EMUZ80BASIC.ASM:585
BAKTMP  = $12EF =  4847          EMUZ80BASIC.ASM:2870
BASTXT  = $80A3 = 32931          EMUZ80BASIC.ASM:150
BCDEFP  = $16E3 =  5859          EMUZ80BASIC.ASM:3525
BFREE   = $00C9 =   201          EMUZ80BASIC.ASM:283
BIN     = $1C20 =  7200          EMUZ80BASIC.ASM:4306
BIN2    = $1C26 =  7206          EMUZ80BASIC.ASM:4308 (unused)
BINERR  = $1C7D =  7293          EMUZ80BASIC.ASM:4369
BINIT   = $1C5C =  7260          EMUZ80BASIC.ASM:4344
BINTFP  = $1C52 =  7250          EMUZ80BASIC.ASM:4340
BITOUT  = $1C3A =  7226          EMUZ80BASIC.ASM:4320
BITOUT2 = $1C3E =  7230          EMUZ80BASIC.ASM:4323
BKSP    = $0008 =     8          EMUZ80BASIC.ASM:107
BN      = $0028 =    40          EMUZ80BASIC.ASM:208
BNORM   = $14A2 =  5282          EMUZ80BASIC.ASM:3139
BNRMLP  = $14A5 =  5285          EMUZ80BASIC.ASM:3142
BRK     = $088B =  2187          EMUZ80BASIC.ASM:1332
BRKFLG  = $8092 = 32914          EMUZ80BASIC.ASM:143
BRKLIN  = $8113 = 33043          EMUZ80BASIC.ASM:168
BRKMSG  = $0393 =   915          EMUZ80BASIC.ASM:583
BRKRET  = $00BA =   186          EMUZ80BASIC.ASM:276
BS      = $0010 =    16          EMUZ80BASIC.ASM:196
BSERR   = $0FC3 =  4035          EMUZ80BASIC.ASM:2361
BUFFER  = $80A6 = 32934          EMUZ80BASIC.ASM:151
BYT2ASC = $1BC5 =  7109          EMUZ80BASIC.ASM:4241
BYTSFT  = $15DA =  5594          EMUZ80BASIC.ASM:3350
CFEVAL  = $0F26 =  3878          EMUZ80BASIC.ASM:2261
CHARTY  = $0ED4 =  3796          EMUZ80BASIC.ASM:2217
CHEKFN  = $1107 =  4359          EMUZ80BASIC.ASM:2566
CHKBIN  = $1C6F =  7279          EMUZ80BASIC.ASM:4359
CHKLTR  = $08E6 =  2278          EMUZ80BASIC.ASM:1386
CHKSTK  = $03CD =   973          EMUZ80BASIC.ASM:622
CHKSUM  = $808F = 32911          EMUZ80BASIC.ASM:141
CHKSYN  = $06BE =  1726          EMUZ80BASIC.ASM:1056
CHKTYP  = $0CBA =  3258          EMUZ80BASIC.ASM:1899
CHR     = $1320 =  4896          EMUZ80BASIC.ASM:2904
CLEAR   = $0939 =  2361          EMUZ80BASIC.ASM:1434
CLOTST  = $06F3 =  1779          EMUZ80BASIC.ASM:1088
CLREG   = $0522 =  1314          EMUZ80BASIC.ASM:828
CLRPTR  = $04FD =  1277          EMUZ80BASIC.ASM:808
CLS     = $1B4F =  6991          EMUZ80BASIC.ASM:4166
CMPFP   = $172C =  5932          EMUZ80BASIC.ASM:3583
CMPLG1  = $0E3A =  3642          EMUZ80BASIC.ASM:2123
CMPLOG  = $0E38 =  3640          EMUZ80BASIC.ASM:2122
CMPNUM  = $1712 =  5906          EMUZ80BASIC.ASM:3566
CMPRES  = $0E7C =  3708          EMUZ80BASIC.ASM:2171
CMPSTR  = $0E64 =  3684          EMUZ80BASIC.ASM:2151
CN      = $0020 =    32          EMUZ80BASIC.ASM:204
CNVNUM  = $17AA =  6058          EMUZ80BASIC.ASM:3673
COLD    = $003C =    60          EMUZ80BASIC.ASM:210
COMMAN  = $8088 = 32904          EMUZ80BASIC.ASM:136
COMPL   = $1502 =  5378          EMUZ80BASIC.ASM:3213
CONCAT  = $1284 =  4740          EMUZ80BASIC.ASM:2803
CONEXP  = $17DA =  6106          EMUZ80BASIC.ASM:3697
CONIO   = $0001 =     1          EMUZ80BASIC.ASM:20
CONPOS  = $149F =  5279          EMUZ80BASIC.ASM:3137
CONSTA  = $0000 =     0          EMUZ80BASIC.ASM:19
CONT    = $08BE =  2238          EMUZ80BASIC.ASM:1360
CONTAD  = $8119 = 33049          EMUZ80BASIC.ASM:171
CONVAR  = $0DA5 =  3493          EMUZ80BASIC.ASM:2023
COPY    = $0058 =    88          EMUZ80BASIC.ASM:224
COS     = $1A84 =  6788          EMUZ80BASIC.ASM:4080
COUNT   = $0763 =  1891          EMUZ80BASIC.ASM:1154
CPDEHL  = $06B8 =  1720          EMUZ80BASIC.ASM:1049
CPYLIT  = $05F4 =  1524          EMUZ80BASIC.ASM:946
CR      = $000D =    13          EMUZ80BASIC.ASM:110
CRARLP  = $0FE3 =  4067          EMUZ80BASIC.ASM:2381
CREARY  = $0FC8 =  4040          EMUZ80BASIC.ASM:2364
CRESTR  = $0A38 =  2616          EMUZ80BASIC.ASM:1573
CRNCLP  = $0555 =  1365          EMUZ80BASIC.ASM:854
CRTMST  = $1140 =  4416          EMUZ80BASIC.ASM:2599
CRTST   = $114C =  4428          EMUZ80BASIC.ASM:2610
CRTSTE  = $1162 =  4450          EMUZ80BASIC.ASM:2624
CRUNCH  = $054C =  1356          EMUZ80BASIC.ASM:850
CS      = $000C =    12          EMUZ80BASIC.ASM:109
CSTART  = $0049 =    73          EMUZ80BASIC.ASM:217
CTLOFG  = $808A = 32906          EMUZ80BASIC.ASM:138
CTRLC   = $0003 =     3          EMUZ80BASIC.ASM:105
CTRLG   = $0007 =     7          EMUZ80BASIC.ASM:106
CTRLO   = $000F =    15          EMUZ80BASIC.ASM:111
CTRLQ   = $0011 =    17          EMUZ80BASIC.ASM:112
CTRLR   = $0012 =    18          EMUZ80BASIC.ASM:113
CTRLS   = $0013 =    19          EMUZ80BASIC.ASM:114
CTRLU   = $0015 =    21          EMUZ80BASIC.ASM:115
CUROPR  = $810A = 33034          EMUZ80BASIC.ASM:162
CURPOS  = $80F0 = 33008          EMUZ80BASIC.ASM:153
DATA    = $09DF =  2527          EMUZ80BASIC.ASM:1525
DATFLG  = $80F3 = 33011          EMUZ80BASIC.ASM:156
DATLIN  = $810E = 33038          EMUZ80BASIC.ASM:164
DATSNR  = $03EA =  1002          EMUZ80BASIC.ASM:642
DCBCDE  = $1763 =  5987          EMUZ80BASIC.ASM:3626
DDERR   = $03F9 =  1017          EMUZ80BASIC.ASM:650
DEEK    = $1B6B =  7019          EMUZ80BASIC.ASM:4181
DEF     = $1084 =  4228          EMUZ80BASIC.ASM:2487
DEFSIZ  = $0FEB =  4075          EMUZ80BASIC.ASM:2385
DEINT   = $08FA =  2298          EMUZ80BASIC.ASM:1397
DEL     = $007F =   127          EMUZ80BASIC.ASM:117
DELCHR  = $0624 =  1572          EMUZ80BASIC.ASM:976
DEPINT  = $08F4 =  2292          EMUZ80BASIC.ASM:1395
DETHL4  = $16F2 =  5874          EMUZ80BASIC.ASM:3537
DETHLB  = $16F4 =  5876          EMUZ80BASIC.ASM:3538
DIGTXT  = $18A4 =  6308          EMUZ80BASIC.ASM:3819
DIM     = $0EA6 =  3750          EMUZ80BASIC.ASM:2197
DIMRET  = $0E9D =  3741          EMUZ80BASIC.ASM:2192
DINPOS  = $06ED =  1773          EMUZ80BASIC.ASM:1083
DIV     = $15EB =  5611          EMUZ80BASIC.ASM:3361
DIV1    = $804F = 32847          EMUZ80BASIC.ASM:126
DIV10   = $15DF =  5599          EMUZ80BASIC.ASM:3356
DIV2    = $8053 = 32851          EMUZ80BASIC.ASM:127
DIV3    = $8057 = 32855          EMUZ80BASIC.ASM:128
DIV4    = $805A = 32858          EMUZ80BASIC.ASM:129
DIVLP   = $1612 =  5650          EMUZ80BASIC.ASM:3385
DIVSUP  = $804E = 32846          EMUZ80BASIC.ASM:125
DOAGN   = $053B =  1339          EMUZ80BASIC.ASM:841
DOCOM   = $0B0C =  2828          EMUZ80BASIC.ASM:1683
DODEL   = $0604 =  1540          EMUZ80BASIC.ASM:960
DOEBIT  = $18E4 =  6372          EMUZ80BASIC.ASM:3862
DOFN    = $10B1 =  4273          EMUZ80BASIC.ASM:2515
DOKE    = $1B76 =  7030          EMUZ80BASIC.ASM:4189
DONULL  = $0AFA =  2810          EMUZ80BASIC.ASM:1672
DOSPC   = $0B36 =  2870          EMUZ80BASIC.ASM:1704
DOTAB   = $0B23 =  2851          EMUZ80BASIC.ASM:1694
DPOINT  = $17D6 =  6102          EMUZ80BASIC.ASM:3695
DTSTR   = $1150 =  4432          EMUZ80BASIC.ASM:2613
DVBCDE  = $15ED =  5613          EMUZ80BASIC.ASM:3363
DZ      = $0014 =    20          EMUZ80BASIC.ASM:198
DZERR   = $03F3 =  1011          EMUZ80BASIC.ASM:646
ECHDEL  = $0618 =  1560          EMUZ80BASIC.ASM:969
EDIGIT  = $181D =  6173          EMUZ80BASIC.ASM:3744
ENDBUF  = $05FB =  1531          EMUZ80BASIC.ASM:952
ENDCON  = $17E9 =  6121          EMUZ80BASIC.ASM:3707
ENDDIM  = $104A =  4170          EMUZ80BASIC.ASM:2454
ENDINP  = $0AEB =  2795          EMUZ80BASIC.ASM:1666
ENDNAM  = $0EC8 =  3784          EMUZ80BASIC.ASM:2213
ENDPRG  = $089A =  2202          EMUZ80BASIC.ASM:1343
ENFMEM  = $03D6 =   982          EMUZ80BASIC.ASM:628
ERRIN   = $0424 =  1060          EMUZ80BASIC.ASM:671
ERRLIN  = $8117 = 33047          EMUZ80BASIC.ASM:170
ERRMSG  = $0381 =   897          EMUZ80BASIC.ASM:579
ERROR   = $0404 =  1028          EMUZ80BASIC.ASM:658
ERRORS  = $02F7 =   759          EMUZ80BASIC.ASM:508
ESC     = $001B =    27          EMUZ80BASIC.ASM:116
EVAL    = $0CC7 =  3271          EMUZ80BASIC.ASM:1907
EVAL1   = $0CCA =  3274          EMUZ80BASIC.ASM:1909
EVAL2   = $0CD3 =  3283          EMUZ80BASIC.ASM:1913
EVAL3   = $0CD6 =  3286          EMUZ80BASIC.ASM:1914
EVLPAR  = $0D8C =  3468          EMUZ80BASIC.ASM:2009
EVNOT   = $0E86 =  3718          EMUZ80BASIC.ASM:2179
EXCUTE  = $0828 =  2088          EMUZ80BASIC.ASM:1265
EXP     = $197E =  6526          EMUZ80BASIC.ASM:3949
EXPLP   = $17C8 =  6088          EMUZ80BASIC.ASM:3687
EXPTAB  = $19BE =  6590          EMUZ80BASIC.ASM:3977
EXPTEN  = $18F6 =  6390          EMUZ80BASIC.ASM:3872
EXTIG   = $0C35 =  3125          EMUZ80BASIC.ASM:1832
FANDT   = $0C5F =  3167          EMUZ80BASIC.ASM:1850
FC      = $0008 =     8          EMUZ80BASIC.ASM:192
FCERR   = $090F =  2319          EMUZ80BASIC.ASM:1407
FDTLP   = $0C46 =  3142          EMUZ80BASIC.ASM:1834
FINDEL  = $1026 =  4134          EMUZ80BASIC.ASM:2426
FLGDIF  = $16A2 =  5794          EMUZ80BASIC.ASM:3481
FLGREL  = $16A9 =  5801          EMUZ80BASIC.ASM:3487
FNARG   = $8125 = 33061          EMUZ80BASIC.ASM:177
FNCTAB  = $0141 =   321          EMUZ80BASIC.ASM:294
FNDARY  = $0F96 =  3990          EMUZ80BASIC.ASM:2334
FNDELP  = $102B =  4139          EMUZ80BASIC.ASM:2431
FNDEND  = $04D0 =  1232          EMUZ80BASIC.ASM:771
FNDNUM  = $1413 =  5139          EMUZ80BASIC.ASM:3054
FNDTOK  = $0742 =  1858          EMUZ80BASIC.ASM:1134
FNDVAR  = $0F0D =  3853          EMUZ80BASIC.ASM:2245
FNDWRD  = $057F =  1407          EMUZ80BASIC.ASM:874
FNOFST  = $0DB6 =  3510          EMUZ80BASIC.ASM:2033
FNRGNM  = $8123 = 33059          EMUZ80BASIC.ASM:176
FNTHR   = $0F1B =  3867          EMUZ80BASIC.ASM:2253
FNVAL   = $0DDD =  3549          EMUZ80BASIC.ASM:2055
FOPRND  = $0CFF =  3327          EMUZ80BASIC.ASM:1935
FOR     = $078F =  1935          EMUZ80BASIC.ASM:1176
FORFLG  = $8110 = 33040          EMUZ80BASIC.ASM:165
FORFND  = $07BF =  1983          EMUZ80BASIC.ASM:1204
FORSLP  = $07A3 =  1955          EMUZ80BASIC.ASM:1185
FPADD   = $1451 =  5201          EMUZ80BASIC.ASM:3088
FPBCDE  = $16D8 =  5848          EMUZ80BASIC.ASM:3517
FPEXP   = $812C = 33068          EMUZ80BASIC.ASM:179
FPINT   = $173F =  5951          EMUZ80BASIC.ASM:3603
FPMULT  = $158C =  5516          EMUZ80BASIC.ASM:3299
FPREG   = $8129 = 33065          EMUZ80BASIC.ASM:178
FPROND  = $14E9 =  5353          EMUZ80BASIC.ASM:3189
FPSINT  = $08EE =  2286          EMUZ80BASIC.ASM:1393
FPTHL   = $16EF =  5871          EMUZ80BASIC.ASM:3536
FRE     = $104E =  4174          EMUZ80BASIC.ASM:2457
FRENUM  = $106A =  4202          EMUZ80BASIC.ASM:2469
FRMEVL  = $0DA8 =  3496          EMUZ80BASIC.ASM:2024
GARBGE  = $11D1 =  4561          EMUZ80BASIC.ASM:2686
GARBLP  = $11D4 =  4564          EMUZ80BASIC.ASM:2687
GETCHR  = $0848 =  2120          EMUZ80BASIC.ASM:1285
GETCMD  = $0448 =  1096          EMUZ80BASIC.ASM:688
GETHEX  = $1BFB =  7163          EMUZ80BASIC.ASM:4279
GETINP  = $1B4D =  6989          EMUZ80BASIC.ASM:4163
GETINT  = $1416 =  5142          EMUZ80BASIC.ASM:3055
GETLEN  = $1304 =  4868          EMUZ80BASIC.ASM:2884
GETLIN  = $0635 =  1589          EMUZ80BASIC.ASM:984
GETLN   = $0915 =  2325          EMUZ80BASIC.ASM:1411
GETNUM  = $0CB5 =  3253          EMUZ80BASIC.ASM:1896
GETNXT  = $059A =  1434          EMUZ80BASIC.ASM:889
GETSTR  = $12CE =  4814          EMUZ80BASIC.ASM:2850
GETVAR  = $0EAB =  3755          EMUZ80BASIC.ASM:2200
GNXARY  = $1208 =  4616          EMUZ80BASIC.ASM:2712
GOFUNC  = $0DE5 =  3557          EMUZ80BASIC.ASM:2059
GOSUB   = $098B =  2443          EMUZ80BASIC.ASM:1476
GOTO    = $099C =  2460          EMUZ80BASIC.ASM:1488
GRBARY  = $1228 =  4648          EMUZ80BASIC.ASM:2731
GRBDON  = $11A9 =  4521          EMUZ80BASIC.ASM:2661
GRBLP   = $11E2 =  4578          EMUZ80BASIC.ASM:2693
GSTRCU  = $12D1 =  4817          EMUZ80BASIC.ASM:2851
GSTRDE  = $12D5 =  4821          EMUZ80BASIC.ASM:2853
GSTRHL  = $12D4 =  4820          EMUZ80BASIC.ASM:2852
GTFLNM  = $1313 =  4883          EMUZ80BASIC.ASM:2894 (unused)
GTFNAM  = $0EB0 =  3760          EMUZ80BASIC.ASM:2203
GTLNLP  = $0918 =  2328          EMUZ80BASIC.ASM:1412
GTSIXD  = $186E =  6254          EMUZ80BASIC.ASM:3788
GTVLUS  = $0BB1 =  2993          EMUZ80BASIC.ASM:1762
HALF    = $1915 =  6421          EMUZ80BASIC.ASM:3893
HALFPI  = $1ACE =  6862          EMUZ80BASIC.ASM:4111
HEX     = $1B8D =  7053          EMUZ80BASIC.ASM:4206
HEX1    = $1BA6 =  7078          EMUZ80BASIC.ASM:4219
HEX2    = $1BA8 =  7080          EMUZ80BASIC.ASM:4221
HEX3    = $1BB6 =  7094          EMUZ80BASIC.ASM:4229
HEX4    = $1BB8 =  7096          EMUZ80BASIC.ASM:4231
HEXIT   = $1C12 =  7186          EMUZ80BASIC.ASM:4294
HEXLP   = $1BEE =  7150          EMUZ80BASIC.ASM:4269
HEXLP1  = $1BF3 =  7155          EMUZ80BASIC.ASM:4271
HEXTFP  = $1BE2 =  7138          EMUZ80BASIC.ASM:4264
HX      = $0026 =    38          EMUZ80BASIC.ASM:207
HXERR   = $1C1B =  7195          EMUZ80BASIC.ASM:4302
ID      = $0016 =    22          EMUZ80BASIC.ASM:199
IDTEST  = $10F9 =  4345          EMUZ80BASIC.ASM:2556
IF      = $0A6E =  2670          EMUZ80BASIC.ASM:1606
IFGO    = $0A7C =  2684          EMUZ80BASIC.ASM:1613
IFJMP   = $082F =  2095          EMUZ80BASIC.ASM:1268
INCHL   = $16ED =  5869          EMUZ80BASIC.ASM:3533
INCLEN  = $06E9 =  1769          EMUZ80BASIC.ASM:1081
INDFND  = $03B3 =   947          EMUZ80BASIC.ASM:604
INEWLN  = $0498 =  1176          EMUZ80BASIC.ASM:731
INIT    = $0050 =    80          EMUZ80BASIC.ASM:221
INITAB  = $0321 =   801          EMUZ80BASIC.ASM:532
INITBE  = $0381 =   897          EMUZ80BASIC.ASM:575
INITST  = $1C8B =  7307          EMUZ80BASIC.ASM:4378
INMSG   = $0388 =   904          EMUZ80BASIC.ASM:580
INP     = $13D3 =  5075          EMUZ80BASIC.ASM:3023
INPBIN  = $0C03 =  3075          EMUZ80BASIC.ASM:1806
INPBRK  = $0897 =  2199          EMUZ80BASIC.ASM:1341
INPORT  = $8084 = 32900          EMUZ80BASIC.ASM:133
INPSUB  = $8083 = 32899          EMUZ80BASIC.ASM:132
INPUT   = $0B71 =  2929          EMUZ80BASIC.ASM:1727
INRNG   = $1877 =  6263          EMUZ80BASIC.ASM:3793
INT     = $176A =  5994          EMUZ80BASIC.ASM:3634
INTVAR  = $050C =  1292          EMUZ80BASIC.ASM:819
INVSGN  = $16C0 =  5824          EMUZ80BASIC.ASM:3500
ITMSEP  = $0BF4 =  3060          EMUZ80BASIC.ASM:1797
JJUMP1  = $1C82 =  7298          EMUZ80BASIC.ASM:4372 (unused)
JSTZER  = $1900 =  6400          EMUZ80BASIC.ASM:3878
KBHIT   = $002B =    43          EMUZ80BASIC.ASM:57
KILFOR  = $0CA5 =  3237          EMUZ80BASIC.ASM:1887
KILIN   = $062F =  1583          EMUZ80BASIC.ASM:981
LCRFLG  = $80F1 = 33009          EMUZ80BASIC.ASM:154
LEFT    = $1330 =  4912          EMUZ80BASIC.ASM:2912
LEN     = $1300 =  4864          EMUZ80BASIC.ASM:2882
LET     = $09F6 =  2550          EMUZ80BASIC.ASM:1541
LETNUM  = $0A49 =  2633          EMUZ80BASIC.ASM:1583
LETSTR  = $0A11 =  2577          EMUZ80BASIC.ASM:1554
LF      = $000A =    10          EMUZ80BASIC.ASM:108
LFRGNM  = $13C9 =  5065          EMUZ80BASIC.ASM:3014
LINEAT  = $80A1 = 32929          EMUZ80BASIC.ASM:149
LINEIN  = $1829 =  6185          EMUZ80BASIC.ASM:3754
LINES   = $1B5C =  7004          EMUZ80BASIC.ASM:4175
LINESC  = $808B = 32907          EMUZ80BASIC.ASM:139
LINESN  = $808D = 32909          EMUZ80BASIC.ASM:140
LINFND  = $0481 =  1153          EMUZ80BASIC.ASM:717
LIST    = $0704 =  1796          EMUZ80BASIC.ASM:1098
LISTLP  = $0710 =  1808          EMUZ80BASIC.ASM:1104
LOADFP  = $16E6 =  5862          EMUZ80BASIC.ASM:3526
LOG     = $154B =  5451          EMUZ80BASIC.ASM:3267
LOGTAB  = $153E =  5438          EMUZ80BASIC.ASM:3262
LOKFOR  = $039D =   925          EMUZ80BASIC.ASM:587
LOOPST  = $810C = 33036          EMUZ80BASIC.ASM:163
LS      = $001C =    28          EMUZ80BASIC.ASM:202
LSTBIN  = $8111 = 33041          EMUZ80BASIC.ASM:166
LSTLP2  = $0730 =  1840          EMUZ80BASIC.ASM:1125
LSTLP3  = $0733 =  1843          EMUZ80BASIC.ASM:1126
LSTRAM  = $80F4 = 33012          EMUZ80BASIC.ASM:157
LSTRND  = $807F = 32895          EMUZ80BASIC.ASM:131
LTSTND  = $0C0E =  3086          EMUZ80BASIC.ASM:1811
LWIDTH  = $8087 = 32903          EMUZ80BASIC.ASM:135
MAKINT  = $1419 =  5145          EMUZ80BASIC.ASM:3056
MAKNUM  = $1893 =  6291          EMUZ80BASIC.ASM:3808
MANLP   = $17B2 =  6066          EMUZ80BASIC.ASM:3679
MATCH   = $05CC =  1484          EMUZ80BASIC.ASM:921
MEMMSG  = $010F =   271          EMUZ80BASIC.ASM:289
MID     = $136A =  4970          EMUZ80BASIC.ASM:2952
MID1    = $1336 =  4918          EMUZ80BASIC.ASM:2916
MIDNUM  = $13CE =  5070          EMUZ80BASIC.ASM:3017
MINCDE  = $1491 =  5265          EMUZ80BASIC.ASM:3123
MINUS   = $0D94 =  3476          EMUZ80BASIC.ASM:2014
MKTMST  = $113D =  4413          EMUZ80BASIC.ASM:2598
MLDBLP  = $178B =  6027          EMUZ80BASIC.ASM:3655
MLDEBC  = $1783 =  6019          EMUZ80BASIC.ASM:3650
MLOOP   = $0070 =   112          EMUZ80BASIC.ASM:236
MLSP10  = $1680 =  5760          EMUZ80BASIC.ASM:3461
MO      = $0024 =    36          EMUZ80BASIC.ASM:206
MONITR  = $1C88 =  7304          EMUZ80BASIC.ASM:4376
MONOUT  = $1C85 =  7301          EMUZ80BASIC.ASM:4374
MORDT   = $0C1A =  3098          EMUZ80BASIC.ASM:1816
MORINP  = $063E =  1598          EMUZ80BASIC.ASM:989
MOVBUF  = $04B7 =  1207          EMUZ80BASIC.ASM:752
MOVDIR  = $05D4 =  1492          EMUZ80BASIC.ASM:929
MOVLP   = $03C2 =   962          EMUZ80BASIC.ASM:614
MOVSTR  = $03BF =   959          EMUZ80BASIC.ASM:611
MOVUP   = $03BC =   956          EMUZ80BASIC.ASM:610
MRPRNT  = $0A8E =  2702          EMUZ80BASIC.ASM:1620
MSIZE   = $006D =   109          EMUZ80BASIC.ASM:235 (unused)
MUL8LP  = $15B7 =  5559          EMUZ80BASIC.ASM:3322
MULLN2  = $1583 =  5507          EMUZ80BASIC.ASM:3293
MULT    = $158A =  5514          EMUZ80BASIC.ASM:3297
MULT8   = $15AE =  5550          EMUZ80BASIC.ASM:3316
MULTEN  = $17F4 =  6132          EMUZ80BASIC.ASM:3715
MULVAL  = $813B = 33083          EMUZ80BASIC.ASM:182
MVSTPT  = $0A40 =  2624          EMUZ80BASIC.ASM:1577
NEDMOR  = $0BAD =  2989          EMUZ80BASIC.ASM:1760
NEGAFT  = $192B =  6443          EMUZ80BASIC.ASM:3902
NEMEM   = $00C0 =   192          EMUZ80BASIC.ASM:279
NEW     = $04FC =  1276          EMUZ80BASIC.ASM:807
NEXITM  = $0B46 =  2886          EMUZ80BASIC.ASM:1713
NEXT    = $0C6A =  3178          EMUZ80BASIC.ASM:1855
NEXT1   = $0C6D =  3181          EMUZ80BASIC.ASM:1856
NF      = $0000 =     0          EMUZ80BASIC.ASM:188
NFERR   = $03F6 =  1014          EMUZ80BASIC.ASM:648
NMIFLG  = $8091 = 32913          EMUZ80BASIC.ASM:142 (unused)
NOCHNG  = $05C4 =  1476          EMUZ80BASIC.ASM:916
NOENED  = $1903 =  6403          EMUZ80BASIC.ASM:3881
NOLIN   = $08AD =  2221          EMUZ80BASIC.ASM:1352
NOMADD  = $15C8 =  5576          EMUZ80BASIC.ASM:3333
NOMLAD  = $1799 =  6041          EMUZ80BASIC.ASM:3663
NOPMPT  = $0B8B =  2955          EMUZ80BASIC.ASM:1739
NORMAL  = $14BC =  5308          EMUZ80BASIC.ASM:3158
NOSPC   = $05BB =  1467          EMUZ80BASIC.ASM:911
NOSUB7  = $1C0E =  7182          EMUZ80BASIC.ASM:4290
NOSWAP  = $146B =  5227          EMUZ80BASIC.ASM:3104
NOTAMP  = $0D69 =  3433          EMUZ80BASIC.ASM:1995
NOTSTR  = $0EE3 =  3811          EMUZ80BASIC.ASM:2225
NOXOR   = $13F9 =  5113          EMUZ80BASIC.ASM:3040
NSCFOR  = $0EF3 =  3827          EMUZ80BASIC.ASM:2233
NULFLG  = $8089 = 32905          EMUZ80BASIC.ASM:137
NULL    = $08D1 =  2257          EMUZ80BASIC.ASM:1371
NULLP   = $0B01 =  2817          EMUZ80BASIC.ASM:1675
NULLS   = $8086 = 32902          EMUZ80BASIC.ASM:134
NUMASC  = $183C =  6204          EMUZ80BASIC.ASM:3764
NXTARY  = $0FAA =  4010          EMUZ80BASIC.ASM:2346
NXTBYT  = $05AA =  1450          EMUZ80BASIC.ASM:901
NXTCHR  = $05EB =  1515          EMUZ80BASIC.ASM:941
NXTDAT  = $8121 = 33057          EMUZ80BASIC.ASM:175
NXTDTA  = $09DE =  2526          EMUZ80BASIC.ASM:1523
NXTITM  = $0BA5 =  2981          EMUZ80BASIC.ASM:1755
NXTOPR  = $8115 = 33045          EMUZ80BASIC.ASM:169
NXTSTL  = $09E5 =  2533          EMUZ80BASIC.ASM:1528
NXTSTT  = $09E8 =  2536          EMUZ80BASIC.ASM:1531
OD      = $0006 =     6          EMUZ80BASIC.ASM:191
OKMSG   = $038D =   909          EMUZ80BASIC.ASM:582
OM      = $000C =    12          EMUZ80BASIC.ASM:194
OMERR   = $03E5 =   997          EMUZ80BASIC.ASM:639
ON      = $0A50 =  2640          EMUZ80BASIC.ASM:1589
ONGO    = $0A5F =  2655          EMUZ80BASIC.ASM:1597
ONGOLP  = $0A60 =  2656          EMUZ80BASIC.ASM:1598
ONJMP   = $0830 =  2096          EMUZ80BASIC.ASM:1269
OPNPAR  = $0CC3 =  3267          EMUZ80BASIC.ASM:1905
OPRND   = $0D3E =  3390          EMUZ80BASIC.ASM:1978
OS      = $001A =    26          EMUZ80BASIC.ASM:201
OTKLN   = $062C =  1580          EMUZ80BASIC.ASM:980
OTPORT  = $804C = 32844          EMUZ80BASIC.ASM:124
OUTC    = $06C9 =  1737          EMUZ80BASIC.ASM:1064
OUTEXP  = $18F4 =  6388          EMUZ80BASIC.ASM:3871
OUTIT   = $06AA =  1706          EMUZ80BASIC.ASM:1042
OUTNBS  = $06B0 =  1712          EMUZ80BASIC.ASM:1045
OUTNCR  = $1C9A =  7322          EMUZ80BASIC.ASM:4389
OUTSUB  = $804B = 32843          EMUZ80BASIC.ASM:123
OUTWRD  = $074C =  1868          EMUZ80BASIC.ASM:1140
OV      = $000A =    10          EMUZ80BASIC.ASM:193
OVERR   = $03FF =  1023          EMUZ80BASIC.ASM:654
OVTST1  = $1673 =  5747          EMUZ80BASIC.ASM:3453
OVTST2  = $1678 =  5752          EMUZ80BASIC.ASM:3456
OVTST3  = $1679 =  5753          EMUZ80BASIC.ASM:3457
PADD    = $1818 =  6168          EMUZ80BASIC.ASM:3740
PAND    = $0DFF =  3583          EMUZ80BASIC.ASM:2081
PASSA   = $107F =  4223          EMUZ80BASIC.ASM:2483
PBUFF   = $812E = 33070          EMUZ80BASIC.ASM:181
PEEK    = $1427 =  5159          EMUZ80BASIC.ASM:3065
PEND    = $0892 =  2194          EMUZ80BASIC.ASM:1338
PHLTFP  = $16D5 =  5845          EMUZ80BASIC.ASM:3516
PLUCDE  = $14F6 =  5366          EMUZ80BASIC.ASM:3200
PNORM   = $14C4 =  5316          EMUZ80BASIC.ASM:3166
POINT   = $8096 = 32918          EMUZ80BASIC.ASM:145
POKE    = $142E =  5166          EMUZ80BASIC.ASM:3069
POPAF   = $11C3 =  4547          EMUZ80BASIC.ASM:2676
POPHL   = $12ED =  4845          EMUZ80BASIC.ASM:2867
POPHRT  = $15D8 =  5592          EMUZ80BASIC.ASM:3347
POPNOK  = $043A =  1082          EMUZ80BASIC.ASM:681
POR     = $0DFE =  3582          EMUZ80BASIC.ASM:2080
POR1    = $0E21 =  3617          EMUZ80BASIC.ASM:2104
POS     = $107C =  4220          EMUZ80BASIC.ASM:2482
POSINT  = $08F1 =  2289          EMUZ80BASIC.ASM:1394
POUT    = $13DF =  5087          EMUZ80BASIC.ASM:3028
POWER   = $1939 =  6457          EMUZ80BASIC.ASM:3910
POWER1  = $1949 =  6473          EMUZ80BASIC.ASM:3918
POWER2  = $1966 =  6502          EMUZ80BASIC.ASM:3936
POWERS  = $1919 =  6425          EMUZ80BASIC.ASM:3895
PRCRLF  = $0AF0 =  2800          EMUZ80BASIC.ASM:1668
PRINT   = $0A92 =  2706          EMUZ80BASIC.ASM:1622
PRITAB  = $02E2 =   738          EMUZ80BASIC.ASM:485
PRNTHL  = $1831 =  6193          EMUZ80BASIC.ASM:3758
PRNTLP  = $0A95 =  2709          EMUZ80BASIC.ASM:1623
PRNTNB  = $0AD8 =  2776          EMUZ80BASIC.ASM:1655
PRNTOK  = $043B =  1083          EMUZ80BASIC.ASM:683
PRNTST  = $0ADC =  2780          EMUZ80BASIC.ASM:1657
PRNUMS  = $118D =  4493          EMUZ80BASIC.ASM:2645
PROCES  = $0657 =  1623          EMUZ80BASIC.ASM:1000
PROGND  = $811B = 33051          EMUZ80BASIC.ASM:172
PROGST  = $813E = 33086          EMUZ80BASIC.ASM:183
PROMPT  = $053F =  1343          EMUZ80BASIC.ASM:844
PRS     = $118E =  4494          EMUZ80BASIC.ASM:2646
PRS1    = $1191 =  4497          EMUZ80BASIC.ASM:2647
PRSLP   = $1198 =  4504          EMUZ80BASIC.ASM:2650
PSET    = $8099 = 32921          EMUZ80BASIC.ASM:146
PSUB    = $144C =  5196          EMUZ80BASIC.ASM:3085
PTRLP   = $04C4 =  1220          EMUZ80BASIC.ASM:761
PUTBUF  = $0696 =  1686          EMUZ80BASIC.ASM:1031
PUTCTL  = $069B =  1691          EMUZ80BASIC.ASM:1033
PUTFID  = $0804 =  2052          EMUZ80BASIC.ASM:1242
QTSTLP  = $1153 =  4435          EMUZ80BASIC.ASM:2615
QTSTR   = $114D =  4429          EMUZ80BASIC.ASM:2611
QUARTR  = $1AD2 =  6866          EMUZ80BASIC.ASM:4113
RD      = $0012 =    18          EMUZ80BASIC.ASM:197
READ    = $0BA0 =  2976          EMUZ80BASIC.ASM:1752
READFG  = $8112 = 33042          EMUZ80BASIC.ASM:167
REDO    = $0B4D =  2893          EMUZ80BASIC.ASM:1717
REM     = $09E1 =  2529          EMUZ80BASIC.ASM:1526
RESDIV  = $1625 =  5669          EMUZ80BASIC.ASM:3398
RESEED  = $1A70 =  6768          EMUZ80BASIC.ASM:4069
RESET   = $809C = 32924          EMUZ80BASIC.ASM:147
RESTNL  = $086D =  2157          EMUZ80BASIC.ASM:1308
RESTOR  = $0858 =  2136          EMUZ80BASIC.ASM:1297
RESZER  = $14B7 =  5303          EMUZ80BASIC.ASM:3154
RETADR  = $0F5A =  3930          EMUZ80BASIC.ASM:2293
RETINT  = $16AE =  5806          EMUZ80BASIC.ASM:3489
RETLIN  = $09D9 =  2521          EMUZ80BASIC.ASM:1520
RETNAD  = $05D0 =  1488          EMUZ80BASIC.ASM:925
RETNUL  = $0F5D =  3933          EMUZ80BASIC.ASM:2297
RETNUM  = $0DA0 =  3488          EMUZ80BASIC.ASM:2019
RETREL  = $16A0 =  5792          EMUZ80BASIC.ASM:3479
RETURN  = $09BA =  2490          EMUZ80BASIC.ASM:1504
RG      = $0004 =     4          EMUZ80BASIC.ASM:190
RIGHT   = $1360 =  4960          EMUZ80BASIC.ASM:2945
RIGHT1  = $1334 =  4916          EMUZ80BASIC.ASM:2914
RINPUT  = $8093 = 32915          EMUZ80BASIC.ASM:144
RLTLP   = $0CE3 =  3299          EMUZ80BASIC.ASM:1921
RND     = $1A0F =  6671          EMUZ80BASIC.ASM:4016
RND1    = $1A4B =  6731          EMUZ80BASIC.ASM:4047
RND2    = $1A67 =  6759          EMUZ80BASIC.ASM:4065
RNDTAB  = $1A78 =  6776          EMUZ80BASIC.ASM:4076
RNGTST  = $1906 =  6406          EMUZ80BASIC.ASM:3885
ROMTOP  = $0000 =     0          EMUZ80BASIC.ASM:10
RONDB   = $14D8 =  5336          EMUZ80BASIC.ASM:3178
RONDUP  = $14D7 =  5335          EMUZ80BASIC.ASM:3177
ROUND   = $143F =  5183          EMUZ80BASIC.ASM:3079
RSCALE  = $1812 =  6162          EMUZ80BASIC.ASM:3738
RSLNBK  = $0786 =  1926          EMUZ80BASIC.ASM:1172
RSTSTR  = $1383 =  4995          EMUZ80BASIC.ASM:2965
RUN     = $097F =  2431          EMUZ80BASIC.ASM:1471
RUNCNT  = $0808 =  2056          EMUZ80BASIC.ASM:1246
RUNFST  = $0508 =  1288          EMUZ80BASIC.ASM:816
RUNLIN  = $099B =  2459          EMUZ80BASIC.ASM:1487
RXA     = $001B =    27          EMUZ80BASIC.ASM:41
SAVEXP  = $14B8 =  5304          EMUZ80BASIC.ASM:3155
SAVSTP  = $07FB =  2043          EMUZ80BASIC.ASM:1235
SAVSTR  = $1128 =  4392          EMUZ80BASIC.ASM:2582
SBSCPT  = $0F68 =  3944          EMUZ80BASIC.ASM:2303
SCALE   = $1516 =  5398          EMUZ80BASIC.ASM:3232
SCALLP  = $1518 =  5400          EMUZ80BASIC.ASM:3233
SCALMI  = $17DD =  6109          EMUZ80BASIC.ASM:3700
SCALPL  = $17F3 =  6131          EMUZ80BASIC.ASM:3714
SCNEND  = $125F =  4703          EMUZ80BASIC.ASM:2772
SCPTLP  = $0F6E =  3950          EMUZ80BASIC.ASM:2307
SEARCH  = $0598 =  1432          EMUZ80BASIC.ASM:887
SEED    = $805C = 32860          EMUZ80BASIC.ASM:130
SETIO   = $1403 =  5123          EMUZ80BASIC.ASM:3047
SETLIN  = $075A =  1882          EMUZ80BASIC.ASM:1148
SETLIT  = $05E2 =  1506          EMUZ80BASIC.ASM:937
SETPTR  = $04BF =  1215          EMUZ80BASIC.ASM:758
SETTOP  = $007F =   127          EMUZ80BASIC.ASM:248
SFTPRG  = $0489 =  1161          EMUZ80BASIC.ASM:721
SGN     = $16A6 =  5798          EMUZ80BASIC.ASM:3486
SGNEXP  = $0DEE =  3566          EMUZ80BASIC.ASM:2067
SGNRES  = $812D = 33069          EMUZ80BASIC.ASM:180
SHRITE  = $1525 =  5413          EMUZ80BASIC.ASM:3241
SHRLP   = $1528 =  5416          EMUZ80BASIC.ASM:3243
SHRT1   = $152C =  5420          EMUZ80BASIC.ASM:3247
SIGNON  = $00D8 =   216          EMUZ80BASIC.ASM:285
SIGNS   = $16FD =  5885          EMUZ80BASIC.ASM:3546
SIN     = $1A8A =  6794          EMUZ80BASIC.ASM:4082
SIN1    = $1ABA =  6842          EMUZ80BASIC.ASM:4102
SINIT   = $0039 =    57          EMUZ80BASIC.ASM:79
SINTAB  = $1AD6 =  6870          EMUZ80BASIC.ASM:4115
SIXDIG  = $1859 =  6233          EMUZ80BASIC.ASM:3778
SMPVAR  = $11F3 =  4595          EMUZ80BASIC.ASM:2700
SMSER1  = $19EE =  6638          EMUZ80BASIC.ASM:3994
SN      = $0002 =     2          EMUZ80BASIC.ASM:189
SNERR   = $03F0 =  1008          EMUZ80BASIC.ASM:644
SPCFST  = $184A =  6218          EMUZ80BASIC.ASM:3770
SPCLP   = $0B3F =  2879          EMUZ80BASIC.ASM:1710
SQR     = $1930 =  6448          EMUZ80BASIC.ASM:3906
SRCHLN  = $04DC =  1244          EMUZ80BASIC.ASM:780
SRCHLP  = $04DF =  1247          EMUZ80BASIC.ASM:781
SSTSA   = $12BB =  4795          EMUZ80BASIC.ASM:2832
ST      = $001E =    30          EMUZ80BASIC.ASM:203
STACK   = $80AB = 32939          EMUZ80BASIC.ASM:152
STAKFP  = $16C8 =  5832          EMUZ80BASIC.ASM:3506
STALL   = $0881 =  2177          EMUZ80BASIC.ASM:1325
STARTB  = $0042 =    66          EMUZ80BASIC.ASM:212
STKTHS  = $0D27 =  3367          EMUZ80BASIC.ASM:1962
STLOOK  = $81A2 = 33186          EMUZ80BASIC.ASM:184
STOP    = $0890 =  2192          EMUZ80BASIC.ASM:1336
STORED  = $095C =  2396          EMUZ80BASIC.ASM:1451
STPOOL  = $1236 =  4662          EMUZ80BASIC.ASM:2737
STR     = $1118 =  4376          EMUZ80BASIC.ASM:2575
STR1    = $111E =  4382          EMUZ80BASIC.ASM:2577
STRADD  = $1239 =  4665          EMUZ80BASIC.ASM:2739
STRBOT  = $8108 = 33032          EMUZ80BASIC.ASM:161
STRENT  = $0BF7 =  3063          EMUZ80BASIC.ASM:1799
STRSPC  = $809F = 32927          EMUZ80BASIC.ASM:148
STTLIN  = $0AE3 =  2787          EMUZ80BASIC.ASM:1661
SUBCDE  = $144E =  5198          EMUZ80BASIC.ASM:3087
SUBPHL  = $1448 =  5192          EMUZ80BASIC.ASM:3083
SUMLP   = $19F7 =  6647          EMUZ80BASIC.ASM:3999
SUMSER  = $19DF =  6623          EMUZ80BASIC.ASM:3987
SUPTLZ  = $18D8 =  6360          EMUZ80BASIC.ASM:3855
SVNAM2  = $0EC7 =  3783          EMUZ80BASIC.ASM:2212
SVSTAD  = $1146 =  4422          EMUZ80BASIC.ASM:2603
TAN     = $1AEB =  6891          EMUZ80BASIC.ASM:4122
TESTOS  = $11C5 =  4549          EMUZ80BASIC.ASM:2679
TESTR   = $11A7 =  4519          EMUZ80BASIC.ASM:2659
TM      = $0018 =    24          EMUZ80BASIC.ASM:200
TMERR   = $0402 =  1026          EMUZ80BASIC.ASM:656
TMPSTR  = $8104 = 33028          EMUZ80BASIC.ASM:160
TMSTPL  = $80F8 = 33016          EMUZ80BASIC.ASM:159
TMSTPT  = $80F6 = 33014          EMUZ80BASIC.ASM:158
TOPOOL  = $132C =  4908          EMUZ80BASIC.ASM:2909
TOSTRA  = $12C4 =  4804          EMUZ80BASIC.ASM:2841
TRYAGN  = $18B3 =  6323          EMUZ80BASIC.ASM:3828
TSALP   = $12C5 =  4805          EMUZ80BASIC.ASM:2842
TSTACK  = $F000 = 61440          EMUZ80BASIC.ASM:13
TSTBIT  = $1C93 =  7315          EMUZ80BASIC.ASM:4382 (unused)
TSTBRK  = $0873 =  2163          EMUZ80BASIC.ASM:1314
TSTNUM  = $0CB8 =  3256          EMUZ80BASIC.ASM:1897
TSTOPL  = $116E =  4462          EMUZ80BASIC.ASM:2631
TSTRED  = $0E26 =  3622          EMUZ80BASIC.ASM:2110
TSTREM  = $05E5 =  1509          EMUZ80BASIC.ASM:938
TSTSGN  = $1697 =  5783          EMUZ80BASIC.ASM:3474
TSTSTR  = $0CB9 =  3257          EMUZ80BASIC.ASM:1898
TTYLIN  = $0635 =  1589          EMUZ80BASIC.ASM:985
TXA     = $002F =    47          EMUZ80BASIC.ASM:65
TXAST1  = $0030 =    48          EMUZ80BASIC.ASM:66
TYPE    = $80F2 = 33010          EMUZ80BASIC.ASM:155
UF      = $0022 =    34          EMUZ80BASIC.ASM:205
UFERR   = $03FC =  1020          EMUZ80BASIC.ASM:652
UL      = $000E =    14          EMUZ80BASIC.ASM:195
ULERR   = $09B5 =  2485          EMUZ80BASIC.ASM:1501
UNITY   = $153A =  5434          EMUZ80BASIC.ASM:3260
UPDATA  = $086E =  2158          EMUZ80BASIC.ASM:1309
USR     = $8048 = 32840          EMUZ80BASIC.ASM:122
VAL     = $139A =  5018          EMUZ80BASIC.ASM:2984
VAL1    = $13B8 =  5048          EMUZ80BASIC.ASM:3004
VAL2    = $13C2 =  5058          EMUZ80BASIC.ASM:3008
VAL3    = $13C5 =  5061          EMUZ80BASIC.ASM:3009
VAREND  = $811D = 33053          EMUZ80BASIC.ASM:173
WAIT    = $13E5 =  5093          EMUZ80BASIC.ASM:3031
WAITLP  = $13FA =  5114          EMUZ80BASIC.ASM:3041
WARM    = $003F =    63          EMUZ80BASIC.ASM:211 (unused)
WARMST  = $00B7 =   183          EMUZ80BASIC.ASM:275
WIDTH   = $1B54 =  6996          EMUZ80BASIC.ASM:4170
WORDS   = $0179 =   377          EMUZ80BASIC.ASM:325
WORDTB  = $0298 =   664          EMUZ80BASIC.ASM:414
WRKSPC  = $8045 = 32837          EMUZ80BASIC.ASM:121
XXXXX   = $00C6 =   198          EMUZ80BASIC.ASM:281
ZDATA   = $0083 =   131          EMUZ80BASIC.ASM:456
ZDIV    = $00AF =   175          EMUZ80BASIC.ASM:474 (unused)
ZEND    = $0080 =   128          EMUZ80BASIC.ASM:454
ZEQUAL  = $00B4 =   180          EMUZ80BASIC.ASM:477
ZERARY  = $1009 =  4105          EMUZ80BASIC.ASM:2406
ZERBYT  = $038C =   908          EMUZ80BASIC.ASM:581
ZEROLP  = $0F4C =  3916          EMUZ80BASIC.ASM:2284
ZEROSUP = $1C2C =  7212          EMUZ80BASIC.ASM:4311
ZFN     = $00A7 =   167          EMUZ80BASIC.ASM:465
ZFOR    = $0081 =   129          EMUZ80BASIC.ASM:455
ZGOSUB  = $008C =   140          EMUZ80BASIC.ASM:458
ZGOTO   = $0088 =   136          EMUZ80BASIC.ASM:457
ZGTR    = $00B3 =   179          EMUZ80BASIC.ASM:476
ZLEFT   = $00CF =   207          EMUZ80BASIC.ASM:481
ZLTH    = $00B5 =   181          EMUZ80BASIC.ASM:478
ZMINUS  = $00AD =   173          EMUZ80BASIC.ASM:472
ZNEW    = $00A4 =   164          EMUZ80BASIC.ASM:461
ZNOT    = $00AA =   170          EMUZ80BASIC.ASM:468
ZONELP  = $0B1A =  2842          EMUZ80BASIC.ASM:1689
ZOR     = $00B2 =   178          EMUZ80BASIC.ASM:475
ZPLUS   = $00AC =   172          EMUZ80BASIC.ASM:471
ZPOINT  = $00C7 =   199          EMUZ80BASIC.ASM:480 (unused)
ZPRINT  = $009E =   158          EMUZ80BASIC.ASM:460
ZREM    = $008E =   142          EMUZ80BASIC.ASM:459
ZSGN    = $00B6 =   182          EMUZ80BASIC.ASM:479
ZSPC    = $00A8 =   168          EMUZ80BASIC.ASM:466
ZSTEP   = $00AB =   171          EMUZ80BASIC.ASM:469
ZTAB    = $00A5 =   165          EMUZ80BASIC.ASM:463
ZTHEN   = $00A9 =   169          EMUZ80BASIC.ASM:467
ZTIMES  = $00AE =   174          EMUZ80BASIC.ASM:473 (unused)
ZTO     = $00A6 =   166          EMUZ80BASIC.ASM:464
_end    = $1CA0 =  7328          EMUZ80BASIC.ASM:23 (unused)
_size   = $1CA0 =  7328          EMUZ80BASIC.ASM:23 (unused)


total time: 0.0315 sec.
no errors
