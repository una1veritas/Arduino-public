                        ; --------------------------------------
                        ; zasm: assemble "CPM22.Z80"
                        ; date: 2025-10-23 23:48:39
                        ; --------------------------------------


                        ;**************************************************************
                        ;*
                        ;*             C P / M   version   2 . 2
                        ;*
                        ;*   Reconstructed from memory image on February 27, 1981
                        ;*
                        ;*                by Clark A. Calkins
                        ;*
                        ;**************************************************************
                        ;
                        ;   Set memory limit here. This is the amount of contigeous
                        ; ram starting from 0000. CP/M will reside at the end of this space.
                        ;
003E:                   MEM	EQU	62		;for a 62k system (TS802 TEST - WORKS OK).
                        ;
0003:                   IOBYTE	EQU	3		;i/o definition byte.
0004:                   TDRIVE	EQU	4		;current drive name and user number.
0005:                   ENTRY	EQU	5		;entry point for the cp/m bdos.
005C:                   TFCB	EQU	5CH		;default file control block.
0080:                   TBUFF	EQU	80H		;i/o buffer and command line storage.
0100:                   TBASE	EQU	100H		;transiant program storage area.
                        ;
                        ;   Set control character equates.
                        ;
0003:                   CNTRLC	EQU	3		;control-c
0005:                   CNTRLE	EQU	05H		;control-e
0008:                   BS	EQU	08H		;backspace
0009:                   TAB	EQU	09H		;tab
000A:                   LF	EQU	0AH		;line feed
000C:                   FF	EQU	0CH		;form feed
000D:                   CR	EQU	0DH		;carriage return
0010:                   CNTRLP	EQU	10H		;control-p
0012:                   CNTRLR	EQU	12H		;control-r
0013:                   CNTRLS	EQU	13H		;control-s
0015:                   CNTRLU	EQU	15H		;control-u
0018:                   CNTRLX	EQU	18H		;control-x
001A:                   CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
007F:                   DEL	EQU	7FH		;rubout
                        ;
                        ;   Set origin for CP/M
                        ;
DC00:                   	ORG	(MEM-7)*1024
                        ;
DC00: C35CDF   [10]     CBASE:	JP	COMMAND		;execute command processor (ccp).
DC03: C358DF   [20]     	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
                        
                        ;
                        ;   Standard cp/m ccp input buffer. Format is (max length),
                        ; (actual length), (char #1), (char #2), (char #3), etc.
                        ;
DC06: 7F                INBUFF:	DEFB	127		;length of input buffer.
DC07: 00                	DEFB	0		;current length of contents.
DC08: 436F7079          	DEFB	'Copyright'
DC0C: 72696768          
DC10: 74                
DC11: 20313937          	DEFB	' 1979 (c) by Digital Research      '
DC15: 39202863          
DC19: 29206279          
DC1D: 20446967          
DC21: 6974616C          
DC25: 20526573          
DC29: 65617263          
DC2D: 68202020          
DC31: 202020            
DC34: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC38: 00...             
DC4B: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC4F: 00...             
DC62: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC66: 00...             
DC79: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DC7D: 00...             
DC88: 08DC              INPOINT:DEFW	INBUFF+2	;input line pointer
DC8A: 0000              NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
                        ;			;start of name in error.
                        ;
                        ;   Routine to print (A) on the console. All registers used.
                        ;
DC8C: 5F       [ 4]     PRINT:	LD	E,A		;setup bdos call.
DC8D: 0E02     [11]     	LD	C,2
DC8F: C30500   [21]     	JP	ENTRY
                        ;
                        ;   Routine to print (A) on the console and to save (BC).
                        ;
DC92: C5       [11]     PRINTB:	PUSH	BC
DC93: CD8CDC   [28]     	CALL	PRINT
DC96: C1       [38]     	POP	BC
DC97: C9       [48]     	RET	
                        ;
                        ;   Routine to send a carriage return, line feed combination
                        ; to the console.
                        ;
DC98: 3E0D     [ 7]     CRLF:	LD	A,CR
DC9A: CD92DC   [24]     	CALL	PRINTB
DC9D: 3E0A     [31]     	LD	A,LF
DC9F: C392DC   [41]     	JP	PRINTB
                        ;
                        ;   Routine to send one space to the console and save (BC).
                        ;
DCA2: 3E20     [ 7]     SPACE:	LD	A,' '
DCA4: C392DC   [17]     	JP	PRINTB
                        ;
                        ;   Routine to print character string pointed to be (BC) on the
                        ; console. It must terminate with a null byte.
                        ;
DCA7: C5       [11]     PLINE:	PUSH	BC
DCA8: CD98DC   [28]     	CALL	CRLF
DCAB: E1       [38]     	POP	HL
DCAC: 7E       [ 7]     PLINE2:	LD	A,(HL)
DCAD: B7       [11]     	OR	A
DCAE: C8       [16|22]  	RET	Z
DCAF: 23       [22]     	INC	HL
DCB0: E5       [33]     	PUSH	HL
DCB1: CD8CDC   [50]     	CALL	PRINT
DCB4: E1       [60]     	POP	HL
DCB5: C3ACDC   [70]     	JP	PLINE2
                        ;
                        ;   Routine to reset the disk system.
                        ;
DCB8: 0E0D     [ 7]     RESDSK:	LD	C,13
DCBA: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to select disk (A).
                        ;
DCBD: 5F       [ 4]     DSKSEL:	LD	E,A
DCBE: 0E0E     [11]     	LD	C,14
DCC0: C30500   [21]     	JP	ENTRY
                        ;
                        ;   Routine to call bdos and save the return code. The zero
                        ; flag is set on a return of 0ffh.
                        ;
DCC3: CD0500   [17]     ENTRY1:	CALL	ENTRY
DCC6: 32EEE3   [30]     	LD	(RTNCODE),A	;save return code.
DCC9: 3C       [34]     	INC	A		;set zero if 0ffh returned.
DCCA: C9       [44]     	RET	
                        ;
                        ;   Routine to open a file. (DE) must point to the FCB.
                        ;
DCCB: 0E0F     [ 7]     OPEN:	LD	C,15
DCCD: C3C3DC   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to open file at (FCB).
                        ;
DCD0: AF       [ 4]     OPENFCB:XOR	A		;clear the record number byte at fcb+32
DCD1: 32EDE3   [17]     	LD	(FCB+32),A
DCD4: 11CDE3   [27]     	LD	DE,FCB
DCD7: C3CBDC   [37]     	JP	OPEN
                        ;
                        ;   Routine to close a file. (DE) points to FCB.
                        ;
DCDA: 0E10     [ 7]     CLOSE:	LD	C,16
DCDC: C3C3DC   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to search for the first file with ambigueous name
                        ; (DE).
                        ;
DCDF: 0E11     [ 7]     SRCHFST:LD	C,17
DCE1: C3C3DC   [17]     	JP	ENTRY1
                        ;
                        ;   Search for the next ambigeous file name.
                        ;
DCE4: 0E12     [ 7]     SRCHNXT:LD	C,18
DCE6: C3C3DC   [17]     	JP	ENTRY1
                        ;
                        ;   Search for file at (FCB).
                        ;
DCE9: 11CDE3   [10]     SRCHFCB:LD	DE,FCB
DCEC: C3DFDC   [20]     	JP	SRCHFST
                        ;
                        ;   Routine to delete a file pointed to by (DE).
                        ;
DCEF: 0E13     [ 7]     DELETE:	LD	C,19
DCF1: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to call the bdos and set the zero flag if a zero
                        ; status is returned.
                        ;
DCF4: CD0500   [17]     ENTRY2:	CALL	ENTRY
DCF7: B7       [21]     	OR	A		;set zero flag if appropriate.
DCF8: C9       [31]     	RET	
                        ;
                        ;   Routine to read the next record from a sequential file.
                        ; (DE) points to the FCB.
                        ;
DCF9: 0E14     [ 7]     RDREC:	LD	C,20
DCFB: C3F4DC   [17]     	JP	ENTRY2
                        ;
                        ;   Routine to read file at (FCB).
                        ;
DCFE: 11CDE3   [10]     READFCB:LD	DE,FCB
DD01: C3F9DC   [20]     	JP	RDREC
                        ;
                        ;   Routine to write the next record of a sequential file.
                        ; (DE) points to the FCB.
                        ;
DD04: 0E15     [ 7]     WRTREC:	LD	C,21
DD06: C3F4DC   [17]     	JP	ENTRY2
                        ;
                        ;   Routine to create the file pointed to by (DE).
                        ;
DD09: 0E16     [ 7]     CREATE:	LD	C,22
DD0B: C3C3DC   [17]     	JP	ENTRY1
                        ;
                        ;   Routine to rename the file pointed to by (DE). Note that
                        ; the new name starts at (DE+16).
                        ;
DD0E: 0E17     [ 7]     RENAM:	LD	C,23
DD10: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Get the current user code.
                        ;
DD13: 1EFF     [ 7]     GETUSR:	LD	E,0FFH
                        ;
                        ;   Routne to get or set the current user code.
                        ; If (E) is FF then this is a GET, else it is a SET.
                        ;
DD15: 0E20     [ 7]     GETSETUC: LD	C,32
DD17: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Routine to set the current drive byte at (TDRIVE).
                        ;
DD1A: CD13DD   [17]     SETCDRV:CALL	GETUSR		;get user number
DD1D: 87       [21]     	ADD	A,A		;and shift into the upper 4 bits.
DD1E: 87       [25]     	ADD	A,A
DD1F: 87       [29]     	ADD	A,A
DD20: 87       [33]     	ADD	A,A
DD21: 21EFE3   [43]     	LD	HL,CDRIVE	;now add in the current drive number.
DD24: B6       [50]     	OR	(HL)
DD25: 320400   [63]     	LD	(TDRIVE),A	;and save.
DD28: C9       [73]     	RET	
                        ;
                        ;   Move currently active drive down to (TDRIVE).
                        ;
DD29: 3AEFE3   [13]     MOVECD:	LD	A,(CDRIVE)
DD2C: 320400   [26]     	LD	(TDRIVE),A
DD2F: C9       [36]     	RET	
                        ;
                        ;   Routine to convert (A) into upper case ascii. Only letters
                        ; are affected.
                        ;
DD30: FE61     [ 7]     UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
DD32: D8       [12|18]  	RET	C
DD33: FE7B     [19]     	CP	'{'
DD35: D0       [24|30]  	RET	NC
DD36: E65F     [31]     	AND	5FH		;convert it if found.
DD38: C9       [41]     	RET	
                        ;
                        ;   Routine to get a line of input. We must check to see if the
                        ; user is in (BATCH) mode. If so, then read the input from file
                        ; ($$$.SUB). At the end, reset to console input.
                        ;
DD39: 3AABE3   [13]     GETINP:	LD	A,(BATCH)	;if =0, then use console input.
DD3C: B7       [17]     	OR	A
DD3D: CA96DD   [27|27]  	JP	Z,GETINP1
                        ;
                        ;   Use the submit file ($$$.sub) which is prepared by a
                        ; SUBMIT run. It must be on drive (A) and it will be deleted
                        ; if and error occures (like eof).
                        ;
DD40: 3AEFE3   [40]     	LD	A,(CDRIVE)	;select drive 0 if need be.
DD43: B7       [44]     	OR	A
DD44: 3E00     [51]     	LD	A,0		;always use drive A for submit.
DD46: C4BDDC   [61|68]  	CALL	NZ,DSKSEL	;select it if required.
DD49: 11ACE3   [71]     	LD	DE,BATCHFCB
DD4C: CDCBDC   [88]     	CALL	OPEN		;look for it.
DD4F: CA96DD   [98|98]  	JP	Z,GETINP1	;if not there, use normal input.
DD52: 3ABBE3   [111]    	LD	A,(BATCHFCB+15)	;get last record number+1.
DD55: 3D       [115]    	DEC	A
DD56: 32CCE3   [128]    	LD	(BATCHFCB+32),A
DD59: 11ACE3   [138]    	LD	DE,BATCHFCB
DD5C: CDF9DC   [155]    	CALL	RDREC		;read last record.
DD5F: C296DD   [165|165]	JP	NZ,GETINP1	;quit on end of file.
                        ;
                        ;   Move this record into input buffer.
                        ;
DD62: 1107DC   [175]    	LD	DE,INBUFF+1
DD65: 218000   [185]    	LD	HL,TBUFF	;data was read into buffer here.
DD68: 0680     [192]    	LD	B,128		;all 128 characters may be used.
DD6A: CD42E0   [209]    	CALL	HL2DE		;(HL) to (DE), (B) bytes.
DD6D: 21BAE3   [219]    	LD	HL,BATCHFCB+14
DD70: 3600     [229]    	LD	(HL),0		;zero out the 's2' byte.
DD72: 23       [235]    	INC	HL		;and decrement the record count.
DD73: 35       [246]    	DEC	(HL)
DD74: 11ACE3   [256]    	LD	DE,BATCHFCB	;close the batch file now.
DD77: CDDADC   [273]    	CALL	CLOSE
DD7A: CA96DD   [283|283]	JP	Z,GETINP1	;quit on an error.
DD7D: 3AEFE3   [296]    	LD	A,(CDRIVE)	;re-select previous drive if need be.
DD80: B7       [300]    	OR	A
DD81: C4BDDC   [310|317]	CALL	NZ,DSKSEL	;don't do needless selects.
                        ;
                        ;   Print line just read on console.
                        ;
DD84: 2108DC   [320]    	LD	HL,INBUFF+2
DD87: CDACDC   [337]    	CALL	PLINE2
DD8A: CDC2DD   [354]    	CALL	CHKCON		;check console, quit on a key.
DD8D: CAA7DD   [364|364]	JP	Z,GETINP2	;jump if no key is pressed.
                        ;
                        ;   Terminate the submit job on any keyboard input. Delete this
                        ; file such that it is not re-started and jump to normal keyboard
                        ; input section.
                        ;
DD90: CDDDDD   [381]    	CALL	DELBATCH	;delete the batch file.
DD93: C382DF   [391]    	JP	CMMND1		;and restart command input.
                        ;
                        ;   Get here for normal keyboard input. Delete the submit file
                        ; incase there was one.
                        ;
DD96: CDDDDD   [17]     GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
DD99: CD1ADD   [34]     	CALL	SETCDRV		;reset active disk.
DD9C: 0E0A     [41]     	LD	C,10		;get line from console device.
DD9E: 1106DC   [51]     	LD	DE,INBUFF
DDA1: CD0500   [68]     	CALL	ENTRY
DDA4: CD29DD   [85]     	CALL	MOVECD		;reset current drive (again).
                        ;
                        ;   Convert input line to upper case.
                        ;
DDA7: 2107DC   [10]     GETINP2:LD	HL,INBUFF+1
DDAA: 46       [17]     	LD	B,(HL)		;(B)=character counter.
DDAB: 23       [ 6]     GETINP3:INC	HL
DDAC: 78       [10]     	LD	A,B		;end of the line?
DDAD: B7       [14]     	OR	A
DDAE: CABADD   [24|24]  	JP	Z,GETINP4
DDB1: 7E       [31]     	LD	A,(HL)		;convert to upper case.
DDB2: CD30DD   [48]     	CALL	UPPER
DDB5: 77       [55]     	LD	(HL),A
DDB6: 05       [59]     	DEC	B		;adjust character count.
DDB7: C3ABDD   [69]     	JP	GETINP3
DDBA: 77       [ 7]     GETINP4:LD	(HL),A		;add trailing null.
DDBB: 2108DC   [17]     	LD	HL,INBUFF+2
DDBE: 2288DC   [33]     	LD	(INPOINT),HL	;reset input line pointer.
DDC1: C9       [43]     	RET	
                        ;
                        ;   Routine to check the console for a key pressed. The zero
                        ; flag is set is none, else the character is returned in (A).
                        ;
DDC2: 0E0B     [ 7]     CHKCON:	LD	C,11		;check console.
DDC4: CD0500   [24]     	CALL	ENTRY
DDC7: B7       [28]     	OR	A
DDC8: C8       [33|39]  	RET	Z		;return if nothing.
DDC9: 0E01     [40]     	LD	C,1		;else get character.
DDCB: CD0500   [57]     	CALL	ENTRY
DDCE: B7       [61]     	OR	A		;clear zero flag and return.
DDCF: C9       [71]     	RET	
                        ;
                        ;   Routine to get the currently active drive number.
                        ;
DDD0: 0E19     [ 7]     GETDSK:	LD	C,25
DDD2: C30500   [17]     	JP	ENTRY
                        ;
                        ;   Set the stabdard dma address.
                        ;
DDD5: 118000   [10]     STDDMA:	LD	DE,TBUFF
                        ;
                        ;   Routine to set the dma address to (DE).
                        ;
DDD8: 0E1A     [ 7]     DMASET:	LD	C,26
DDDA: C30500   [17]     	JP	ENTRY
                        ;
                        ;  Delete the batch file created by SUBMIT.
                        ;
DDDD: 21ABE3   [10]     DELBATCH: LD	HL,BATCH	;is batch active?
DDE0: 7E       [17]     	LD	A,(HL)
DDE1: B7       [21]     	OR	A
DDE2: C8       [26|32]  	RET	Z
DDE3: 3600     [36]     	LD	(HL),0		;yes, de-activate it.
DDE5: AF       [40]     	XOR	A
DDE6: CDBDDC   [57]     	CALL	DSKSEL		;select drive 0 for sure.
DDE9: 11ACE3   [67]     	LD	DE,BATCHFCB	;and delete this file.
DDEC: CDEFDC   [84]     	CALL	DELETE
DDEF: 3AEFE3   [97]     	LD	A,(CDRIVE)	;reset current drive.
DDF2: C3BDDC   [107]    	JP	DSKSEL
                        ;
                        ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
                        ; the same or we halt....
                        ;
DDF5: 1128DF   [10]     VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
DDF8: 2100E4   [20]     	LD	HL,PATTRN2	;ditto, but how could they be different?
DDFB: 0606     [27]     	LD	B,6		;6 bytes each.
DDFD: 1A       [ 7]     VERIFY1:LD	A,(DE)
DDFE: BE       [14]     	CP	(HL)
DDFF: C2CFDF   [24|24]  	JP	NZ,HALT		;jump to halt routine.
DE02: 13       [30]     	INC	DE
DE03: 23       [36]     	INC	HL
DE04: 05       [40]     	DEC	B
DE05: C2FDDD   [50|50]  	JP	NZ,VERIFY1
DE08: C9       [60]     	RET	
                        ;
                        ;   Print back file name with a '?' to indicate a syntax error.
                        ;
DE09: CD98DC   [17]     SYNERR:	CALL	CRLF		;end current line.
DE0C: 2A8ADC   [33]     	LD	HL,(NAMEPNT)	;this points to name in error.
DE0F: 7E       [ 7]     SYNERR1:LD	A,(HL)		;print it until a space or null is found.
DE10: FE20     [14]     	CP	' '
DE12: CA22DE   [24|24]  	JP	Z,SYNERR2
DE15: B7       [28]     	OR	A
DE16: CA22DE   [38|38]  	JP	Z,SYNERR2
DE19: E5       [49]     	PUSH	HL
DE1A: CD8CDC   [66]     	CALL	PRINT
DE1D: E1       [76]     	POP	HL
DE1E: 23       [82]     	INC	HL
DE1F: C30FDE   [92]     	JP	SYNERR1
DE22: 3E3F     [ 7]     SYNERR2:LD	A,'?'		;add trailing '?'.
DE24: CD8CDC   [24]     	CALL	PRINT
DE27: CD98DC   [41]     	CALL	CRLF
DE2A: CDDDDD   [58]     	CALL	DELBATCH	;delete any batch file.
DE2D: C382DF   [68]     	JP	CMMND1		;and restart from console input.
                        ;
                        ;   Check character at (DE) for legal command input. Note that the
                        ; zero flag is set if the character is a delimiter.
                        ;
DE30: 1A       [ 7]     CHECK:	LD	A,(DE)
DE31: B7       [11]     	OR	A
DE32: C8       [16|22]  	RET	Z
DE33: FE20     [23]     	CP	' '		;control characters are not legal here.
DE35: DA09DE   [33|33]  	JP	C,SYNERR
DE38: C8       [38|44]  	RET	Z		;check for valid delimiter.
DE39: FE3D     [45]     	CP	'='
DE3B: C8       [50|56]  	RET	Z
DE3C: FE5F     [57]     	CP	'_'
DE3E: C8       [62|68]  	RET	Z
DE3F: FE2E     [69]     	CP	'.'
DE41: C8       [74|80]  	RET	Z
DE42: FE3A     [81]     	CP	':'
DE44: C8       [86|92]  	RET	Z
DE45: FE3B     [93]     	CP	';'
DE47: C8       [98|104] 	RET	Z
DE48: FE3C     [105]    	CP	'<'
DE4A: C8       [110|116]	RET	Z
DE4B: FE3E     [117]    	CP	'>'
DE4D: C8       [122|128]	RET	Z
DE4E: C9       [132]    	RET	
                        ;
                        ;   Get the next non-blank character from (DE).
                        ;
DE4F: 1A       [ 7]     NONBLANK: LD	A,(DE)
DE50: B7       [11]     	OR	A		;string ends with a null.
DE51: C8       [16|22]  	RET	Z
DE52: FE20     [23]     	CP	' '
DE54: C0       [28|34]  	RET	NZ
DE55: 13       [34]     	INC	DE
DE56: C34FDE   [44]     	JP	NONBLANK
                        ;
                        ;   Add (HL)=(HL)+(A)
                        ;
DE59: 85       [ 4]     ADDHL:	ADD	A,L
DE5A: 6F       [ 8]     	LD	L,A
DE5B: D0       [13|19]  	RET	NC		;take care of any carry.
DE5C: 24       [17]     	INC	H
DE5D: C9       [27]     	RET	
                        ;
                        ;   Convert the first name in (FCB).
                        ;
DE5E: 3E00     [ 7]     CONVFST:LD	A,0
                        ;
                        ;   Format a file name (convert * to '?', etc.). On return,
                        ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
                        ; the position within the fcb for the name (either 0 or 16).
                        ;
DE60: 21CDE3   [10]     CONVERT:LD	HL,FCB
DE63: CD59DE   [27]     	CALL	ADDHL
DE66: E5       [38]     	PUSH	HL
DE67: E5       [49]     	PUSH	HL
DE68: AF       [53]     	XOR	A
DE69: 32F0E3   [66]     	LD	(CHGDRV),A	;initialize drive change flag.
DE6C: 2A88DC   [82]     	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
DE6F: EB       [86]     	EX	DE,HL
DE70: CD4FDE   [103]    	CALL	NONBLANK	;get next non-blank character.
DE73: EB       [107]    	EX	DE,HL
DE74: 228ADC   [123]    	LD	(NAMEPNT),HL	;save pointer here for any error message.
DE77: EB       [127]    	EX	DE,HL
DE78: E1       [137]    	POP	HL
DE79: 1A       [144]    	LD	A,(DE)		;get first character.
DE7A: B7       [148]    	OR	A
DE7B: CA89DE   [158|158]	JP	Z,CONVRT1
DE7E: DE40     [165]    	SBC	A,'A'-1		;might be a drive name, convert to binary.
DE80: 47       [169]    	LD	B,A		;and save.
DE81: 13       [175]    	INC	DE		;check next character for a ':'.
DE82: 1A       [182]    	LD	A,(DE)
DE83: FE3A     [189]    	CP	':'
DE85: CA90DE   [199|199]	JP	Z,CONVRT2
DE88: 1B       [205]    	DEC	DE		;nope, move pointer back to the start of the line.
DE89: 3AEFE3   [13]     CONVRT1:LD	A,(CDRIVE)
DE8C: 77       [20]     	LD	(HL),A
DE8D: C396DE   [30]     	JP	CONVRT3
DE90: 78       [ 4]     CONVRT2:LD	A,B
DE91: 32F0E3   [17]     	LD	(CHGDRV),A	;set change in drives flag.
DE94: 70       [24]     	LD	(HL),B
DE95: 13       [30]     	INC	DE
                        ;
                        ;   Convert the basic file name.
                        ;
DE96: 0608     [ 7]     CONVRT3:LD	B,08H
DE98: CD30DE   [17]     CONVRT4:CALL	CHECK
DE9B: CAB9DE   [27|27]  	JP	Z,CONVRT8
DE9E: 23       [33]     	INC	HL
DE9F: FE2A     [40]     	CP	'*'		;note that an '*' will fill the remaining
DEA1: C2A9DE   [50|50]  	JP	NZ,CONVRT5	;field with '?'.
DEA4: 363F     [60]     	LD	(HL),'?'
DEA6: C3ABDE   [70]     	JP	CONVRT6
DEA9: 77       [ 7]     CONVRT5:LD	(HL),A
DEAA: 13       [13]     	INC	DE
DEAB: 05       [ 4]     CONVRT6:DEC	B
DEAC: C298DE   [14|14]  	JP	NZ,CONVRT4
DEAF: CD30DE   [17]     CONVRT7:CALL	CHECK		;get next delimiter.
DEB2: CAC0DE   [27|27]  	JP	Z,GETEXT
DEB5: 13       [33]     	INC	DE
DEB6: C3AFDE   [43]     	JP	CONVRT7
DEB9: 23       [ 6]     CONVRT8:INC	HL		;blank fill the file name.
DEBA: 3620     [16]     	LD	(HL),' '
DEBC: 05       [20]     	DEC	B
DEBD: C2B9DE   [30|30]  	JP	NZ,CONVRT8
                        ;
                        ;   Get the extension and convert it.
                        ;
DEC0: 0603     [ 7]     GETEXT:	LD	B,03H
DEC2: FE2E     [14]     	CP	'.'
DEC4: C2E9DE   [24|24]  	JP	NZ,GETEXT5
DEC7: 13       [30]     	INC	DE
DEC8: CD30DE   [17]     GETEXT1:CALL	CHECK
DECB: CAE9DE   [27|27]  	JP	Z,GETEXT5
DECE: 23       [33]     	INC	HL
DECF: FE2A     [40]     	CP	'*'
DED1: C2D9DE   [50|50]  	JP	NZ,GETEXT2
DED4: 363F     [60]     	LD	(HL),'?'
DED6: C3DBDE   [70]     	JP	GETEXT3
DED9: 77       [ 7]     GETEXT2:LD	(HL),A
DEDA: 13       [13]     	INC	DE
DEDB: 05       [ 4]     GETEXT3:DEC	B
DEDC: C2C8DE   [14|14]  	JP	NZ,GETEXT1
DEDF: CD30DE   [17]     GETEXT4:CALL	CHECK
DEE2: CAF0DE   [27|27]  	JP	Z,GETEXT6
DEE5: 13       [33]     	INC	DE
DEE6: C3DFDE   [43]     	JP	GETEXT4
DEE9: 23       [ 6]     GETEXT5:INC	HL
DEEA: 3620     [16]     	LD	(HL),' '
DEEC: 05       [20]     	DEC	B
DEED: C2E9DE   [30|30]  	JP	NZ,GETEXT5
DEF0: 0603     [ 7]     GETEXT6:LD	B,3
DEF2: 23       [ 6]     GETEXT7:INC	HL
DEF3: 3600     [16]     	LD	(HL),0
DEF5: 05       [20]     	DEC	B
DEF6: C2F2DE   [30|30]  	JP	NZ,GETEXT7
DEF9: EB       [34]     	EX	DE,HL
DEFA: 2288DC   [50]     	LD	(INPOINT),HL	;save input line pointer.
DEFD: E1       [60]     	POP	HL
                        ;
                        ;   Check to see if this is an ambigeous file name specification.
                        ; Set the (A) register to non zero if it is.
                        ;
DEFE: 010B00   [70]     	LD	BC,11		;set name length.
DF01: 23       [ 6]     GETEXT8:INC	HL
DF02: 7E       [13]     	LD	A,(HL)
DF03: FE3F     [20]     	CP	'?'		;any question marks?
DF05: C209DF   [30|30]  	JP	NZ,GETEXT9
DF08: 04       [34]     	INC	B		;count them.
DF09: 0D       [ 4]     GETEXT9:DEC	C
DF0A: C201DF   [14|14]  	JP	NZ,GETEXT8
DF0D: 78       [18]     	LD	A,B
DF0E: B7       [22]     	OR	A
DF0F: C9       [32]     	RET	
                        ;
                        ;   CP/M command table. Note commands can be either 3 or 4 characters long.
                        ;
0006:                   NUMCMDS EQU	6		;number of commands
DF10: 44495220          CMDTBL:	DEFB	'DIR '
DF14: 45524120          	DEFB	'ERA '
DF18: 54595045          	DEFB	'TYPE'
DF1C: 53415645          	DEFB	'SAVE'
DF20: 52454E20          	DEFB	'REN '
DF24: 55534552          	DEFB	'USER'
                        ;
                        ;   The following six bytes must agree with those at (PATTRN2)
                        ; or cp/m will HALT. Why?
                        ;
DF28: 00160000          PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
DF2C: 0000              
                        ;
                        ;   Search the command table for a match with what has just
                        ; been entered. If a match is found, then we jump to the
                        ; proper section. Else jump to (UNKNOWN).
                        ; On return, the (C) register is set to the command number
                        ; that matched (or NUMCMDS+1 if no match).
                        ;
DF2E: 2110DF   [10]     SEARCH:	LD	HL,CMDTBL
DF31: 0E00     [17]     	LD	C,0
DF33: 79       [ 4]     SEARCH1:LD	A,C
DF34: FE06     [11]     	CP	NUMCMDS		;this commands exists.
DF36: D0       [16|22]  	RET	NC
DF37: 11CEE3   [26]     	LD	DE,FCB+1	;check this one.
DF3A: 0604     [33]     	LD	B,4		;max command length.
DF3C: 1A       [ 7]     SEARCH2:LD	A,(DE)
DF3D: BE       [14]     	CP	(HL)
DF3E: C24FDF   [24|24]  	JP	NZ,SEARCH3	;not a match.
DF41: 13       [30]     	INC	DE
DF42: 23       [36]     	INC	HL
DF43: 05       [40]     	DEC	B
DF44: C23CDF   [50|50]  	JP	NZ,SEARCH2
DF47: 1A       [57]     	LD	A,(DE)		;allow a 3 character command to match.
DF48: FE20     [64]     	CP	' '
DF4A: C254DF   [74|74]  	JP	NZ,SEARCH4
DF4D: 79       [78]     	LD	A,C		;set return register for this command.
DF4E: C9       [88]     	RET	
DF4F: 23       [ 6]     SEARCH3:INC	HL
DF50: 05       [10]     	DEC	B
DF51: C24FDF   [20|20]  	JP	NZ,SEARCH3
DF54: 0C       [ 4]     SEARCH4:INC	C
DF55: C333DF   [14]     	JP	SEARCH1
                        ;
                        ;   Set the input buffer to empty and then start the command
                        ; processor (ccp).
                        ;
DF58: AF       [ 4]     CLEARBUF: XOR	A
DF59: 3207DC   [17]     	LD	(INBUFF+1),A	;second byte is actual length.
                        ;
                        ;**************************************************************
                        ;*
                        ;*
                        ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
                        ;*
                        ;**************************************************************
                        ;*
DF5C: 31ABE3   [10]     COMMAND:LD	SP,CCPSTACK	;setup stack area.
DF5F: C5       [21]     	PUSH	BC		;note that (C) should be equal to:
DF60: 79       [25]     	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
DF61: 1F       [29]     	RRA			;and 'dddd' is the drive number.
DF62: 1F       [33]     	RRA	
DF63: 1F       [37]     	RRA	
DF64: 1F       [41]     	RRA	
DF65: E60F     [48]     	AND	0FH		;isolate the user number.
DF67: 5F       [52]     	LD	E,A
DF68: CD15DD   [69]     	CALL	GETSETUC	;and set it.
DF6B: CDB8DC   [86]     	CALL	RESDSK		;reset the disk system.
DF6E: 32ABE3   [99]     	LD	(BATCH),A	;clear batch mode flag.
DF71: C1       [109]    	POP	BC
DF72: 79       [113]    	LD	A,C
DF73: E60F     [120]    	AND	0FH		;isolate the drive number.
DF75: 32EFE3   [133]    	LD	(CDRIVE),A	;and save.
DF78: CDBDDC   [150]    	CALL	DSKSEL		;...and select.
DF7B: 3A07DC   [163]    	LD	A,(INBUFF+1)
DF7E: B7       [167]    	OR	A		;anything in input buffer already?
DF7F: C298DF   [177|177]	JP	NZ,CMMND2	;yes, we just process it.
                        ;
                        ;   Entry point to get a command line from the console.
                        ;
DF82: 31ABE3   [10]     CMMND1:	LD	SP,CCPSTACK	;set stack straight.
DF85: CD98DC   [27]     	CALL	CRLF		;start a new line on the screen.
DF88: CDD0DD   [44]     	CALL	GETDSK		;get current drive.
DF8B: C661     [51]     	ADD	A,'a'
DF8D: CD8CDC   [68]     	CALL	PRINT		;print current drive.
DF90: 3E3E     [75]     	LD	A,'>'
DF92: CD8CDC   [92]     	CALL	PRINT		;and add prompt.
DF95: CD39DD   [109]    	CALL	GETINP		;get line from user.
                        ;
                        ;   Process command line here.
                        ;
DF98: 118000   [10]     CMMND2:	LD	DE,TBUFF
DF9B: CDD8DD   [27]     	CALL	DMASET		;set standard dma address.
DF9E: CDD0DD   [44]     	CALL	GETDSK
DFA1: 32EFE3   [57]     	LD	(CDRIVE),A	;set current drive.
DFA4: CD5EDE   [74]     	CALL	CONVFST		;convert name typed in.
DFA7: C409DE   [84|91]  	CALL	NZ,SYNERR	;wild cards are not allowed.
DFAA: 3AF0E3   [97]     	LD	A,(CHGDRV)	;if a change in drives was indicated,
DFAD: B7       [101]    	OR	A		;then treat this as an unknown command
DFAE: C2A5E2   [111|111]	JP	NZ,UNKNOWN	;which gets executed.
DFB1: CD2EDF   [128]    	CALL	SEARCH		;else search command table for a match.
                        ;
                        ;   Note that an unknown command returns
                        ; with (A) pointing to the last address
                        ; in our table which is (UNKNOWN).
                        ;
DFB4: 21C1DF   [138]    	LD	HL,CMDADR	;now, look thru our address table for command (A).
DFB7: 5F       [142]    	LD	E,A		;set (DE) to command number.
DFB8: 1600     [149]    	LD	D,0
DFBA: 19       [160]    	ADD	HL,DE
DFBB: 19       [171]    	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
DFBC: 7E       [178]    	LD	A,(HL)		;now pick out this address.
DFBD: 23       [184]    	INC	HL
DFBE: 66       [191]    	LD	H,(HL)
DFBF: 6F       [195]    	LD	L,A
DFC0: E9       [199]    	JP	(HL)		;now execute it.
                        ;
                        ;   CP/M command address table.
                        ;
DFC1: 77E01FE1          CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
DFC5: 5DE1ADE1          
DFC9: 10E28EE2          	DEFW	RENAME,USER,UNKNOWN
DFCD: A5E2              
                        ;
                        ;   Halt the system. Reason for this is unknown at present.
                        ;
DFCF: 21F376   [10]     HALT:	LD	HL,76F3H	;'DI HLT' instructions.
DFD2: 2200DC   [26]     	LD	(CBASE),HL
DFD5: 2100DC   [36]     	LD	HL,CBASE
DFD8: E9       [40]     	JP	(HL)
                        ;
                        ;   Read error while TYPEing a file.
                        ;
DFD9: 01DFDF   [10]     RDERROR:LD	BC,RDERR
DFDC: C3A7DC   [20]     	JP	PLINE
DFDF: 52656164          RDERR:	DEFB	'Read error',0
DFE3: 20657272          
DFE7: 6F7200            
                        ;
                        ;   Required file was not located.
                        ;
DFEA: 01F0DF   [10]     NONE:	LD	BC,NOFILE
DFED: C3A7DC   [20]     	JP	PLINE
DFF0: 4E6F2066          NOFILE:	DEFB	'No file',0
DFF4: 696C6500          
                        ;
                        ;   Decode a command of the form 'A>filename number{ filename}.
                        ; Note that a drive specifier is not allowed on the first file
                        ; name. On return, the number is in register (A). Any error
                        ; causes 'filename?' to be printed and the command is aborted.
                        ;
DFF8: CD5EDE   [17]     DECODE:	CALL	CONVFST		;convert filename.
DFFB: 3AF0E3   [30]     	LD	A,(CHGDRV)	;do not allow a drive to be specified.
DFFE: B7       [34]     	OR	A
DFFF: C209DE   [44|44]  	JP	NZ,SYNERR
E002: 21CEE3   [54]     	LD	HL,FCB+1	;convert number now.
E005: 010B00   [64]     	LD	BC,11		;(B)=sum register, (C)=max digit count.
E008: 7E       [ 7]     DECODE1:LD	A,(HL)
E009: FE20     [14]     	CP	' '		;a space terminates the numeral.
E00B: CA33E0   [24|24]  	JP	Z,DECODE3
E00E: 23       [30]     	INC	HL
E00F: D630     [37]     	SUB	'0'		;make binary from ascii.
E011: FE0A     [44]     	CP	10		;legal digit?
E013: D209DE   [54|54]  	JP	NC,SYNERR
E016: 57       [58]     	LD	D,A		;yes, save it in (D).
E017: 78       [62]     	LD	A,B		;compute (B)=(B)*10 and check for overflow.
E018: E6E0     [69]     	AND	0E0H
E01A: C209DE   [79|79]  	JP	NZ,SYNERR
E01D: 78       [83]     	LD	A,B
E01E: 07       [87]     	RLCA	
E01F: 07       [91]     	RLCA	
E020: 07       [95]     	RLCA			;(A)=(B)*8
E021: 80       [99]     	ADD	A,B		;.......*9
E022: DA09DE   [109|109]	JP	C,SYNERR
E025: 80       [113]    	ADD	A,B		;.......*10
E026: DA09DE   [123|123]	JP	C,SYNERR
E029: 82       [127]    	ADD	A,D		;add in new digit now.
E02A: DA09DE   [10|10]  DECODE2:JP	C,SYNERR
E02D: 47       [14]     	LD	B,A		;and save result.
E02E: 0D       [18]     	DEC	C		;only look at 11 digits.
E02F: C208E0   [28|28]  	JP	NZ,DECODE1
E032: C9       [38]     	RET	
E033: 7E       [ 7]     DECODE3:LD	A,(HL)		;spaces must follow (why?).
E034: FE20     [14]     	CP	' '
E036: C209DE   [24|24]  	JP	NZ,SYNERR
E039: 23       [30]     	INC	HL
E03A: 0D       [ 4]     DECODE4:DEC	C
E03B: C233E0   [14|14]  	JP	NZ,DECODE3
E03E: 78       [18]     	LD	A,B		;set (A)=the numeric value entered.
E03F: C9       [28]     	RET	
                        ;
                        ;   Move 3 bytes from (HL) to (DE). Note that there is only
                        ; one reference to this at (A2D5h).
                        ;
E040: 0603     [ 7]     MOVE3:	LD	B,3
                        ;
                        ;   Move (B) bytes from (HL) to (DE).
                        ;
E042: 7E       [ 7]     HL2DE:	LD	A,(HL)
E043: 12       [14]     	LD	(DE),A
E044: 23       [20]     	INC	HL
E045: 13       [26]     	INC	DE
E046: 05       [30]     	DEC	B
E047: C242E0   [40|40]  	JP	NZ,HL2DE
E04A: C9       [50]     	RET	
                        ;
                        ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
                        ;
E04B: 218000   [10]     EXTRACT:LD	HL,TBUFF
E04E: 81       [14]     	ADD	A,C
E04F: CD59DE   [31]     	CALL	ADDHL
E052: 7E       [38]     	LD	A,(HL)
E053: C9       [48]     	RET	
                        ;
                        ;  Check drive specified. If it means a change, then the new
                        ; drive will be selected. In any case, the drive byte of the
                        ; fcb will be set to null (means use current drive).
                        ;
E054: AF       [ 4]     DSELECT:XOR	A		;null out first byte of fcb.
E055: 32CDE3   [17]     	LD	(FCB),A
E058: 3AF0E3   [30]     	LD	A,(CHGDRV)	;a drive change indicated?
E05B: B7       [34]     	OR	A
E05C: C8       [39|45]  	RET	Z
E05D: 3D       [43]     	DEC	A		;yes, is it the same as the current drive?
E05E: 21EFE3   [53]     	LD	HL,CDRIVE
E061: BE       [60]     	CP	(HL)
E062: C8       [65|71]  	RET	Z
E063: C3BDDC   [75]     	JP	DSKSEL		;no. Select it then.
                        ;
                        ;   Check the drive selection and reset it to the previous
                        ; drive if it was changed for the preceeding command.
                        ;
E066: 3AF0E3   [13]     RESETDR:LD	A,(CHGDRV)	;drive change indicated?
E069: B7       [17]     	OR	A
E06A: C8       [22|28]  	RET	Z
E06B: 3D       [26]     	DEC	A		;yes, was it a different drive?
E06C: 21EFE3   [36]     	LD	HL,CDRIVE
E06F: BE       [43]     	CP	(HL)
E070: C8       [48|54]  	RET	Z
E071: 3AEFE3   [61]     	LD	A,(CDRIVE)	;yes, re-select our old drive.
E074: C3BDDC   [71]     	JP	DSKSEL
                        ;
                        ;**************************************************************
                        ;*
                        ;*           D I R E C T O R Y   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E077: CD5EDE   [17]     DIRECT:	CALL	CONVFST		;convert file name.
E07A: CD54E0   [34]     	CALL	DSELECT		;select indicated drive.
E07D: 21CEE3   [44]     	LD	HL,FCB+1	;was any file indicated?
E080: 7E       [51]     	LD	A,(HL)
E081: FE20     [58]     	CP	' '
E083: C28FE0   [68|68]  	JP	NZ,DIRECT2
E086: 060B     [75]     	LD	B,11		;no. Fill field with '?' - same as *.*.
E088: 363F     [10]     DIRECT1:LD	(HL),'?'
E08A: 23       [16]     	INC	HL
E08B: 05       [20]     	DEC	B
E08C: C288E0   [30|30]  	JP	NZ,DIRECT1
E08F: 1E00     [ 7]     DIRECT2:LD	E,0		;set initial cursor position.
E091: D5       [18]     	PUSH	DE
E092: CDE9DC   [35]     	CALL	SRCHFCB		;get first file name.
E095: CCEADF   [45|52]  	CALL	Z,NONE		;none found at all?
E098: CA1BE1   [10|10]  DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
E09B: 3AEEE3   [23]     	LD	A,(RTNCODE)	;get file's position in segment (0-3).
E09E: 0F       [27]     	RRCA	
E09F: 0F       [31]     	RRCA	
E0A0: 0F       [35]     	RRCA	
E0A1: E660     [42]     	AND	60H		;(A)=position*32
E0A3: 4F       [46]     	LD	C,A
E0A4: 3E0A     [53]     	LD	A,10
E0A6: CD4BE0   [70]     	CALL	EXTRACT		;extract the tenth entry in fcb.
E0A9: 17       [74]     	RLA			;check system file status bit.
E0AA: DA0FE1   [84|84]  	JP	C,DIRECT8	;we don't list them.
E0AD: D1       [94]     	POP	DE
E0AE: 7B       [98]     	LD	A,E		;bump name count.
E0AF: 1C       [102]    	INC	E
E0B0: D5       [113]    	PUSH	DE
E0B1: E603     [120]    	AND	03H		;at end of line?
E0B3: F5       [131]    	PUSH	AF
E0B4: C2CCE0   [141|141]	JP	NZ,DIRECT4
E0B7: CD98DC   [158]    	CALL	CRLF		;yes, end this line and start another.
E0BA: C5       [169]    	PUSH	BC
E0BB: CDD0DD   [186]    	CALL	GETDSK		;start line with ('A:').
E0BE: C1       [196]    	POP	BC
E0BF: C641     [203]    	ADD	A,'A'
E0C1: CD92DC   [220]    	CALL	PRINTB
E0C4: 3E3A     [227]    	LD	A,':'
E0C6: CD92DC   [244]    	CALL	PRINTB
E0C9: C3D4E0   [254]    	JP	DIRECT5
E0CC: CDA2DC   [17]     DIRECT4:CALL	SPACE		;add seperator between file names.
E0CF: 3E3A     [24]     	LD	A,':'
E0D1: CD92DC   [41]     	CALL	PRINTB
E0D4: CDA2DC   [17]     DIRECT5:CALL	SPACE
E0D7: 0601     [24]     	LD	B,1		;'extract' each file name character at a time.
E0D9: 78       [ 4]     DIRECT6:LD	A,B
E0DA: CD4BE0   [21]     	CALL	EXTRACT
E0DD: E67F     [28]     	AND	7FH		;strip bit 7 (status bit).
E0DF: FE20     [35]     	CP	' '		;are we at the end of the name?
E0E1: C2F9E0   [45|45]  	JP	NZ,DRECT65
E0E4: F1       [55]     	POP	AF		;yes, don't print spaces at the end of a line.
E0E5: F5       [66]     	PUSH	AF
E0E6: FE03     [73]     	CP	3
E0E8: C2F7E0   [83|83]  	JP	NZ,DRECT63
E0EB: 3E09     [90]     	LD	A,9		;first check for no extension.
E0ED: CD4BE0   [107]    	CALL	EXTRACT
E0F0: E67F     [114]    	AND	7FH
E0F2: FE20     [121]    	CP	' '
E0F4: CA0EE1   [131|131]	JP	Z,DIRECT7	;don't print spaces.
E0F7: 3E20     [ 7]     DRECT63:LD	A,' '		;else print them.
E0F9: CD92DC   [17]     DRECT65:CALL	PRINTB
E0FC: 04       [21]     	INC	B		;bump to next character psoition.
E0FD: 78       [25]     	LD	A,B
E0FE: FE0C     [32]     	CP	12		;end of the name?
E100: D20EE1   [42|42]  	JP	NC,DIRECT7
E103: FE09     [49]     	CP	9		;nope, starting extension?
E105: C2D9E0   [59|59]  	JP	NZ,DIRECT6
E108: CDA2DC   [76]     	CALL	SPACE		;yes, add seperating space.
E10B: C3D9E0   [86]     	JP	DIRECT6
E10E: F1       [10]     DIRECT7:POP	AF		;get the next file name.
E10F: CDC2DD   [17]     DIRECT8:CALL	CHKCON		;first check console, quit on anything.
E112: C21BE1   [27|27]  	JP	NZ,DIRECT9
E115: CDE4DC   [44]     	CALL	SRCHNXT		;get next name.
E118: C398E0   [54]     	JP	DIRECT3		;and continue with our list.
E11B: D1       [10]     DIRECT9:POP	DE		;restore the stack and return to command level.
E11C: C386E3   [20]     	JP	GETBACK
                        ;
                        ;**************************************************************
                        ;*
                        ;*                E R A S E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E11F: CD5EDE   [17]     ERASE:	CALL	CONVFST		;convert file name.
E122: FE0B     [24]     	CP	11		;was '*.*' entered?
E124: C242E1   [34|34]  	JP	NZ,ERASE1
E127: 0152E1   [44]     	LD	BC,YESNO	;yes, ask for confirmation.
E12A: CDA7DC   [61]     	CALL	PLINE
E12D: CD39DD   [78]     	CALL	GETINP
E130: 2107DC   [88]     	LD	HL,INBUFF+1
E133: 35       [99]     	DEC	(HL)		;must be exactly 'y'.
E134: C282DF   [109|109]	JP	NZ,CMMND1
E137: 23       [115]    	INC	HL
E138: 7E       [122]    	LD	A,(HL)
E139: FE59     [129]    	CP	'Y'
E13B: C282DF   [139|139]	JP	NZ,CMMND1
E13E: 23       [145]    	INC	HL
E13F: 2288DC   [161]    	LD	(INPOINT),HL	;save input line pointer.
E142: CD54E0   [17]     ERASE1:	CALL	DSELECT		;select desired disk.
E145: 11CDE3   [27]     	LD	DE,FCB
E148: CDEFDC   [44]     	CALL	DELETE		;delete the file.
E14B: 3C       [48]     	INC	A
E14C: CCEADF   [58|65]  	CALL	Z,NONE		;not there?
E14F: C386E3   [68]     	JP	GETBACK		;return to command level now.
E152: 416C6C20          YESNO:	DEFB	'All (y/n)?',0
E156: 28792F6E          
E15A: 293F00            
                        ;
                        ;**************************************************************
                        ;*
                        ;*            T Y P E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E15D: CD5EDE   [17]     TYPE:	CALL	CONVFST		;convert file name.
E160: C209DE   [27|27]  	JP	NZ,SYNERR	;wild cards not allowed.
E163: CD54E0   [44]     	CALL	DSELECT		;select indicated drive.
E166: CDD0DC   [61]     	CALL	OPENFCB		;open the file.
E169: CAA7E1   [71|71]  	JP	Z,TYPE5		;not there?
E16C: CD98DC   [88]     	CALL	CRLF		;ok, start a new line on the screen.
E16F: 21F1E3   [98]     	LD	HL,NBYTES	;initialize byte counter.
E172: 36FF     [108]    	LD	(HL),0FFH	;set to read first sector.
E174: 21F1E3   [10]     TYPE1:	LD	HL,NBYTES
E177: 7E       [ 7]     TYPE2:	LD	A,(HL)		;have we written the entire sector?
E178: FE80     [14]     	CP	128
E17A: DA87E1   [24|24]  	JP	C,TYPE3
E17D: E5       [35]     	PUSH	HL		;yes, read in the next one.
E17E: CDFEDC   [52]     	CALL	READFCB
E181: E1       [62]     	POP	HL
E182: C2A0E1   [72|72]  	JP	NZ,TYPE4	;end or error?
E185: AF       [76]     	XOR	A		;ok, clear byte counter.
E186: 77       [83]     	LD	(HL),A
E187: 34       [11]     TYPE3:	INC	(HL)		;count this byte.
E188: 218000   [21]     	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
E18B: CD59DE   [38]     	CALL	ADDHL
E18E: 7E       [45]     	LD	A,(HL)
E18F: FE1A     [52]     	CP	CNTRLZ		;end of file mark?
E191: CA86E3   [62|62]  	JP	Z,GETBACK
E194: CD8CDC   [79]     	CALL	PRINT		;no, print it.
E197: CDC2DD   [96]     	CALL	CHKCON		;check console, quit if anything ready.
E19A: C286E3   [106|106]	JP	NZ,GETBACK
E19D: C374E1   [116]    	JP	TYPE1
                        ;
                        ;   Get here on an end of file or read error.
                        ;
E1A0: 3D       [ 4]     TYPE4:	DEC	A		;read error?
E1A1: CA86E3   [14|14]  	JP	Z,GETBACK
E1A4: CDD9DF   [31]     	CALL	RDERROR		;yes, print message.
E1A7: CD66E0   [17]     TYPE5:	CALL	RESETDR		;and reset proper drive
E1AA: C309DE   [27]     	JP	SYNERR		;now print file name with problem.
                        ;
                        ;**************************************************************
                        ;*
                        ;*            S A V E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E1AD: CDF8DF   [17]     SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
E1B0: F5       [28]     	PUSH	AF		;save number of pages to write.
E1B1: CD5EDE   [45]     	CALL	CONVFST		;convert file name.
E1B4: C209DE   [55|55]  	JP	NZ,SYNERR	;wild cards not allowed.
E1B7: CD54E0   [72]     	CALL	DSELECT		;select specified drive.
E1BA: 11CDE3   [82]     	LD	DE,FCB		;now delete this file.
E1BD: D5       [93]     	PUSH	DE
E1BE: CDEFDC   [110]    	CALL	DELETE
E1C1: D1       [120]    	POP	DE
E1C2: CD09DD   [137]    	CALL	CREATE		;and create it again.
E1C5: CAFBE1   [147|147]	JP	Z,SAVE3		;can't create?
E1C8: AF       [151]    	XOR	A		;clear record number byte.
E1C9: 32EDE3   [164]    	LD	(FCB+32),A
E1CC: F1       [174]    	POP	AF		;convert pages to sectors.
E1CD: 6F       [178]    	LD	L,A
E1CE: 2600     [185]    	LD	H,0
E1D0: 29       [196]    	ADD	HL,HL		;(HL)=number of sectors to write.
E1D1: 110001   [206]    	LD	DE,TBASE	;and we start from here.
E1D4: 7C       [ 4]     SAVE1:	LD	A,H		;done yet?
E1D5: B5       [ 8]     	OR	L
E1D6: CAF1E1   [18|18]  	JP	Z,SAVE2
E1D9: 2B       [24]     	DEC	HL		;nope, count this and compute the start
E1DA: E5       [35]     	PUSH	HL		;of the next 128 byte sector.
E1DB: 218000   [45]     	LD	HL,128
E1DE: 19       [56]     	ADD	HL,DE
E1DF: E5       [67]     	PUSH	HL		;save it and set the transfer address.
E1E0: CDD8DD   [84]     	CALL	DMASET
E1E3: 11CDE3   [94]     	LD	DE,FCB		;write out this sector now.
E1E6: CD04DD   [111]    	CALL	WRTREC
E1E9: D1       [121]    	POP	DE		;reset (DE) to the start of the last sector.
E1EA: E1       [131]    	POP	HL		;restore sector count.
E1EB: C2FBE1   [141|141]	JP	NZ,SAVE3	;write error?
E1EE: C3D4E1   [151]    	JP	SAVE1
                        ;
                        ;   Get here after writing all of the file.
                        ;
E1F1: 11CDE3   [10]     SAVE2:	LD	DE,FCB		;now close the file.
E1F4: CDDADC   [27]     	CALL	CLOSE
E1F7: 3C       [31]     	INC	A		;did it close ok?
E1F8: C201E2   [41|41]  	JP	NZ,SAVE4
                        ;
                        ;   Print out error message (no space).
                        ;
E1FB: 0107E2   [10]     SAVE3:	LD	BC,NOSPACE
E1FE: CDA7DC   [27]     	CALL	PLINE
E201: CDD5DD   [17]     SAVE4:	CALL	STDDMA		;reset the standard dma address.
E204: C386E3   [27]     	JP	GETBACK
E207: 4E6F2073          NOSPACE:DEFB	'No space',0
E20B: 70616365          
E20F: 00                
                        ;
                        ;**************************************************************
                        ;*
                        ;*           R E N A M E   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E210: CD5EDE   [17]     RENAME:	CALL	CONVFST		;convert first file name.
E213: C209DE   [27|27]  	JP	NZ,SYNERR	;wild cards not allowed.
E216: 3AF0E3   [40]     	LD	A,(CHGDRV)	;remember any change in drives specified.
E219: F5       [51]     	PUSH	AF
E21A: CD54E0   [68]     	CALL	DSELECT		;and select this drive.
E21D: CDE9DC   [85]     	CALL	SRCHFCB		;is this file present?
E220: C279E2   [95|95]  	JP	NZ,RENAME6	;yes, print error message.
E223: 21CDE3   [105]    	LD	HL,FCB		;yes, move this name into second slot.
E226: 11DDE3   [115]    	LD	DE,FCB+16
E229: 0610     [122]    	LD	B,16
E22B: CD42E0   [139]    	CALL	HL2DE
E22E: 2A88DC   [155]    	LD	HL,(INPOINT)	;get input pointer.
E231: EB       [159]    	EX	DE,HL
E232: CD4FDE   [176]    	CALL	NONBLANK	;get next non blank character.
E235: FE3D     [183]    	CP	'='		;only allow an '=' or '_' seperator.
E237: CA3FE2   [193|193]	JP	Z,RENAME1
E23A: FE5F     [200]    	CP	'_'
E23C: C273E2   [210|210]	JP	NZ,RENAME5
E23F: EB       [ 4]     RENAME1:EX	DE,HL
E240: 23       [10]     	INC	HL		;ok, skip seperator.
E241: 2288DC   [26]     	LD	(INPOINT),HL	;save input line pointer.
E244: CD5EDE   [43]     	CALL	CONVFST		;convert this second file name now.
E247: C273E2   [53|53]  	JP	NZ,RENAME5	;again, no wild cards.
E24A: F1       [63]     	POP	AF		;if a drive was specified, then it
E24B: 47       [67]     	LD	B,A		;must be the same as before.
E24C: 21F0E3   [77]     	LD	HL,CHGDRV
E24F: 7E       [84]     	LD	A,(HL)
E250: B7       [88]     	OR	A
E251: CA59E2   [98|98]  	JP	Z,RENAME2
E254: B8       [102]    	CP	B
E255: 70       [109]    	LD	(HL),B
E256: C273E2   [119|119]	JP	NZ,RENAME5	;they were different, error.
E259: 70       [ 7]     RENAME2:LD	(HL),B		;	reset as per the first file specification.
E25A: AF       [11]     	XOR	A
E25B: 32CDE3   [24]     	LD	(FCB),A		;clear the drive byte of the fcb.
E25E: CDE9DC   [17]     RENAME3:CALL	SRCHFCB		;and go look for second file.
E261: CA6DE2   [27|27]  	JP	Z,RENAME4	;doesn't exist?
E264: 11CDE3   [37]     	LD	DE,FCB
E267: CD0EDD   [54]     	CALL	RENAM		;ok, rename the file.
E26A: C386E3   [64]     	JP	GETBACK
                        ;
                        ;   Process rename errors here.
                        ;
E26D: CDEADF   [17]     RENAME4:CALL	NONE		;file not there.
E270: C386E3   [27]     	JP	GETBACK
E273: CD66E0   [17]     RENAME5:CALL	RESETDR		;bad command format.
E276: C309DE   [27]     	JP	SYNERR
E279: 0182E2   [10]     RENAME6:LD	BC,EXISTS	;destination file already exists.
E27C: CDA7DC   [27]     	CALL	PLINE
E27F: C386E3   [37]     	JP	GETBACK
E282: 46696C65          EXISTS:	DEFB	'File exists',0
E286: 20657869          
E28A: 73747300          
                        ;
                        ;**************************************************************
                        ;*
                        ;*             U S E R   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E28E: CDF8DF   [17]     USER:	CALL	DECODE		;get numeric value following command.
E291: FE10     [24]     	CP	16		;legal user number?
E293: D209DE   [34|34]  	JP	NC,SYNERR
E296: 5F       [38]     	LD	E,A		;yes but is there anything else?
E297: 3ACEE3   [51]     	LD	A,(FCB+1)
E29A: FE20     [58]     	CP	' '
E29C: CA09DE   [68|68]  	JP	Z,SYNERR	;yes, that is not allowed.
E29F: CD15DD   [85]     	CALL	GETSETUC	;ok, set user code.
E2A2: C389E3   [95]     	JP	GETBACK1
                        ;
                        ;**************************************************************
                        ;*
                        ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
                        ;*
                        ;**************************************************************
                        ;
E2A5: CDF5DD   [17]     UNKNOWN:CALL	VERIFY		;check for valid system (why?).
E2A8: 3ACEE3   [30]     	LD	A,(FCB+1)	;anything to execute?
E2AB: FE20     [37]     	CP	' '
E2AD: C2C4E2   [47|47]  	JP	NZ,UNKWN1
E2B0: 3AF0E3   [60]     	LD	A,(CHGDRV)	;nope, only a drive change?
E2B3: B7       [64]     	OR	A
E2B4: CA89E3   [74|74]  	JP	Z,GETBACK1	;neither???
E2B7: 3D       [78]     	DEC	A
E2B8: 32EFE3   [91]     	LD	(CDRIVE),A	;ok, store new drive.
E2BB: CD29DD   [108]    	CALL	MOVECD		;set (TDRIVE) also.
E2BE: CDBDDC   [125]    	CALL	DSKSEL		;and select this drive.
E2C1: C389E3   [135]    	JP	GETBACK1	;then return.
                        ;
                        ;   Here a file name was typed. Prepare to execute it.
                        ;
E2C4: 11D6E3   [10]     UNKWN1:	LD	DE,FCB+9	;an extension specified?
E2C7: 1A       [17]     	LD	A,(DE)
E2C8: FE20     [24]     	CP	' '
E2CA: C209DE   [34|34]  	JP	NZ,SYNERR	;yes, not allowed.
E2CD: D5       [11]     UNKWN2:	PUSH	DE
E2CE: CD54E0   [28]     	CALL	DSELECT		;select specified drive.
E2D1: D1       [38]     	POP	DE
E2D2: 2183E3   [48]     	LD	HL,COMFILE	;set the extension to 'COM'.
E2D5: CD40E0   [65]     	CALL	MOVE3
E2D8: CDD0DC   [82]     	CALL	OPENFCB		;and open this file.
E2DB: CA6BE3   [92|92]  	JP	Z,UNKWN9	;not present?
                        ;
                        ;   Load in the program.
                        ;
E2DE: 210001   [102]    	LD	HL,TBASE	;store the program starting here.
E2E1: E5       [11]     UNKWN3:	PUSH	HL
E2E2: EB       [15]     	EX	DE,HL
E2E3: CDD8DD   [32]     	CALL	DMASET		;set transfer address.
E2E6: 11CDE3   [42]     	LD	DE,FCB		;and read the next record.
E2E9: CDF9DC   [59]     	CALL	RDREC
E2EC: C201E3   [69|69]  	JP	NZ,UNKWN4	;end of file or read error?
E2EF: E1       [79]     	POP	HL		;nope, bump pointer for next sector.
E2F0: 118000   [89]     	LD	DE,128
E2F3: 19       [100]    	ADD	HL,DE
E2F4: 1100DC   [110]    	LD	DE,CBASE	;enough room for the whole file?
E2F7: 7D       [114]    	LD	A,L
E2F8: 93       [118]    	SUB	E
E2F9: 7C       [122]    	LD	A,H
E2FA: 9A       [126]    	SBC	A,D
E2FB: D271E3   [136|136]	JP	NC,UNKWN0	;no, it can't fit.
E2FE: C3E1E2   [146]    	JP	UNKWN3
                        ;
                        ;   Get here after finished reading.
                        ;
E301: E1       [10]     UNKWN4:	POP	HL
E302: 3D       [14]     	DEC	A		;normal end of file?
E303: C271E3   [24|24]  	JP	NZ,UNKWN0
E306: CD66E0   [41]     	CALL	RESETDR		;yes, reset previous drive.
E309: CD5EDE   [58]     	CALL	CONVFST		;convert the first file name that follows
E30C: 21F0E3   [68]     	LD	HL,CHGDRV	;command name.
E30F: E5       [79]     	PUSH	HL
E310: 7E       [86]     	LD	A,(HL)		;set drive code in default fcb.
E311: 32CDE3   [99]     	LD	(FCB),A
E314: 3E10     [106]    	LD	A,16		;put second name 16 bytes later.
E316: CD60DE   [123]    	CALL	CONVERT		;convert second file name.
E319: E1       [133]    	POP	HL
E31A: 7E       [140]    	LD	A,(HL)		;and set the drive for this second file.
E31B: 32DDE3   [153]    	LD	(FCB+16),A
E31E: AF       [157]    	XOR	A		;clear record byte in fcb.
E31F: 32EDE3   [170]    	LD	(FCB+32),A
E322: 115C00   [180]    	LD	DE,TFCB		;move it into place at(005Ch).
E325: 21CDE3   [190]    	LD	HL,FCB
E328: 0621     [197]    	LD	B,33
E32A: CD42E0   [214]    	CALL	HL2DE
E32D: 2108DC   [224]    	LD	HL,INBUFF+2	;now move the remainder of the input
E330: 7E       [ 7]     UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
E331: B7       [11]     	OR	A		;or a null.
E332: CA3EE3   [21|21]  	JP	Z,UNKWN6
E335: FE20     [28]     	CP	' '
E337: CA3EE3   [38|38]  	JP	Z,UNKWN6
E33A: 23       [44]     	INC	HL
E33B: C330E3   [54]     	JP	UNKWN5
                        ;
                        ;   Do the line move now. It ends in a null byte.
                        ;
E33E: 0600     [ 7]     UNKWN6:	LD	B,0		;keep a character count.
E340: 118100   [17]     	LD	DE,TBUFF+1	;data gets put here.
E343: 7E       [ 7]     UNKWN7:	LD	A,(HL)		;move it now.
E344: 12       [14]     	LD	(DE),A
E345: B7       [18]     	OR	A
E346: CA4FE3   [28|28]  	JP	Z,UNKWN8
E349: 04       [32]     	INC	B
E34A: 23       [38]     	INC	HL
E34B: 13       [44]     	INC	DE
E34C: C343E3   [54]     	JP	UNKWN7
E34F: 78       [ 4]     UNKWN8:	LD	A,B		;now store the character count.
E350: 328000   [17]     	LD	(TBUFF),A
E353: CD98DC   [34]     	CALL	CRLF		;clean up the screen.
E356: CDD5DD   [51]     	CALL	STDDMA		;set standard transfer address.
E359: CD1ADD   [68]     	CALL	SETCDRV		;reset current drive.
E35C: CD0001   [85]     	CALL	TBASE		;and execute the program.
                        ;
                        ;   Transiant programs return here (or reboot).
                        ;
E35F: 31ABE3   [95]     	LD	SP,BATCH	;set stack first off.
E362: CD29DD   [112]    	CALL	MOVECD		;move current drive into place (TDRIVE).
E365: CDBDDC   [129]    	CALL	DSKSEL		;and reselect it.
E368: C382DF   [139]    	JP	CMMND1		;back to comand mode.
                        ;
                        ;   Get here if some error occured.
                        ;
E36B: CD66E0   [17]     UNKWN9:	CALL	RESETDR		;inproper format.
E36E: C309DE   [27]     	JP	SYNERR
E371: 017AE3   [10]     UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
E374: CDA7DC   [27]     	CALL	PLINE
E377: C386E3   [37]     	JP	GETBACK
E37A: 42616420          BADLOAD:DEFB	'Bad load',0
E37E: 6C6F6164          
E382: 00                
E383: 434F4D            COMFILE:DEFB	'COM'		;command file extension.
                        ;
                        ;   Get here to return to command level. We will reset the
                        ; previous active drive and then either return to command
                        ; level directly or print error message and then return.
                        ;
E386: CD66E0   [17]     GETBACK:CALL	RESETDR		;reset previous drive.
E389: CD5EDE   [17]     GETBACK1: CALL	CONVFST		;convert first name in (FCB).
E38C: 3ACEE3   [30]     	LD	A,(FCB+1)	;if this was just a drive change request,
E38F: D620     [37]     	SUB	' '		;make sure it was valid.
E391: 21F0E3   [47]     	LD	HL,CHGDRV
E394: B6       [54]     	OR	(HL)
E395: C209DE   [64|64]  	JP	NZ,SYNERR
E398: C382DF   [74]     	JP	CMMND1		;ok, return to command level.
                        ;
                        ;   ccp stack area.
                        ;
E39B: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E39F: 00...             
E3AB:                   CCPSTACK EQU	$	;end of ccp stack area.
                        ;
                        ;   Batch (or SUBMIT) processing information storage.
                        ;
E3AB: 00                BATCH:	DEFB	0		;batch mode flag (0=not active).
E3AC: 00242424          BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E3B0: 20202020          
E3B4: 20535542          
E3B8: 00000000          
E3BC: 00...             
                        ;
                        ;   File control block setup by the CCP.
                        ;
E3CD: 00202020          FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
E3D1: 20202020          
E3D5: 20202020          
E3D9: 00000000          
E3DD: 00202020          
E3E1: 20202020          
E3E5: 20202020          
E3E9: 00000000          
E3ED: 00                
E3EE: 00                RTNCODE:DEFB	0		;status returned from bdos call.
E3EF: 00                CDRIVE:	DEFB	0		;currently active drive.
E3F0: 00                CHGDRV:	DEFB	0		;change in drives flag (0=no change).
E3F1: 0000              NBYTES:	DEFW	0		;byte counter used by TYPE.
                        ;
                        ;   Room for expansion?
                        ;
E3F3: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
E3F7: 00...             
                        ;
                        ;   Note that the following six bytes must match those at
                        ; (PATTRN1) or cp/m will HALT. Why?
                        ;
E400: 00160000          PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
E404: 0000              
                        ;
                        ;**************************************************************
                        ;*
                        ;*                    B D O S   E N T R Y
                        ;*
                        ;**************************************************************
                        ;
E406: C311E4   [10]     FBASE:	JP	FBASE1
                        ;
                        ;   Bdos error table.
                        ;
E409: 99E4              BADSCTR:DEFW	ERROR1		;bad sector on read or write.
E40B: A5E4              BADSLCT:DEFW	ERROR2		;bad disk select.
E40D: ABE4              RODISK:	DEFW	ERROR3		;disk is read only.
E40F: B1E4              ROFILE:	DEFW	ERROR4		;file is read only.
                        ;
                        ;   Entry into bdos. (DE) or (E) are the parameters passed. The
                        ; function number desired is in register (C).
                        ;
E411: EB       [ 4]     FBASE1:	EX	DE,HL		;save the (DE) parameters.
E412: 2243E7   [20]     	LD	(PARAMS),HL
E415: EB       [24]     	EX	DE,HL
E416: 7B       [28]     	LD	A,E		;and save register (E) in particular.
E417: 32D6F1   [41]     	LD	(EPARAM),A
E41A: 210000   [51]     	LD	HL,0
E41D: 2245E7   [67]     	LD	(STATUS),HL	;clear return status.
E420: 39       [78]     	ADD	HL,SP
E421: 220FE7   [94]     	LD	(USRSTACK),HL	;save users stack pointer.
E424: 3141E7   [104]    	LD	SP,STKAREA	;and set our own.
E427: AF       [108]    	XOR	A		;clear auto select storage space.
E428: 32E0F1   [121]    	LD	(AUTOFLAG),A
E42B: 32DEF1   [134]    	LD	(AUTO),A
E42E: 2174F1   [144]    	LD	HL,GOBACK	;set return address.
E431: E5       [155]    	PUSH	HL
E432: 79       [159]    	LD	A,C		;get function number.
E433: FE29     [166]    	CP	NFUNCTS		;valid function number?
E435: D0       [171|177]	RET	NC
E436: 4B       [175]    	LD	C,E		;keep single register function here.
E437: 2147E4   [185]    	LD	HL,FUNCTNS	;now look thru the function table.
E43A: 5F       [189]    	LD	E,A
E43B: 1600     [196]    	LD	D,0		;(DE)=function number.
E43D: 19       [207]    	ADD	HL,DE
E43E: 19       [218]    	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
E43F: 5E       [225]    	LD	E,(HL)
E440: 23       [231]    	INC	HL
E441: 56       [238]    	LD	D,(HL)		;now (DE)=address for this function.
E442: 2A43E7   [254]    	LD	HL,(PARAMS)	;retrieve parameters.
E445: EB       [258]    	EX	DE,HL		;now (DE) has the original parameters.
E446: E9       [262]    	JP	(HL)		;execute desired function.
                        ;
                        ;   BDOS function jump table.
                        ;
0029:                   NFUNCTS EQU	41		;number of functions in followin table.
                        ;
E447: 03F2C8E6          FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
E44B: 90E5CEE6          
E44F: 12F20FF2          
E453: D4E6EDE6          
E457: F3E6F8E6          	DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
E45B: E1E5FEE6          
E45F: 7EF083F0          
E463: 45F09CF0          
E467: A5F0ABF0          	DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
E46B: C8F0D7F0          
E46F: E0F0E6F0          
E473: ECF0              
E475: F5F0FEF0          	DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
E479: 04F10AF1          
E47D: 11F12CE9          
E481: 17F11DF1          
E485: 26F12DF1          	DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
E489: 41F147F1          
E48D: 4DF10EF0          
E491: 53F104E7          
E495: 04E79BF1          	DEFW	RTN,WTSPECL
                        ;
                        ;   Bdos error message section.
                        ;
E499: 21CAE4   [10]     ERROR1:	LD	HL,BADSEC	;bad sector message.
E49C: CDE5E4   [27]     	CALL	PRTERR		;print it and get a 1 char responce.
E49F: FE03     [34]     	CP	CNTRLC		;re-boot request (control-c)?
E4A1: CA0000   [44|44]  	JP	Z,0		;yes.
E4A4: C9       [54]     	RET			;no, return to retry i/o function.
                        ;
E4A5: 21D5E4   [10]     ERROR2:	LD	HL,BADSEL	;bad drive selected.
E4A8: C3B4E4   [20]     	JP	ERROR5
                        ;
E4AB: 21E1E4   [10]     ERROR3:	LD	HL,DISKRO	;disk is read only.
E4AE: C3B4E4   [20]     	JP	ERROR5
                        ;
E4B1: 21DCE4   [10]     ERROR4:	LD	HL,FILERO	;file is read only.
                        ;
E4B4: CDE5E4   [17]     ERROR5:	CALL	PRTERR
E4B7: C30000   [27]     	JP	0		;always reboot on these errors.
                        ;
E4BA: 42646F73          BDOSERR:DEFB	'Bdos Err On '
E4BE: 20457272          
E4C2: 204F6E20          
E4C6: 203A2024          BDOSDRV:DEFB	' : $'
E4CA: 42616420          BADSEC:	DEFB	'Bad Sector$'
E4CE: 53656374          
E4D2: 6F7224            
E4D5: 53656C65          BADSEL:	DEFB	'Select$'
E4D9: 637424            
E4DC: 46696C65          FILERO:	DEFB	'File '
E4E0: 20                
E4E1: 522F4F24          DISKRO:	DEFB	'R/O$'
                        ;
                        ;   Print bdos error message.
                        ;
E4E5: E5       [11]     PRTERR:	PUSH	HL		;save second message pointer.
E4E6: CDC9E5   [28]     	CALL	OUTCRLF		;send (cr)(lf).
E4E9: 3A42E7   [41]     	LD	A,(ACTIVE)	;get active drive.
E4EC: C641     [48]     	ADD	A,'A'		;make ascii.
E4EE: 32C6E4   [61]     	LD	(BDOSDRV),A	;and put in message.
E4F1: 01BAE4   [71]     	LD	BC,BDOSERR	;and print it.
E4F4: CDD3E5   [88]     	CALL	PRTMESG
E4F7: C1       [98]     	POP	BC		;print second message line now.
E4F8: CDD3E5   [115]    	CALL	PRTMESG
                        ;
                        ;   Get an input character. We will check our 1 character
                        ; buffer first. This may be set by the console status routine.
                        ;
E4FB: 210EE7   [10]     GETCHAR:LD	HL,CHARBUF	;check character buffer.
E4FE: 7E       [17]     	LD	A,(HL)		;anything present already?
E4FF: 3600     [27]     	LD	(HL),0		;...either case clear it.
E501: B7       [31]     	OR	A
E502: C0       [36|42]  	RET	NZ		;yes, use it.
E503: C309F2   [46]     	JP	CONIN		;nope, go get a character responce.
                        ;
                        ;   Input and echo a character.
                        ;
E506: CDFBE4   [17]     GETECHO:CALL	GETCHAR		;input a character.
E509: CD14E5   [34]     	CALL	CHKCHAR		;carriage control?
E50C: D8       [39|45]  	RET	C		;no, a regular control char so don't echo.
E50D: F5       [50]     	PUSH	AF		;ok, save character now.
E50E: 4F       [54]     	LD	C,A
E50F: CD90E5   [71]     	CALL	OUTCON		;and echo it.
E512: F1       [81]     	POP	AF		;get character and return.
E513: C9       [91]     	RET	
                        ;
                        ;   Check character in (A). Set the zero flag on a carriage
                        ; control character and the carry flag on any other control
                        ; character.
                        ;
E514: FE0D     [ 7]     CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
E516: C8       [12|18]  	RET	Z		;or a tab.
E517: FE0A     [19]     	CP	LF
E519: C8       [24|30]  	RET	Z
E51A: FE09     [31]     	CP	TAB
E51C: C8       [36|42]  	RET	Z
E51D: FE08     [43]     	CP	BS
E51F: C8       [48|54]  	RET	Z
E520: FE20     [55]     	CP	' '		;other control char? Set carry flag.
E522: C9       [65]     	RET	
                        ;
                        ;   Check the console during output. Halt on a control-s, then
                        ; reboot on a control-c. If anything else is ready, clear the
                        ; zero flag and return (the calling routine may want to do
                        ; something).
                        ;
E523: 3A0EE7   [13]     CKCONSOL: LD	A,(CHARBUF)	;check buffer.
E526: B7       [17]     	OR	A		;if anything, just return without checking.
E527: C245E5   [27|27]  	JP	NZ,CKCON2
E52A: CD06F2   [44]     	CALL	CONST		;nothing in buffer. Check console.
E52D: E601     [51]     	AND	01H		;look at bit 0.
E52F: C8       [56|62]  	RET	Z		;return if nothing.
E530: CD09F2   [73]     	CALL	CONIN		;ok, get it.
E533: FE13     [80]     	CP	CNTRLS		;if not control-s, return with zero cleared.
E535: C242E5   [90|90]  	JP	NZ,CKCON1
E538: CD09F2   [107]    	CALL	CONIN		;halt processing until another char
E53B: FE03     [114]    	CP	CNTRLC		;is typed. Control-c?
E53D: CA0000   [124|124]	JP	Z,0		;yes, reboot now.
E540: AF       [128]    	XOR	A		;no, just pretend nothing was ever ready.
E541: C9       [138]    	RET	
E542: 320EE7   [13]     CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
E545: 3E01     [ 7]     CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
E547: C9       [17]     	RET	
                        ;
                        ;   Output (C) to the screen. If the printer flip-flop flag
                        ; is set, we will send character to printer also. The console
                        ; will be checked in the process.
                        ;
E548: 3A0AE7   [13]     OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
E54B: B7       [17]     	OR	A		;anything and we won't generate output.
E54C: C262E5   [27|27]  	JP	NZ,OUTCHR1
E54F: C5       [38]     	PUSH	BC
E550: CD23E5   [55]     	CALL	CKCONSOL	;check console (we don't care whats there).
E553: C1       [65]     	POP	BC
E554: C5       [76]     	PUSH	BC
E555: CD0CF2   [93]     	CALL	CONOUT		;output (C) to the screen.
E558: C1       [103]    	POP	BC
E559: C5       [114]    	PUSH	BC
E55A: 3A0DE7   [127]    	LD	A,(PRTFLAG)	;check printer flip-flop flag.
E55D: B7       [131]    	OR	A
E55E: C40FF2   [141|148]	CALL	NZ,LIST		;print it also if non-zero.
E561: C1       [151]    	POP	BC
E562: 79       [ 4]     OUTCHR1:LD	A,C		;update cursors position.
E563: 210CE7   [14]     	LD	HL,CURPOS
E566: FE7F     [21]     	CP	DEL		;rubouts don't do anything here.
E568: C8       [26|32]  	RET	Z
E569: 34       [37]     	INC	(HL)		;bump line pointer.
E56A: FE20     [44]     	CP	' '		;and return if a normal character.
E56C: D0       [49|55]  	RET	NC
E56D: 35       [60]     	DEC	(HL)		;restore and check for the start of the line.
E56E: 7E       [67]     	LD	A,(HL)
E56F: B7       [71]     	OR	A
E570: C8       [76|82]  	RET	Z		;ingnore control characters at the start of the line.
E571: 79       [80]     	LD	A,C
E572: FE08     [87]     	CP	BS		;is it a backspace?
E574: C279E5   [97|97]  	JP	NZ,OUTCHR2
E577: 35       [108]    	DEC	(HL)		;yes, backup pointer.
E578: C9       [118]    	RET	
E579: FE0A     [ 7]     OUTCHR2:CP	LF		;is it a line feed?
E57B: C0       [12|18]  	RET	NZ		;ignore anything else.
E57C: 3600     [22]     	LD	(HL),0		;reset pointer to start of line.
E57E: C9       [32]     	RET	
                        ;
                        ;   Output (A) to the screen. If it is a control character
                        ; (other than carriage control), use ^x format.
                        ;
E57F: 79       [ 4]     SHOWIT:	LD	A,C
E580: CD14E5   [21]     	CALL	CHKCHAR		;check character.
E583: D290E5   [31|31]  	JP	NC,OUTCON	;not a control, use normal output.
E586: F5       [42]     	PUSH	AF
E587: 0E5E     [49]     	LD	C,'^'		;for a control character, preceed it with '^'.
E589: CD48E5   [66]     	CALL	OUTCHAR
E58C: F1       [76]     	POP	AF
E58D: F640     [83]     	OR	'@'		;and then use the letter equivelant.
E58F: 4F       [87]     	LD	C,A
                        ;
                        ;   Function to output (C) to the console device and expand tabs
                        ; if necessary.
                        ;
E590: 79       [ 4]     OUTCON:	LD	A,C
E591: FE09     [11]     	CP	TAB		;is it a tab?
E593: C248E5   [21|21]  	JP	NZ,OUTCHAR	;use regular output.
E596: 0E20     [ 7]     OUTCON1:LD	C,' '		;yes it is, use spaces instead.
E598: CD48E5   [24]     	CALL	OUTCHAR
E59B: 3A0CE7   [37]     	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
                        
E59E: E607     [44]     	AND	07H		;position.
E5A0: C296E5   [54|54]  	JP	NZ,OUTCON1
E5A3: C9       [64]     	RET	
                        ;
                        ;   Echo a backspace character. Erase the prevoius character
                        ; on the screen.
                        ;
E5A4: CDACE5   [17]     BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
E5A7: 0E20     [24]     	LD	C,' '		;then blank that character.
E5A9: CD0CF2   [41]     	CALL	CONOUT
E5AC: 0E08     [ 7]     BACKUP1:LD	C,BS		;then back space once more.
E5AE: C30CF2   [17]     	JP	CONOUT
                        ;
                        ;   Signal a deleted line. Print a '#' at the end and start
                        ; over.
                        ;
E5B1: 0E23     [ 7]     NEWLINE:LD	C,'#'
E5B3: CD48E5   [24]     	CALL	OUTCHAR		;print this.
E5B6: CDC9E5   [41]     	CALL	OUTCRLF		;start new line.
E5B9: 3A0CE7   [13]     NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
E5BC: 210BE7   [23]     	LD	HL,STARTING
E5BF: BE       [30]     	CP	(HL)
E5C0: D0       [35|41]  	RET	NC		;there yet?
E5C1: 0E20     [42]     	LD	C,' '
E5C3: CD48E5   [59]     	CALL	OUTCHAR		;nope, keep going.
E5C6: C3B9E5   [69]     	JP	NEWLN1
                        ;
                        ;   Output a (cr) (lf) to the console device (screen).
                        ;
E5C9: 0E0D     [ 7]     OUTCRLF:LD	C,CR
E5CB: CD48E5   [24]     	CALL	OUTCHAR
E5CE: 0E0A     [31]     	LD	C,LF
E5D0: C348E5   [41]     	JP	OUTCHAR
                        ;
                        ;   Print message pointed to by (BC). It will end with a '$'.
                        ;
E5D3: 0A       [ 7]     PRTMESG:LD	A,(BC)		;check for terminating character.
E5D4: FE24     [14]     	CP	'$'
E5D6: C8       [19|25]  	RET	Z
E5D7: 03       [25]     	INC	BC
E5D8: C5       [36]     	PUSH	BC		;otherwise, bump pointer and print it.
E5D9: 4F       [40]     	LD	C,A
E5DA: CD90E5   [57]     	CALL	OUTCON
E5DD: C1       [67]     	POP	BC
E5DE: C3D3E5   [77]     	JP	PRTMESG
                        ;
                        ;   Function to execute a buffered read.
                        ;
E5E1: 3A0CE7   [13]     RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
E5E4: 320BE7   [26]     	LD	(STARTING),A
E5E7: 2A43E7   [42]     	LD	HL,(PARAMS)	;get the maximum buffer space.
E5EA: 4E       [49]     	LD	C,(HL)
E5EB: 23       [55]     	INC	HL		;point to first available space.
E5EC: E5       [66]     	PUSH	HL		;and save.
E5ED: 0600     [73]     	LD	B,0		;keep a character count.
E5EF: C5       [11]     RDBUF1:	PUSH	BC
E5F0: E5       [22]     	PUSH	HL
E5F1: CDFBE4   [17]     RDBUF2:	CALL	GETCHAR		;get the next input character.
E5F4: E67F     [24]     	AND	7FH		;strip bit 7.
E5F6: E1       [34]     	POP	HL		;reset registers.
E5F7: C1       [44]     	POP	BC
E5F8: FE0D     [51]     	CP	CR		;en of the line?
E5FA: CAC1E6   [61|61]  	JP	Z,RDBUF17
E5FD: FE0A     [68]     	CP	LF
E5FF: CAC1E6   [78|78]  	JP	Z,RDBUF17
E602: FE08     [85]     	CP	BS		;how about a backspace?
E604: C216E6   [95|95]  	JP	NZ,RDBUF3
E607: 78       [99]     	LD	A,B		;yes, but ignore at the beginning of the line.
E608: B7       [103]    	OR	A
E609: CAEFE5   [113|113]	JP	Z,RDBUF1
E60C: 05       [117]    	DEC	B		;ok, update counter.
E60D: 3A0CE7   [130]    	LD	A,(CURPOS)	;if we backspace to the start of the line,
E610: 320AE7   [143]    	LD	(OUTFLAG),A	;treat as a cancel (control-x).
E613: C370E6   [153]    	JP	RDBUF10
E616: FE7F     [ 7]     RDBUF3:	CP	DEL		;user typed a rubout?
E618: C226E6   [17|17]  	JP	NZ,RDBUF4
E61B: 78       [21]     	LD	A,B		;ignore at the start of the line.
E61C: B7       [25]     	OR	A
E61D: CAEFE5   [35|35]  	JP	Z,RDBUF1
E620: 7E       [42]     	LD	A,(HL)		;ok, echo the prevoius character.
E621: 05       [46]     	DEC	B		;and reset pointers (counters).
E622: 2B       [52]     	DEC	HL
E623: C3A9E6   [62]     	JP	RDBUF15
E626: FE05     [ 7]     RDBUF4:	CP	CNTRLE		;physical end of line?
E628: C237E6   [17|17]  	JP	NZ,RDBUF5
E62B: C5       [28]     	PUSH	BC		;yes, do it.
E62C: E5       [39]     	PUSH	HL
E62D: CDC9E5   [56]     	CALL	OUTCRLF
E630: AF       [60]     	XOR	A		;and update starting position.
E631: 320BE7   [73]     	LD	(STARTING),A
E634: C3F1E5   [83]     	JP	RDBUF2
E637: FE10     [ 7]     RDBUF5:	CP	CNTRLP		;control-p?
E639: C248E6   [17|17]  	JP	NZ,RDBUF6
E63C: E5       [28]     	PUSH	HL		;yes, flip the print flag filp-flop byte.
E63D: 210DE7   [38]     	LD	HL,PRTFLAG
E640: 3E01     [45]     	LD	A,1		;PRTFLAG=1-PRTFLAG
E642: 96       [52]     	SUB	(HL)
E643: 77       [59]     	LD	(HL),A
E644: E1       [69]     	POP	HL
E645: C3EFE5   [79]     	JP	RDBUF1
E648: FE18     [ 7]     RDBUF6:	CP	CNTRLX		;control-x (cancel)?
E64A: C25FE6   [17|17]  	JP	NZ,RDBUF8
E64D: E1       [27]     	POP	HL
E64E: 3A0BE7   [13]     RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
E651: 210CE7   [23]     	LD	HL,CURPOS
E654: BE       [30]     	CP	(HL)
E655: D2E1E5   [40|40]  	JP	NC,RDBUFF	;done yet?
E658: 35       [51]     	DEC	(HL)		;no, decrement pointer and output back up one space.
E659: CDA4E5   [68]     	CALL	BACKUP
E65C: C34EE6   [78]     	JP	RDBUF7
E65F: FE15     [ 7]     RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
E661: C26BE6   [17|17]  	JP	NZ,RDBUF9
E664: CDB1E5   [34]     	CALL	NEWLINE		;start a new line.
E667: E1       [44]     	POP	HL
E668: C3E1E5   [54]     	JP	RDBUFF
E66B: FE12     [ 7]     RDBUF9:	CP	CNTRLR		;control-r?
E66D: C2A6E6   [17|17]  	JP	NZ,RDBUF14
E670: C5       [11]     RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
E671: CDB1E5   [28]     	CALL	NEWLINE
E674: C1       [38]     	POP	BC
E675: E1       [48]     	POP	HL
E676: E5       [59]     	PUSH	HL
E677: C5       [70]     	PUSH	BC
E678: 78       [ 4]     RDBUF11:LD	A,B		;done whole line yet?
E679: B7       [ 8]     	OR	A
E67A: CA8AE6   [18|18]  	JP	Z,RDBUF12
E67D: 23       [24]     	INC	HL		;nope, get next character.
E67E: 4E       [31]     	LD	C,(HL)
E67F: 05       [35]     	DEC	B		;count it.
E680: C5       [46]     	PUSH	BC
E681: E5       [57]     	PUSH	HL
E682: CD7FE5   [74]     	CALL	SHOWIT		;and display it.
E685: E1       [84]     	POP	HL
E686: C1       [94]     	POP	BC
E687: C378E6   [104]    	JP	RDBUF11
E68A: E5       [11]     RDBUF12:PUSH	HL		;done with line. If we were displaying
E68B: 3A0AE7   [24]     	LD	A,(OUTFLAG)	;then update cursor position.
E68E: B7       [28]     	OR	A
E68F: CAF1E5   [38|38]  	JP	Z,RDBUF2
E692: 210CE7   [48]     	LD	HL,CURPOS	;because this line is shorter, we must
E695: 96       [55]     	SUB	(HL)		;back up the cursor (not the screen however)
E696: 320AE7   [68]     	LD	(OUTFLAG),A	;some number of positions.
E699: CDA4E5   [17]     RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
E69C: 210AE7   [27]     	LD	HL,OUTFLAG	;zero, the screen will not be changed.
E69F: 35       [38]     	DEC	(HL)
E6A0: C299E6   [48|48]  	JP	NZ,RDBUF13
E6A3: C3F1E5   [58]     	JP	RDBUF2		;now just get the next character.
                        ;
                        ;   Just a normal character, put this in our buffer and echo.
                        ;
E6A6: 23       [ 6]     RDBUF14:INC	HL
E6A7: 77       [13]     	LD	(HL),A		;store character.
E6A8: 04       [17]     	INC	B		;and count it.
E6A9: C5       [11]     RDBUF15:PUSH	BC
E6AA: E5       [22]     	PUSH	HL
E6AB: 4F       [26]     	LD	C,A		;echo it now.
E6AC: CD7FE5   [43]     	CALL	SHOWIT
E6AF: E1       [53]     	POP	HL
E6B0: C1       [63]     	POP	BC
E6B1: 7E       [70]     	LD	A,(HL)		;was it an abort request?
E6B2: FE03     [77]     	CP	CNTRLC		;control-c abort?
E6B4: 78       [81]     	LD	A,B
E6B5: C2BDE6   [91|91]  	JP	NZ,RDBUF16
E6B8: FE01     [98]     	CP	1		;only if at start of line.
E6BA: CA0000   [108|108]	JP	Z,0
E6BD: B9       [ 4]     RDBUF16:CP	C		;nope, have we filled the buffer?
E6BE: DAEFE5   [14|14]  	JP	C,RDBUF1
E6C1: E1       [10]     RDBUF17:POP	HL		;yes end the line and return.
E6C2: 70       [17]     	LD	(HL),B
E6C3: 0E0D     [24]     	LD	C,CR
E6C5: C348E5   [34]     	JP	OUTCHAR		;output (cr) and return.
                        ;
                        ;   Function to get a character from the console device.
                        ;
E6C8: CD06E5   [17]     GETCON:	CALL	GETECHO		;get and echo.
E6CB: C301E7   [27]     	JP	SETSTAT		;save status and return.
                        ;
                        ;   Function to get a character from the tape reader device.
                        ;
E6CE: CD15F2   [17]     GETRDR:	CALL	READER		;get a character from reader, set status and return.
E6D1: C301E7   [27]     	JP	SETSTAT
                        ;
                        ;  Function to perform direct console i/o. If (C) contains (FF)
                        ; then this is an input request. If (C) contains (FE) then
                        ; this is a status request. Otherwise we are to output (C).
                        ;
E6D4: 79       [ 4]     DIRCIO:	LD	A,C		;test for (FF).
E6D5: 3C       [ 8]     	INC	A
E6D6: CAE0E6   [18|18]  	JP	Z,DIRC1
E6D9: 3C       [22]     	INC	A		;test for (FE).
E6DA: CA06F2   [32|32]  	JP	Z,CONST
E6DD: C30CF2   [42]     	JP	CONOUT		;just output (C).
E6E0: CD06F2   [17]     DIRC1:	CALL	CONST		;this is an input request.
E6E3: B7       [21]     	OR	A
E6E4: CA91F1   [31|31]  	JP	Z,GOBACK1	;not ready? Just return (directly).
E6E7: CD09F2   [48]     	CALL	CONIN		;yes, get character.
E6EA: C301E7   [58]     	JP	SETSTAT		;set status and return.
                        ;
                        ;   Function to return the i/o byte.
                        ;
E6ED: 3A0300   [13]     GETIOB:	LD	A,(IOBYTE)
E6F0: C301E7   [23]     	JP	SETSTAT
                        ;
                        ;   Function to set the i/o byte.
                        ;
E6F3: 210300   [10]     SETIOB:	LD	HL,IOBYTE
E6F6: 71       [17]     	LD	(HL),C
E6F7: C9       [27]     	RET	
                        ;
                        ;   Function to print the character string pointed to by (DE)
                        ; on the console device. The string ends with a '$'.
                        ;
E6F8: EB       [ 4]     PRTSTR:	EX	DE,HL
E6F9: 4D       [ 8]     	LD	C,L
E6FA: 44       [12]     	LD	B,H		;now (BC) points to it.
E6FB: C3D3E5   [22]     	JP	PRTMESG
                        ;
                        ;   Function to interigate the console device.
                        ;
E6FE: CD23E5   [17]     GETCSTS:CALL	CKCONSOL
                        ;
                        ;   Get here to set the status and return to the cleanup
                        ; section. Then back to the user.
                        ;
E701: 3245E7   [13]     SETSTAT:LD	(STATUS),A
E704: C9       [10]     RTN:	RET	
                        ;
                        ;   Set the status to 1 (read or write error code).
                        ;
E705: 3E01     [ 7]     IOERR1:	LD	A,1
E707: C301E7   [17]     	JP	SETSTAT
                        ;
E70A: 00                OUTFLAG:DEFB	0		;output flag (non zero means no output).
E70B: 02                STARTING: DEFB	2		;starting position for cursor.
E70C: 00                CURPOS:	DEFB	0		;cursor position (0=start of line).
E70D: 00                PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
E70E: 00                CHARBUF:DEFB	0		;single input character buffer.
                        ;
                        ;   Stack area for BDOS calls.
                        ;
E70F: 0000              USRSTACK: DEFW	0		;save users stack pointer here.
                        ;
E711: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E715: 00...             
E729: 00000000          	DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
E72D: 00...             
E741:                   STKAREA EQU	$		;end of stack area.
                        ;
E741: 00                USERNO:	DEFB	0		;current user number.
E742: 00                ACTIVE:	DEFB	0		;currently active drive.
E743: 0000              PARAMS:	DEFW	0		;save (DE) parameters here on entry.
E745: 0000              STATUS:	DEFW	0		;status returned from bdos function.
                        ;
                        ;   Select error occured, jump to error routine.
                        ;
E747: 210BE4   [10]     SLCTERR:LD	HL,BADSLCT
                        ;
                        ;   Jump to (HL) indirectly.
                        ;
E74A: 5E       [ 7]     JUMPHL:	LD	E,(HL)
E74B: 23       [13]     	INC	HL
E74C: 56       [20]     	LD	D,(HL)		;now (DE) contain the desired address.
E74D: EB       [24]     	EX	DE,HL
E74E: E9       [28]     	JP	(HL)
                        ;
                        ;   Block move. (DE) to (HL), (C) bytes total.
                        ;
E74F: 0C       [ 4]     DE2HL:	INC	C		;is count down to zero?
E750: 0D       [ 4]     DE2HL1:	DEC	C
E751: C8       [ 9|15]  	RET	Z		;yes, we are done.
E752: 1A       [16]     	LD	A,(DE)		;no, move one more byte.
E753: 77       [23]     	LD	(HL),A
E754: 13       [29]     	INC	DE
E755: 23       [35]     	INC	HL
E756: C350E7   [45]     	JP	DE2HL1		;and repeat.
                        ;
                        ;   Select the desired drive.
                        ;
E759: 3A42E7   [13]     SELECT:	LD	A,(ACTIVE)	;get active disk.
E75C: 4F       [17]     	LD	C,A
E75D: CD1BF2   [34]     	CALL	SELDSK		;select it.
E760: 7C       [38]     	LD	A,H		;valid drive?
E761: B5       [42]     	OR	L		;valid drive?
E762: C8       [47|53]  	RET	Z		;return if not.
                        ;
                        ;   Here, the BIOS returned the address of the parameter block
                        ; in (HL). We will extract the necessary pointers and save them.
                        ;
E763: 5E       [54]     	LD	E,(HL)		;yes, get address of translation table into (DE).
E764: 23       [60]     	INC	HL
E765: 56       [67]     	LD	D,(HL)
E766: 23       [73]     	INC	HL
E767: 22B3F1   [89]     	LD	(SCRATCH1),HL	;save pointers to scratch areas.
E76A: 23       [95]     	INC	HL
E76B: 23       [101]    	INC	HL
E76C: 22B5F1   [117]    	LD	(SCRATCH2),HL	;ditto.
E76F: 23       [123]    	INC	HL
E770: 23       [129]    	INC	HL
E771: 22B7F1   [145]    	LD	(SCRATCH3),HL	;ditto.
E774: 23       [151]    	INC	HL
E775: 23       [157]    	INC	HL
E776: EB       [161]    	EX	DE,HL		;now save the translation table address.
E777: 22D0F1   [177]    	LD	(XLATE),HL
E77A: 21B9F1   [187]    	LD	HL,DIRBUF	;put the next 8 bytes here.
E77D: 0E08     [194]    	LD	C,8		;they consist of the directory buffer
E77F: CD4FE7   [211]    	CALL	DE2HL		;pointer, parameter block pointer,
E782: 2ABBF1   [227]    	LD	HL,(DISKPB)	;check and allocation vectors.
E785: EB       [231]    	EX	DE,HL
E786: 21C1F1   [241]    	LD	HL,SECTORS	;move parameter block into our ram.
E789: 0E0F     [248]    	LD	C,15		;it is 15 bytes long.
E78B: CD4FE7   [265]    	CALL	DE2HL
E78E: 2AC6F1   [281]    	LD	HL,(DSKSIZE)	;check disk size.
E791: 7C       [285]    	LD	A,H		;more than 256 blocks on this?
E792: 21DDF1   [295]    	LD	HL,BIGDISK
E795: 36FF     [305]    	LD	(HL),0FFH	;set to samll.
E797: B7       [309]    	OR	A
E798: CA9DE7   [319|319]	JP	Z,SELECT1
E79B: 3600     [329]    	LD	(HL),0		;wrong, set to large.
E79D: 3EFF     [ 7]     SELECT1:LD	A,0FFH		;clear the zero flag.
E79F: B7       [11]     	OR	A
E7A0: C9       [21]     	RET	
                        ;
                        ;   Routine to home the disk track head and clear pointers.
                        ;
E7A1: CD18F2   [17]     HOMEDRV:CALL	HOME		;home the head.
E7A4: AF       [21]     	XOR	A
E7A5: 2AB5F1   [37]     	LD	HL,(SCRATCH2)	;set our track pointer also.
E7A8: 77       [44]     	LD	(HL),A
E7A9: 23       [50]     	INC	HL
E7AA: 77       [57]     	LD	(HL),A
E7AB: 2AB7F1   [73]     	LD	HL,(SCRATCH3)	;and our sector pointer.
E7AE: 77       [80]     	LD	(HL),A
E7AF: 23       [86]     	INC	HL
E7B0: 77       [93]     	LD	(HL),A
E7B1: C9       [103]    	RET	
                        ;
                        ;   Do the actual disk read and check the error return status.
                        ;
E7B2: CD27F2   [17]     DOREAD:	CALL	READ
E7B5: C3BBE7   [27]     	JP	IORET
                        ;
                        ;   Do the actual disk write and handle any bios error.
                        ;
E7B8: CD2AF2   [17]     DOWRITE:CALL	WRITE
E7BB: B7       [ 4]     IORET:	OR	A
E7BC: C8       [ 9|15]  	RET	Z		;return unless an error occured.
E7BD: 2109E4   [19]     	LD	HL,BADSCTR	;bad read/write on this sector.
E7C0: C34AE7   [29]     	JP	JUMPHL
                        ;
                        ;   Routine to select the track and sector that the desired
                        ; block number falls in.
                        ;
E7C3: 2AEAF1   [16]     TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
E7C6: 0E02     [23]     	LD	C,2		;in directory and compute sector #.
E7C8: CDEAE8   [40]     	CALL	SHIFTR		;sector #=file-position/4.
E7CB: 22E5F1   [56]     	LD	(BLKNMBR),HL	;save this as the block number of interest.
E7CE: 22ECF1   [72]     	LD	(CKSUMTBL),HL	;what's it doing here too?
                        ;
                        ;   if the sector number has already been set (BLKNMBR), enter
                        ; at this point.
                        ;
E7D1: 21E5F1   [10]     TRKSEC1:LD	HL,BLKNMBR
E7D4: 4E       [17]     	LD	C,(HL)		;move sector number into (BC).
E7D5: 23       [23]     	INC	HL
E7D6: 46       [30]     	LD	B,(HL)
E7D7: 2AB7F1   [46]     	LD	HL,(SCRATCH3)	;get current sector number and
E7DA: 5E       [53]     	LD	E,(HL)		;move this into (DE).
E7DB: 23       [59]     	INC	HL
E7DC: 56       [66]     	LD	D,(HL)
E7DD: 2AB5F1   [82]     	LD	HL,(SCRATCH2)	;get current track number.
E7E0: 7E       [89]     	LD	A,(HL)		;and this into (HL).
E7E1: 23       [95]     	INC	HL
E7E2: 66       [102]    	LD	H,(HL)
E7E3: 6F       [106]    	LD	L,A
E7E4: 79       [ 4]     TRKSEC2:LD	A,C		;is desired sector before current one?
E7E5: 93       [ 8]     	SUB	E
E7E6: 78       [12]     	LD	A,B
E7E7: 9A       [16]     	SBC	A,D
E7E8: D2FAE7   [26|26]  	JP	NC,TRKSEC3
E7EB: E5       [37]     	PUSH	HL		;yes, decrement sectors by one track.
E7EC: 2AC1F1   [53]     	LD	HL,(SECTORS)	;get sectors per track.
E7EF: 7B       [57]     	LD	A,E
E7F0: 95       [61]     	SUB	L
E7F1: 5F       [65]     	LD	E,A
E7F2: 7A       [69]     	LD	A,D
E7F3: 9C       [73]     	SBC	A,H
E7F4: 57       [77]     	LD	D,A		;now we have backed up one full track.
E7F5: E1       [87]     	POP	HL
E7F6: 2B       [93]     	DEC	HL		;adjust track counter.
E7F7: C3E4E7   [103]    	JP	TRKSEC2
E7FA: E5       [11]     TRKSEC3:PUSH	HL		;desired sector is after current one.
E7FB: 2AC1F1   [27]     	LD	HL,(SECTORS)	;get sectors per track.
E7FE: 19       [38]     	ADD	HL,DE		;bump sector pointer to next track.
E7FF: DA0FE8   [48|48]  	JP	C,TRKSEC4
E802: 79       [52]     	LD	A,C		;is desired sector now before current one?
E803: 95       [56]     	SUB	L
E804: 78       [60]     	LD	A,B
E805: 9C       [64]     	SBC	A,H
E806: DA0FE8   [74|74]  	JP	C,TRKSEC4
E809: EB       [78]     	EX	DE,HL		;not yes, increment track counter
E80A: E1       [88]     	POP	HL		;and continue until it is.
E80B: 23       [94]     	INC	HL
E80C: C3FAE7   [104]    	JP	TRKSEC3
                        ;
                        ;   here we have determined the track number that contains the
                        ; desired sector.
                        ;
E80F: E1       [10]     TRKSEC4:POP	HL		;get track number (HL).
E810: C5       [21]     	PUSH	BC
E811: D5       [32]     	PUSH	DE
E812: E5       [43]     	PUSH	HL
E813: EB       [47]     	EX	DE,HL
E814: 2ACEF1   [63]     	LD	HL,(OFFSET)	;adjust for first track offset.
E817: 19       [74]     	ADD	HL,DE
E818: 44       [78]     	LD	B,H
E819: 4D       [82]     	LD	C,L
E81A: CD1EF2   [99]     	CALL	SETTRK		;select this track.
E81D: D1       [109]    	POP	DE		;reset current track pointer.
E81E: 2AB5F1   [125]    	LD	HL,(SCRATCH2)
E821: 73       [132]    	LD	(HL),E
E822: 23       [138]    	INC	HL
E823: 72       [145]    	LD	(HL),D
E824: D1       [155]    	POP	DE
E825: 2AB7F1   [171]    	LD	HL,(SCRATCH3)	;reset the first sector on this track.
E828: 73       [178]    	LD	(HL),E
E829: 23       [184]    	INC	HL
E82A: 72       [191]    	LD	(HL),D
E82B: C1       [201]    	POP	BC
E82C: 79       [205]    	LD	A,C		;now subtract the desired one.
E82D: 93       [209]    	SUB	E		;to make it relative (1-# sectors/track).
E82E: 4F       [213]    	LD	C,A
E82F: 78       [217]    	LD	A,B
E830: 9A       [221]    	SBC	A,D
E831: 47       [225]    	LD	B,A
E832: 2AD0F1   [241]    	LD	HL,(XLATE)	;translate this sector according to this table.
E835: EB       [245]    	EX	DE,HL
E836: CD30F2   [262]    	CALL	SECTRN		;let the bios translate it.
E839: 4D       [266]    	LD	C,L
E83A: 44       [270]    	LD	B,H
E83B: C321F2   [280]    	JP	SETSEC		;and select it.
                        ;
                        ;   Compute block number from record number (SAVNREC) and
                        ; extent number (SAVEXT).
                        ;
E83E: 21C3F1   [10]     GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
E841: 4E       [17]     	LD	C,(HL)		;note that this is base 2 log of ratio.
E842: 3AE3F1   [30]     	LD	A,(SAVNREC)	;get record number.
E845: B7       [ 4]     GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
E846: 1F       [ 8]     	RRA	
E847: 0D       [12]     	DEC	C
E848: C245E8   [22|22]  	JP	NZ,GETBLK1
E84B: 47       [26]     	LD	B,A		;save result in (B).
E84C: 3E08     [33]     	LD	A,8
E84E: 96       [40]     	SUB	(HL)
E84F: 4F       [44]     	LD	C,A		;compute (C)=8-BLKSHFT.
E850: 3AE2F1   [57]     	LD	A,(SAVEXT)
E853: 0D       [ 4]     GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
E854: CA5CE8   [14|14]  	JP	Z,GETBLK3
E857: B7       [18]     	OR	A
E858: 17       [22]     	RLA	
E859: C353E8   [32]     	JP	GETBLK2
E85C: 80       [ 4]     GETBLK3:ADD	A,B
E85D: C9       [14]     	RET	
                        ;
                        ;   Routine to extract the (BC) block byte from the fcb pointed
                        ; to by (PARAMS). If this is a big-disk, then these are 16 bit
                        ; block numbers, else they are 8 bit numbers.
                        ; Number is returned in (HL).
                        ;
E85E: 2A43E7   [16]     EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
E861: 111000   [26]     	LD	DE,16		;block numbers start 16 bytes into fcb.
E864: 19       [37]     	ADD	HL,DE
E865: 09       [48]     	ADD	HL,BC
E866: 3ADDF1   [61]     	LD	A,(BIGDISK)	;are we using a big-disk?
E869: B7       [65]     	OR	A
E86A: CA71E8   [75|75]  	JP	Z,EXTBLK1
E86D: 6E       [82]     	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
E86E: 2600     [89]     	LD	H,0
E870: C9       [99]     	RET	
E871: 09       [11]     EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
E872: 5E       [18]     	LD	E,(HL)
E873: 23       [24]     	INC	HL
E874: 56       [31]     	LD	D,(HL)
E875: EB       [35]     	EX	DE,HL		;return in (HL).
E876: C9       [45]     	RET	
                        ;
                        ;   Compute block number.
                        ;
E877: CD3EE8   [17]     COMBLK:	CALL	GETBLOCK
E87A: 4F       [21]     	LD	C,A
E87B: 0600     [28]     	LD	B,0
E87D: CD5EE8   [45]     	CALL	EXTBLK
E880: 22E5F1   [61]     	LD	(BLKNMBR),HL
E883: C9       [71]     	RET	
                        ;
                        ;   Check for a zero block number (unused).
                        ;
E884: 2AE5F1   [16]     CHKBLK:	LD	HL,(BLKNMBR)
E887: 7D       [20]     	LD	A,L		;is it zero?
E888: B4       [24]     	OR	H
E889: C9       [34]     	RET	
                        ;
                        ;   Adjust physical block (BLKNMBR) and convert to logical
                        ; sector (LOGSECT). This is the starting sector of this block.
                        ; The actual sector of interest is then added to this and the
                        ; resulting sector number is stored back in (BLKNMBR). This
                        ; will still have to be adjusted for the track number.
                        ;
E88A: 3AC3F1   [13]     LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
E88D: 2AE5F1   [29]     	LD	HL,(BLKNMBR)	;get physical sector desired.
E890: 29       [11]     LOGICL1:ADD	HL,HL		;compute logical sector number.
E891: 3D       [15]     	DEC	A		;note logical sectors are 128 bytes long.
E892: C290E8   [25|25]  	JP	NZ,LOGICL1
E895: 22E7F1   [41]     	LD	(LOGSECT),HL	;save logical sector.
E898: 3AC4F1   [54]     	LD	A,(BLKMASK)	;get block mask.
E89B: 4F       [58]     	LD	C,A
E89C: 3AE3F1   [71]     	LD	A,(SAVNREC)	;get next sector to access.
E89F: A1       [75]     	AND	C		;extract the relative position within physical block.
E8A0: B5       [79]     	OR	L		;and add it too logical sector.
E8A1: 6F       [83]     	LD	L,A
E8A2: 22E5F1   [99]     	LD	(BLKNMBR),HL	;and store.
E8A5: C9       [109]    	RET	
                        ;
                        ;   Set (HL) to point to extent byte in fcb.
                        ;
E8A6: 2A43E7   [16]     SETEXT:	LD	HL,(PARAMS)
E8A9: 110C00   [26]     	LD	DE,12		;it is the twelth byte.
E8AC: 19       [37]     	ADD	HL,DE
E8AD: C9       [47]     	RET	
                        ;
                        ;   Set (HL) to point to record count byte in fcb and (DE) to
                        ; next record number byte.
                        ;
E8AE: 2A43E7   [16]     SETHLDE:LD	HL,(PARAMS)
E8B1: 110F00   [26]     	LD	DE,15		;record count byte (#15).
E8B4: 19       [37]     	ADD	HL,DE
E8B5: EB       [41]     	EX	DE,HL
E8B6: 211100   [51]     	LD	HL,17		;next record number (#32).
E8B9: 19       [62]     	ADD	HL,DE
E8BA: C9       [72]     	RET	
                        ;
                        ;   Save current file data from fcb.
                        ;
E8BB: CDAEE8   [17]     STRDATA:CALL	SETHLDE
E8BE: 7E       [24]     	LD	A,(HL)		;get and store record count byte.
E8BF: 32E3F1   [37]     	LD	(SAVNREC),A
E8C2: EB       [41]     	EX	DE,HL
E8C3: 7E       [48]     	LD	A,(HL)		;get and store next record number byte.
E8C4: 32E1F1   [61]     	LD	(SAVNXT),A
E8C7: CDA6E8   [78]     	CALL	SETEXT		;point to extent byte.
E8CA: 3AC5F1   [91]     	LD	A,(EXTMASK)	;get extent mask.
E8CD: A6       [98]     	AND	(HL)
E8CE: 32E2F1   [111]    	LD	(SAVEXT),A	;and save extent here.
E8D1: C9       [121]    	RET	
                        ;
                        ;   Set the next record to access. If (MODE) is set to 2, then
                        ; the last record byte (SAVNREC) has the correct number to access.
                        ; For sequential access, (MODE) will be equal to 1.
                        ;
E8D2: CDAEE8   [17]     SETNREC:CALL	SETHLDE
E8D5: 3AD5F1   [30]     	LD	A,(MODE)	;get sequential flag (=1).
E8D8: FE02     [37]     	CP	2		;a 2 indicates that no adder is needed.
E8DA: C2DEE8   [47|47]  	JP	NZ,STNREC1
E8DD: AF       [51]     	XOR	A		;clear adder (random access?).
E8DE: 4F       [ 4]     STNREC1:LD	C,A
E8DF: 3AE3F1   [17]     	LD	A,(SAVNREC)	;get last record number.
E8E2: 81       [21]     	ADD	A,C		;increment record count.
E8E3: 77       [28]     	LD	(HL),A		;and set fcb's next record byte.
E8E4: EB       [32]     	EX	DE,HL
E8E5: 3AE1F1   [45]     	LD	A,(SAVNXT)	;get next record byte from storage.
E8E8: 77       [52]     	LD	(HL),A		;and put this into fcb as number of records used.
E8E9: C9       [62]     	RET	
                        ;
                        ;   Shift (HL) right (C) bits.
                        ;
E8EA: 0C       [ 4]     SHIFTR:	INC	C
E8EB: 0D       [ 4]     SHIFTR1:DEC	C
E8EC: C8       [ 9|15]  	RET	Z
E8ED: 7C       [13]     	LD	A,H
E8EE: B7       [17]     	OR	A
E8EF: 1F       [21]     	RRA	
E8F0: 67       [25]     	LD	H,A
E8F1: 7D       [29]     	LD	A,L
E8F2: 1F       [33]     	RRA	
E8F3: 6F       [37]     	LD	L,A
E8F4: C3EBE8   [47]     	JP	SHIFTR1
                        ;
                        ;   Compute the check-sum for the directory buffer. Return
                        ; integer sum in (A).
                        ;
E8F7: 0E80     [ 7]     CHECKSUM: LD	C,128		;length of buffer.
E8F9: 2AB9F1   [23]     	LD	HL,(DIRBUF)	;get its location.
E8FC: AF       [27]     	XOR	A		;clear summation byte.
E8FD:                   CHKSUM1:
E8FD: 86       [ 7]     	add a, (hl) ; ADD	A,M		;and compute sum ignoring carries.
E8FE: 23       [13]     	INC	HL
E8FF: 0D       [17]     	DEC	C
E900: C2FDE8   [27|27]  	JP	NZ,CHKSUM1
E903: C9       [37]     	RET	
                        ;
                        ;   Shift (HL) left (C) bits.
                        ;
E904: 0C       [ 4]     SHIFTL:	INC	C
E905: 0D       [ 4]     SHIFTL1:DEC	C
E906: C8       [ 9|15]  	RET	Z
E907: 29       [20]     	ADD	HL,HL		;shift left 1 bit.
E908: C305E9   [30]     	JP	SHIFTL1
                        ;
                        ;   Routine to set a bit in a 16 bit value contained in (BC).
                        ; The bit set depends on the current drive selection.
                        ;
E90B: C5       [11]     SETBIT:	PUSH	BC		;save 16 bit word.
E90C: 3A42E7   [24]     	LD	A,(ACTIVE)	;get active drive.
E90F: 4F       [28]     	LD	C,A
E910: 210100   [38]     	LD	HL,1
E913: CD04E9   [55]     	CALL	SHIFTL		;shift bit 0 into place.
E916: C1       [65]     	POP	BC		;now 'or' this with the original word.
E917: 79       [69]     	LD	A,C
E918: B5       [73]     	OR	L
E919: 6F       [77]     	LD	L,A		;low byte done, do high byte.
E91A: 78       [81]     	LD	A,B
E91B: B4       [85]     	OR	H
E91C: 67       [89]     	LD	H,A
E91D: C9       [99]     	RET	
                        ;
                        ;   Extract the write protect status bit for the current drive.
                        ; The result is returned in (A), bit 0.
                        ;
E91E: 2AADF1   [16]     GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
E921: 3A42E7   [29]     	LD	A,(ACTIVE)	;which drive is current?
E924: 4F       [33]     	LD	C,A
E925: CDEAE8   [50]     	CALL	SHIFTR		;shift status such that bit 0 is the
E928: 7D       [54]     	LD	A,L		;one of interest for this drive.
E929: E601     [61]     	AND	01H		;and isolate it.
E92B: C9       [71]     	RET	
                        ;
                        ;   Function to write protect the current disk.
                        ;
E92C: 21ADF1   [10]     WRTPRTD:LD	HL,WRTPRT	;point to status word.
E92F: 4E       [17]     	LD	C,(HL)		;set (BC) equal to the status.
E930: 23       [23]     	INC	HL
E931: 46       [30]     	LD	B,(HL)
E932: CD0BE9   [47]     	CALL	SETBIT		;and set this bit according to current drive.
E935: 22ADF1   [63]     	LD	(WRTPRT),HL	;then save.
E938: 2AC8F1   [79]     	LD	HL,(DIRSIZE)	;now save directory size limit.
E93B: 23       [85]     	INC	HL		;remember the last one.
E93C: EB       [89]     	EX	DE,HL
E93D: 2AB3F1   [105]    	LD	HL,(SCRATCH1)	;and store it here.
E940: 73       [112]    	LD	(HL),E		;put low byte.
E941: 23       [118]    	INC	HL
E942: 72       [125]    	LD	(HL),D		;then high byte.
E943: C9       [135]    	RET	
                        ;
                        ;   Check for a read only file.
                        ;
E944: CD5EE9   [17]     CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
E947: 110900   [10]     CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
E94A: 19       [21]     	ADD	HL,DE
E94B: 7E       [28]     	LD	A,(HL)
E94C: 17       [32]     	RLA	
E94D: D0       [37|43]  	RET	NC		;return if ok.
E94E: 210FE4   [47]     	LD	HL,ROFILE	;else, print error message and terminate.
E951: C34AE7   [57]     	JP	JUMPHL
                        ;
                        ;   Check the write protect status of the active disk.
                        ;
E954: CD1EE9   [17]     CHKWPRT:CALL	GETWPRT
E957: C8       [22|28]  	RET	Z		;return if ok.
E958: 210DE4   [32]     	LD	HL,RODISK	;else print message and terminate.
E95B: C34AE7   [42]     	JP	JUMPHL
                        ;
                        ;   Routine to set (HL) pointing to the proper entry in the
                        ; directory buffer.
                        ;
E95E: 2AB9F1   [16]     FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
E961: 3AE9F1   [29]     	LD	A,(FCBPOS)	;relative position of file.
                        ;
                        ;   Routine to add (A) to (HL).
                        ;
E964: 85       [ 4]     ADDA2HL:ADD	A,L
E965: 6F       [ 8]     	LD	L,A
E966: D0       [13|19]  	RET	NC
E967: 24       [17]     	INC	H		;take care of any carry.
E968: C9       [27]     	RET	
                        ;
                        ;   Routine to get the 's2' byte from the fcb supplied in
                        ; the initial parameter specification.
                        ;
E969: 2A43E7   [16]     GETS2:	LD	HL,(PARAMS)	;get address of fcb.
E96C: 110E00   [26]     	LD	DE,14		;relative position of 's2'.
E96F: 19       [37]     	ADD	HL,DE
E970: 7E       [44]     	LD	A,(HL)		;extract this byte.
E971: C9       [54]     	RET	
                        ;
                        ;   Clear the 's2' byte in the fcb.
                        ;
E972: CD69E9   [17]     CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
E975: 3600     [27]     	LD	(HL),0		;now clear it.
E977: C9       [37]     	RET	
                        ;
                        ;   Set bit 7 in the 's2' byte of the fcb.
                        ;
E978: CD69E9   [17]     SETS2B7:CALL	GETS2		;get the byte.
E97B: F680     [24]     	OR	80H		;and set bit 7.
E97D: 77       [31]     	LD	(HL),A		;then store.
E97E: C9       [41]     	RET	
                        ;
                        ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
                        ; the difference. This checks to see if there are more file
                        ; names in the directory. We are at (FILEPOS) and there are
                        ; (SCRATCH1) of them to check.
                        ;
E97F: 2AEAF1   [16]     MOREFLS:LD	HL,(FILEPOS)	;we are here.
E982: EB       [20]     	EX	DE,HL
E983: 2AB3F1   [36]     	LD	HL,(SCRATCH1)	;and don't go past here.
E986: 7B       [40]     	LD	A,E		;compute difference but don't keep.
E987: 96       [47]     	SUB	(HL)
E988: 23       [53]     	INC	HL
E989: 7A       [57]     	LD	A,D
E98A: 9E       [64]     	sbc (hl); SBC	A,M		;set carry if no more names.
E98B: C9       [74]     	RET	
                        ;
                        ;   Call this routine to prevent (SCRATCH1) from being greater
                        ; than (FILEPOS).
                        ;
E98C: CD7FE9   [17]     CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
E98F: D8       [22|28]  	RET	C
E990: 13       [28]     	INC	DE		;yes, reset it to (FILEPOS).
E991: 72       [35]     	LD	(HL),D
E992: 2B       [41]     	DEC	HL
E993: 73       [48]     	LD	(HL),E
E994: C9       [58]     	RET	
                        ;
                        ;   Compute (HL)=(DE)-(HL)
                        ;
E995: 7B       [ 4]     SUBHL:	LD	A,E		;compute difference.
E996: 95       [ 8]     	SUB	L
E997: 6F       [12]     	LD	L,A		;store low byte.
E998: 7A       [16]     	LD	A,D
E999: 9C       [20]     	SBC	A,H
E99A: 67       [24]     	LD	H,A		;and then high byte.
E99B: C9       [34]     	RET	
                        ;
                        ;   Set the directory checksum byte.
                        ;
E99C: 0EFF     [ 7]     SETDIR:	LD	C,0FFH
                        ;
                        ;   Routine to set or compare the directory checksum byte. If
                        ; (C)=0ffh, then this will set the checksum byte. Else the byte
                        ; will be checked. If the check fails (the disk has been changed),
                        ; then this disk will be write protected.
                        ;
E99E: 2AECF1   [16]     CHECKDIR: LD	HL,(CKSUMTBL)
E9A1: EB       [20]     	EX	DE,HL
E9A2: 2ACCF1   [36]     	LD	HL,(ALLOC1)
E9A5: CD95E9   [53]     	CALL	SUBHL
E9A8: D0       [58|64]  	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
E9A9: C5       [69]     	PUSH	BC
E9AA: CDF7E8   [86]     	CALL	CHECKSUM	;else compute checksum.
E9AD: 2ABDF1   [102]    	LD	HL,(CHKVECT)	;get address of checksum table.
E9B0: EB       [106]    	EX	DE,HL
E9B1: 2AECF1   [122]    	LD	HL,(CKSUMTBL)
E9B4: 19       [133]    	ADD	HL,DE		;set (HL) to point to byte for this drive.
E9B5: C1       [143]    	POP	BC
E9B6: 0C       [147]    	INC	C		;set or check ?
E9B7: CAC4E9   [157|157]	JP	Z,CHKDIR1
E9BA: BE       [164]    	CP	(HL)		;check them.
E9BB: C8       [169|175]	RET	Z		;return if they are the same.
E9BC: CD7FE9   [186]    	CALL	MOREFLS		;not the same, do we care?
E9BF: D0       [191|197]	RET	NC
E9C0: CD2CE9   [208]    	CALL	WRTPRTD		;yes, mark this as write protected.
E9C3: C9       [218]    	RET	
E9C4: 77       [ 7]     CHKDIR1:LD	(HL),A		;just set the byte.
E9C5: C9       [17]     	RET	
                        ;
                        ;   Do a write to the directory of the current disk.
                        ;
E9C6: CD9CE9   [17]     DIRWRITE: CALL	SETDIR		;set checksum byte.
E9C9: CDE0E9   [34]     	CALL	DIRDMA		;set directory dma address.
E9CC: 0E01     [41]     	LD	C,1		;tell the bios to actually write.
E9CE: CDB8E7   [58]     	CALL	DOWRITE		;then do the write.
E9D1: C3DAE9   [68]     	JP	DEFDMA
                        ;
                        ;   Read from the directory.
                        ;
E9D4: CDE0E9   [17]     DIRREAD:CALL	DIRDMA		;set the directory dma address.
E9D7: CDB2E7   [34]     	CALL	DOREAD		;and read it.
                        ;
                        ;   Routine to set the dma address to the users choice.
                        ;
E9DA: 21B1F1   [10]     DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
E9DD: C3E3E9   [20]     	JP	DIRDMA1
                        ;
                        ;   Routine to set the dma address for directory work.
                        ;
E9E0: 21B9F1   [10]     DIRDMA:	LD	HL,DIRBUF
                        ;
                        ;   Set the dma address. On entry, (HL) points to
                        ; word containing the desired dma address.
                        ;
E9E3: 4E       [ 7]     DIRDMA1:LD	C,(HL)
E9E4: 23       [13]     	INC	HL
E9E5: 46       [20]     	LD	B,(HL)		;setup (BC) and go to the bios to set it.
E9E6: C324F2   [30]     	JP	SETDMA
                        ;
                        ;   Move the directory buffer into user's dma space.
                        ;
E9E9: 2AB9F1   [16]     MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
E9EC: EB       [20]     	EX	DE,HL
E9ED: 2AB1F1   [36]     	LD	HL,(USERDMA)	; put it here.
E9F0: 0E80     [43]     	LD	C,128		;this is its length.
E9F2: C34FE7   [53]     	JP	DE2HL		;move it now and return.
                        ;
                        ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
                        ;
E9F5: 21EAF1   [10]     CKFILPOS: LD	HL,FILEPOS
E9F8: 7E       [17]     	LD	A,(HL)
E9F9: 23       [23]     	INC	HL
E9FA: BE       [30]     	CP	(HL)		;are both bytes the same?
E9FB: C0       [35|41]  	RET	NZ
E9FC: 3C       [39]     	INC	A		;yes, but are they each 0ffh?
E9FD: C9       [49]     	RET	
                        ;
                        ;   Set location (FILEPOS) to 0ffffh.
                        ;
E9FE: 21FFFF   [10]     STFILPOS: LD	HL,0FFFFH
EA01: 22EAF1   [26]     	LD	(FILEPOS),HL
EA04: C9       [36]     	RET	
                        ;
                        ;   Move on to the next file position within the current
                        ; directory buffer. If no more exist, set pointer to 0ffffh
                        ; and the calling routine will check for this. Enter with (C)
                        ; equal to 0ffh to cause the checksum byte to be set, else we
                        ; will check this disk and set write protect if checksums are
                        ; not the same (applies only if another directory sector must
                        ; be read).
                        ;
EA05: 2AC8F1   [16]     NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
EA08: EB       [20]     	EX	DE,HL
EA09: 2AEAF1   [36]     	LD	HL,(FILEPOS)	;get current count.
EA0C: 23       [42]     	INC	HL		;go on to the next one.
EA0D: 22EAF1   [58]     	LD	(FILEPOS),HL
EA10: CD95E9   [75]     	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
EA13: D219EA   [85|85]  	JP	NC,NXENT1	;is there more room left?
EA16: C3FEE9   [95]     	JP	STFILPOS	;no. Set this flag and return.
EA19: 3AEAF1   [13]     NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
EA1C: E603     [20]     	AND	03H		;only look within this sector (only 4 entries fit).
EA1E: 0605     [27]     	LD	B,5		;convert to relative position (32 bytes each).
EA20: 87       [ 4]     NXENT2:	ADD	A,A		;note that this is not efficient code.
EA21: 05       [ 8]     	DEC	B		;5 'ADD A's would be better.
EA22: C220EA   [18|18]  	JP	NZ,NXENT2
EA25: 32E9F1   [31]     	LD	(FCBPOS),A	;save it as position of fcb.
EA28: B7       [35]     	OR	A
EA29: C0       [40|46]  	RET	NZ		;return if we are within buffer.
EA2A: C5       [51]     	PUSH	BC
EA2B: CDC3E7   [68]     	CALL	TRKSEC		;we need the next directory sector.
EA2E: CDD4E9   [85]     	CALL	DIRREAD
EA31: C1       [95]     	POP	BC
EA32: C39EE9   [105]    	JP	CHECKDIR
                        ;
                        ;   Routine to to get a bit from the disk space allocation
                        ; map. It is returned in (A), bit position 0. On entry to here,
                        ; set (BC) to the block number on the disk to check.
                        ; On return, (D) will contain the original bit position for
                        ; this block number and (HL) will point to the address for it.
                        ;
EA35: 79       [ 4]     CKBITMAP: LD	A,C		;determine bit number of interest.
EA36: E607     [11]     	AND	07H		;compute (D)=(E)=(C and 7)+1.
EA38: 3C       [15]     	INC	A
EA39: 5F       [19]     	LD	E,A		;save particular bit number.
EA3A: 57       [23]     	LD	D,A
                        ;
                        ;   compute (BC)=(BC)/8.
                        ;
EA3B: 79       [27]     	LD	A,C
EA3C: 0F       [31]     	RRCA			;now shift right 3 bits.
EA3D: 0F       [35]     	RRCA	
EA3E: 0F       [39]     	RRCA	
EA3F: E61F     [46]     	AND	1FH		;and clear bits 7,6,5.
EA41: 4F       [50]     	LD	C,A
EA42: 78       [54]     	LD	A,B
EA43: 87       [58]     	ADD	A,A		;now shift (B) into bits 7,6,5.
EA44: 87       [62]     	ADD	A,A
EA45: 87       [66]     	ADD	A,A
EA46: 87       [70]     	ADD	A,A
EA47: 87       [74]     	ADD	A,A
EA48: B1       [78]     	OR	C		;and add in (C).
EA49: 4F       [82]     	LD	C,A		;ok, (C) ha been completed.
EA4A: 78       [86]     	LD	A,B		;is there a better way of doing this?
EA4B: 0F       [90]     	RRCA	
EA4C: 0F       [94]     	RRCA	
EA4D: 0F       [98]     	RRCA	
EA4E: E61F     [105]    	AND	1FH
EA50: 47       [109]    	LD	B,A		;and now (B) is completed.
                        ;
                        ;   use this as an offset into the disk space allocation
                        ; table.
                        ;
EA51: 2ABFF1   [125]    	LD	HL,(ALOCVECT)
EA54: 09       [136]    	ADD	HL,BC
EA55: 7E       [143]    	LD	A,(HL)		;now get correct byte.
EA56: 07       [ 4]     CKBMAP1:RLCA			;get correct bit into position 0.
EA57: 1D       [ 8]     	DEC	E
EA58: C256EA   [18|18]  	JP	NZ,CKBMAP1
EA5B: C9       [28]     	RET	
                        ;
                        ;   Set or clear the bit map such that block number (BC) will be marked
                        ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
                        ; 1 then it will be set (don't use anyother values).
                        ;
EA5C: D5       [11]     STBITMAP: PUSH	DE
EA5D: CD35EA   [28]     	CALL	CKBITMAP	;get the byte of interest.
EA60: E6FE     [35]     	AND	0FEH		;clear the affected bit.
EA62: C1       [45]     	POP	BC
EA63: B1       [49]     	OR	C		;and now set it acording to (C).
                        ;
                        ;  entry to restore the original bit position and then store
                        ; in table. (A) contains the value, (D) contains the bit
                        ; position (1-8), and (HL) points to the address within the
                        ; space allocation table for this byte.
                        ;
EA64: 0F       [ 4]     STBMAP1:RRCA			;restore original bit position.
EA65: 15       [ 8]     	DEC	D
EA66: C264EA   [18|18]  	JP	NZ,STBMAP1
EA69: 77       [25]     	LD	(HL),A		;and stor byte in table.
EA6A: C9       [35]     	RET	
                        ;
                        ;   Set/clear space used bits in allocation map for this file.
                        ; On entry, (C)=1 to set the map and (C)=0 to clear it.
                        ;
EA6B: CD5EE9   [17]     SETFILE:CALL	FCB2HL		;get address of fcb
EA6E: 111000   [27]     	LD	DE,16
EA71: 19       [38]     	ADD	HL,DE		;get to block number bytes.
EA72: C5       [49]     	PUSH	BC
EA73: 0E11     [56]     	LD	C,17		;check all 17 bytes (max) of table.
EA75: D1       [10]     SETFL1:	POP	DE
EA76: 0D       [14]     	DEC	C		;done all bytes yet?
EA77: C8       [19|25]  	RET	Z
EA78: D5       [30]     	PUSH	DE
EA79: 3ADDF1   [43]     	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
EA7C: B7       [47]     	OR	A
EA7D: CA88EA   [57|57]  	JP	Z,SETFL2
EA80: C5       [68]     	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
EA81: E5       [79]     	PUSH	HL
EA82: 4E       [86]     	LD	C,(HL)		;get low byte from table, always
EA83: 0600     [93]     	LD	B,0		;set high byte to zero.
EA85: C38EEA   [103]    	JP	SETFL3
EA88: 0D       [ 4]     SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
EA89: C5       [15]     	PUSH	BC
EA8A: 4E       [22]     	LD	C,(HL)		;now get both the low and high bytes.
EA8B: 23       [28]     	INC	HL
EA8C: 46       [35]     	LD	B,(HL)
EA8D: E5       [46]     	PUSH	HL
EA8E: 79       [ 4]     SETFL3:	LD	A,C		;block used?
EA8F: B0       [ 8]     	OR	B
EA90: CA9DEA   [18|18]  	JP	Z,SETFL4
EA93: 2AC6F1   [34]     	LD	HL,(DSKSIZE)	;is this block number within the
EA96: 7D       [38]     	LD	A,L		;space on the disk?
EA97: 91       [42]     	SUB	C
EA98: 7C       [46]     	LD	A,H
EA99: 98       [50]     	SBC	A,B
EA9A: D45CEA   [60|67]  	CALL	NC,STBITMAP	;yes, set the proper bit.
EA9D: E1       [10]     SETFL4:	POP	HL		;point to next block number in fcb.
EA9E: 23       [16]     	INC	HL
EA9F: C1       [26]     	POP	BC
EAA0: C375EA   [36]     	JP	SETFL1
                        ;
                        ;   Construct the space used allocation bit map for the active
                        ; drive. If a file name starts with '$' and it is under the
                        ; current user number, then (STATUS) is set to minus 1. Otherwise
                        ; it is not set at all.
                        ;
EAA3: 2AC6F1   [16]     BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
EAA6: 0E03     [23]     	LD	C,3
EAA8: CDEAE8   [40]     	CALL	SHIFTR		;(HL)=(HL)/8.
EAAB: 23       [46]     	INC	HL		;at lease 1 byte.
EAAC: 44       [50]     	LD	B,H
EAAD: 4D       [54]     	LD	C,L		;set (BC) to the allocation table length.
                        ;
                        ;   Initialize the bitmap for this drive. Right now, the first
                        ; two bytes are specified by the disk parameter block. However
                        ; a patch could be entered here if it were necessary to setup
                        ; this table in a special mannor. For example, the bios could
                        ; determine locations of 'bad blocks' and set them as already
                        ; 'used' in the map.
                        ;
EAAE: 2ABFF1   [70]     	LD	HL,(ALOCVECT)	;now zero out the table now.
EAB1: 3600     [10]     BITMAP1:LD	(HL),0
EAB3: 23       [16]     	INC	HL
EAB4: 0B       [22]     	DEC	BC
EAB5: 78       [26]     	LD	A,B
EAB6: B1       [30]     	OR	C
EAB7: C2B1EA   [40|40]  	JP	NZ,BITMAP1
EABA: 2ACAF1   [56]     	LD	HL,(ALLOC0)	;get initial space used by directory.
EABD: EB       [60]     	EX	DE,HL
EABE: 2ABFF1   [76]     	LD	HL,(ALOCVECT)	;and put this into map.
EAC1: 73       [83]     	LD	(HL),E
EAC2: 23       [89]     	INC	HL
EAC3: 72       [96]     	LD	(HL),D
                        ;
                        ;   End of initialization portion.
                        ;
EAC4: CDA1E7   [113]    	CALL	HOMEDRV		;now home the drive.
EAC7: 2AB3F1   [129]    	LD	HL,(SCRATCH1)
EACA: 3603     [139]    	LD	(HL),3		;force next directory request to read
EACC: 23       [145]    	INC	HL		;in a sector.
EACD: 3600     [155]    	LD	(HL),0
EACF: CDFEE9   [172]    	CALL	STFILPOS	;clear initial file position also.
EAD2: 0EFF     [ 7]     BITMAP2:LD	C,0FFH		;read next file name in directory
EAD4: CD05EA   [24]     	CALL	NXENTRY		;and set checksum byte.
EAD7: CDF5E9   [41]     	CALL	CKFILPOS	;is there another file?
EADA: C8       [46|52]  	RET	Z
EADB: CD5EE9   [63]     	CALL	FCB2HL		;yes, get its address.
EADE: 3EE5     [70]     	LD	A,0E5H
EAE0: BE       [77]     	CP	(HL)		;empty file entry?
EAE1: CAD2EA   [87|87]  	JP	Z,BITMAP2
EAE4: 3A41E7   [100]    	LD	A,(USERNO)	;no, correct user number?
EAE7: BE       [107]    	CP	(HL)
EAE8: C2F6EA   [117|117]	JP	NZ,BITMAP3
EAEB: 23       [123]    	INC	HL
EAEC: 7E       [130]    	LD	A,(HL)		;yes, does name start with a '$'?
EAED: D624     [137]    	SUB	'$'
EAEF: C2F6EA   [147|147]	JP	NZ,BITMAP3
EAF2: 3D       [151]    	DEC	A		;yes, set atatus to minus one.
EAF3: 3245E7   [164]    	LD	(STATUS),A
EAF6: 0E01     [ 7]     BITMAP3:LD	C,1		;now set this file's space as used in bit map.
EAF8: CD6BEA   [24]     	CALL	SETFILE
EAFB: CD8CE9   [41]     	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
EAFE: C3D2EA   [51]     	JP	BITMAP2
                        ;
                        ;   Set the status (STATUS) and return.
                        ;
EB01: 3AD4F1   [13]     STSTATUS: LD	A,(FNDSTAT)
EB04: C301E7   [23]     	JP	SETSTAT
                        ;
                        ;   Check extents in (A) and (C). Set the zero flag if they
                        ; are the same. The number of 16k chunks of disk space that
                        ; the directory extent covers is expressad is (EXTMASK+1).
                        ; No registers are modified.
                        ;
EB07: C5       [11]     SAMEXT:	PUSH	BC
EB08: F5       [22]     	PUSH	AF
EB09: 3AC5F1   [35]     	LD	A,(EXTMASK)	;get extent mask and use it to
EB0C: 2F       [39]     	CPL			;to compare both extent numbers.
EB0D: 47       [43]     	LD	B,A		;save resulting mask here.
EB0E: 79       [47]     	LD	A,C		;mask first extent and save in (C).
EB0F: A0       [51]     	AND	B
EB10: 4F       [55]     	LD	C,A
EB11: F1       [65]     	POP	AF		;now mask second extent and compare
EB12: A0       [69]     	AND	B		;with the first one.
EB13: 91       [73]     	SUB	C
EB14: E61F     [80]     	AND	1FH		;(* only check buts 0-4 *)
EB16: C1       [90]     	POP	BC		;the zero flag is set if they are the same.
EB17: C9       [100]    	RET			;restore (BC) and return.
                        ;
                        ;   Search for the first occurence of a file name. On entry,
                        ; register (C) should contain the number of bytes of the fcb
                        ; that must match.
                        ;
EB18: 3EFF     [ 7]     FINDFST:LD	A,0FFH
EB1A: 32D4F1   [20]     	LD	(FNDSTAT),A
EB1D: 21D8F1   [30]     	LD	HL,COUNTER	;save character count.
EB20: 71       [37]     	LD	(HL),C
EB21: 2A43E7   [53]     	LD	HL,(PARAMS)	;get filename to match.
EB24: 22D9F1   [69]     	LD	(SAVEFCB),HL	;and save.
EB27: CDFEE9   [86]     	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
EB2A: CDA1E7   [103]    	CALL	HOMEDRV		;home the drive.
                        ;
                        ;   Entry to locate the next occurence of a filename within the
                        ; directory. The disk is not expected to have been changed. If
                        ; it was, then it will be write protected.
                        ;
EB2D: 0E00     [ 7]     FINDNXT:LD	C,0		;write protect the disk if changed.
EB2F: CD05EA   [24]     	CALL	NXENTRY		;get next filename entry in directory.
EB32: CDF5E9   [41]     	CALL	CKFILPOS	;is file position = 0ffffh?
EB35: CA94EB   [51|51]  	JP	Z,FNDNXT6	;yes, exit now then.
EB38: 2AD9F1   [67]     	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
EB3B: EB       [71]     	EX	DE,HL
EB3C: 1A       [78]     	LD	A,(DE)
EB3D: FEE5     [85]     	CP	0E5H		;empty directory entry?
EB3F: CA4AEB   [95|95]  	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
EB42: D5       [106]    	PUSH	DE
EB43: CD7FE9   [123]    	CALL	MOREFLS		;more files in directory?
EB46: D1       [133]    	POP	DE
EB47: D294EB   [143|143]	JP	NC,FNDNXT6	;no more. Exit now.
EB4A: CD5EE9   [17]     FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
EB4D: 3AD8F1   [30]     	LD	A,(COUNTER)	;get number of bytes (characters) to check.
EB50: 4F       [34]     	LD	C,A
EB51: 0600     [41]     	LD	B,0		;initialize byte position counter.
EB53: 79       [ 4]     FNDNXT2:LD	A,C		;are we done with the compare?
EB54: B7       [ 8]     	OR	A
EB55: CA83EB   [18|18]  	JP	Z,FNDNXT5
EB58: 1A       [25]     	LD	A,(DE)		;no, check next byte.
EB59: FE3F     [32]     	CP	'?'		;don't care about this character?
EB5B: CA7CEB   [42|42]  	JP	Z,FNDNXT4
EB5E: 78       [46]     	LD	A,B		;get bytes position in fcb.
EB5F: FE0D     [53]     	CP	13		;don't care about the thirteenth byte either.
EB61: CA7CEB   [63|63]  	JP	Z,FNDNXT4
EB64: FE0C     [70]     	CP	12		;extent byte?
EB66: 1A       [77]     	LD	A,(DE)
EB67: CA73EB   [87|87]  	JP	Z,FNDNXT3
EB6A: 96       [94]     	SUB	(HL)		;otherwise compare characters.
EB6B: E67F     [101]    	AND	7FH
EB6D: C22DEB   [111|111]	JP	NZ,FINDNXT	;not the same, check next entry.
EB70: C37CEB   [121]    	JP	FNDNXT4		;so far so good, keep checking.
EB73: C5       [11]     FNDNXT3:PUSH	BC		;check the extent byte here.
EB74: 4E       [18]     	LD	C,(HL)
EB75: CD07EB   [35]     	CALL	SAMEXT
EB78: C1       [45]     	POP	BC
EB79: C22DEB   [55|55]  	JP	NZ,FINDNXT	;not the same, look some more.
                        ;
                        ;   So far the names compare. Bump pointers to the next byte
                        ; and continue until all (C) characters have been checked.
                        ;
EB7C: 13       [ 6]     FNDNXT4:INC	DE		;bump pointers.
EB7D: 23       [12]     	INC	HL
EB7E: 04       [16]     	INC	B
EB7F: 0D       [20]     	DEC	C		;adjust character counter.
EB80: C353EB   [30]     	JP	FNDNXT2
EB83: 3AEAF1   [13]     FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
EB86: E603     [20]     	AND	03H
EB88: 3245E7   [33]     	LD	(STATUS),A
EB8B: 21D4F1   [43]     	LD	HL,FNDSTAT
EB8E: 7E       [50]     	LD	A,(HL)
EB8F: 17       [54]     	RLA	
EB90: D0       [59|65]  	RET	NC
EB91: AF       [63]     	XOR	A
EB92: 77       [70]     	LD	(HL),A
EB93: C9       [80]     	RET	
                        ;
                        ;   Filename was not found. Set appropriate status.
                        ;
EB94: CDFEE9   [17]     FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
EB97: 3EFF     [24]     	LD	A,0FFH		;say not located.
EB99: C301E7   [34]     	JP	SETSTAT
                        ;
                        ;   Erase files from the directory. Only the first byte of the
                        ; fcb will be affected. It is set to (E5).
                        ;
EB9C: CD54E9   [17]     ERAFILE:CALL	CHKWPRT		;is disk write protected?
EB9F: 0E0C     [24]     	LD	C,12		;only compare file names.
EBA1: CD18EB   [41]     	CALL	FINDFST		;get first file name.
EBA4: CDF5E9   [17]     ERAFIL1:CALL	CKFILPOS	;any found?
EBA7: C8       [22|28]  	RET	Z		;nope, we must be done.
EBA8: CD44E9   [39]     	CALL	CHKROFL		;is file read only?
EBAB: CD5EE9   [56]     	CALL	FCB2HL		;nope, get address of fcb and
EBAE: 36E5     [66]     	LD	(HL),0E5H	;set first byte to 'empty'.
EBB0: 0E00     [73]     	LD	C,0		;clear the space from the bit map.
EBB2: CD6BEA   [90]     	CALL	SETFILE
EBB5: CDC6E9   [107]    	CALL	DIRWRITE	;now write the directory sector back out.
EBB8: CD2DEB   [124]    	CALL	FINDNXT		;find the next file name.
EBBB: C3A4EB   [134]    	JP	ERAFIL1		;and repeat process.
                        ;
                        ;   Look through the space allocation map (bit map) for the
                        ; next available block. Start searching at block number (BC-1).
                        ; The search procedure is to look for an empty block that is
                        ; before the starting block. If not empty, look at a later
                        ; block number. In this way, we return the closest empty block
                        ; on either side of the 'target' block number. This will speed
                        ; access on random devices. For serial devices, this should be
                        ; changed to look in the forward direction first and then start
                        ; at the front and search some more.
                        ;
                        ;   On return, (DE)= block number that is empty and (HL) =0
                        ; if no empry block was found.
                        ;
EBBE: 50       [ 4]     FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
EBBF: 59       [ 8]     	LD	E,C
                        ;
                        ;   Look before target block. Registers (BC) are used as the lower
                        ; pointer and (DE) as the upper pointer.
                        ;
EBC0: 79       [ 4]     FNDSPA1:LD	A,C		;is block 0 specified?
EBC1: B0       [ 8]     	OR	B
EBC2: CAD1EB   [18|18]  	JP	Z,FNDSPA2
EBC5: 0B       [24]     	DEC	BC		;nope, check previous block.
EBC6: D5       [35]     	PUSH	DE
EBC7: C5       [46]     	PUSH	BC
EBC8: CD35EA   [63]     	CALL	CKBITMAP
EBCB: 1F       [67]     	RRA			;is this block empty?
EBCC: D2ECEB   [77|77]  	JP	NC,FNDSPA3	;yes. use this.
                        ;
                        ;   Note that the above logic gets the first block that it finds
                        ; that is empty. Thus a file could be written 'backward' making
                        ; it very slow to access. This could be changed to look for the
                        ; first empty block and then continue until the start of this
                        ; empty space is located and then used that starting block.
                        ; This should help speed up access to some files especially on
                        ; a well used disk with lots of fairly small 'holes'.
                        ;
EBCF: C1       [87]     	POP	BC		;nope, check some more.
EBD0: D1       [97]     	POP	DE
                        ;
                        ;   Now look after target block.
                        ;
EBD1: 2AC6F1   [16]     FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
EBD4: 7B       [20]     	LD	A,E
EBD5: 95       [24]     	SUB	L
EBD6: 7A       [28]     	LD	A,D
EBD7: 9C       [32]     	SBC	A,H
EBD8: D2F4EB   [42|42]  	JP	NC,FNDSPA4
EBDB: 13       [48]     	INC	DE		;yes, move on to next one.
EBDC: C5       [59]     	PUSH	BC
EBDD: D5       [70]     	PUSH	DE
EBDE: 42       [74]     	LD	B,D
EBDF: 4B       [78]     	LD	C,E
EBE0: CD35EA   [95]     	CALL	CKBITMAP	;check it.
EBE3: 1F       [99]     	RRA			;empty?
EBE4: D2ECEB   [109|109]	JP	NC,FNDSPA3
EBE7: D1       [119]    	POP	DE		;nope, continue searching.
EBE8: C1       [129]    	POP	BC
EBE9: C3C0EB   [139]    	JP	FNDSPA1
                        ;
                        ;   Empty block found. Set it as used and return with (HL)
                        ; pointing to it (true?).
                        ;
EBEC: 17       [ 4]     FNDSPA3:RLA			;reset byte.
EBED: 3C       [ 8]     	INC	A		;and set bit 0.
EBEE: CD64EA   [25]     	CALL	STBMAP1		;update bit map.
EBF1: E1       [35]     	POP	HL		;set return registers.
EBF2: D1       [45]     	POP	DE
EBF3: C9       [55]     	RET	
                        ;
                        ;   Free block was not found. If (BC) is not zero, then we have
                        ; not checked all of the disk space.
                        ;
EBF4: 79       [ 4]     FNDSPA4:LD	A,C
EBF5: B0       [ 8]     	OR	B
EBF6: C2C0EB   [18|18]  	JP	NZ,FNDSPA1
EBF9: 210000   [28]     	LD	HL,0		;set 'not found' status.
EBFC: C9       [38]     	RET	
                        ;
                        ;   Move a complete fcb entry into the directory and write it.
                        ;
EBFD: 0E00     [ 7]     FCBSET:	LD	C,0
EBFF: 1E20     [14]     	LD	E,32		;length of each entry.
                        ;
                        ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
                        ; fcb in directory starting at relative byte (C). This updated
                        ; directory buffer is then written to the disk.
                        ;
EC01: D5       [11]     UPDATE:	PUSH	DE
EC02: 0600     [18]     	LD	B,0		;set (BC) to relative byte position.
EC04: 2A43E7   [34]     	LD	HL,(PARAMS)	;get address of fcb.
EC07: 09       [45]     	ADD	HL,BC		;compute starting byte.
EC08: EB       [49]     	EX	DE,HL
EC09: CD5EE9   [66]     	CALL	FCB2HL		;get address of fcb to update in directory.
EC0C: C1       [76]     	POP	BC		;set (C) to number of bytes to change.
EC0D: CD4FE7   [93]     	CALL	DE2HL
EC10: CDC3E7   [17]     UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
EC13: C3C6E9   [27]     	JP	DIRWRITE	;then write this sector out.
                        ;
                        ;   Routine to change the name of all files on the disk with a
                        ; specified name. The fcb contains the current name as the
                        ; first 12 characters and the new name 16 bytes into the fcb.
                        ;
EC16: CD54E9   [17]     CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
EC19: 0E0C     [24]     	LD	C,12		;match first 12 bytes of fcb only.
EC1B: CD18EB   [41]     	CALL	FINDFST		;get first name.
EC1E: 2A43E7   [57]     	LD	HL,(PARAMS)	;get address of fcb.
EC21: 7E       [64]     	LD	A,(HL)		;get user number.
EC22: 111000   [74]     	LD	DE,16		;move over to desired name.
EC25: 19       [85]     	ADD	HL,DE
EC26: 77       [92]     	LD	(HL),A		;keep same user number.
EC27: CDF5E9   [17]     CHGNAM1:CALL	CKFILPOS	;any matching file found?
EC2A: C8       [22|28]  	RET	Z		;no, we must be done.
EC2B: CD44E9   [39]     	CALL	CHKROFL		;check for read only file.
EC2E: 0E10     [46]     	LD	C,16		;start 16 bytes into fcb.
EC30: 1E0C     [53]     	LD	E,12		;and update the first 12 bytes of directory.
EC32: CD01EC   [70]     	CALL	UPDATE
EC35: CD2DEB   [87]     	CALL	FINDNXT		;get te next file name.
EC38: C327EC   [97]     	JP	CHGNAM1		;and continue.
                        ;
                        ;   Update a files attributes. The procedure is to search for
                        ; every file with the same name as shown in fcb (ignoring bit 7)
                        ; and then to update it (which includes bit 7). No other changes
                        ; are made.
                        ;
EC3B: 0E0C     [ 7]     SAVEATTR: LD	C,12		;match first 12 bytes.
EC3D: CD18EB   [24]     	CALL	FINDFST		;look for first filename.
EC40: CDF5E9   [17]     SAVATR1:CALL	CKFILPOS	;was one found?
EC43: C8       [22|28]  	RET	Z		;nope, we must be done.
EC44: 0E00     [29]     	LD	C,0		;yes, update the first 12 bytes now.
EC46: 1E0C     [36]     	LD	E,12
EC48: CD01EC   [53]     	CALL	UPDATE		;update filename and write directory.
EC4B: CD2DEB   [70]     	CALL	FINDNXT		;and get the next file.
EC4E: C340EC   [80]     	JP	SAVATR1		;then continue until done.
                        ;
                        ;  Open a file (name specified in fcb).
                        ;
EC51: 0E0F     [ 7]     OPENIT:	LD	C,15		;compare the first 15 bytes.
EC53: CD18EB   [24]     	CALL	FINDFST		;get the first one in directory.
EC56: CDF5E9   [41]     	CALL	CKFILPOS	;any at all?
EC59: C8       [46|52]  	RET	Z
EC5A: CDA6E8   [17]     OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
EC5D: 7E       [24]     	LD	A,(HL)		;and get it.
EC5E: F5       [35]     	PUSH	AF		;save it and address.
EC5F: E5       [46]     	PUSH	HL
EC60: CD5EE9   [63]     	CALL	FCB2HL		;point to fcb in directory.
EC63: EB       [67]     	EX	DE,HL
EC64: 2A43E7   [83]     	LD	HL,(PARAMS)	;this is the users copy.
EC67: 0E20     [90]     	LD	C,32		;move it into users space.
EC69: D5       [101]    	PUSH	DE
EC6A: CD4FE7   [118]    	CALL	DE2HL
EC6D: CD78E9   [135]    	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
EC70: D1       [145]    	POP	DE		;now get the extent byte from this fcb.
EC71: 210C00   [155]    	LD	HL,12
EC74: 19       [166]    	ADD	HL,DE
EC75: 4E       [173]    	LD	C,(HL)		;into (C).
EC76: 210F00   [183]    	LD	HL,15		;now get the record count byte into (B).
EC79: 19       [194]    	ADD	HL,DE
EC7A: 46       [201]    	LD	B,(HL)
EC7B: E1       [211]    	POP	HL		;keep the same extent as the user had originally.
EC7C: F1       [221]    	POP	AF
EC7D: 77       [228]    	LD	(HL),A
EC7E: 79       [232]    	LD	A,C		;is it the same as in the directory fcb?
EC7F: BE       [239]    	CP	(HL)
EC80: 78       [243]    	LD	A,B		;if yes, then use the same record count.
EC81: CA8BEC   [253|253]	JP	Z,OPENIT2
EC84: 3E00     [260]    	LD	A,0		;if the user specified an extent greater than
EC86: DA8BEC   [270|270]	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
EC89: 3E80     [277]    	LD	A,128		;otherwise set to maximum.
EC8B: 2A43E7   [16]     OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
EC8E: 110F00   [26]     	LD	DE,15
EC91: 19       [37]     	ADD	HL,DE		;compute relative position.
EC92: 77       [44]     	LD	(HL),A		;and set the record count.
EC93: C9       [54]     	RET	
                        ;
                        ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
                        ; point to a zero value (16 bit).
                        ;   Return with zero flag set it (DE) was moved. Registers (DE)
                        ; and (HL) are not changed. However (A) is.
                        ;
EC94: 7E       [ 7]     MOVEWORD: LD	A,(HL)		;check for a zero word.
EC95: 23       [13]     	INC	HL
EC96: B6       [20]     	OR	(HL)		;both bytes zero?
EC97: 2B       [26]     	DEC	HL
EC98: C0       [31|37]  	RET	NZ		;nope, just return.
EC99: 1A       [38]     	LD	A,(DE)		;yes, move two bytes from (DE) into
EC9A: 77       [45]     	LD	(HL),A		;this zero space.
EC9B: 13       [51]     	INC	DE
EC9C: 23       [57]     	INC	HL
EC9D: 1A       [64]     	LD	A,(DE)
EC9E: 77       [71]     	LD	(HL),A
EC9F: 1B       [77]     	DEC	DE		;don't disturb these registers.
ECA0: 2B       [83]     	DEC	HL
ECA1: C9       [93]     	RET	
                        ;
                        ;   Get here to close a file specified by (fcb).
                        ;
ECA2: AF       [ 4]     CLOSEIT:XOR	A		;clear status and file position bytes.
ECA3: 3245E7   [17]     	LD	(STATUS),A
ECA6: 32EAF1   [30]     	LD	(FILEPOS),A
ECA9: 32EBF1   [43]     	LD	(FILEPOS+1),A
ECAC: CD1EE9   [60]     	CALL	GETWPRT		;get write protect bit for this drive.
ECAF: C0       [65|71]  	RET	NZ		;just return if it is set.
ECB0: CD69E9   [82]     	CALL	GETS2		;else get the 's2' byte.
ECB3: E680     [89]     	AND	80H		;and look at bit 7 (file unmodified?).
ECB5: C0       [94|100] 	RET	NZ		;just return if set.
ECB6: 0E0F     [101]    	LD	C,15		;else look up this file in directory.
ECB8: CD18EB   [118]    	CALL	FINDFST
ECBB: CDF5E9   [135]    	CALL	CKFILPOS	;was it found?
ECBE: C8       [140|146]	RET	Z		;just return if not.
ECBF: 011000   [150]    	LD	BC,16		;set (HL) pointing to records used section.
ECC2: CD5EE9   [167]    	CALL	FCB2HL
ECC5: 09       [178]    	ADD	HL,BC
ECC6: EB       [182]    	EX	DE,HL
ECC7: 2A43E7   [198]    	LD	HL,(PARAMS)	;do the same for users specified fcb.
ECCA: 09       [209]    	ADD	HL,BC
ECCB: 0E10     [216]    	LD	C,16		;this many bytes are present in this extent.
ECCD: 3ADDF1   [13]     CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
ECD0: B7       [17]     	OR	A
ECD1: CAE8EC   [27|27]  	JP	Z,CLOSEIT4
ECD4: 7E       [34]     	LD	A,(HL)		;just 8 bit. Get one from users fcb.
ECD5: B7       [38]     	OR	A
ECD6: 1A       [45]     	LD	A,(DE)		;now get one from directory fcb.
ECD7: C2DBEC   [55|55]  	JP	NZ,CLOSEIT2
ECDA: 77       [62]     	LD	(HL),A		;users byte was zero. Update from directory.
ECDB: B7       [ 4]     CLOSEIT2: OR	A
ECDC: C2E1EC   [14|14]  	JP	NZ,CLOSEIT3
ECDF: 7E       [21]     	LD	A,(HL)		;directories byte was zero, update from users fcb.
ECE0: 12       [28]     	LD	(DE),A
ECE1: BE       [ 7]     CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
ECE2: C21FED   [17|17]  	JP	NZ,CLOSEIT7	;then close error if they are not the same.
ECE5: C3FDEC   [27]     	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
ECE8: CD94EC   [17]     CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
ECEB: EB       [21]     	EX	DE,HL
ECEC: CD94EC   [38]     	CALL	MOVEWORD	;update directories fcb if it is zero.
ECEF: EB       [42]     	EX	DE,HL
ECF0: 1A       [49]     	LD	A,(DE)		;if these two values are no different,
ECF1: BE       [56]     	CP	(HL)		;then a close error occured.
ECF2: C21FED   [66|66]  	JP	NZ,CLOSEIT7
ECF5: 13       [72]     	INC	DE		;check second byte.
ECF6: 23       [78]     	INC	HL
ECF7: 1A       [85]     	LD	A,(DE)
ECF8: BE       [92]     	CP	(HL)
ECF9: C21FED   [102|102]	JP	NZ,CLOSEIT7
ECFC: 0D       [106]    	DEC	C		;remember 16 bit values.
ECFD: 13       [ 6]     CLOSEIT5: INC	DE		;bump to next item in table.
ECFE: 23       [12]     	INC	HL
ECFF: 0D       [16]     	DEC	C		;there are 16 entries only.
ED00: C2CDEC   [26|26]  	JP	NZ,CLOSEIT1	;continue if more to do.
ED03: 01ECFF   [36]     	LD	BC,0FFECH	;backup 20 places (extent byte).
ED06: 09       [47]     	ADD	HL,BC
ED07: EB       [51]     	EX	DE,HL
ED08: 09       [62]     	ADD	HL,BC
ED09: 1A       [69]     	LD	A,(DE)
ED0A: BE       [76]     	CP	(HL)		;directory's extent already greater than the
ED0B: DA17ED   [86|86]  	JP	C,CLOSEIT6	;users extent?
ED0E: 77       [93]     	LD	(HL),A		;no, update directory extent.
ED0F: 010300   [103]    	LD	BC,3		;and update the record count byte in
ED12: 09       [114]    	ADD	HL,BC		;directories fcb.
ED13: EB       [118]    	EX	DE,HL
ED14: 09       [129]    	ADD	HL,BC
ED15: 7E       [136]    	LD	A,(HL)		;get from user.
ED16: 12       [143]    	LD	(DE),A		;and put in directory.
ED17: 3EFF     [ 7]     CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
ED19: 32D2F1   [20]     	LD	(CLOSEFLG),A
ED1C: C310EC   [30]     	JP	UPDATE1		;update the directory now.
ED1F: 2145E7   [10]     CLOSEIT7: LD	HL,STATUS	;set return status and then return.
ED22: 35       [21]     	DEC	(HL)
ED23: C9       [31]     	RET	
                        ;
                        ;   Routine to get the next empty space in the directory. It
                        ; will then be cleared for use.
                        ;
ED24: CD54E9   [17]     GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
ED27: 2A43E7   [33]     	LD	HL,(PARAMS)	;save current parameters (fcb).
ED2A: E5       [44]     	PUSH	HL
ED2B: 21ACF1   [54]     	LD	HL,EMPTYFCB	;use special one for empty space.
ED2E: 2243E7   [70]     	LD	(PARAMS),HL
ED31: 0E01     [77]     	LD	C,1		;search for first empty spot in directory.
ED33: CD18EB   [94]     	CALL	FINDFST		;(* only check first byte *)
ED36: CDF5E9   [111]    	CALL	CKFILPOS	;none?
ED39: E1       [121]    	POP	HL
ED3A: 2243E7   [137]    	LD	(PARAMS),HL	;restore original fcb address.
ED3D: C8       [142|148]	RET	Z		;return if no more space.
ED3E: EB       [146]    	EX	DE,HL
ED3F: 210F00   [156]    	LD	HL,15		;point to number of records for this file.
ED42: 19       [167]    	ADD	HL,DE
ED43: 0E11     [174]    	LD	C,17		;and clear all of this space.
ED45: AF       [178]    	XOR	A
ED46: 77       [ 7]     GETMT1:	LD	(HL),A
ED47: 23       [13]     	INC	HL
ED48: 0D       [17]     	DEC	C
ED49: C246ED   [27|27]  	JP	NZ,GETMT1
ED4C: 210D00   [37]     	LD	HL,13		;clear the 's1' byte also.
ED4F: 19       [48]     	ADD	HL,DE
ED50: 77       [55]     	LD	(HL),A
ED51: CD8CE9   [72]     	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
ED54: CDFDEB   [89]     	CALL	FCBSET		;write out this fcb entry to directory.
ED57: C378E9   [99]     	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
                        ;
                        ;   Routine to close the current extent and open the next one
                        ; for reading.
                        ;
ED5A: AF       [ 4]     GETNEXT:XOR	A
ED5B: 32D2F1   [17]     	LD	(CLOSEFLG),A	;clear close flag.
ED5E: CDA2EC   [34]     	CALL	CLOSEIT		;close this extent.
ED61: CDF5E9   [51]     	CALL	CKFILPOS
ED64: C8       [56|62]  	RET	Z		;not there???
ED65: 2A43E7   [72]     	LD	HL,(PARAMS)	;get extent byte.
ED68: 010C00   [82]     	LD	BC,12
ED6B: 09       [93]     	ADD	HL,BC
ED6C: 7E       [100]    	LD	A,(HL)		;and increment it.
ED6D: 3C       [104]    	INC	A
ED6E: E61F     [111]    	AND	1FH		;keep within range 0-31.
ED70: 77       [118]    	LD	(HL),A
ED71: CA83ED   [128|128]	JP	Z,GTNEXT1	;overflow?
ED74: 47       [132]    	LD	B,A		;mask extent byte.
ED75: 3AC5F1   [145]    	LD	A,(EXTMASK)
ED78: A0       [149]    	AND	B
ED79: 21D2F1   [159]    	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
ED7C: A6       [166]    	AND	(HL)
ED7D: CA8EED   [176|176]	JP	Z,GTNEXT2	;if zero, we must read in next extent.
ED80: C3ACED   [186]    	JP	GTNEXT3		;else, it is already in memory.
ED83: 010200   [10]     GTNEXT1:LD	BC,2		;Point to the 's2' byte.
ED86: 09       [21]     	ADD	HL,BC
ED87: 34       [32]     	INC	(HL)		;and bump it.
ED88: 7E       [39]     	LD	A,(HL)		;too many extents?
ED89: E60F     [46]     	AND	0FH
ED8B: CAB6ED   [56|56]  	JP	Z,GTNEXT5	;yes, set error code.
                        ;
                        ;   Get here to open the next extent.
                        ;
ED8E: 0E0F     [ 7]     GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
ED90: CD18EB   [24]     	CALL	FINDFST		;find the first one.
ED93: CDF5E9   [41]     	CALL	CKFILPOS	;none available?
ED96: C2ACED   [51|51]  	JP	NZ,GTNEXT3
ED99: 3AD3F1   [64]     	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
ED9C: 3C       [68]     	INC	A		;0ffh means reading (so not possible).
ED9D: CAB6ED   [78|78]  	JP	Z,GTNEXT5	;or an error.
EDA0: CD24ED   [95]     	CALL	GETEMPTY	;we are writing, get an empty entry.
EDA3: CDF5E9   [112]    	CALL	CKFILPOS	;none?
EDA6: CAB6ED   [122|122]	JP	Z,GTNEXT5	;error if true.
EDA9: C3AFED   [132]    	JP	GTNEXT4		;else we are almost done.
EDAC: CD5AEC   [17]     GTNEXT3:CALL	OPENIT1		;open this extent.
EDAF: CDBBE8   [17]     GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
EDB2: AF       [21]     	XOR	A		;clear status and return.
EDB3: C301E7   [31]     	JP	SETSTAT
                        ;
                        ;   Error in extending the file. Too many extents were needed
                        ; or not enough space on the disk.
                        ;
EDB6: CD05E7   [17]     GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
EDB9: C378E9   [27]     	JP	SETS2B7		;so this is not written on a close.
                        ;
                        ;   Read a sequential file.
                        ;
EDBC: 3E01     [ 7]     RDSEQ:	LD	A,1		;set sequential access mode.
EDBE: 32D5F1   [20]     	LD	(MODE),A
EDC1: 3EFF     [ 7]     RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
EDC3: 32D3F1   [20]     	LD	(RDWRTFLG),A
EDC6: CDBBE8   [37]     	CALL	STRDATA		;put rec# and ext# into fcb.
EDC9: 3AE3F1   [50]     	LD	A,(SAVNREC)	;get next record to read.
EDCC: 21E1F1   [60]     	LD	HL,SAVNXT	;get number of records in extent.
EDCF: BE       [67]     	CP	(HL)		;within this extent?
EDD0: DAE6ED   [77|77]  	JP	C,RDSEQ2
EDD3: FE80     [84]     	CP	128		;no. Is this extent fully used?
EDD5: C2FBED   [94|94]  	JP	NZ,RDSEQ3	;no. End-of-file.
EDD8: CD5AED   [111]    	CALL	GETNEXT		;yes, open the next one.
EDDB: AF       [115]    	XOR	A		;reset next record to read.
EDDC: 32E3F1   [128]    	LD	(SAVNREC),A
EDDF: 3A45E7   [141]    	LD	A,(STATUS)	;check on open, successful?
EDE2: B7       [145]    	OR	A
EDE3: C2FBED   [155|155]	JP	NZ,RDSEQ3	;no, error.
EDE6: CD77E8   [17]     RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
EDE9: CD84E8   [34]     	CALL	CHKBLK		;check it. Within bounds?
EDEC: CAFBED   [44|44]  	JP	Z,RDSEQ3	;no, error.
EDEF: CD8AE8   [61]     	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
EDF2: CDD1E7   [78]     	CALL	TRKSEC1		;set the track and sector for this block #.
EDF5: CDB2E7   [95]     	CALL	DOREAD		;and read it.
EDF8: C3D2E8   [105]    	JP	SETNREC		;and set the next record to be accessed.
                        ;
                        ;   Read error occured. Set status and return.
                        ;
EDFB: C305E7   [10]     RDSEQ3:	JP	IOERR1
                        ;
                        ;   Write the next sequential record.
                        ;
EDFE: 3E01     [ 7]     WTSEQ:	LD	A,1		;set sequential access mode.
EE00: 32D5F1   [20]     	LD	(MODE),A
EE03: 3E00     [ 7]     WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
EE05: 32D3F1   [20]     	LD	(RDWRTFLG),A
EE08: CD54E9   [37]     	CALL	CHKWPRT		;check write protect status.
EE0B: 2A43E7   [53]     	LD	HL,(PARAMS)
EE0E: CD47E9   [70]     	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
EE11: CDBBE8   [87]     	CALL	STRDATA		;put updated data into fcb.
EE14: 3AE3F1   [100]    	LD	A,(SAVNREC)	;get record number to write.
EE17: FE80     [107]    	CP	128		;within range?
EE19: D205E7   [117|117]	JP	NC,IOERR1	;no, error(?).
EE1C: CD77E8   [134]    	CALL	COMBLK		;compute block number.
EE1F: CD84E8   [151]    	CALL	CHKBLK		;check number.
EE22: 0E00     [158]    	LD	C,0		;is there one to write to?
EE24: C26EEE   [168|168]	JP	NZ,WTSEQ6	;yes, go do it.
EE27: CD3EE8   [185]    	CALL	GETBLOCK	;get next block number within fcb to use.
EE2A: 32D7F1   [198]    	LD	(RELBLOCK),A	;and save.
EE2D: 010000   [208]    	LD	BC,0		;start looking for space from the start
EE30: B7       [212]    	OR	A		;if none allocated as yet.
EE31: CA3BEE   [222|222]	JP	Z,WTSEQ2
EE34: 4F       [226]    	LD	C,A		;extract previous block number from fcb
EE35: 0B       [232]    	DEC	BC		;so we can be closest to it.
EE36: CD5EE8   [249]    	CALL	EXTBLK
EE39: 44       [253]    	LD	B,H
EE3A: 4D       [257]    	LD	C,L
EE3B: CDBEEB   [17]     WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
EE3E: 7D       [21]     	LD	A,L		;check for a zero number.
EE3F: B4       [25]     	OR	H
EE40: C248EE   [35|35]  	JP	NZ,WTSEQ3
EE43: 3E02     [42]     	LD	A,2		;no more space?
EE45: C301E7   [52]     	JP	SETSTAT
EE48: 22E5F1   [16]     WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
EE4B: EB       [20]     	EX	DE,HL		;put block number into (DE).
EE4C: 2A43E7   [36]     	LD	HL,(PARAMS)	;now we must update the fcb for this
EE4F: 011000   [46]     	LD	BC,16		;newly allocated block.
EE52: 09       [57]     	ADD	HL,BC
EE53: 3ADDF1   [70]     	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
EE56: B7       [74]     	OR	A
EE57: 3AD7F1   [87]     	LD	A,(RELBLOCK)	;(* update this entry *)
EE5A: CA64EE   [97|97]  	JP	Z,WTSEQ4	;zero means 16 bit ones.
EE5D: CD64E9   [114]    	CALL	ADDA2HL		;(HL)=(HL)+(A)
EE60: 73       [121]    	LD	(HL),E		;store new block number.
EE61: C36CEE   [131]    	JP	WTSEQ5
EE64: 4F       [ 4]     WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
EE65: 0600     [11]     	LD	B,0
EE67: 09       [22]     	ADD	HL,BC
EE68: 09       [33]     	ADD	HL,BC
EE69: 73       [40]     	LD	(HL),E		;stuff block number (DE) there.
EE6A: 23       [46]     	INC	HL
EE6B: 72       [53]     	LD	(HL),D
EE6C: 0E02     [ 7]     WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
EE6E: 3A45E7   [13]     WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
EE71: B7       [17]     	OR	A
EE72: C0       [22|28]  	RET	NZ
EE73: C5       [33]     	PUSH	BC		;yes, save write flag for bios (register C).
EE74: CD8AE8   [50]     	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
EE77: 3AD5F1   [63]     	LD	A,(MODE)	;get access mode flag (1=sequential,
EE7A: 3D       [67]     	DEC	A		;0=random, 2=special?).
EE7B: 3D       [71]     	DEC	A
EE7C: C2BBEE   [81|81]  	JP	NZ,WTSEQ9
                        ;
                        ;   Special random i/o from function #40. Maybe for M/PM, but the
                        ; current block, if it has not been written to, will be zeroed
                        ; out and then written (reason?).
                        ;
EE7F: C1       [91]     	POP	BC
EE80: C5       [102]    	PUSH	BC
EE81: 79       [106]    	LD	A,C		;get write status flag (2=writing unused space).
EE82: 3D       [110]    	DEC	A
EE83: 3D       [114]    	DEC	A
EE84: C2BBEE   [124|124]	JP	NZ,WTSEQ9
EE87: E5       [135]    	PUSH	HL
EE88: 2AB9F1   [151]    	LD	HL,(DIRBUF)	;zero out the directory buffer.
EE8B: 57       [155]    	LD	D,A		;note that (A) is zero here.
EE8C: 77       [ 7]     WTSEQ7:	LD	(HL),A
EE8D: 23       [13]     	INC	HL
EE8E: 14       [17]     	INC	D		;do 128 bytes.
EE8F: F28CEE   [27|27]  	JP	P,WTSEQ7
EE92: CDE0E9   [44]     	CALL	DIRDMA		;tell the bios the dma address for directory access.
EE95: 2AE7F1   [60]     	LD	HL,(LOGSECT)	;get sector that starts current block.
EE98: 0E02     [67]     	LD	C,2		;set 'writing to unused space' flag.
EE9A: 22E5F1   [16]     WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
EE9D: C5       [27]     	PUSH	BC
EE9E: CDD1E7   [44]     	CALL	TRKSEC1		;determine its track and sector numbers.
EEA1: C1       [54]     	POP	BC
EEA2: CDB8E7   [71]     	CALL	DOWRITE		;now write out 128 bytes of zeros.
EEA5: 2AE5F1   [87]     	LD	HL,(BLKNMBR)	;get sector number.
EEA8: 0E00     [94]     	LD	C,0		;set normal write flag.
EEAA: 3AC4F1   [107]    	LD	A,(BLKMASK)	;determine if we have written the entire
EEAD: 47       [111]    	LD	B,A		;physical block.
EEAE: A5       [115]    	AND	L
EEAF: B8       [119]    	CP	B
EEB0: 23       [125]    	INC	HL		;prepare for the next one.
EEB1: C29AEE   [135|135]	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
EEB4: E1       [145]    	POP	HL		;reset next sector number.
EEB5: 22E5F1   [161]    	LD	(BLKNMBR),HL
EEB8: CDDAE9   [178]    	CALL	DEFDMA		;and reset dma address.
                        ;
                        ;   Normal disk write. Set the desired track and sector then
                        ; do the actual write.
                        ;
EEBB: CDD1E7   [17]     WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
EEBE: C1       [27]     	POP	BC		;get write status flag.
EEBF: C5       [38]     	PUSH	BC
EEC0: CDB8E7   [55]     	CALL	DOWRITE		;and write this out.
EEC3: C1       [65]     	POP	BC
EEC4: 3AE3F1   [78]     	LD	A,(SAVNREC)	;get number of records in file.
EEC7: 21E1F1   [88]     	LD	HL,SAVNXT	;get last record written.
EECA: BE       [95]     	CP	(HL)
EECB: DAD2EE   [105|105]	JP	C,WTSEQ10
EECE: 77       [112]    	LD	(HL),A		;we have to update record count.
EECF: 34       [123]    	INC	(HL)
EED0: 0E02     [130]    	LD	C,2
                        ;
                        ;*   This area has been patched to correct disk update problem
                        ;* when using blocking and de-blocking in the BIOS.
                        ;
EED2: 00       [ 4]     WTSEQ10:NOP			;was 'dcr c'
EED3: 00       [ 8]     	NOP			;was 'dcr c'
EED4: 210000   [18]     	LD	HL,0		;was 'jnz wtseq99'
                        ;
                        ; *   End of patch.
                        ;
EED7: F5       [29]     	PUSH	AF
EED8: CD69E9   [46]     	CALL	GETS2		;set 'extent written to' flag.
EEDB: E67F     [53]     	AND	7FH		;(* clear bit 7 *)
EEDD: 77       [60]     	LD	(HL),A
EEDE: F1       [70]     	POP	AF		;get record count for this extent.
EEDF: FE7F     [ 7]     WTSEQ99:CP	127		;is it full?
EEE1: C200EF   [17|17]  	JP	NZ,WTSEQ12
EEE4: 3AD5F1   [30]     	LD	A,(MODE)	;yes, are we in sequential mode?
EEE7: FE01     [37]     	CP	1
EEE9: C200EF   [47|47]  	JP	NZ,WTSEQ12
EEEC: CDD2E8   [64]     	CALL	SETNREC		;yes, set next record number.
EEEF: CD5AED   [81]     	CALL	GETNEXT		;and get next empty space in directory.
EEF2: 2145E7   [91]     	LD	HL,STATUS	;ok?
EEF5: 7E       [98]     	LD	A,(HL)
EEF6: B7       [102]    	OR	A
EEF7: C2FEEE   [112|112]	JP	NZ,WTSEQ11
EEFA: 3D       [116]    	DEC	A		;yes, set record count to -1.
EEFB: 32E3F1   [129]    	LD	(SAVNREC),A
EEFE: 3600     [10]     WTSEQ11:LD	(HL),0		;clear status.
EF00: C3D2E8   [10]     WTSEQ12:JP	SETNREC		;set next record to access.
                        ;
                        ;   For random i/o, set the fcb for the desired record number
                        ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
                        ; used as follows:
                        ;
                        ;       fcb+35            fcb+34            fcb+33
                        ;  |     'r-2'      |      'r-1'      |      'r-0'     |
                        ;  |7             0 | 7             0 | 7             0|
                        ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
                        ;  |    overflow   | | extra |  extent   |   record #  |
                        ;  | ______________| |_extent|__number___|_____________|
                        ;                     also 's2'
                        ;
                        ;   On entry, register (C) contains 0ffh if this is a read
                        ; and thus we can not access unwritten disk space. Otherwise,
                        ; another extent will be opened (for writing) if required.
                        ;
EF03: AF       [ 4]     POSITION: XOR	A		;set random i/o flag.
EF04: 32D5F1   [17]     	LD	(MODE),A
                        ;
                        ;   Special entry (function #40). M/PM ?
                        ;
EF07: C5       [11]     POSITN1:PUSH	BC		;save read/write flag.
EF08: 2A43E7   [27]     	LD	HL,(PARAMS)	;get address of fcb.
EF0B: EB       [31]     	EX	DE,HL
EF0C: 212100   [41]     	LD	HL,33		;now get byte 'r0'.
EF0F: 19       [52]     	ADD	HL,DE
EF10: 7E       [59]     	LD	A,(HL)
EF11: E67F     [66]     	AND	7FH		;keep bits 0-6 for the record number to access.
EF13: F5       [77]     	PUSH	AF
EF14: 7E       [84]     	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
EF15: 17       [88]     	RLA	
EF16: 23       [94]     	INC	HL
EF17: 7E       [101]    	LD	A,(HL)
EF18: 17       [105]    	RLA	
EF19: E61F     [112]    	AND	1FH		;and save this in bits 0-4 of (C).
EF1B: 4F       [116]    	LD	C,A		;this is the extent byte.
EF1C: 7E       [123]    	LD	A,(HL)		;now get the extra extent byte.
EF1D: 1F       [127]    	RRA	
EF1E: 1F       [131]    	RRA	
EF1F: 1F       [135]    	RRA	
EF20: 1F       [139]    	RRA	
EF21: E60F     [146]    	AND	0FH
EF23: 47       [150]    	LD	B,A		;and save it in (B).
EF24: F1       [160]    	POP	AF		;get record number back to (A).
EF25: 23       [166]    	INC	HL		;check overflow byte 'r2'.
EF26: 6E       [173]    	LD	L,(HL)
EF27: 2C       [177]    	INC	L
EF28: 2D       [181]    	DEC	L
EF29: 2E06     [188]    	LD	L,6		;prepare for error.
EF2B: C28BEF   [198|198]	JP	NZ,POSITN5	;out of disk space error.
EF2E: 212000   [208]    	LD	HL,32		;store record number into fcb.
EF31: 19       [219]    	ADD	HL,DE
EF32: 77       [226]    	LD	(HL),A
EF33: 210C00   [236]    	LD	HL,12		;and now check the extent byte.
EF36: 19       [247]    	ADD	HL,DE
EF37: 79       [251]    	LD	A,C
EF38: 96       [258]    	SUB	(HL)		;same extent as before?
EF39: C247EF   [268|268]	JP	NZ,POSITN2
EF3C: 210E00   [278]    	LD	HL,14		;yes, check extra extent byte 's2' also.
EF3F: 19       [289]    	ADD	HL,DE
EF40: 78       [293]    	LD	A,B
EF41: 96       [300]    	SUB	(HL)
EF42: E67F     [307]    	AND	7FH
EF44: CA7FEF   [317|317]	JP	Z,POSITN3	;same, we are almost done then.
                        ;
                        ;  Get here when another extent is required.
                        ;
EF47: C5       [11]     POSITN2:PUSH	BC
EF48: D5       [22]     	PUSH	DE
EF49: CDA2EC   [39]     	CALL	CLOSEIT		;close current extent.
EF4C: D1       [49]     	POP	DE
EF4D: C1       [59]     	POP	BC
EF4E: 2E03     [66]     	LD	L,3		;prepare for error.
EF50: 3A45E7   [79]     	LD	A,(STATUS)
EF53: 3C       [83]     	INC	A
EF54: CA84EF   [93|93]  	JP	Z,POSITN4	;close error.
EF57: 210C00   [103]    	LD	HL,12		;put desired extent into fcb now.
EF5A: 19       [114]    	ADD	HL,DE
EF5B: 71       [121]    	LD	(HL),C
EF5C: 210E00   [131]    	LD	HL,14		;and store extra extent byte 's2'.
EF5F: 19       [142]    	ADD	HL,DE
EF60: 70       [149]    	LD	(HL),B
EF61: CD51EC   [166]    	CALL	OPENIT		;try and get this extent.
EF64: 3A45E7   [179]    	LD	A,(STATUS)	;was it there?
EF67: 3C       [183]    	INC	A
EF68: C27FEF   [193|193]	JP	NZ,POSITN3
EF6B: C1       [203]    	POP	BC		;no. can we create a new one (writing?).
EF6C: C5       [214]    	PUSH	BC
EF6D: 2E04     [221]    	LD	L,4		;prepare for error.
EF6F: 0C       [225]    	INC	C
EF70: CA84EF   [235|235]	JP	Z,POSITN4	;nope, reading unwritten space error.
EF73: CD24ED   [252]    	CALL	GETEMPTY	;yes we can, try to find space.
EF76: 2E05     [259]    	LD	L,5		;prepare for error.
EF78: 3A45E7   [272]    	LD	A,(STATUS)
EF7B: 3C       [276]    	INC	A
EF7C: CA84EF   [286|286]	JP	Z,POSITN4	;out of space?
                        ;
                        ;   Normal return location. Clear error code and return.
                        ;
EF7F: C1       [10]     POSITN3:POP	BC		;restore stack.
EF80: AF       [14]     	XOR	A		;and clear error code byte.
EF81: C301E7   [24]     	JP	SETSTAT
                        ;
                        ;   Error. Set the 's2' byte to indicate this (why?).
                        ;
EF84: E5       [11]     POSITN4:PUSH	HL
EF85: CD69E9   [28]     	CALL	GETS2
EF88: 36C0     [38]     	LD	(HL),0C0H
EF8A: E1       [48]     	POP	HL
                        ;
                        ;   Return with error code (presently in L).
                        ;
EF8B: C1       [10]     POSITN5:POP	BC
EF8C: 7D       [14]     	LD	A,L		;get error code.
EF8D: 3245E7   [27]     	LD	(STATUS),A
EF90: C378E9   [37]     	JP	SETS2B7
                        ;
                        ;   Read a random record.
                        ;
EF93: 0EFF     [ 7]     READRAN:LD	C,0FFH		;set 'read' status.
EF95: CD03EF   [24]     	CALL	POSITION	;position the file to proper record.
EF98: CCC1ED   [34|41]  	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
EF9B: C9       [44]     	RET	
                        ;
                        ;   Write to a random record.
                        ;
EF9C: 0E00     [ 7]     WRITERAN: LD	C,0		;set 'writing' flag.
EF9E: CD03EF   [24]     	CALL	POSITION	;position the file to proper record.
EFA1: CC03EE   [34|41]  	CALL	Z,WTSEQ1	;and write as usual (if no errors).
EFA4: C9       [44]     	RET	
                        ;
                        ;   Compute the random record number. Enter with (HL) pointing
                        ; to a fcb an (DE) contains a relative location of a record
                        ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
                        ; byte, and (A) the 'r2' byte.
                        ;
                        ;   On return, the zero flag is set if the record is within
                        ; bounds. Otherwise, an overflow occured.
                        ;
EFA5: EB       [ 4]     COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
EFA6: 19       [15]     	ADD	HL,DE		;compute relative position of record #.
EFA7: 4E       [22]     	LD	C,(HL)		;get record number into (BC).
EFA8: 0600     [29]     	LD	B,0
EFAA: 210C00   [39]     	LD	HL,12		;now get extent.
EFAD: 19       [50]     	ADD	HL,DE
EFAE: 7E       [57]     	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
EFAF: 0F       [61]     	RRCA			;move lower bit into bit 7.
EFB0: E680     [68]     	AND	80H		;and ignore all other bits.
EFB2: 81       [72]     	ADD	A,C		;add to our record number.
EFB3: 4F       [76]     	LD	C,A
EFB4: 3E00     [83]     	LD	A,0		;take care of any carry.
EFB6: 88       [87]     	ADC	A,B
EFB7: 47       [91]     	LD	B,A
EFB8: 7E       [98]     	LD	A,(HL)		;now get the upper bits of extent into
EFB9: 0F       [102]    	RRCA			;bit positions 0-3.
EFBA: E60F     [109]    	AND	0FH		;and ignore all others.
EFBC: 80       [113]    	ADD	A,B		;add this in to 'r1' byte.
EFBD: 47       [117]    	LD	B,A
EFBE: 210E00   [127]    	LD	HL,14		;get the 's2' byte (extra extent).
EFC1: 19       [138]    	ADD	HL,DE
EFC2: 7E       [145]    	LD	A,(HL)
EFC3: 87       [149]    	ADD	A,A		;and shift it left 4 bits (bits 4-7).
EFC4: 87       [153]    	ADD	A,A
EFC5: 87       [157]    	ADD	A,A
EFC6: 87       [161]    	ADD	A,A
EFC7: F5       [172]    	PUSH	AF		;save carry flag (bit 0 of flag byte).
EFC8: 80       [176]    	ADD	A,B		;now add extra extent into 'r1'.
EFC9: 47       [180]    	LD	B,A
EFCA: F5       [191]    	PUSH	AF		;and save carry (overflow byte 'r2').
EFCB: E1       [201]    	POP	HL		;bit 0 of (L) is the overflow indicator.
EFCC: 7D       [205]    	LD	A,L
EFCD: E1       [215]    	POP	HL		;and same for first carry flag.
EFCE: B5       [219]    	OR	L		;either one of these set?
EFCF: E601     [226]    	AND	01H		;only check the carry flags.
EFD1: C9       [236]    	RET	
                        ;
                        ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
                        ; reflect the last record used for a random (or other) file.
                        ; This reads the directory and looks at all extents computing
                        ; the largerst record number for each and keeping the maximum
                        ; value only. Then 'r0', 'r1', and 'r2' will reflect this
                        ; maximum record number. This is used to compute the space used
                        ; by a random file.
                        ;
EFD2: 0E0C     [ 7]     RANSIZE:LD	C,12		;look thru directory for first entry with
EFD4: CD18EB   [24]     	CALL	FINDFST		;this name.
EFD7: 2A43E7   [40]     	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
EFDA: 112100   [50]     	LD	DE,33
EFDD: 19       [61]     	ADD	HL,DE
EFDE: E5       [72]     	PUSH	HL
EFDF: 72       [79]     	LD	(HL),D		;note that (D)=0.
EFE0: 23       [85]     	INC	HL
EFE1: 72       [92]     	LD	(HL),D
EFE2: 23       [98]     	INC	HL
EFE3: 72       [105]    	LD	(HL),D
EFE4: CDF5E9   [17]     RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
EFE7: CA0CF0   [27|27]  	JP	Z,RANSIZ3	;no, we are done.
EFEA: CD5EE9   [44]     	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
EFED: 110F00   [54]     	LD	DE,15		;point to last record in extent.
EFF0: CDA5EF   [71]     	CALL	COMPRAND	;and compute random parameters.
EFF3: E1       [81]     	POP	HL
EFF4: E5       [92]     	PUSH	HL		;now check these values against those
EFF5: 5F       [96]     	LD	E,A		;already in fcb.
EFF6: 79       [100]    	LD	A,C		;the carry flag will be set if those
EFF7: 96       [107]    	SUB	(HL)		;in the fcb represent a larger size than
EFF8: 23       [113]    	INC	HL		;this extent does.
EFF9: 78       [117]    	LD	A,B
EFFA: 9E       [124]    	sbc (hl) ; SBC	A,M
EFFB: 23       [130]    	INC	HL
EFFC: 7B       [134]    	LD	A,E
EFFD: 9E       [141]    	sbc (hl) ; SBC	A,M
EFFE: DA06F0   [151|151]	JP	C,RANSIZ2
F001: 73       [158]    	LD	(HL),E		;we found a larger (in size) extent.
F002: 2B       [164]    	DEC	HL		;stuff these values into fcb.
F003: 70       [171]    	LD	(HL),B
F004: 2B       [177]    	DEC	HL
F005: 71       [184]    	LD	(HL),C
F006: CD2DEB   [17]     RANSIZ2:CALL	FINDNXT		;now get the next extent.
F009: C3E4EF   [27]     	JP	RANSIZ1		;continue til all done.
F00C: E1       [10]     RANSIZ3:POP	HL		;we are done, restore the stack and
F00D: C9       [20]     	RET			;return.
                        ;
                        ;   Function to return the random record position of a given
                        ; file which has been read in sequential mode up to now.
                        ;
F00E: 2A43E7   [16]     SETRAN:	LD	HL,(PARAMS)	;point to fcb.
F011: 112000   [26]     	LD	DE,32		;and to last used record.
F014: CDA5EF   [43]     	CALL	COMPRAND	;compute random position.
F017: 212100   [53]     	LD	HL,33		;now stuff these values into fcb.
F01A: 19       [64]     	ADD	HL,DE
F01B: 71       [71]     	LD	(HL),C		;move 'r0'.
F01C: 23       [77]     	INC	HL
F01D: 70       [84]     	LD	(HL),B		;and 'r1'.
F01E: 23       [90]     	INC	HL
F01F: 77       [97]     	LD	(HL),A		;and lastly 'r2'.
F020: C9       [107]    	RET	
                        ;
                        ;   This routine select the drive specified in (ACTIVE) and
                        ; update the login vector and bitmap table if this drive was
                        ; not already active.
                        ;
F021: 2AAFF1   [16]     LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
F024: 3A42E7   [29]     	LD	A,(ACTIVE)	;get the default drive.
F027: 4F       [33]     	LD	C,A
F028: CDEAE8   [50]     	CALL	SHIFTR		;position active bit for this drive
F02B: E5       [61]     	PUSH	HL		;into bit 0.
F02C: EB       [65]     	EX	DE,HL
F02D: CD59E7   [82]     	CALL	SELECT		;select this drive.
F030: E1       [92]     	POP	HL
F031: CC47E7   [102|109]	CALL	Z,SLCTERR	;valid drive?
F034: 7D       [106]    	LD	A,L		;is this a newly activated drive?
F035: 1F       [110]    	RRA	
F036: D8       [115|121]	RET	C
F037: 2AAFF1   [131]    	LD	HL,(LOGIN)	;yes, update the login vector.
F03A: 4D       [135]    	LD	C,L
F03B: 44       [139]    	LD	B,H
F03C: CD0BE9   [156]    	CALL	SETBIT
F03F: 22AFF1   [172]    	LD	(LOGIN),HL	;and save.
F042: C3A3EA   [182]    	JP	BITMAP		;now update the bitmap.
                        ;
                        ;   Function to set the active disk number.
                        ;
F045: 3AD6F1   [13]     SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
F048: 2142E7   [23]     	LD	HL,ACTIVE	;represents a change in drives.
F04B: BE       [30]     	CP	(HL)
F04C: C8       [35|41]  	RET	Z
F04D: 77       [42]     	LD	(HL),A		;yes it does, log it in.
F04E: C321F0   [52]     	JP	LOGINDRV
                        ;
                        ;   This is the 'auto disk select' routine. The firsst byte
                        ; of the fcb is examined for a drive specification. If non
                        ; zero then the drive will be selected and loged in.
                        ;
F051: 3EFF     [ 7]     AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
F053: 32DEF1   [20]     	LD	(AUTO),A
F056: 2A43E7   [36]     	LD	HL,(PARAMS)	;get drive specified.
F059: 7E       [43]     	LD	A,(HL)
F05A: E61F     [50]     	AND	1FH		;look at lower 5 bits.
F05C: 3D       [54]     	DEC	A		;adjust for (1=A, 2=B) etc.
F05D: 32D6F1   [67]     	LD	(EPARAM),A	;and save for the select routine.
F060: FE1E     [74]     	CP	1EH		;check for 'no change' condition.
F062: D275F0   [84|84]  	JP	NC,AUTOSL1	;yes, don't change.
F065: 3A42E7   [97]     	LD	A,(ACTIVE)	;we must change, save currently active
F068: 32DFF1   [110]    	LD	(OLDDRV),A	;drive.
F06B: 7E       [117]    	LD	A,(HL)		;and save first byte of fcb also.
F06C: 32E0F1   [130]    	LD	(AUTOFLAG),A	;this must be non-zero.
F06F: E6E0     [137]    	AND	0E0H		;whats this for (bits 6,7 are used for
F071: 77       [144]    	LD	(HL),A		;something)?
F072: CD45F0   [161]    	CALL	SETDSK		;select and log in this drive.
F075: 3A41E7   [13]     AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
F078: 2A43E7   [29]     	LD	HL,(PARAMS)	;(* upper half of first byte *)
F07B: B6       [36]     	OR	(HL)
F07C: 77       [43]     	LD	(HL),A
F07D: C9       [53]     	RET			;and return (all done).
                        ;
                        ;   Function to return the current cp/m version number.
                        ;
F07E: 3E22     [ 7]     GETVER:	LD	A,022H		;version 2.2
F080: C301E7   [17]     	JP	SETSTAT
                        ;
                        ;   Function to reset the disk system.
                        ;
F083: 210000   [10]     RSTDSK:	LD	HL,0		;clear write protect status and log
F086: 22ADF1   [26]     	LD	(WRTPRT),HL	;in vector.
F089: 22AFF1   [42]     	LD	(LOGIN),HL
F08C: AF       [46]     	XOR	A		;select drive 'A'.
F08D: 3242E7   [59]     	LD	(ACTIVE),A
F090: 218000   [69]     	LD	HL,TBUFF	;setup default dma address.
F093: 22B1F1   [85]     	LD	(USERDMA),HL
F096: CDDAE9   [102]    	CALL	DEFDMA
F099: C321F0   [112]    	JP	LOGINDRV	;now log in drive 'A'.
                        ;
                        ;   Function to open a specified file.
                        ;
F09C: CD72E9   [17]     OPENFIL:CALL	CLEARS2		;clear 's2' byte.
F09F: CD51F0   [34]     	CALL	AUTOSEL		;select proper disk.
F0A2: C351EC   [44]     	JP	OPENIT		;and open the file.
                        ;
                        ;   Function to close a specified file.
                        ;
F0A5: CD51F0   [17]     CLOSEFIL: CALL	AUTOSEL		;select proper disk.
F0A8: C3A2EC   [27]     	JP	CLOSEIT		;and close the file.
                        ;
                        ;   Function to return the first occurence of a specified file
                        ; name. If the first byte of the fcb is '?' then the name will
                        ; not be checked (get the first entry no matter what).
                        ;
F0AB: 0E00     [ 7]     GETFST:	LD	C,0		;prepare for special search.
F0AD: EB       [11]     	EX	DE,HL
F0AE: 7E       [18]     	LD	A,(HL)		;is first byte a '?'?
F0AF: FE3F     [25]     	CP	'?'
F0B1: CAC2F0   [35|35]  	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
F0B4: CDA6E8   [52]     	CALL	SETEXT		;get the extension byte from fcb.
F0B7: 7E       [59]     	LD	A,(HL)		;is it '?'? if yes, then we want
F0B8: FE3F     [66]     	CP	'?'		;an entry with a specific 's2' byte.
F0BA: C472E9   [76|83]  	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
F0BD: CD51F0   [93]     	CALL	AUTOSEL		;select proper drive.
F0C0: 0E0F     [100]    	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
F0C2: CD18EB   [17]     GETFST1:CALL	FINDFST		;find an entry and then move it into
F0C5: C3E9E9   [27]     	JP	MOVEDIR		;the users dma space.
                        ;
                        ;   Function to return the next occurence of a file name.
                        ;
F0C8: 2AD9F1   [16]     GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
F0CB: 2243E7   [32]     	LD	(PARAMS),HL	;other dbos calls are allowed.
F0CE: CD51F0   [49]     	CALL	AUTOSEL		;no error will be returned, but the
F0D1: CD2DEB   [66]     	CALL	FINDNXT		;results will be wrong.
F0D4: C3E9E9   [76]     	JP	MOVEDIR
                        ;
                        ;   Function to delete a file by name.
                        ;
F0D7: CD51F0   [17]     DELFILE:CALL	AUTOSEL		;select proper drive.
F0DA: CD9CEB   [34]     	CALL	ERAFILE		;erase the file.
F0DD: C301EB   [44]     	JP	STSTATUS	;set status and return.
                        ;
                        ;   Function to execute a sequential read of the specified
                        ; record number.
                        ;
F0E0: CD51F0   [17]     READSEQ:CALL	AUTOSEL		;select proper drive then read.
F0E3: C3BCED   [27]     	JP	RDSEQ
                        ;
                        ;   Function to write the net sequential record.
                        ;
F0E6: CD51F0   [17]     WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
F0E9: C3FEED   [27]     	JP	WTSEQ
                        ;
                        ;   Create a file function.
                        ;
F0EC: CD72E9   [17]     FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
F0EF: CD51F0   [34]     	CALL	AUTOSEL		;select proper drive and get the next
F0F2: C324ED   [44]     	JP	GETEMPTY	;empty directory space.
                        ;
                        ;   Function to rename a file.
                        ;
F0F5: CD51F0   [17]     RENFILE:CALL	AUTOSEL		;select proper drive and then switch
F0F8: CD16EC   [34]     	CALL	CHGNAMES	;file names.
F0FB: C301EB   [44]     	JP	STSTATUS
                        ;
                        ;   Function to return the login vector.
                        ;
F0FE: 2AAFF1   [16]     GETLOG:	LD	HL,(LOGIN)
F101: C329F1   [26]     	JP	GETPRM1
                        ;
                        ;   Function to return the current disk assignment.
                        ;
F104: 3A42E7   [13]     GETCRNT:LD	A,(ACTIVE)
F107: C301E7   [23]     	JP	SETSTAT
                        ;
                        ;   Function to set the dma address.
                        ;
F10A: EB       [ 4]     PUTDMA:	EX	DE,HL
F10B: 22B1F1   [20]     	LD	(USERDMA),HL	;save in our space and then get to
F10E: C3DAE9   [30]     	JP	DEFDMA		;the bios with this also.
                        ;
                        ;   Function to return the allocation vector.
                        ;
F111: 2ABFF1   [16]     GETALOC:LD	HL,(ALOCVECT)
F114: C329F1   [26]     	JP	GETPRM1
                        ;
                        ;   Function to return the read-only status vector.
                        ;
F117: 2AADF1   [16]     GETROV:	LD	HL,(WRTPRT)
F11A: C329F1   [26]     	JP	GETPRM1
                        ;
                        ;   Function to set the file attributes (read-only, system).
                        ;
F11D: CD51F0   [17]     SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
F120: CD3BEC   [34]     	CALL	SAVEATTR
F123: C301EB   [44]     	JP	STSTATUS
                        ;
                        ;   Function to return the address of the disk parameter block
                        ; for the current drive.
                        ;
F126: 2ABBF1   [16]     GETPARM:LD	HL,(DISKPB)
F129: 2245E7   [16]     GETPRM1:LD	(STATUS),HL
F12C: C9       [26]     	RET	
                        ;
                        ;   Function to get or set the user number. If (E) was (FF)
                        ; then this is a request to return the current user number.
                        ; Else set the user number from (E).
                        ;
F12D: 3AD6F1   [13]     GETUSER:LD	A,(EPARAM)	;get parameter.
F130: FEFF     [20]     	CP	0FFH		;get user number?
F132: C23BF1   [30|30]  	JP	NZ,SETUSER
F135: 3A41E7   [43]     	LD	A,(USERNO)	;yes, just do it.
F138: C301E7   [53]     	JP	SETSTAT
F13B: E61F     [ 7]     SETUSER:AND	1FH		;no, we should set it instead. keep low
F13D: 3241E7   [20]     	LD	(USERNO),A	;bits (0-4) only.
F140: C9       [30]     	RET	
                        ;
                        ;   Function to read a random record from a file.
                        ;
F141: CD51F0   [17]     RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
F144: C393EF   [27]     	JP	READRAN
                        ;
                        ;   Function to compute the file size for random files.
                        ;
F147: CD51F0   [17]     WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
F14A: C39CEF   [27]     	JP	WRITERAN
                        ;
                        ;   Function to compute the size of a random file.
                        ;
F14D: CD51F0   [17]     FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
F150: C3D2EF   [27]     	JP	RANSIZE
                        ;
                        ;   Function #37. This allows a program to log off any drives.
                        ; On entry, set (DE) to contain a word with bits set for those
                        ; drives that are to be logged off. The log-in vector and the
                        ; write protect vector will be updated. This must be a M/PM
                        ; special function.
                        ;
F153: 2A43E7   [16]     LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
F156: 7D       [20]     	LD	A,L		;for each bit that is set, we want
F157: 2F       [24]     	CPL			;to clear that bit in (LOGIN)
F158: 5F       [28]     	LD	E,A		;and (WRTPRT).
F159: 7C       [32]     	LD	A,H
F15A: 2F       [36]     	CPL	
F15B: 2AAFF1   [52]     	LD	HL,(LOGIN)	;reset the login vector.
F15E: A4       [56]     	AND	H
F15F: 57       [60]     	LD	D,A
F160: 7D       [64]     	LD	A,L
F161: A3       [68]     	AND	E
F162: 5F       [72]     	LD	E,A
F163: 2AADF1   [88]     	LD	HL,(WRTPRT)
F166: EB       [92]     	EX	DE,HL
F167: 22AFF1   [108]    	LD	(LOGIN),HL	;and save.
F16A: 7D       [112]    	LD	A,L		;now do the write protect vector.
F16B: A3       [116]    	AND	E
F16C: 6F       [120]    	LD	L,A
F16D: 7C       [124]    	LD	A,H
F16E: A2       [128]    	AND	D
F16F: 67       [132]    	LD	H,A
F170: 22ADF1   [148]    	LD	(WRTPRT),HL	;and save. all done.
F173: C9       [158]    	RET	
                        ;
                        ;   Get here to return to the user.
                        ;
F174: 3ADEF1   [13]     GOBACK:	LD	A,(AUTO)	;was auto select activated?
F177: B7       [17]     	OR	A
F178: CA91F1   [27|27]  	JP	Z,GOBACK1
F17B: 2A43E7   [43]     	LD	HL,(PARAMS)	;yes, but was a change made?
F17E: 3600     [53]     	LD	(HL),0		;(* reset first byte of fcb *)
F180: 3AE0F1   [66]     	LD	A,(AUTOFLAG)
F183: B7       [70]     	OR	A
F184: CA91F1   [80|80]  	JP	Z,GOBACK1
F187: 77       [87]     	LD	(HL),A		;yes, reset first byte properly.
F188: 3ADFF1   [100]    	LD	A,(OLDDRV)	;and get the old drive and select it.
F18B: 32D6F1   [113]    	LD	(EPARAM),A
F18E: CD45F0   [130]    	CALL	SETDSK
F191: 2A0FE7   [16]     GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
F194: F9       [22]     	LD	SP,HL
F195: 2A45E7   [38]     	LD	HL,(STATUS)	;get return status.
F198: 7D       [42]     	LD	A,L		;force version 1.4 compatability.
F199: 44       [46]     	LD	B,H
F19A: C9       [56]     	RET			;and go back to user.
                        ;
                        ;   Function #40. This is a special entry to do random i/o.
                        ; For the case where we are writing to unused disk space, this
                        ; space will be zeroed out first. This must be a M/PM special
                        ; purpose function, because why would any normal program even
                        ; care about the previous contents of a sector about to be
                        ; written over.
                        ;
F19B: CD51F0   [17]     WTSPECL:CALL	AUTOSEL		;select proper drive.
F19E: 3E02     [24]     	LD	A,2		;use special write mode.
F1A0: 32D5F1   [37]     	LD	(MODE),A
F1A3: 0E00     [44]     	LD	C,0		;set write indicator.
F1A5: CD07EF   [61]     	CALL	POSITN1		;position the file.
F1A8: CC03EE   [71|78]  	CALL	Z,WTSEQ1	;and write (if no errors).
F1AB: C9       [81]     	RET	
                        ;
                        ;**************************************************************
                        ;*
                        ;*     BDOS data storage pool.
                        ;*
                        ;**************************************************************
                        ;
F1AC: E5                EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
F1AD: 0000              WRTPRT:	DEFW	0		;write protect status for all 16 drives.
F1AF: 0000              LOGIN:	DEFW	0		;drive active word (1 bit per drive).
F1B1: 8000              USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
                        ;
                        ;   Scratch areas from parameter block.
                        ;
F1B3: 0000              SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
F1B5: 0000              SCRATCH2: DEFW	0		;last selected track number.
F1B7: 0000              SCRATCH3: DEFW	0		;last selected sector number.
                        ;
                        ;   Disk storage areas from parameter block.
                        ;
F1B9: 0000              DIRBUF:	DEFW	0		;address of directory buffer to use.
F1BB: 0000              DISKPB:	DEFW	0		;contains address of disk parameter block.
F1BD: 0000              CHKVECT:DEFW	0		;address of check vector.
F1BF: 0000              ALOCVECT: DEFW	0		;address of allocation vector (bit map).
                        ;
                        ;   Parameter block returned from the bios.
                        ;
F1C1: 0000              SECTORS:DEFW	0		;sectors per track from bios.
F1C3: 00                BLKSHFT:DEFB	0		;block shift.
F1C4: 00                BLKMASK:DEFB	0		;block mask.
F1C5: 00                EXTMASK:DEFB	0		;extent mask.
F1C6: 0000              DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
F1C8: 0000              DIRSIZE:DEFW	0		;directory size.
F1CA: 0000              ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
F1CC: 0000              ALLOC1:	DEFW	0
F1CE: 0000              OFFSET:	DEFW	0		;first usable track number.
F1D0: 0000              XLATE:	DEFW	0		;sector translation table address.
                        ;
                        ;
F1D2: 00                CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
F1D3: 00                RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
F1D4: 00                FNDSTAT:DEFB	0		;filename found status (0=found first entry).
F1D5: 00                MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
F1D6: 00                EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
F1D7: 00                RELBLOCK: DEFB	0		;relative position within fcb of block number written.
F1D8: 00                COUNTER:DEFB	0		;byte counter for directory name searches.
F1D9: 00000000          SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
F1DD: 00                BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
F1DE: 00                AUTO:	DEFB	0		;if non-zero, then auto select activated.
F1DF: 00                OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
F1E0: 00                AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
F1E1: 00                SAVNXT:	DEFB	0		;storage for next record number to access.
F1E2: 00                SAVEXT:	DEFB	0		;storage for extent number of file.
F1E3: 0000              SAVNREC:DEFW	0		;storage for number of records in file.
F1E5: 0000              BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
F1E7: 0000              LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
F1E9: 00                FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
F1EA: 0000              FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
                        ;
                        ;   Disk directory buffer checksum bytes. One for each of the
                        ; 16 possible drives.
                        ;
F1EC: 00000000          CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
F1F0: 00...             
                        ;
                        ;   Extra space ?
                        ;
F1FC: 00000000          	DEFB	0,0,0,0
                        ;
                        ;**************************************************************
                        ;*
                        ;*        B I O S   J U M P   T A B L E
                        ;*
                        ;**************************************************************
                        ;
F200: C30000   [10]     BOOT:	JP	0		;NOTE WE USE FAKE DESTINATIONS
F203: C30000   [10]     WBOOT:	JP	0
F206: C30000   [10]     CONST:	JP	0
F209: C30000   [10]     CONIN:	JP	0
F20C: C30000   [10]     CONOUT:	JP	0
F20F: C30000   [10]     LIST:	JP	0
F212: C30000   [10]     PUNCH:	JP	0
F215: C30000   [10]     READER:	JP	0
F218: C30000   [10]     HOME:	JP	0
F21B: C30000   [10]     SELDSK:	JP	0
F21E: C30000   [10]     SETTRK:	JP	0
F221: C30000   [10]     SETSEC:	JP	0
F224: C30000   [10]     SETDMA:	JP	0
F227: C30000   [10]     READ:	JP	0
F22A: C30000   [10]     WRITE:	JP	0
F22D: C30000   [10]     PRSTAT:	JP	0
F230: C30000   [10]     SECTRN:	JP	0
                        ;
                        ;*
                        ;******************   E N D   O F   C P / M   *****************
                        ;*
                        


; +++ segments +++

#CODE          = $DC00 = 56320,  size = $1633 =  5683

; +++ global symbols +++

ACTIVE   = $E742 = 59202          CPM22.Z80:1699
ADDA2HL  = $E964 = 59748          CPM22.Z80:2129
ADDHL    = $DE59 = 56921          CPM22.Z80:431
ALLOC0   = $F1CA = 61898          CPM22.Z80:3677
ALLOC1   = $F1CC = 61900          CPM22.Z80:3678
ALOCVECT = $F1BF = 61887          CPM22.Z80:3667
AUTO     = $F1DE = 61918          CPM22.Z80:3692
AUTOFLAG = $F1E0 = 61920          CPM22.Z80:3694
AUTOSEL  = $F051 = 61521          CPM22.Z80:3407
AUTOSL1  = $F075 = 61557          CPM22.Z80:3423
BACKUP   = $E5A4 = 58788          CPM22.Z80:1459
BACKUP1  = $E5AC = 58796          CPM22.Z80:1462
BADLOAD  = $E37A = 58234          CPM22.Z80:1190
BADSCTR  = $E409 = 58377          CPM22.Z80:1243
BADSEC   = $E4CA = 58570          CPM22.Z80:1314
BADSEL   = $E4D5 = 58581          CPM22.Z80:1315
BADSLCT  = $E40B = 58379          CPM22.Z80:1244
BATCH    = $E3AB = 58283          CPM22.Z80:1213
BATCHFCB = $E3AC = 58284          CPM22.Z80:1214
BDOSDRV  = $E4C6 = 58566          CPM22.Z80:1313
BDOSERR  = $E4BA = 58554          CPM22.Z80:1312
BIGDISK  = $F1DD = 61917          CPM22.Z80:3691
BITMAP   = $EAA3 = 60067          CPM22.Z80:2422
BITMAP1  = $EAB1 = 60081          CPM22.Z80:2437
BITMAP2  = $EAD2 = 60114          CPM22.Z80:2458
BITMAP3  = $EAF6 = 60150          CPM22.Z80:2475
BLKMASK  = $F1C4 = 61892          CPM22.Z80:3673
BLKNMBR  = $F1E5 = 61925          CPM22.Z80:3698
BLKSHFT  = $F1C3 = 61891          CPM22.Z80:3672
BOOT     = $F200 = 61952          CPM22.Z80:3718 (unused)
BS       = $0008 =     8          CPM22.Z80:27
CBASE    = $DC00 = 56320          CPM22.Z80:44
CCPSTACK = $E3AB = 58283          CPM22.Z80:1209
CDRIVE   = $E3EF = 58351          CPM22.Z80:1220
CHARBUF  = $E70E = 59150          CPM22.Z80:1688
CHECK    = $DE30 = 56880          CPM22.Z80:397
CHECKDIR = $E99E = 59806          CPM22.Z80:2202
CHECKSUM = $E8F7 = 59639          CPM22.Z80:2040
CHGDRV   = $E3F0 = 58352          CPM22.Z80:1221
CHGNAM1  = $EC27 = 60455          CPM22.Z80:2714
CHGNAMES = $EC16 = 60438          CPM22.Z80:2706
CHKBLK   = $E884 = 59524          CPM22.Z80:1947
CHKCHAR  = $E514 = 58644          CPM22.Z80:1356
CHKCON   = $DDC2 = 56770          CPM22.Z80:322
CHKDIR1  = $E9C4 = 59844          CPM22.Z80:2222
CHKNMBR  = $E98C = 59788          CPM22.Z80:2175
CHKROFL  = $E944 = 59716          CPM22.Z80:2105
CHKSUM1  = $E8FD = 59645          CPM22.Z80:2043
CHKVECT  = $F1BD = 61885          CPM22.Z80:3666
CHKWPRT  = $E954 = 59732          CPM22.Z80:2116
CKBITMAP = $EA35 = 59957          CPM22.Z80:2316
CKBMAP1  = $EA56 = 59990          CPM22.Z80:2351
CKCON1   = $E542 = 58690          CPM22.Z80:1386
CKCON2   = $E545 = 58693          CPM22.Z80:1387
CKCONSOL = $E523 = 58659          CPM22.Z80:1372
CKFILPOS = $E9F5 = 59893          CPM22.Z80:2265
CKROF1   = $E947 = 59719          CPM22.Z80:2106
CKSUMTBL = $F1EC = 61932          CPM22.Z80:3706
CLEARBUF = $DF58 = 57176          CPM22.Z80:597
CLEARS2  = $E972 = 59762          CPM22.Z80:2146
CLOSE    = $DCDA = 56538          CPM22.Z80:137
CLOSEFIL = $F0A5 = 61605          CPM22.Z80:3454
CLOSEFLG = $F1D2 = 61906          CPM22.Z80:3683
CLOSEIT  = $ECA2 = 60578          CPM22.Z80:2800
CLOSEIT1 = $ECCD = 60621          CPM22.Z80:2820
CLOSEIT2 = $ECDB = 60635          CPM22.Z80:2828
CLOSEIT3 = $ECE1 = 60641          CPM22.Z80:2832
CLOSEIT4 = $ECE8 = 60648          CPM22.Z80:2835
CLOSEIT5 = $ECFD = 60669          CPM22.Z80:2848
CLOSEIT6 = $ED17 = 60695          CPM22.Z80:2866
CLOSEIT7 = $ED1F = 60703          CPM22.Z80:2869
CMDADR   = $DFC1 = 57281          CPM22.Z80:669
CMDTBL   = $DF10 = 57104          CPM22.Z80:551
CMMND1   = $DF82 = 57218          CPM22.Z80:630
CMMND2   = $DF98 = 57240          CPM22.Z80:641
CNTRLC   = $0003 =     3          CPM22.Z80:25
CNTRLE   = $0005 =     5          CPM22.Z80:26
CNTRLP   = $0010 =    16          CPM22.Z80:32
CNTRLR   = $0012 =    18          CPM22.Z80:33
CNTRLS   = $0013 =    19          CPM22.Z80:34
CNTRLU   = $0015 =    21          CPM22.Z80:35
CNTRLX   = $0018 =    24          CPM22.Z80:36
CNTRLZ   = $001A =    26          CPM22.Z80:37
COMBLK   = $E877 = 59511          CPM22.Z80:1938
COMFILE  = $E383 = 58243          CPM22.Z80:1191
COMMAND  = $DF5C = 57180          CPM22.Z80:607
COMPRAND = $EFA5 = 61349          CPM22.Z80:3273
CONIN    = $F209 = 61961          CPM22.Z80:3721
CONOUT   = $F20C = 61964          CPM22.Z80:3722
CONST    = $F206 = 61958          CPM22.Z80:3720
CONVERT  = $DE60 = 56928          CPM22.Z80:445
CONVFST  = $DE5E = 56926          CPM22.Z80:439
CONVRT1  = $DE89 = 56969          CPM22.Z80:468
CONVRT2  = $DE90 = 56976          CPM22.Z80:471
CONVRT3  = $DE96 = 56982          CPM22.Z80:478
CONVRT4  = $DE98 = 56984          CPM22.Z80:479
CONVRT5  = $DEA9 = 57001          CPM22.Z80:486
CONVRT6  = $DEAB = 57003          CPM22.Z80:488
CONVRT7  = $DEAF = 57007          CPM22.Z80:490
CONVRT8  = $DEB9 = 57017          CPM22.Z80:494
COUNTER  = $F1D8 = 61912          CPM22.Z80:3689
CR       = $000D =    13          CPM22.Z80:31
CREATE   = $DD09 = 56585          CPM22.Z80:187
CRLF     = $DC98 = 56472          CPM22.Z80:79
CURPOS   = $E70C = 59148          CPM22.Z80:1686
DE2HL    = $E74F = 59215          CPM22.Z80:1717
DE2HL1   = $E750 = 59216          CPM22.Z80:1718
DECODE   = $DFF8 = 57336          CPM22.Z80:696
DECODE1  = $E008 = 57352          CPM22.Z80:702
DECODE2  = $E02A = 57386          CPM22.Z80:722 (unused)
DECODE3  = $E033 = 57395          CPM22.Z80:727
DECODE4  = $E03A = 57402          CPM22.Z80:731 (unused)
DEFDMA   = $E9DA = 59866          CPM22.Z80:2240
DEL      = $007F =   127          CPM22.Z80:38
DELBATCH = $DDDD = 56797          CPM22.Z80:347
DELETE   = $DCEF = 56559          CPM22.Z80:158
DELFILE  = $F0D7 = 61655          CPM22.Z80:3485
DIRBUF   = $F1B9 = 61881          CPM22.Z80:3664
DIRC1    = $E6E0 = 59104          CPM22.Z80:1644
DIRCIO   = $E6D4 = 59092          CPM22.Z80:1638
DIRDMA   = $E9E0 = 59872          CPM22.Z80:2245
DIRDMA1  = $E9E3 = 59875          CPM22.Z80:2250
DIRECT   = $E077 = 57463          CPM22.Z80:793
DIRECT1  = $E088 = 57480          CPM22.Z80:800
DIRECT2  = $E08F = 57487          CPM22.Z80:804
DIRECT3  = $E098 = 57496          CPM22.Z80:808
DIRECT4  = $E0CC = 57548          CPM22.Z80:835
DIRECT5  = $E0D4 = 57556          CPM22.Z80:838
DIRECT6  = $E0D9 = 57561          CPM22.Z80:840
DIRECT7  = $E10E = 57614          CPM22.Z80:864
DIRECT8  = $E10F = 57615          CPM22.Z80:865
DIRECT9  = $E11B = 57627          CPM22.Z80:869
DIRREAD  = $E9D4 = 59860          CPM22.Z80:2235
DIRSIZE  = $F1C8 = 61896          CPM22.Z80:3676
DIRWRITE = $E9C6 = 59846          CPM22.Z80:2227
DISKPB   = $F1BB = 61883          CPM22.Z80:3665
DISKRO   = $E4E1 = 58593          CPM22.Z80:1317
DMASET   = $DDD8 = 56792          CPM22.Z80:342
DOREAD   = $E7B2 = 59314          CPM22.Z80:1788
DOWRITE  = $E7B8 = 59320          CPM22.Z80:1793
DRECT63  = $E0F7 = 57591          CPM22.Z80:854
DRECT65  = $E0F9 = 57593          CPM22.Z80:855
DSELECT  = $E054 = 57428          CPM22.Z80:763
DSKSEL   = $DCBD = 56509          CPM22.Z80:111
DSKSIZE  = $F1C6 = 61894          CPM22.Z80:3675
EMPTYFCB = $F1AC = 61868          CPM22.Z80:3651
ENTRY    = $0005 =     5          CPM22.Z80:18
ENTRY1   = $DCC3 = 56515          CPM22.Z80:118
ENTRY2   = $DCF4 = 56564          CPM22.Z80:164
EPARAM   = $F1D6 = 61910          CPM22.Z80:3687
ERAFIL1  = $EBA4 = 60324          CPM22.Z80:2592
ERAFILE  = $EB9C = 60316          CPM22.Z80:2589
ERASE    = $E11F = 57631          CPM22.Z80:878
ERASE1   = $E142 = 57666          CPM22.Z80:893
ERROR1   = $E499 = 58521          CPM22.Z80:1295
ERROR2   = $E4A5 = 58533          CPM22.Z80:1301
ERROR3   = $E4AB = 58539          CPM22.Z80:1304
ERROR4   = $E4B1 = 58545          CPM22.Z80:1307
ERROR5   = $E4B4 = 58548          CPM22.Z80:1309
EXISTS   = $E282 = 57986          CPM22.Z80:1055
EXTBLK   = $E85E = 59486          CPM22.Z80:1919
EXTBLK1  = $E871 = 59505          CPM22.Z80:1929
EXTMASK  = $F1C5 = 61893          CPM22.Z80:3674
EXTRACT  = $E04B = 57419          CPM22.Z80:753
FBASE    = $E406 = 58374          CPM22.Z80:1239 (unused)
FBASE1   = $E411 = 58385          CPM22.Z80:1251
FCB      = $E3CD = 58317          CPM22.Z80:1218
FCB2HL   = $E95E = 59742          CPM22.Z80:2124
FCBPOS   = $F1E9 = 61929          CPM22.Z80:3700
FCBSET   = $EBFD = 60413          CPM22.Z80:2684
FCREATE  = $F0EC = 61676          CPM22.Z80:3502
FF       = $000C =    12          CPM22.Z80:30 (unused)
FILEPOS  = $F1EA = 61930          CPM22.Z80:3701
FILERO   = $E4DC = 58588          CPM22.Z80:1316
FILESIZE = $F14D = 61773          CPM22.Z80:3576
FINDFST  = $EB18 = 60184          CPM22.Z80:2509
FINDNXT  = $EB2D = 60205          CPM22.Z80:2522
FNDNXT1  = $EB4A = 60234          CPM22.Z80:2535
FNDNXT2  = $EB53 = 60243          CPM22.Z80:2539
FNDNXT3  = $EB73 = 60275          CPM22.Z80:2555
FNDNXT4  = $EB7C = 60284          CPM22.Z80:2564
FNDNXT5  = $EB83 = 60291          CPM22.Z80:2569
FNDNXT6  = $EB94 = 60308          CPM22.Z80:2582
FNDSPA1  = $EBC0 = 60352          CPM22.Z80:2622
FNDSPA2  = $EBD1 = 60369          CPM22.Z80:2645
FNDSPA3  = $EBEC = 60396          CPM22.Z80:2666
FNDSPA4  = $EBF4 = 60404          CPM22.Z80:2676
FNDSPACE = $EBBE = 60350          CPM22.Z80:2616
FNDSTAT  = $F1D4 = 61908          CPM22.Z80:3685
FUNCTNS  = $E447 = 58439          CPM22.Z80:1286
GETALOC  = $F111 = 61713          CPM22.Z80:3530
GETBACK  = $E386 = 58246          CPM22.Z80:1197
GETBACK1 = $E389 = 58249          CPM22.Z80:1198
GETBLK1  = $E845 = 59461          CPM22.Z80:1897
GETBLK2  = $E853 = 59475          CPM22.Z80:1906
GETBLK3  = $E85C = 59484          CPM22.Z80:1911
GETBLOCK = $E83E = 59454          CPM22.Z80:1894
GETCHAR  = $E4FB = 58619          CPM22.Z80:1334
GETCON   = $E6C8 = 59080          CPM22.Z80:1626
GETCRNT  = $F104 = 61700          CPM22.Z80:3519
GETCSTS  = $E6FE = 59134          CPM22.Z80:1671
GETDSK   = $DDD0 = 56784          CPM22.Z80:333
GETECHO  = $E506 = 58630          CPM22.Z80:1343
GETEMPTY = $ED24 = 60708          CPM22.Z80:2876
GETEXT   = $DEC0 = 57024          CPM22.Z80:501
GETEXT1  = $DEC8 = 57032          CPM22.Z80:505
GETEXT2  = $DED9 = 57049          CPM22.Z80:512
GETEXT3  = $DEDB = 57051          CPM22.Z80:514
GETEXT4  = $DEDF = 57055          CPM22.Z80:516
GETEXT5  = $DEE9 = 57065          CPM22.Z80:520
GETEXT6  = $DEF0 = 57072          CPM22.Z80:524
GETEXT7  = $DEF2 = 57074          CPM22.Z80:525
GETEXT8  = $DF01 = 57089          CPM22.Z80:537
GETEXT9  = $DF09 = 57097          CPM22.Z80:542
GETFST   = $F0AB = 61611          CPM22.Z80:3461
GETFST1  = $F0C2 = 61634          CPM22.Z80:3472
GETINP   = $DD39 = 56633          CPM22.Z80:238
GETINP1  = $DD96 = 56726          CPM22.Z80:294
GETINP2  = $DDA7 = 56743          CPM22.Z80:303
GETINP3  = $DDAB = 56747          CPM22.Z80:305
GETINP4  = $DDBA = 56762          CPM22.Z80:314
GETIOB   = $E6ED = 59117          CPM22.Z80:1652
GETLOG   = $F0FE = 61694          CPM22.Z80:3514
GETMT1   = $ED46 = 60742          CPM22.Z80:2892
GETNEXT  = $ED5A = 60762          CPM22.Z80:2906
GETNXT   = $F0C8 = 61640          CPM22.Z80:3477
GETPARM  = $F126 = 61734          CPM22.Z80:3547
GETPRM1  = $F129 = 61737          CPM22.Z80:3548
GETRDR   = $E6CE = 59086          CPM22.Z80:1631
GETROV   = $F117 = 61719          CPM22.Z80:3535
GETS2    = $E969 = 59753          CPM22.Z80:2138
GETSETUC = $DD15 = 56597          CPM22.Z80:203
GETUSER  = $F12D = 61741          CPM22.Z80:3555
GETUSR   = $DD13 = 56595          CPM22.Z80:198
GETVER   = $F07E = 61566          CPM22.Z80:3431
GETWPRT  = $E91E = 59678          CPM22.Z80:2078
GOBACK   = $F174 = 61812          CPM22.Z80:3611
GOBACK1  = $F191 = 61841          CPM22.Z80:3623
GTNEXT1  = $ED83 = 60803          CPM22.Z80:2926
GTNEXT2  = $ED8E = 60814          CPM22.Z80:2935
GTNEXT3  = $EDAC = 60844          CPM22.Z80:2946
GTNEXT4  = $EDAF = 60847          CPM22.Z80:2947
GTNEXT5  = $EDB6 = 60854          CPM22.Z80:2954
HALT     = $DFCF = 57295          CPM22.Z80:674
HL2DE    = $E042 = 57410          CPM22.Z80:743
HOME     = $F218 = 61976          CPM22.Z80:3726
HOMEDRV  = $E7A1 = 59297          CPM22.Z80:1774
INBUFF   = $DC06 = 56326          CPM22.Z80:51
INPOINT  = $DC88 = 56456          CPM22.Z80:59
IOBYTE   = $0003 =     3          CPM22.Z80:16
IOERR1   = $E705 = 59141          CPM22.Z80:1681
IORET    = $E7BB = 59323          CPM22.Z80:1794
JUMPHL   = $E74A = 59210          CPM22.Z80:1709
LF       = $000A =    10          CPM22.Z80:29
LIST     = $F20F = 61967          CPM22.Z80:3723
LOGICAL  = $E88A = 59530          CPM22.Z80:1958
LOGICL1  = $E890 = 59536          CPM22.Z80:1960
LOGIN    = $F1AF = 61871          CPM22.Z80:3653
LOGINDRV = $F021 = 61473          CPM22.Z80:3375
LOGOFF   = $F153 = 61779          CPM22.Z80:3585
LOGSECT  = $F1E7 = 61927          CPM22.Z80:3699
MEM      = $003E =    62          CPM22.Z80:14
MODE     = $F1D5 = 61909          CPM22.Z80:3686
MOREFLS  = $E97F = 59775          CPM22.Z80:2162
MOVE3    = $E040 = 57408          CPM22.Z80:739
MOVECD   = $DD29 = 56617          CPM22.Z80:220
MOVEDIR  = $E9E9 = 59881          CPM22.Z80:2257
MOVEWORD = $EC94 = 60564          CPM22.Z80:2783
NAMEPNT  = $DC8A = 56458          CPM22.Z80:60
NBYTES   = $E3F1 = 58353          CPM22.Z80:1222
NEWLINE  = $E5B1 = 58801          CPM22.Z80:1468
NEWLN1   = $E5B9 = 58809          CPM22.Z80:1471
NFUNCTS  = $0029 =    41          CPM22.Z80:1284
NOFILE   = $DFF0 = 57328          CPM22.Z80:689
NONBLANK = $DE4F = 56911          CPM22.Z80:421
NONE     = $DFEA = 57322          CPM22.Z80:687
NOSPACE  = $E207 = 57863          CPM22.Z80:997
NUMCMDS  = $0006 =     6          CPM22.Z80:550
NXENT1   = $EA19 = 59929          CPM22.Z80:2295
NXENT2   = $EA20 = 59936          CPM22.Z80:2298
NXENTRY  = $EA05 = 59909          CPM22.Z80:2287
OFFSET   = $F1CE = 61902          CPM22.Z80:3679
OLDDRV   = $F1DF = 61919          CPM22.Z80:3693
OPEN     = $DCCB = 56523          CPM22.Z80:125
OPENFCB  = $DCD0 = 56528          CPM22.Z80:130
OPENFIL  = $F09C = 61596          CPM22.Z80:3448
OPENIT   = $EC51 = 60497          CPM22.Z80:2740
OPENIT1  = $EC5A = 60506          CPM22.Z80:2744
OPENIT2  = $EC8B = 60555          CPM22.Z80:2772
OUTCHAR  = $E548 = 58696          CPM22.Z80:1394
OUTCHR1  = $E562 = 58722          CPM22.Z80:1408
OUTCHR2  = $E579 = 58745          CPM22.Z80:1424
OUTCON   = $E590 = 58768          CPM22.Z80:1445
OUTCON1  = $E596 = 58774          CPM22.Z80:1448
OUTCRLF  = $E5C9 = 58825          CPM22.Z80:1481
OUTFLAG  = $E70A = 59146          CPM22.Z80:1684
PARAMS   = $E743 = 59203          CPM22.Z80:1700
PATTRN1  = $DF28 = 57128          CPM22.Z80:561
PATTRN2  = $E400 = 58368          CPM22.Z80:1231
PLINE    = $DCA7 = 56487          CPM22.Z80:92
PLINE2   = $DCAC = 56492          CPM22.Z80:95
POSITION = $EF03 = 61187          CPM22.Z80:3150
POSITN1  = $EF07 = 61191          CPM22.Z80:3155
POSITN2  = $EF47 = 61255          CPM22.Z80:3201
POSITN3  = $EF7F = 61311          CPM22.Z80:3233
POSITN4  = $EF84 = 61316          CPM22.Z80:3239
POSITN5  = $EF8B = 61323          CPM22.Z80:3246
PRINT    = $DC8C = 56460          CPM22.Z80:65
PRINTB   = $DC92 = 56466          CPM22.Z80:71
PRSTAT   = $F22D = 61997          CPM22.Z80:3733 (unused)
PRTERR   = $E4E5 = 58597          CPM22.Z80:1321
PRTFLAG  = $E70D = 59149          CPM22.Z80:1687
PRTMESG  = $E5D3 = 58835          CPM22.Z80:1488
PRTSTR   = $E6F8 = 59128          CPM22.Z80:1664
PUNCH    = $F212 = 61970          CPM22.Z80:3724
PUTDMA   = $F10A = 61706          CPM22.Z80:3524
RANSIZ1  = $EFE4 = 61412          CPM22.Z80:3329
RANSIZ2  = $F006 = 61446          CPM22.Z80:3351
RANSIZ3  = $F00C = 61452          CPM22.Z80:3353
RANSIZE  = $EFD2 = 61394          CPM22.Z80:3318
RDBUF1   = $E5EF = 58863          CPM22.Z80:1507
RDBUF10  = $E670 = 58992          CPM22.Z80:1569
RDBUF11  = $E678 = 59000          CPM22.Z80:1575
RDBUF12  = $E68A = 59018          CPM22.Z80:1587
RDBUF13  = $E699 = 59033          CPM22.Z80:1594
RDBUF14  = $E6A6 = 59046          CPM22.Z80:1602
RDBUF15  = $E6A9 = 59049          CPM22.Z80:1605
RDBUF16  = $E6BD = 59069          CPM22.Z80:1617
RDBUF17  = $E6C1 = 59073          CPM22.Z80:1619
RDBUF2   = $E5F1 = 58865          CPM22.Z80:1509
RDBUF3   = $E616 = 58902          CPM22.Z80:1526
RDBUF4   = $E626 = 58918          CPM22.Z80:1535
RDBUF5   = $E637 = 58935          CPM22.Z80:1543
RDBUF6   = $E648 = 58952          CPM22.Z80:1552
RDBUF7   = $E64E = 58958          CPM22.Z80:1555
RDBUF8   = $E65F = 58975          CPM22.Z80:1562
RDBUF9   = $E66B = 58987          CPM22.Z80:1567
RDBUFF   = $E5E1 = 58849          CPM22.Z80:1500
RDERR    = $DFDF = 57311          CPM22.Z80:683
RDERROR  = $DFD9 = 57305          CPM22.Z80:681
RDRANDOM = $F141 = 61761          CPM22.Z80:3566
RDREC    = $DCF9 = 56569          CPM22.Z80:171
RDSEQ    = $EDBC = 60860          CPM22.Z80:2959
RDSEQ1   = $EDC1 = 60865          CPM22.Z80:2961
RDSEQ2   = $EDE6 = 60902          CPM22.Z80:2976
RDSEQ3   = $EDFB = 60923          CPM22.Z80:2986
RDWRTFLG = $F1D3 = 61907          CPM22.Z80:3684
READ     = $F227 = 61991          CPM22.Z80:3731
READER   = $F215 = 61973          CPM22.Z80:3725
READFCB  = $DCFE = 56574          CPM22.Z80:176
READRAN  = $EF93 = 61331          CPM22.Z80:3253
READSEQ  = $F0E0 = 61664          CPM22.Z80:3492
RELBLOCK = $F1D7 = 61911          CPM22.Z80:3688
RENAM    = $DD0E = 56590          CPM22.Z80:193
RENAME   = $E210 = 57872          CPM22.Z80:1005
RENAME1  = $E23F = 57919          CPM22.Z80:1023
RENAME2  = $E259 = 57945          CPM22.Z80:1037
RENAME3  = $E25E = 57950          CPM22.Z80:1040 (unused)
RENAME4  = $E26D = 57965          CPM22.Z80:1048
RENAME5  = $E273 = 57971          CPM22.Z80:1050
RENAME6  = $E279 = 57977          CPM22.Z80:1052
RENFILE  = $F0F5 = 61685          CPM22.Z80:3508
RESDSK   = $DCB8 = 56504          CPM22.Z80:106
RESETDR  = $E066 = 57446          CPM22.Z80:777
RODISK   = $E40D = 58381          CPM22.Z80:1245
ROFILE   = $E40F = 58383          CPM22.Z80:1246
RSTDSK   = $F083 = 61571          CPM22.Z80:3436
RTN      = $E704 = 59140          CPM22.Z80:1677
RTNCODE  = $E3EE = 58350          CPM22.Z80:1219
SAMEXT   = $EB07 = 60167          CPM22.Z80:2490
SAVATR1  = $EC40 = 60480          CPM22.Z80:2730
SAVE     = $E1AD = 57773          CPM22.Z80:950
SAVE1    = $E1D4 = 57812          CPM22.Z80:968
SAVE2    = $E1F1 = 57841          CPM22.Z80:986
SAVE3    = $E1FB = 57851          CPM22.Z80:993
SAVE4    = $E201 = 57857          CPM22.Z80:995
SAVEATTR = $EC3B = 60475          CPM22.Z80:2728
SAVEFCB  = $F1D9 = 61913          CPM22.Z80:3690
SAVEXT   = $F1E2 = 61922          CPM22.Z80:3696
SAVNREC  = $F1E3 = 61923          CPM22.Z80:3697
SAVNXT   = $F1E1 = 61921          CPM22.Z80:3695
SCRATCH1 = $F1B3 = 61875          CPM22.Z80:3658
SCRATCH2 = $F1B5 = 61877          CPM22.Z80:3659
SCRATCH3 = $F1B7 = 61879          CPM22.Z80:3660
SEARCH   = $DF2E = 57134          CPM22.Z80:569
SEARCH1  = $DF33 = 57139          CPM22.Z80:571
SEARCH2  = $DF3C = 57148          CPM22.Z80:576
SEARCH3  = $DF4F = 57167          CPM22.Z80:588
SEARCH4  = $DF54 = 57172          CPM22.Z80:591
SECTORS  = $F1C1 = 61889          CPM22.Z80:3671
SECTRN   = $F230 = 62000          CPM22.Z80:3734
SELDSK   = $F21B = 61979          CPM22.Z80:3727
SELECT   = $E759 = 59225          CPM22.Z80:1728
SELECT1  = $E79D = 59293          CPM22.Z80:1768
SETATTR  = $F11D = 61725          CPM22.Z80:3540
SETBIT   = $E90B = 59659          CPM22.Z80:2061
SETCDRV  = $DD1A = 56602          CPM22.Z80:208
SETDIR   = $E99C = 59804          CPM22.Z80:2195
SETDMA   = $F224 = 61988          CPM22.Z80:3730
SETDSK   = $F045 = 61509          CPM22.Z80:3396
SETEXT   = $E8A6 = 59558          CPM22.Z80:1975
SETFILE  = $EA6B = 60011          CPM22.Z80:2380
SETFL1   = $EA75 = 60021          CPM22.Z80:2385
SETFL2   = $EA88 = 60040          CPM22.Z80:2397
SETFL3   = $EA8E = 60046          CPM22.Z80:2403
SETFL4   = $EA9D = 60061          CPM22.Z80:2412
SETHLDE  = $E8AE = 59566          CPM22.Z80:1983
SETIOB   = $E6F3 = 59123          CPM22.Z80:1657
SETNREC  = $E8D2 = 59602          CPM22.Z80:2009
SETRAN   = $F00E = 61454          CPM22.Z80:3359
SETS2B7  = $E978 = 59768          CPM22.Z80:2152
SETSEC   = $F221 = 61985          CPM22.Z80:3729
SETSTAT  = $E701 = 59137          CPM22.Z80:1676
SETTRK   = $F21E = 61982          CPM22.Z80:3728
SETUSER  = $F13B = 61755          CPM22.Z80:3560
SHIFTL   = $E904 = 59652          CPM22.Z80:2052
SHIFTL1  = $E905 = 59653          CPM22.Z80:2053
SHIFTR   = $E8EA = 59626          CPM22.Z80:2025
SHIFTR1  = $E8EB = 59627          CPM22.Z80:2026
SHOWIT   = $E57F = 58751          CPM22.Z80:1432
SLCTERR  = $E747 = 59207          CPM22.Z80:1705
SPACE    = $DCA2 = 56482          CPM22.Z80:86
SRCHFCB  = $DCE9 = 56553          CPM22.Z80:153
SRCHFST  = $DCDF = 56543          CPM22.Z80:143
SRCHNXT  = $DCE4 = 56548          CPM22.Z80:148
STARTING = $E70B = 59147          CPM22.Z80:1685
STATUS   = $E745 = 59205          CPM22.Z80:1701
STBITMAP = $EA5C = 59996          CPM22.Z80:2360
STBMAP1  = $EA64 = 60004          CPM22.Z80:2371
STDDMA   = $DDD5 = 56789          CPM22.Z80:338
STFILPOS = $E9FE = 59902          CPM22.Z80:2275
STKAREA  = $E741 = 59201          CPM22.Z80:1696
STNREC1  = $E8DE = 59614          CPM22.Z80:2014
STRDATA  = $E8BB = 59579          CPM22.Z80:1993
STSTATUS = $EB01 = 60161          CPM22.Z80:2482
SUBHL    = $E995 = 59797          CPM22.Z80:2185
SYNERR   = $DE09 = 56841          CPM22.Z80:376
SYNERR1  = $DE0F = 56847          CPM22.Z80:378
SYNERR2  = $DE22 = 56866          CPM22.Z80:388
TAB      = $0009 =     9          CPM22.Z80:28
TBASE    = $0100 =   256          CPM22.Z80:21
TBUFF    = $0080 =   128          CPM22.Z80:20
TDRIVE   = $0004 =     4          CPM22.Z80:17
TFCB     = $005C =    92          CPM22.Z80:19
TRKSEC   = $E7C3 = 59331          CPM22.Z80:1802
TRKSEC1  = $E7D1 = 59345          CPM22.Z80:1811
TRKSEC2  = $E7E4 = 59364          CPM22.Z80:1824
TRKSEC3  = $E7FA = 59386          CPM22.Z80:1840
TRKSEC4  = $E80F = 59407          CPM22.Z80:1857
TYPE     = $E15D = 57693          CPM22.Z80:907
TYPE1    = $E174 = 57716          CPM22.Z80:915
TYPE2    = $E177 = 57719          CPM22.Z80:916 (unused)
TYPE3    = $E187 = 57735          CPM22.Z80:925
TYPE4    = $E1A0 = 57760          CPM22.Z80:938
TYPE5    = $E1A7 = 57767          CPM22.Z80:941
UNKNOWN  = $E2A5 = 58021          CPM22.Z80:1079
UNKWN0   = $E371 = 58225          CPM22.Z80:1187
UNKWN1   = $E2C4 = 58052          CPM22.Z80:1094
UNKWN2   = $E2CD = 58061          CPM22.Z80:1098 (unused)
UNKWN3   = $E2E1 = 58081          CPM22.Z80:1109
UNKWN4   = $E301 = 58113          CPM22.Z80:1128
UNKWN5   = $E330 = 58160          CPM22.Z80:1149
UNKWN6   = $E33E = 58174          CPM22.Z80:1159
UNKWN7   = $E343 = 58179          CPM22.Z80:1161
UNKWN8   = $E34F = 58191          CPM22.Z80:1169
UNKWN9   = $E36B = 58219          CPM22.Z80:1185
UPDATE   = $EC01 = 60417          CPM22.Z80:2691
UPDATE1  = $EC10 = 60432          CPM22.Z80:2699
UPPER    = $DD30 = 56624          CPM22.Z80:227
USER     = $E28E = 57998          CPM22.Z80:1063
USERDMA  = $F1B1 = 61873          CPM22.Z80:3654
USERNO   = $E741 = 59201          CPM22.Z80:1698
USRSTACK = $E70F = 59151          CPM22.Z80:1692
VERIFY   = $DDF5 = 56821          CPM22.Z80:362
VERIFY1  = $DDFD = 56829          CPM22.Z80:365
WBOOT    = $F203 = 61955          CPM22.Z80:3719
WRITE    = $F22A = 61994          CPM22.Z80:3732
WRITERAN = $EF9C = 61340          CPM22.Z80:3260
WRTPRT   = $F1AD = 61869          CPM22.Z80:3652
WRTPRTD  = $E92C = 59692          CPM22.Z80:2088
WRTREC   = $DD04 = 56580          CPM22.Z80:182
WRTSEQ   = $F0E6 = 61670          CPM22.Z80:3497
WTRANDOM = $F147 = 61767          CPM22.Z80:3571
WTSEQ    = $EDFE = 60926          CPM22.Z80:2990
WTSEQ1   = $EE03 = 60931          CPM22.Z80:2992
WTSEQ10  = $EED2 = 61138          CPM22.Z80:3107
WTSEQ11  = $EEFE = 61182          CPM22.Z80:3131
WTSEQ12  = $EF00 = 61184          CPM22.Z80:3132
WTSEQ2   = $EE3B = 60987          CPM22.Z80:3015
WTSEQ3   = $EE48 = 61000          CPM22.Z80:3021
WTSEQ4   = $EE64 = 61028          CPM22.Z80:3033
WTSEQ5   = $EE6C = 61036          CPM22.Z80:3040
WTSEQ6   = $EE6E = 61038          CPM22.Z80:3041
WTSEQ7   = $EE8C = 61068          CPM22.Z80:3064
WTSEQ8   = $EE9A = 61082          CPM22.Z80:3071
WTSEQ9   = $EEBB = 61115          CPM22.Z80:3091
WTSEQ99  = $EEDF = 61151          CPM22.Z80:3118 (unused)
WTSPECL  = $F19B = 61851          CPM22.Z80:3637
XLATE    = $F1D0 = 61904          CPM22.Z80:3680
YESNO    = $E152 = 57682          CPM22.Z80:899
_end     = $F233 = 62003          CPM22.Z80:42 (unused)
_size    = $1633 =  5683          CPM22.Z80:42 (unused)


total time: 0.0156 sec.
no errors
