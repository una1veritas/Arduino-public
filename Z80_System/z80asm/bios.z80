;	MDS-800 I/O Drivers for CP/M 2.2
;	(four drive single density version)
;
;	Version 2.2 February, 1980
;
vers	equ	22	;version 2.2
;
;	Copyright (c) 1980
;	Digital Research
;	Box 579, Pacific Grove
;	California, 93950
;
;
true	equ	0ffffh	;value of "true"
false	equ	not true	;"false"
test	equ	false	;true if test bios
;
	if	test
bias	equ	03400h	;base of CCP in test system
	endif
	if	not test
bias	equ	0000h	;generate relocatable cp/m system
	endif
;
patch	equ	1600h
;
	org	patch
cpmb	equ	$-patch	;base of cpm console processor
bdos	equ	806h+cpmb	;basic dos (resident portion)
cpml	equ	$-cpmb	;length (in bytes) of cpm system
nsects	equ	cpml/128	;number of sectors to load
offset	equ	2	;number of disk tracks used by cp/m
cdisk	equ	0004h	;address of last logged disk on warm start
buff	equ	0080h	;default buffer address
retry	equ	10	;max retries on disk i/o before error
;
;	perform following functions
;	boot	cold start
;	wboot	warm start (save i/o byte)
;	(boot and wboot are the same for mds)
;	const	console status
;		reg-a = 00 if no character ready
;		reg-a = ff if character ready
;	conin	console character in (result in reg-a)
;	conout	console character out (char in reg-c)
;	list	list out (char in reg-c)
;	punch	punch out (char in reg-c)
;	reader	paper tape reader in (result to reg-a)
;	home	move to track 00
;
;	(the following calls set-up the io parameter block for the
;	mds, which is used to perform subsequent reads and writes)
;	seldsk	select disk given by reg-c (0,1,2...)
;	settrk	set track address (0,...76) for subsequent read/write
;	setsec	set sector address (1,...,26) for subsequent read/write
;	setdma	set subsequent dma address (initially 80h)
;
;	(read and write assume previous calls to set up the io parameters)
;	read	read track/sector to preset dma address
;	write	write track/sector from preset dma address
;
;	jump vector for indiviual routines
	 jp boot
wboote:	 jp wboot
	 jp const
	 jp conin
	 jp conout
	 jp list
	 jp punch
	 jp reader
	 jp home
	 jp seldsk
	 jp settrk
	 jp setsec
	 jp setdma
	 jp read
	 jp write
	 jp listst	;list status
	 jp sectran
;
	maclib	diskdef	;load the disk definition library
	disks	4	;four disks
	diskdef	0,1,26,6,1024,243,64,64,offset
	diskdef	1,0
	diskdef	2,0
	diskdef	3,0
;	endef occurs at end of assembly
;
;	end of controller - independent code, the remaining subroutines
;	are tailored to the particular operating environment, and must
;	be altered for any system which differs from the intel mds.
;
;	the following code assumes the mds monitor exists at 0f800h
;	and uses the i/o subroutines within the monitor
;
;	we also assume the mds system has four disk drives
revrt	equ	0fdh	;interrupt revert port
intc	equ	0fch	;interrupt mask port
icon	equ	0f3h	;interrupt control port
inte	equ	0111$1110b	;enable rst 0(warm boot), rst 7 (monitor)
;
;	mds monitor equates
mon80	equ	0f800h	;mds monitor
rmon80	equ	0ff0fh	;restart mon80 (boot error)
ci	equ	0f803h	;console character to reg-a
ri	equ	0f806h	;reader in to reg-a
co	equ	0f809h	;console char from c to console out
po	equ	0f80ch	;punch char from c to punch device
lo	equ	0f80fh	;list from c to list device
csts	equ	0f812h	;console status 00/ff to register a
;
;	disk ports and commands
base	equ	78h	;base of disk command io ports
dstat	equ	base	;disk status (input)
rtype	equ	base+1	;result type (input)
rbyte	equ	base+3	;result byte (input)
;
ilow	equ	base+1	;iopb low address (output)
ihigh	equ	base+2	;iopb high address (output)
;
readf	equ	4h	;read function
writf	equ	6h	;write function
recal	equ	3h	;recalibrate drive
iordy	equ	4h	;i/o finished mask
cr	equ	0dh	;carriage return
lf	equ	0ah	;line feed
;
signon:	;signon message: xxk cp/m vers y.y
	db	cr,lf,lf
	if	test
	db	'32'	;32k example bios
	endif
	if	not test
	db	'00'	;memory size filled by relocator
	endif
	db	'k CP/M vers '
	db	vers/10+'0','.',vers mod 10+'0'
	db	cr,lf,0
;
boot:	;print signon message and go to ccp
;	(note: mds boot initialized iobyte at 0003h)
	ld sp,buff+80h
	ld hl,signon
	call prmsg	;print message
	xor a,a	;clear accumulator
	ld (cdisk),a	;set initially to disk a
	 jp gocpm	;go to cp/m
;
;
wboot:;	loader on track 0, sector 1, which will be skipped for warm 
;	read cp/m from disk - assuming there is a 128 byte cold start
;	start.
;
	ld sp,buff	;using dma - thus 80 thru ff available for stack
;
	ld c,retry	;max retries
	push bc
wboot0:	;enter here on error retries
	ld bc,cpmb	;set dma address to start of disk system
	call setdma
	ld c,0	;boot from drive 0
	call seldsk
	ld c,0
	call settrk	;start with track 0
	ld c,2	;start reading sector 2
	call setsec
;
;	read sectors, count nsects to zero
	pop bc	;10-error count
	ld b,nsects
rdsec:	;read next sector
	push bc	;save sector count
	call read
	jp nz,booterr	;retry if errors occur
	ld hl,(iod)	;increment dma address
	ld de,128	;sector size
	add hl,de	;incremented dma address in hl
	ld b,h
	ld c,l	;ready for call to set dma
	call setdma
	ld a,(ios)	;sector number just read
	cp a,26	;read last sector?
	jp c,rd1
;	must be sector 26, zero and go to next track
	ld a,(iot)	;get track to register a
	inc a
	ld c,a	;ready for call
	call settrk
	xor a,a	;clear sector number
rd1:	inc a	;to next sector
	ld c,a	;ready for call
	call setsec
	pop bc	;recall sector count
	dec b	;done?
	jp nz,rdsec
;
;	done with the load, reset default buffer address
gocpm:	;(enter here from cold start boot)
;	enable rst0 and rst7
	di
	ld a,12h	;initialize command
	out (revrt),a
	xor a,a
	out (intc),a	;cleared
	ld a,inte	;rst0 and rst7 bits on
	out (intc),a
	xor a,a
	out (icon),a	;interrupt control
;
;	set default buffer address to 80h
	ld bc,buff
	call setdma
;
;	reset monitor entry points
	ld a,jmp
	ld (0),a
	ld hl,wboote
	ld (1),hl	;jmp wboot at location 00
	ld (5),a
	ld hl,bdos
	ld (6),hl	;jmp bdos at location 5
	if	not test
	ld (7*8),a	;jmp to mon80 (may have been changed by ddt)
	ld hl,mon80
	ld (7*8+1),hl
	endif
;	leave iobyte set
;	previously selected disk was b, send parameter to cpm
	ld a,(cdisk)	;last logged disk number
	ld c,a	;send to ccp to log it in
	ei
	 jp cpmb
;
;	error condition occurred, print message and retry
booterr:
	pop bc	;recall counts
	dec c
	jp z,booter0
;	try again
	push bc
	 jp wboot0
;
booter0:
;	otherwise too many retries
	ld hl,bootmsg
	call prmsg
	 jp rmon80	;mds hardware monitor
;
bootmsg:
	db	'?boot',0
;
;
const:	;console status to reg-a
;	(exactly the same as mds call)
	 jp csts
;
conin:	;console character to reg-a
	call ci
	and a,7fh	;remove parity bit
	ret
;
conout:	;console character from c to console out
	 jp co
;
list:	;list device out
;	(exactly the same as mds call)
	 jp lo
;
listst:
	;return list status
	xor a,a
	ret		;always not ready
;
punch:	;punch device out
;	(exactly the same as mds call)
	 jp po
;
reader:	;reader character in to reg-a
;	(exactly the same as mds call)
	 jp ri
;
home:	;move to home position
;	treat as track 00 seek
	ld c,0
	 jp settrk
;
seldsk:	;select disk given by register c
	ld hl,0000h	;return 0000 if error
	ld a,c
	cp a,ndisks	;too large?
	ret nc		;leave HL = 0000
;
	and a,10b	;00 00 for drive 0,1 and 10 10 for drive 2,3
	ld (dbank),a	;to select drive bank
	ld a,c	;00, 01, 10, 11
	and a,1b	;mds has 0,1 at 78, 2,3 at 88
	or a,a	;result 00?
	jp z,setdrive
	ld a,00110000b	;selects drive 1 in bank
setdrive:
	ld b,a	;save the function
	ld hl,iof	;io function
	ld a,(hl)
	and a,11001111b	;mask out disk number
	or a,b	;mask in new disk number
	ld (hl),a	;save it in iopb
	ld l,c
	ld h,0	;HL=disk number
	add hl,hl	;*2
	add hl,hl	;*4
	add hl,hl	;*8
	add hl,hl	;*16
	ld de,dpbase
	add hl,de	;HL=disk header table address
	ret
;
;
settrk:	;set track address given by c
	ld hl,iot
	ld (hl),c
	ret
;
setsec:	;set sector number given by c
	ld hl,ios
	ld (hl),c
	ret
sectran:
		;translate sector bc using table at de
	ld b,0	;double precision sector number in BC
	ex de,hl		;translate table address to HL
	add hl,bc	;translate(sector) address
	ld a,(hl)	;translated sector number to A
	ld (ios),a
	ld l,a	;return sector number in L
	ret
;
setdma:	;set dma address given by regs b,c
	ld l,c
	ld h,b
	ld (iod),hl
	ret
;
read:	;read next disk record (assuming disk/trk/sec/dma set)
	ld c,readf	;set to read function
	call setfunc
	call waitio	;perform read function
	ret		;may have error set in reg-a
;
;
write:	;disk write function
	ld c,writf
	call setfunc	;set to write function
	call waitio
	ret		;may have error set
;
;
;	utility subroutines
prmsg:	;print message at h,l to 0
	ld a,(hl)
	or a,a	;zero?
	ret z
;	more to print
	push hl
	ld c,a
	call conout
	pop hl
	inc hl
	 jp prmsg
;
setfunc:
;	set function for next i/o (command in reg-c)
	ld hl,iof	;io function address
	ld a,(hl)	;get it to accumulator for masking
	and a,11111000b	;remove previous command
	or a,c	;set to new command
	ld (hl),a	;replaced in iopb
;	the mds-800 controller requires disk bank bit in sector byte
;	mask the bit from the current i/o function
	and a,00100000b	;mask the disk select bit
	ld hl,ios		;address the sector select byte
	or a,(hl)		;select proper disk bank
	ld (hl),a		;set disk select bit on/off
	ret
;
waitio:
	ld c,retry	;max retries before perm error
rewait:
;	start the i/o function and wait for completion
	call intype	;in rtype
	call inbyte	;clears the controller
;
	ld a,(dbank)		;set bank flags
	or a,a		;zero if drive 0,1 and nz if 2,3
	ld a,iopb and 0ffh	;low address for iopb
	ld b,iopb shr 8	;high address for iopb
	jp nz,iodr1	;drive bank 1?
	out (ilow),a		;low address to controller
	ld a,b
	out (ihigh),a	;high address
	 jp wait0		;to wait for complete
;
iodr1:	;drive bank 1
	out (ilow+10h),a	;88 for drive bank 10
	ld a,b
	out (ihigh+10h),a
;
wait0:	call instat		;wait for completion
	and a,iordy		;ready?
	jp z,wait0
;
;	check io completion ok
	call intype		;must be io complete (00) unlinked
;	00 unlinked i/o complete,    01 linked i/o complete (not used)
;	10 disk status changed       11 (not used)
	cp a,10b		;ready status change?
	jp z,wready
;
;	must be 00 in the accumulator
	or a,a
	jp nz,werror		;some other condition, retry
;
;	check i/o error bits
	call inbyte
	rla
	jp c,wready		;unit not ready
	rra
	and a,11111110b	;any other errors?  (deleted data ok)
	jp nz,werror
;
;	read or write is ok, accumulator contains zero
	ret
;
wready:	;not ready, treat as error for now
	call inbyte		;clear result byte
	 jp trycount
;
werror:	;return hardware malfunction (crc, track, seek, etc.)
;	the mds controller has returned a bit in each position
;	of the accumulator, corresponding to the conditions:
;	0	- deleted data (accepted as ok above)
;	1	- crc error
;	2	- seek error
;	3	- address error (hardware malfunction)
;	4	- data over/under flow (hardware malfunction)
;	5	- write protect (treated as not ready)
;	6	- write error (hardware malfunction)
;	7	- not ready
;	(accumulator bits are numbered 7 6 5 4 3 2 1 0)
;
;	it may be useful to filter out the various conditions,
;	but we will get a permanent error message if it is not
;	recoverable.  in any case, the not ready condition is
;	treated as a separate condition for later improvement
trycount:
;	register c contains retry count, decrement 'til zero
	dec c
	jp nz,rewait	;for another try
;
;	cannot recover from error
	ld a,1	;error code
	ret
;
;	intype, inbyte, instat read drive bank 00 or 10
intype:	ld a,(dbank)
	or a,a
	jp nz,intyp1	;skip to bank 10
	in a,(rtype)
	ret
intyp1:	in a,(rtype+10h)	;78 for 0,1  88 for 2,3
	ret
;
inbyte:	ld a,(dbank)
	or a,a
	jp nz,inbyt1
	in a,(rbyte)
	ret
inbyt1:	in a,(rbyte+10h)
	ret
;
instat:	ld a,(dbank)
	or a,a
	jp nz,insta1
	in a,(dstat)
	ret
insta1:	in a,(dstat+10h)
	ret
;
;
;
;	data areas (must be in ram)
dbank:	db	0	;disk bank 00 if drive 0,1
			;	   10 if drive 2,3
iopb:	;io parameter block
	db	80h	;normal i/o operation
iof:	db	readf	;io function, initial read
ion:	db	1	;number of sectors to read
iot:	db	offset	;track number
ios:	db	1	;sector number
iod:	dw	buff	;io address
;
;
;	define ram areas for bdos operation
	endef
	end
