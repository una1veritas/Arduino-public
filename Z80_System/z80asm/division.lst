                        ; --------------------------------------
                        ; zasm: assemble "division.asm"
                        ; date: 2025-09-26 15:34:33
                        ; --------------------------------------


                        
0000:                       org     0000h
0000:                   rst:
0000: 310001   [10]         ld      sp, 0100h
0003: C32000   [20]         jp      main
                        
                        ; working area
                            org     0010h
0010:                   dividiend:
0010: B3E6                  dw      $e6b3 
0012:                   divisor:
0012: 8500                  dw      $0085
0014:                   quotient:
0014: 0000                  dw      0
0016:                   reminder:
0016: 0000                  dw      0
                        
0018: 00000000              ds      8, 0
001C: 00000000          
                        
                            org     0020h
0020:                   main:
0020: 2A1200   [16]         ld      hl, (divisor)
0023: E5       [27]         push    hl
0024: 2A1000   [43]         ld      hl, (dividiend)
0027: E5       [54]         push    hl
0028: CD5500   [71]         call    div16
002B: E1       [81]         pop     hl
002C: 221400   [97]         ld      (quotient), hl
002F: E1       [107]        pop     hl
0030: 221600   [123]        ld      (reminder), hl
                        
0033: 2A1600   [139]        ld      hl, (reminder)
0036: E5       [150]        push    hl
0037: 2A1400   [166]        ld      hl, (quotient)
003A: E5       [177]        push    hl
003B: CD8A00   [194]        call    div16_8
003E: E1       [204]        pop     hl
003F: 221800   [220]        ld      (quotient+4), hl
0042: E1       [230]        pop     hl
0043: 221A00   [246]        ld      (reminder+4), hl
0046: 76       [250]        halt
                        
                        ; divide dividiend in d by divisor in e 
                        ; returns quotient in d and remainder in a
0047:                   div_d_e:
0047: AF       [ 4]        xor	a
0048: 0608     [11]        ld	b, 8
                        
004A:                   div_d_e_loop:
004A: CB22     [ 8]        sla	d
004C: 17       [12]        rla
004D: BB       [16]        cp	e
004E: 3802     [23|28]     jr	c, $+4
0050: 93       [27]        sub	e
0051: 14       [31]        inc	d
                           
0052: 10F6     [39|44]     djnz	div_d_e_loop
                           
0054: C9       [49]        ret
                        ; dvi_hl_de stack in out wrapper
                        ; [ret addr] [dividiend] [divisor] 
                        ; --> [ret addr] [quotient] [reminder]
0055:                   div16:
0055: DD210200 [14]         ld      ix, 02
0059: DD39     [29]         add     ix, sp
005B: DD4E00   [48]         ld      c, (ix)
005E: DD7E01   [67]         ld      a, (ix+1)
0061: DD5E02   [86]         ld      de, (ix+2)
0064: DD5603   [105]    
0067: CD7700   [122]        call    div_ac_de
006A: DD7502   [141]        ld      (ix+2), hl
006D: DD7403   [160]    
0070: DD7100   [179]        ld      (ix), c
0073: DD7701   [198]        ld      (ix+1), a
0076: C9       [208]        ret
                        
                        ; The following routine divides ac (dividiend) by de (divisor) and 
                        ; places the quotient in ac and the remainder in hl
                        ; destrys hl, a, b, c, d, e, ix
                        ; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Division
                        ;
0077:                   div_ac_de:
0077: 210000   [10]         ld	    hl, 0
007A: 0610     [17]         ld	    b, 16
007C:                   div_ac_de_loop:
007C: CB31     [ 8]         sll	c
007E: 17       [12]         rla
007F: ED6A     [27]         adc	hl, hl
0081: ED52     [42]         sbc	hl, de
0083: 3002     [49|54]      jr	nc, $+4 
0085: 19       [60]         add	hl, de
0086: 0D       [64]         dec	c
                            
0087: 10F3     [72|77]      djnz	div_ac_de_loop
0089: C9       [82]         ret
                        
                        
                        
                        
                        ; dvi_hl_c stack in out wrapper
                        ; [ret addr] [dividiend] [divisor:low] 
                        ; --> [ret addr] [quotient] [reminder:low]
008A:                   div16_8:
008A: DD210200 [14]         ld      ix, 02
008E: DD39     [29]         add     ix, sp
0090: DD6E00   [48]         ld      hl, (ix)
0093: DD6601   [67]     
0096: DD4E02   [86]         ld      c, (ix+2)
0099: CDA600   [103]        call    div_hl_c
009C: DD7500   [122]        ld      (ix), hl
009F: DD7401   [141]    
00A2: DD7702   [160]        ld      (ix+2), a
00A5: C9       [170]        ret
                        
                        ; divides hl by c and places the quotient in hl 
                        ; and the remainder in a
00A6:                   div_hl_c:
00A6: AF       [ 4]        xor	a
00A7: 0610     [11]        ld	b, 16
                        
00A9:                   div_hl_c_loop:
00A9: 29       [11]        add	hl, hl
00AA: 17       [15]        rla
00AB: 3803     [22|27]     jr	c, $+5
00AD: B9       [26]        cp	c
00AE: 3802     [33|38]     jr	c, $+4
                        
00B0: 91       [37]        sub	c
00B1: 2C       [41]        inc	l
                           
00B2: 10F5     [49|54]     djnz	div_hl_c_loop
                           
00B4: C9       [59]        ret
                        
                        
                        ; print the decimal integer in HL 
00B5:                   print_hl_dec:
00B5: AF       [ 4]     	xor 	a
00B6: F5       [15]     	push 	af 		; terminal null char
00B7: 0E0A     [22]     	ld 		c, 10 	; radix = 10
                        
00B9:                   print_hl_dec_loop0:
00B9: CDA600   [17]     	call 	div_hl_c 	; a = hl % 10, hl = hl / 10
00BC: C630     [24]     	add 	a, $30		; to ascii code between '0' and '9'
00BE: F5       [35]     	push 	af
00BF: 7C       [39]     	ld 		a, h 		; check whether hl is empty
00C0: B5       [43]     	or 		l
00C1: 2802     [50|55]  	jr 		z, print_hl_dec_output		; if z then conversion finished
00C3: 18F4     [62]     	jr 		print_hl_dec_loop0
                        
00C5:                   print_hl_dec_output:
00C5: F1       [10]     	pop 	af
00C6: A7       [14]     	and 	a
00C7: C8       [19|25]  	ret 	z
00C8: D302     [30]     	out 	(2), a
00CA: 18F9     [42]     	jr 		print_hl_dec_output


; +++ segments +++

#CODE          = $0000 =     0,  size = $00CC =   204

; +++ global symbols +++

_end                = $00CC =   204          division.asm:2 (unused)
_size               = $00CC =   204          division.asm:2 (unused)
div16               = $0055 =    85          division.asm:63
div16_8             = $008A =   138          division.asm:101
div_ac_de           = $0077 =   119          division.asm:80
div_ac_de_loop      = $007C =   124          division.asm:83
div_d_e             = $0047 =    71          division.asm:45 (unused)
div_d_e_loop        = $004A =    74          division.asm:49
div_hl_c            = $00A6 =   166          division.asm:113
div_hl_c_loop       = $00A9 =   169          division.asm:117
dividiend           = $0010 =    16          division.asm:9
divisor             = $0012 =    18          division.asm:11
main                = $0020 =    32          division.asm:21
print_hl_dec        = $00B5 =   181          division.asm:133 (unused)
print_hl_dec_loop0  = $00B9 =   185          division.asm:138
print_hl_dec_output = $00C5 =   197          division.asm:147
quotient            = $0014 =    20          division.asm:13
reminder            = $0016 =    22          division.asm:15
rst                 = $0000 =     0          division.asm:3 (unused)


total time: 0.0015 sec.
no errors
