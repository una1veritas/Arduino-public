                        ; --------------------------------------
                        ; zasm: assemble "rom_mon_F000.asm"
                        ; date: 2025-10-13 01:35:31
                        ; --------------------------------------


                        ; macros
                        clrcf:	macro		; clear carry flag
                        		and 	a
                        		endm
                        ;
                        clra: 	macro
                        		xor 	a
                        		endm
                        ;
                        ; I/O port
                        ;
0000:                   CONSTA 	equ 	0
0001:                   CONIO 	equ 	1
                        ;CONOUT equ 	2
0080:                   CLKMODE	equ 	128
0081:                   BUSDISP	equ 	129
                        ;
                        ;
                        ; a  ... workspace reg.
                        ; b  ... workspace reg. dnjz counter
                        ; c  ... command
                        ; de ... address
                        ; ix ...  mon_curr_addr, curr_addr + 2 == end_addr
                        ;
                        
                        ; rom subroutines;
                        ;clk_spd_change     = $F11D
                        ;dump               = $F09F
                        ;getln              = $F000 
                        ;hex2nib            = $F0E8 
                        ;hexstr_de          = $F106 
                        ;print_byte         = $F05B 
                        ;print_endl         = $F068 
                        ;print_err_msg      = $F079 
                        ;print_nibble       = $F04C 
                        ;print_str_hl       = $F071 
                        ;
                        
                        ; work space
EFA0:                   addr	equ		0EFA0H
EFA2:                   addr2	equ 	addr+2
EFA4:                   escqbuf	equ		addr+4
EFB0:                   lbuf	equ 	0EFB0H
003F:                   BUFSIZE equ 	63
                        
                        ;
                        
F000:                           org     0F000h
F000:                   mon:            ;entry point
F000: 110000   [10]     		ld 		de, 0
F003: ED53A0EF [30]     		ld 		(addr), de
F007: ED53A2EF [50]     		ld 		(addr2), de
F00B: ED53B0EF [70]     		ld 		(lbuf), de 
F00F:                   read_line:
F00F: 21B0EF   [10]     		ld 		hl, lbuf 	; line buffer
F012: 0E3F     [17]     		ld 		c, BUFSIZE	; line size (except null terminal)
F014: CDCDF0   [34]     		call	getln
F017: 21B0EF   [44]     		ld 		hl, lbuf
F01A: 7E       [51]     		ld 		a, (hl)
                        ; no arity commands
F01B: FE00     [58]     		cp 		$0 		; line is empty
F01D: 2844     [65|70]  		jr 		z, default_dump
                        		;
F01F: FE48     [72]     		cp 		'H' 	; begins with H
F021: CACCF0   [82|82]  		jp 		z, mon_halt
                        		;
F024: FE2E     [89]     		cp 		'.'		; begins with .
F026: 2827     [96|101] 		jr 		z, specify_end
F028: FE3A     [103]    		cp 		':'		; begins with :
F02A: 2866     [110|115]		jr 		z, write_mode
                        		;
                        ; specify start address and function
F02C: 0E04     [117]    		ld 		c, 4
F02E: CDFEF1   [134]    		call 	hexstr_de
F031: ED53A0EF [154]    		ld 		(addr), de
                        		;
F035: 7E       [161]    		ld 		a, (hl)
F036: FE00     [168]    		cp 		$0
F038: 2829     [175|180]		jr 		z, default_dump
F03A: FE2E     [182]    		cp		'.'
F03C: 2811     [189|194]		jr 		z, specify_end
F03E: FE3A     [196]    		cp		':'
F040: 2850     [203|208]		jr 		z, write_mode
F042: FE52     [210]    		cp		'R'
F044: 2873     [217|222]		jr 		z, run_mode
                        		;cp		'C'
                        		;jr 		z, call_mode
F046: FE53     [224]    		cp		'S'
F048: 287B     [231|236]		jr 		z, clk_mode
F04A: CD71F1   [248]    		call 	print_err_msg
F04D: 18B1     [260]    		jr 		mon		; addr and addr2 are possibly corrupted
                        		;
F04F:                   specify_end:
F04F: 23       [ 6]     		inc 	hl 		; next to '.'
F050: 0E04     [13]     		ld 		c, 4
F052: CDFEF1   [30]     		call 	hexstr_de
F055: ED53A2EF [50]     		ld 		(addr2), de
F059: 7E       [57]     		ld 		a, (hl)
F05A: FE00     [64]     		cp 		0
F05C: 2805     [71|76]  		jr 		z, default_dump
F05E: CD71F1   [88]     		call 	print_err_msg
F061: 189D     [100]    		jr 		mon		; addr and addr2 are possibly corrupted
                        		;
F063:                   default_dump:
F063: 2AA0EF   [16]     		ld 		hl, (addr)
F066: ED5BA2EF [36]     		ld 		de, (addr2)
F06A: 7C       [40]     		ld 		a, h
F06B: BA       [44]     		cp 		d 
F06C: 2002     [51|56]  		jr 		nz, $+4 
F06E: 7D       [55]     		ld 		a, l 
F06F: BB       [59]     		cp 		e 
F070: 3809     [66|71]  		jr 		c, do_dump  ; start < end
F072: 2807     [73|78]  		jr 		z, do_dump  ; start == end
F074: 111000   [83]     		ld 		de, $10
F077: 19       [94]     		add 	hl, de
F078: 22A2EF   [110]    		ld 		(addr2), hl
                        		;
F07B:                   do_dump:
F07B: 2AA0EF   [16]     		ld 		hl, (addr)
F07E: ED5BA2EF [36]     		ld 		de, (addr2)
F082: CD97F1   [53]     		call 	dump
F085: 22A0EF   [69]     		ld 		(addr), hl
F088: 110000   [79]     		ld 		de, 0
F08B: ED53A2EF [99]     		ld 		(addr2), de
F08F: C30FF0   [109]    		jp 		read_line
                        ;
F092:                   write_mode:
F092: 23       [ 6]     		inc 	hl 		; next to ':'
F093: 7E       [13]     		ld 		a, (hl)
F094: FE20     [20]     		cp 		' '
F096: 28FA     [27|32]  		jr 		z, write_mode
                        		;
F098: 0E02     [34]     		ld 		c, 2
F09A: CDFEF1   [51]     		call 	hexstr_de
F09D: 79       [55]     		ld 		a, c 
F09E: FE02     [62]     		cp 		a, 2
F0A0: 2814     [69|74]  		jr 		z, write_mode.exit	; no arg or illegal char
F0A2: DD2AA0EF [89]     		ld 		ix, (addr)
F0A6: DD7300   [108]    		ld 		(ix), e
F0A9: DD23     [118]    		inc 	ix
F0AB: DD22A0EF [138]    		ld 		(addr), ix
F0AF: 7E       [145]    		ld 		a, (hl)
F0B0: FE00     [152]    		cp 		0
F0B2: 2802     [159|164]		jr 		z, write_mode.exit
F0B4: 18DC     [171]    		jr 		write_mode
F0B6:                   write_mode.exit
F0B6: C30FF0   [10]     		jp 		read_line
                        ;
F0B9:                   run_mode:
F0B9: 2AA0EF   [16]     		ld 		hl, (addr)
F0BC: E9       [20]     		jp 		(hl)
                        ;
F0BD:                   call_mode:
F0BD: 210FF0   [10]     		ld 		hl, read_line
F0C0: E5       [21]     		push 	hl
F0C1: 2AA0EF   [37]     		ld 		hl, (addr)
F0C4: E9       [41]     		jp 		(hl)
                        ;
                        ;
                        ;  clockspeed change by output number to port 128
F0C5:                   clk_mode:
F0C5: 7B       [ 4]     		ld 		a, e
F0C6: CD1FF2   [21]     		call 	clk_spd_change
F0C9: C30FF0   [31]     		jp 		read_line
                        ;
F0CC:                   mon_halt:
F0CC: 76       [ 4]     		halt
                        
                        
                        ; getlin
                        ; read up to c bytes into buffer pointed by hl, end with 0
                        ; hl ... line buffer pointer
                        ; c  .... buffer limit length
F0CD:                   getln:
F0CD: 3600     [10]     		ld 		(hl), 0
F0CF: 0600     [17]     		ld 		b, 0		; char count
F0D1: CD60F1   [34]     		call 	print_endl
F0D4: 3E2A     [41]     		ld 		a, '*'
F0D6: D301     [52]     		out 	(CONIO), a
                                ;
F0D8:                   getln_wait:
                        		;call 	getchar
F0D8: DB00     [11]     		in 		a, (CONSTA)
F0DA: A7       [15]     		and 	a
F0DB: 28FB     [22|27]  		jr 		z, getln_wait
F0DD: DB01     [33]     		in 		a, (CONIO)
                        		;
F0DF: FE08     [40]     		cp 		$08 	;backspace
F0E1: 2817     [47|52]  		jr 		z, getln_bkspc
F0E3: FE7F     [54]     		cp 		$7f		; del
F0E5: 2813     [61|66]  		jr 		z, getln_bkspc
F0E7: FE0A     [68]     		cp 		$0a
F0E9: 2858     [75|80]  		jr 		z, getln_end
F0EB: FE0D     [82]     		cp 		$0d
F0ED: 2854     [89|94]  		jr 		z, getln_end
                        ; other ctrl codes
F0EF: FE1B     [96]     		cp 		$1b
F0F1: CA10F1   [106|106]		jp 		z, esc_seq_machine
F0F4: FE20     [113]    		cp 		$20
F0F6: 303E     [120|125]		jr 		nc, getln_echo_proceed
F0F8: 18DE     [132]    		jr 		getln_wait
                        
F0FA:                   getln_bkspc:
F0FA: 78       [ 4]     		ld 		a, b
F0FB: A7       [ 8]     		and 	a
F0FC: 28DA     [15|20]  		jr 		z, getln_wait
F0FE: 3E08     [22]     		ld 		a, $08
F100: D301     [33]     		out 	(CONIO), a
F102: 3E20     [40]     		ld 		a, ' '
F104: D301     [51]     		out 	(CONIO), a
F106: 3E08     [58]     		ld 		a, $08
F108: D301     [69]     		out 	(CONIO), a
F10A: 2B       [75]     		dec 	hl
F10B: 3600     [85]     		ld 		(hl), $0
F10D: 05       [89]     		dec 	b
F10E: 18C8     [101]    		jr 		getln_wait
                        
F110:                   esc_seq_machine:
F110: DD21A4EF [14]     		ld		ix, escqbuf
F114: DD7700   [33]     		ld 		(ix), a
F117: DD23     [43]     		inc 	ix
F119: FFFFFF   [76]     		call 	getchar
***ERROR***             		     	       ^ label "getchar" not found
F11C: FE5B     [83]     		cp 		'['
F11E: 20B8     [90|95]  		jr 		nz, getln_wait
F120: DD7700   [109]    		ld 		(ix), a
F123: DD23     [119]    		inc 	ix
F125: FFFFFF   [152]    		call 	getchar
***ERROR***             		     	       ^ label "getchar" not found
F128: FE44     [159]    		cp 		'D'
F12A: C0       [164|170]		ret 	nz
F12B: DD7700   [183]    		ld 		(ix), a
F12E: DD23     [193]    		inc 	ix
                        		clra	
F130: AF       [197]    		xor 	a
F131: DD7700   [216]    		ld 		(ix), a
                        		; echo back
F134: 18C4     [228]    		jr 		getln_bkspc
                        
F136:                   getln_echo_proceed:
F136: D301     [11]     		out 	(CONIO), a 		; echo back
                        		;
F138: 77       [18]     		ld 		(hl),a		; *ptr++ = a
F139: 23       [24]     		inc 	hl
F13A: 3600     [34]     		ld 		(hl), $0	; *ptr = NULL
F13C: 04       [38]     		inc 	b
F13D: 78       [42]     		ld 		a, b
F13E: B9       [46]     		cp 		c
F13F: 3002     [53|58]  		jr 		nc, getln_end  ; force terminate line
F141: 1895     [65]     		jr 		getln_wait
                        
F143:                   getln_end:	; parse lbuf
F143: C9       [10]     		ret
                        ;
                        ; print a nibble in A
F144:                   print_nibble:
F144: E60F     [ 7]     		and 	$0f
F146: FE0A     [14]     		cp 		$a
F148: C630     [21]     		add 	'0'
F14A: FE3A     [28]     		cp 		':'
F14C: 3802     [35|40]  		jr 		c, print_nibble_out
F14E: C607     [42]     		add 	7
F150:                   print_nibble_out:
F150: D301     [11]     		out 	(CONIO), a
F152: C9       [21]     		ret
                        
                        ; print a byte in A
F153:                   print_byte:
F153: F5       [11]     		push 	af
F154: 07       [15]     		rlca
F155: 07       [19]     		rlca
F156: 07       [23]     		rlca
F157: 07       [27]     		rlca
F158: CD44F1   [44]     		call 	print_nibble
F15B: F1       [54]     		pop 	af
F15C: CD44F1   [71]     		call 	print_nibble
F15F: C9       [81]     		ret
                        
F160:                   print_endl:
F160: 3E0A     [ 7]     		ld 		a, $0a
F162: D301     [18]     		out 	(CONIO), A
F164: 3E0D     [25]     		ld 		a, $0d
F166: D301     [36]     		out 	(CONIO), A
F168: C9       [46]     		ret
                        ;
                        ;
F169:                   print_str_hl:
F169: 7E       [ 7]     		ld 		a,(hl)
F16A: A7       [11]     		and 	A
F16B: C8       [16|22]  		ret 	z
F16C: D301     [27]     		out 	(CONIO), a
F16E: 23       [33]     		inc 	hl
F16F: 18F8     [45]     		jr 		print_str_hl
                        ;
                        ;
F171:                   print_err_msg:
F171: E5       [11]     		push 	hl
F172: F5       [22]     		push 	af
F173: CD60F1   [39]     		call 	print_endl
F176: 218DF1   [49]     		ld 		hl, str_err
F179: CD69F1   [66]     		call 	print_str_hl
F17C: F1       [76]     		pop 	af
F17D: CD53F1   [93]     		call 	print_byte
F180: CD60F1   [110]    		call 	print_endl
F183: E1       [120]    		pop 	hl
F184: 7C       [124]    		ld 		a, h
F185: CD53F1   [141]    		call 	print_byte
F188: 7D       [145]    		ld 		a, l
F189: CD53F1   [162]    		call 	print_byte
F18C: C9       [172]    		ret
                        		;
F18D:                   str_err:
F18D: 0A0D6572          		db 	$0a, $0d, "error"
F191: 726F72            
F194:                   str_endl:
F194: 0A0D00            		db $0a, $0d, 0
                        ;
                        
                        ; dump : dump memory from addr to addr+2 (value)
                        ; hl ... start address (will be trucated)
                        ; de ... end address
                        ;
                        ; bc ... the original start address
                        
F197:                   dump:
F197: 44       [ 4]     	ld 		b, h
F198: 4D       [ 8]     	ld 		c, l
F199: 3EF0     [15]     	ld 		a, $F0
F19B: A5       [19]     	and 	l
F19C: 6F       [23]     	ld 		l, a
F19D:                   dump.print_header:
F19D: CD60F1   [17]     	call 	print_endl
F1A0: 78       [21]     	ld 		a, b
F1A1: CD53F1   [38]     	call 	print_byte
F1A4: 79       [42]     	ld 		a, c
F1A5: CD53F1   [59]     	call 	print_byte
F1A8: 3E20     [66]     	ld 		a, ' '
F1AA: D301     [77]     	out 	(CONIO), a
F1AC: 3E3A     [84]     	ld 		a, ':'
F1AE: D301     [95]     	out 	(CONIO), a
F1B0: 3E20     [102]    	ld 		a, ' '
F1B2: D301     [113]    	out 	(CONIO), a
                            ;
F1B4:                   dump.bytes:
                        	;cp 	bc, hl
F1B4: 78       [ 4]     	ld 		a, b
F1B5: BC       [ 8]     	cp 		h
F1B6: 2002     [15|20]  	jr 		nz, $+4
F1B8: 79       [19]     	ld 		a, c
F1B9: BD       [23]     	cp 		l
                        	;
F1BA: 380A     [30|35]  	jr 		c, dump.print_byte
F1BC: 2808     [37|42]  	jr 		z, dump.print_byte
                        ; print two-spaces
F1BE: 3E20     [44]     	ld 		a, ' '
F1C0: D301     [55]     	out 	(CONIO), a
F1C2: D301     [66]     	out 	(CONIO), a
F1C4: 1804     [78]     	jr 		dump.print_spc
F1C6:                   dump.print_byte
F1C6: 7E       [ 7]     	ld 		a, (hl)
F1C7: CD53F1   [24]     	call 	print_byte
F1CA:                   dump.print_spc:
F1CA: 3E20     [ 7]     	ld 		a, ' '
F1CC: D301     [18]     	out 	(CONIO), a
F1CE: 23       [24]     	inc 	hl
                        	; cp 	de, hl
F1CF: 7A       [28]     	ld 		a, d
F1D0: BC       [32]     	cp 		h
F1D1: 2002     [39|44]  	jr 		nz, $+4; dump.cp_de_hl_end
F1D3: 7B       [43]     	ld 		a, e
F1D4: BD       [47]     	cp 		l
                        	; cp 	de, hl end
F1D5: C8       [52|58]  	ret 	z ; de == hl, then exit dump
F1D6: D8       [57|63]  	ret 	c ; de < hl, then exit dump
F1D7: 7D       [61]     	ld 		a, l 	; test whether the least 4 bits of address is zero
F1D8: E60F     [68]     	and 	$0f
F1DA: 20D8     [75|80]  	jr 		nz, dump.bytes
F1DC: 44       [79]     	ld 		b, h 
F1DD: 4D       [83]     	ld 		c, l
F1DE: 18BD     [95]     	jr 		dump.print_header  ; if so print address header
                            ;
                        
                        ; convert one char expressing a hexadecimal digit 
                        ; in A reg. to nibble in A
                        ; set carry flag if got a wrong char
                        ;
F1E0:                   hex2nib:
F1E0: FE30     [ 7]     		cp 		'0'
F1E2: D8       [12|18]  		ret 	c		; A < '0'
F1E3: FE3A     [19]     		cp 		'9' + 1
F1E5: 3003     [26|31]  		jr 		nc, hex2nib.alpha
F1E7: D630     [33]     		sub 	'0' 	; A was digit, results carry reset
F1E9: C9       [43]     		ret
F1EA:                   hex2nib.alpha:
F1EA: FE61     [ 7]     		cp 		'a'
F1EC: 3806     [14|19]  		jr 		c, hex2nib.upper
F1EE: FE67     [21]     		cp 		'f'+1
F1F0: 3F       [25]     		ccf		; set carry if A >= 'f'+1
F1F1: D8       [30|36]  		ret 	c
F1F2: E6DF     [37]     		and 	$df		; a - f to upper char
F1F4:                   hex2nib.upper:
F1F4: FE41     [ 7]     		cp 		'A'
F1F6: D8       [12|18]  		ret 	c
F1F7: FE47     [19]     		cp      'F' + 1
F1F9: 3F       [23]     		ccf
F1FA: D8       [28|34]  		ret 	c      ; error if it is larger than 'F'
F1FB: D637     [35]     		sub 	'A'-10
F1FD: C9       [45]     		ret
                        
                        ; read hexadecimal string char upto 2 or 4 (set in C) 
                        ; bytes from (HL) and return int val in DE
                        ; if non hexdec char is encountered at (HL), returns with current de value without inc hl.
                        ; if C upper-limit bytes has been read, returns with current de value with increment hl.
                        ; A reg. hold the last char read from (HL).
                        ;
F1FE:                   hexstr_de:
F1FE: 110000   [10]     		ld      de, 0000h
F201:                   hexstr_de.loop:
F201: 7E       [ 7]     		ld      a, (hl)
F202: CDE0F1   [24]     		call 	hex2nib
F205: D8       [29|35]  		ret 	c 			; encountered non-hexdec char.
F206:                   hexstr_de.hex2nib_succ:
F206: 0604     [ 7]     		ld 		b, 4
F208:                   hexstr_de.rl4:
F208: CB13     [ 8]     		rl      e		 ;rotate left entire de
F20A: CB12     [16]     		rl      d
F20C: 10FA     [24|29]  		djnz    hexstr_de.rl4
F20E: 83       [28]     		add 	e
F20F: 5F       [32]     		ld 		e, a
F210: 23       [38]     		inc 	hl 		; 
F211: 0D       [42]     		dec 	c
F212: 20ED     [49|54]  		jr      nz, hexstr_de.loop
F214: C9       [59]     		ret 			; return after c bytes read
                        ;
                        ;
                        ; translate adcii char digit in A register
                        ; into integer value
F215:                   dec2nib:
F215: FE30     [ 7]     		cp 		'0'
F217: D8       [12|18]  		ret 	c		; A < '0'
F218: FE3A     [19]     		cp 		'9' + 1
F21A: 3F       [23]     		ccf
F21B: D8       [28|34]  		ret 	c
F21C: D630     [35]     		sub 	'0' 	; A was digit, results carry reset
F21E: C9       [45]     		ret
                        ;
                        ;
                        
                        
                        
                        
                        ;
F21F:                   clk_spd_change:
F21F: E607     [ 7]     		and 	$07
F221: D380     [18]     		out		(CLKMODE), a
F223: C9       [28]     		ret
                        
                        ;
                        ; arithmetic routines
                        ;
                        ;8*8 multiplication
                        ;The following routine multiplies h by e and places the result in hl
F224:                   mul_h_e:
F224: 1600     [ 7]        ld	d, 0	; Combining the overhead and
F226: CB24     [15]        sla	h		; optimised first iteration
F228: 9F       [19]        sbc	a, a
F229: A3       [23]        and	e
F22A: 6F       [27]        ld	l, a
                           ;
F22B: 0607     [34]        ld	b, 7
F22D:                   mul_h_e.loop:
F22D: 29       [11]        add	hl, hl          
F22E: 3001     [18|23]     jr	nc, $+3
F230: 19       [29]        add	hl, de
                           ;
F231: 10FA     [37|42]     djnz	mul_h_e.loop
                           ;
F233: C9       [47]        ret
                        
                        ; 16*8 multiplication
                        ; The following routine multiplies de by a and places the result in ahl
                        ; (which means a is the most significant byte of the product, l the least 
                        ; significant and h the intermediate one...)
                        ;
F234:                   mul_a_de:
F234: 0E00     [ 7]        ld	c, 0
F236: 61       [11]        ld	h, c
F237: 6C       [15]        ld	l, h
                           ;
F238: 87       [19]        add	a, a		; optimised 1st iteration
F239: 3002     [26|31]     jr	nc, $+4
F23B: 62       [30]        ld	h,d
F23C: 6B       [34]        ld	l,e
                           ;
F23D: 0607     [41]        ld b, 7
F23F:                   mul_a_de.loop:
F23F: 29       [11]        add	hl, hl
F240: 17       [15]        rla
F241: 3002     [22|27]     jr	nc, $+4
F243: 19       [33]        add	hl, de
F244: 89       [37]        adc	a, c   		; yes this is actually adc a, 0 but since c is free we set it to zero and so we can save 1 byte and up to 3 T-states per iteration
                           ;
F245: 100E     [45|50]     djnz	_loop
                           ;   
F247: C9       [55]        ret
                        
                        ;
                        ; 16*16 multiplication
                        ;The following routine multiplies bc by de and places the result in dehl.
F248:                   mul_de_bc:
F248: 210000   [10]        ld	hl, 0
                        
F24B: CB23     [18]        sla	e		; optimised 1st iteration
F24D: CB12     [26]        rl	d
F24F: 3002     [33|38]     jr	nc, $+4
F251: 60       [37]        ld	h, b
F252: 69       [41]        ld	l, c
                        
F253: 3E0F     [48]        ld	a, 15
F255:                   _loop:
F255: 29       [11]        add	hl, hl
F256: CB13     [19]        rl	e
F258: CB12     [27]        rl	d
F25A: 3004     [34|39]     jr	nc, $+6
F25C: 09       [45]        add	hl, bc
F25D: 3001     [52|57]     jr	nc, $+3
F25F: 13       [58]        inc	de
                           
F260: 3D       [62]        dec	a
F261: 20F2     [69|74]     jr	nz, _loop
                           
F263: C9       [79]        ret
                         
                         
                        ; divide dividiend in d by divisor in e 
                        ; returns quotient in d and remainder in a
F264:                   div_d_e:
F264: AF       [ 4]        xor	a
F265: 0608     [11]        ld	b, 8
                           ;
F267:                   div_d_e_loop:
F267: CB22     [ 8]        sla	d
F269: 17       [12]        rla
F26A: BB       [16]        cp	e
F26B: 3802     [23|28]     jr	c, $+4
F26D: 93       [27]        sub	e
F26E: 14       [31]        inc	d
                           ;
F26F: 10F6     [39|44]     djnz	div_d_e_loop
                           ;
F271: C9       [49]        ret
                        
                        ; dvi_hl_de stack in out wrapper
                        ; [ret addr] [dividiend] [divisor] 
                        ; --> [ret addr] [quotient] [reminder]
F272:                   div16:
F272: DD210200 [14]         ld      ix, 02
F276: DD39     [29]         add     ix, sp
F278: DD4E00   [48]         ld      c, (ix)
F27B: DD7E01   [67]         ld      a, (ix+1)
F27E: DD5E02   [86]         ld      de, (ix+2)
F281: DD5603   [105]    
F284: CD94F2   [122]        call    div_ac_de
F287: DD7502   [141]        ld      (ix+2), hl
F28A: DD7403   [160]    
F28D: DD7100   [179]        ld      (ix), c
F290: DD7701   [198]        ld      (ix+1), a
F293: C9       [208]        ret
                        
                        ; The following routine divides ac (dividiend) by de (divisor) and 
                        ; places the quotient in ac and the remainder in hl
                        ; destrys hl, a, b, c, d, e, ix
                        ; https://wikiti.brandonw.net/index.php?title=Z80_Routines:Math:Division
                        ;
F294:                   div_ac_de:
F294: 210000   [10]         ld	    hl, 0
F297: 0610     [17]         ld	    b, 16
F299:                   div_ac_de_loop:
F299: CB31     [ 8]         sll	c
F29B: 17       [12]         rla
F29C: ED6A     [27]         adc	hl, hl
F29E: ED52     [42]         sbc	hl, de
F2A0: 3002     [49|54]      jr	nc, $+4 
F2A2: 19       [60]         add	hl, de
F2A3: 0D       [64]         dec	c
                            
F2A4: 10F3     [72|77]      djnz	div_ac_de_loop
F2A6: C9       [82]         ret
                        
                        
                        ; dvi_hl_c stack in out wrapper
                        ; [ret addr] [dividiend] [divisor:low] 
                        ; --> [ret addr] [quotient] [reminder:low]
F2A7:                   div16_8:
F2A7: DD210200 [14]         ld      ix, 02
F2AB: DD39     [29]         add     ix, sp
F2AD: DD6E00   [48]         ld      hl, (ix)
F2B0: DD6601   [67]     
F2B3: DD4E02   [86]         ld      c, (ix+2)
F2B6: CDC3F2   [103]        call    div_hl_c
F2B9: DD7500   [122]        ld      (ix), hl
F2BC: DD7401   [141]    
F2BF: DD7702   [160]        ld      (ix+2), a
F2C2: C9       [170]        ret
                        
                        ; divides hl by c and places the quotient in hl 
                        ; and the remainder in a
F2C3:                   div_hl_c:
F2C3: AF       [ 4]        xor	a
F2C4: 0610     [11]        ld	b, 16
                        
F2C6:                   div_hl_c_loop:
F2C6: 29       [11]        add	hl, hl
F2C7: 17       [15]        rla
F2C8: 3803     [22|27]     jr	c, $+5
F2CA: B9       [26]        cp	c
F2CB: 3802     [33|38]     jr	c, $+4
                        
F2CD: 91       [37]        sub	c
F2CE: 2C       [41]        inc	l
                           
F2CF: 10F5     [49|54]     djnz	div_hl_c_loop
                           
F2D1: C9       [59]        ret
                        
                        
                        ; print the decimal integer in HL 
F2D2:                   print_hl_dec:
F2D2: AF       [ 4]     	xor 	a
F2D3: F5       [15]     	push 	af 		; terminal null char
F2D4: 0E0A     [22]     	ld 		c, 10 	; radix = 10
                        
F2D6:                   print_hl_dec_loop0:
F2D6: CDC3F2   [17]     	call 	div_hl_c 	; a = hl % 10, hl = hl / 10
F2D9: C630     [24]     	add 	a, $30		; to ascii code between '0' and '9'
F2DB: F5       [35]     	push 	af
F2DC: 7C       [39]     	ld 		a, h 		; check whether hl is empty
F2DD: B5       [43]     	or 		l
F2DE: 2802     [50|55]  	jr 		z, print_hl_dec_output		; if z then conversion finished
F2E0: 18F4     [62]     	jr 		print_hl_dec_loop0
                        
F2E2:                   print_hl_dec_output:
F2E2: F1       [10]     	pop 	af
F2E3: A7       [14]     	and 	a
F2E4: C8       [19|25]  	ret 	z
F2E5: D302     [30]     	out 	(2), a
F2E7: 18F9     [42]     	jr 		print_hl_dec_output


; +++ segments +++

#CODE          = $F000 = 61440,  size = $02E9 =   745

; +++ global symbols +++

BUFSIZE            = $003F =    63          rom_mon_F000.asm:44
BUSDISP            = $0081 =   129          rom_mon_F000.asm:16 (unused)
CLKMODE            = $0080 =   128          rom_mon_F000.asm:15
CONIO              = $0001 =     1          rom_mon_F000.asm:13
CONSTA             = $0000 =     0          rom_mon_F000.asm:12
_end               = $F2E9 = 62185          rom_mon_F000.asm:48 (unused)
_loop              = $F255 = 62037          rom_mon_F000.asm:516
_size              = $02E9 =   745          rom_mon_F000.asm:48 (unused)
addr               = $EFA0 = 61344          rom_mon_F000.asm:40
addr2              = $EFA2 = 61346          rom_mon_F000.asm:41
call_mode          = $F0BD = 61629          rom_mon_F000.asm:153 (unused)
clk_mode           = $F0C5 = 61637          rom_mon_F000.asm:161
clk_spd_change     = $F21F = 61983          rom_mon_F000.asm:449
dec2nib            = $F215 = 61973          rom_mon_F000.asm:434 (unused)
default_dump       = $F063 = 61539          rom_mon_F000.asm:104
div16              = $F272 = 62066          rom_mon_F000.asm:552 (unused)
div16_8            = $F2A7 = 62119          rom_mon_F000.asm:588 (unused)
div_ac_de          = $F294 = 62100          rom_mon_F000.asm:569
div_ac_de_loop     = $F299 = 62105          rom_mon_F000.asm:572
div_d_e            = $F264 = 62052          rom_mon_F000.asm:533 (unused)
div_d_e_loop       = $F267 = 62055          rom_mon_F000.asm:537
div_hl_c           = $F2C3 = 62147          rom_mon_F000.asm:600
div_hl_c_loop      = $F2C6 = 62150          rom_mon_F000.asm:604
do_dump            = $F07B = 61563          rom_mon_F000.asm:118
dump               = $F197 = 61847          rom_mon_F000.asm:321
dump.bytes         = $F1B4 = 61876          rom_mon_F000.asm:340
dump.print_byte    = $F1C6 = 61894          rom_mon_F000.asm:355
dump.print_header  = $F19D = 61853          rom_mon_F000.asm:327
dump.print_spc     = $F1CA = 61898          rom_mon_F000.asm:358
esc_seq_machine    = $F110 = 61712          rom_mon_F000.asm:218
escqbuf            = $EFA4 = 61348          rom_mon_F000.asm:42
getchar            = ***UNDEFINED***
getln              = $F0CD = 61645          rom_mon_F000.asm:174
getln_bkspc        = $F0FA = 61690          rom_mon_F000.asm:203
getln_echo_proceed = $F136 = 61750          rom_mon_F000.asm:237
getln_end          = $F143 = 61763          rom_mon_F000.asm:249
getln_wait         = $F0D8 = 61656          rom_mon_F000.asm:181
hex2nib            = $F1E0 = 61920          rom_mon_F000.asm:383
hex2nib.alpha      = $F1EA = 61930          rom_mon_F000.asm:390
hex2nib.upper      = $F1F4 = 61940          rom_mon_F000.asm:397
hexstr_de          = $F1FE = 61950          rom_mon_F000.asm:412
hexstr_de.hex2nib_succ = $F206 = 61958          rom_mon_F000.asm:418 (unused)
hexstr_de.loop     = $F201 = 61953          rom_mon_F000.asm:414
hexstr_de.rl4      = $F208 = 61960          rom_mon_F000.asm:420
lbuf               = $EFB0 = 61360          rom_mon_F000.asm:43
mon                = $F000 = 61440          rom_mon_F000.asm:49
mon_halt           = $F0CC = 61644          rom_mon_F000.asm:166
mul_a_de           = $F234 = 62004          rom_mon_F000.asm:481 (unused)
mul_a_de.loop      = $F23F = 62015          rom_mon_F000.asm:492 (unused)
mul_de_bc          = $F248 = 62024          rom_mon_F000.asm:506 (unused)
mul_h_e            = $F224 = 61988          rom_mon_F000.asm:459 (unused)
mul_h_e.loop       = $F22D = 61997          rom_mon_F000.asm:467
print_byte         = $F153 = 61779          rom_mon_F000.asm:265
print_endl         = $F160 = 61792          rom_mon_F000.asm:276
print_err_msg      = $F171 = 61809          rom_mon_F000.asm:293
print_hl_dec       = $F2D2 = 62162          rom_mon_F000.asm:620 (unused)
print_hl_dec_loop0 = $F2D6 = 62166          rom_mon_F000.asm:625
print_hl_dec_output = $F2E2 = 62178          rom_mon_F000.asm:634
print_nibble       = $F144 = 61764          rom_mon_F000.asm:253
print_nibble_out   = $F150 = 61776          rom_mon_F000.asm:260
print_str_hl       = $F169 = 61801          rom_mon_F000.asm:284
read_line          = $F00F = 61455          rom_mon_F000.asm:54
run_mode           = $F0B9 = 61625          rom_mon_F000.asm:149
specify_end        = $F04F = 61519          rom_mon_F000.asm:93
str_endl           = $F194 = 61844          rom_mon_F000.asm:311 (unused)
str_err            = $F18D = 61837          rom_mon_F000.asm:309
write_mode         = $F092 = 61586          rom_mon_F000.asm:127
write_mode.exit    = $F0B6 = 61622          rom_mon_F000.asm:146


; +++ used but undefined or unresolved labels +++

getchar = ***undefined***


total time: 0.0012 sec.
2 errors
