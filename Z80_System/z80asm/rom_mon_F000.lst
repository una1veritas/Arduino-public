                        ; --------------------------------------
                        ; zasm: assemble "rom_mon_F000.asm"
                        ; date: 2025-10-06 21:20:35
                        ; --------------------------------------


                        ; macros
                        clrcf:	macro		; clear carry flag
                        		and 	a
                        		endm
                        ;
                        clra: 	macro
                        		xor 	a
                        		endm
                        ;
                        ; I/O port
                        ;
0000:                   CONSTA 	equ 	0
0001:                   CONIO 	equ 	1
                        ;CONOUT equ 	2
0080:                   CLKMODE	equ 	128
0081:                   BUSDISP	equ 	129
                        ;
                        ;
                        ; a  ... workspace reg.
                        ; b  ... workspace reg. dnjz counter
                        ; c  ... command
                        ; de ... address
                        ; ix ...  mon_curr_addr, curr_addr + 2 == end_addr
                        ;
                        
                        ; rom subroutines;
                        ;clk_spd_change     = $F11D
                        ;dump               = $F09F
                        ;getln              = $F000 
                        ;hex2nib            = $F0E8 
                        ;hexstr_de          = $F106 
                        ;print_byte         = $F05B 
                        ;print_endl         = $F068 
                        ;print_err_msg      = $F079 
                        ;print_nibble       = $F04C 
                        ;print_str_hl       = $F071 
                        ;
                        
                        ; work space
EFA0:                   addr	equ		0EFA0H
EFA2:                   addr2	equ 	addr+2
EFB0:                   lbuf	equ 	0EFB0H
003F:                   BUFSIZE equ 	63
                        ;
                        
F000:                           org     0F000h
F000:                   mon:            ;entry point
F000: 110000   [10]     		ld 		de, 0
F003: ED53A0EF [30]     		ld 		(addr), de
F007: ED53A2EF [50]     		ld 		(addr2), de
F00B: ED53B0EF [70]     		ld 		(lbuf), de 
F00F:                   read_line:
F00F: 21B0EF   [10]     		ld 		hl, lbuf 	; line buffer
F012: 0E3F     [17]     		ld 		c, BUFSIZE	; line size (except null terminal)
F014: CDC5F0   [34]     		call	getln
F017: 21B0EF   [44]     		ld 		hl, lbuf
F01A: 7E       [51]     		ld 		a, (hl)
                        ; no arity commands
F01B: FE00     [58]     		cp 		$0 		; line is empty
F01D: 2844     [65|70]  		jr 		z, default_dump
                        		;
F01F: FE48     [72]     		cp 		'H' 	; begins with H
F021: CAC4F0   [82|82]  		jp 		z, mon_halt
                        		;
F024: FE2E     [89]     		cp 		'.'		; begins with .
F026: 2827     [96|101] 		jr 		z, specify_end
F028: FE3A     [103]    		cp 		':'		; begins with :
F02A: 2866     [110|115]		jr 		z, write_mode
                        		;
                        ; specify start address and function
F02C: 0E04     [117]    		ld 		c, 4
F02E: CDCBF1   [134]    		call 	hexstr_de
F031: ED53A0EF [154]    		ld 		(addr), de
                        		;
F035: 7E       [161]    		ld 		a, (hl)
F036: FE00     [168]    		cp 		$0
F038: 2829     [175|180]		jr 		z, default_dump
F03A: FE2E     [182]    		cp		'.'
F03C: 2811     [189|194]		jr 		z, specify_end
F03E: FE3A     [196]    		cp		':'
F040: 2850     [203|208]		jr 		z, write_mode
F042: FE52     [210]    		cp		'R'
F044: 2873     [217|222]		jr 		z, run_mode
F046: FE53     [224]    		cp		'S'
F048: 2873     [231|236]		jr 		z, clk_mode
F04A: CD3EF1   [248]    		call 	print_err_msg
F04D: 18B1     [260]    		jr 		mon		; addr and addr2 are possibly corrupted
                        		;
F04F:                   specify_end:
F04F: 23       [ 6]     		inc 	hl 		; next to '.'
F050: 0E04     [13]     		ld 		c, 4
F052: CDCBF1   [30]     		call 	hexstr_de
F055: ED53A2EF [50]     		ld 		(addr2), de
F059: 7E       [57]     		ld 		a, (hl)
F05A: FE00     [64]     		cp 		0
F05C: 2805     [71|76]  		jr 		z, default_dump
F05E: CD3EF1   [88]     		call 	print_err_msg
F061: 189D     [100]    		jr 		mon		; addr and addr2 are possibly corrupted
                        		;
F063:                   default_dump:
F063: 2AA0EF   [16]     		ld 		hl, (addr)
F066: ED5BA2EF [36]     		ld 		de, (addr2)
F06A: 7C       [40]     		ld 		a, h
F06B: BA       [44]     		cp 		d 
F06C: 2002     [51|56]  		jr 		nz, $+4 
F06E: 7D       [55]     		ld 		a, l 
F06F: BB       [59]     		cp 		e 
F070: 3809     [66|71]  		jr 		c, do_dump  ; start < end
F072: 2807     [73|78]  		jr 		z, do_dump  ; start == end
F074: 111000   [83]     		ld 		de, $10
F077: 19       [94]     		add 	hl, de
F078: 22A2EF   [110]    		ld 		(addr2), hl
                        		;
F07B:                   do_dump:
F07B: 2AA0EF   [16]     		ld 		hl, (addr)
F07E: ED5BA2EF [36]     		ld 		de, (addr2)
F082: CD64F1   [53]     		call 	dump
F085: 22A0EF   [69]     		ld 		(addr), hl
F088: 110000   [79]     		ld 		de, 0
F08B: ED53A2EF [99]     		ld 		(addr2), de
F08F: C30FF0   [109]    		jp 		read_line
                        ;
F092:                   write_mode:
F092: 23       [ 6]     		inc 	hl 		; next to ':'
F093: 7E       [13]     		ld 		a, (hl)
F094: FE20     [20]     		cp 		' '
F096: 28FA     [27|32]  		jr 		z, write_mode
                        		;
F098: 0E02     [34]     		ld 		c, 2
F09A: CDCBF1   [51]     		call 	hexstr_de
F09D: 79       [55]     		ld 		a, c 
F09E: FE02     [62]     		cp 		a, 2
F0A0: 2814     [69|74]  		jr 		z, write_mode.exit	; no arg or illegal char
F0A2: DD2AA0EF [89]     		ld 		ix, (addr)
F0A6: DD7300   [108]    		ld 		(ix), e
F0A9: DD23     [118]    		inc 	ix
F0AB: DD22A0EF [138]    		ld 		(addr), ix
F0AF: 7E       [145]    		ld 		a, (hl)
F0B0: FE00     [152]    		cp 		0
F0B2: 2802     [159|164]		jr 		z, write_mode.exit
F0B4: 18DC     [171]    		jr 		write_mode
F0B6:                   write_mode.exit
F0B6: C30FF0   [10]     		jp 		read_line
                        ;
F0B9:                   run_mode:
F0B9: 2AA0EF   [16]     		ld 		hl, (addr)
F0BC: E9       [20]     		jp 		(hl)
                        ;;
                        ;  clockspeed change by output number to port 128
F0BD:                   clk_mode:
F0BD: 7B       [ 4]     		ld 		a, e
F0BE: CDE2F1   [21]     		call 	clk_spd_change
F0C1: C30FF0   [31]     		jp 		read_line
                        ;
F0C4:                   mon_halt:
F0C4: 76       [ 4]     		halt
                        
                        
                        ; subroutines
                        
                        ; getlin
                        ; read up to c bytes into buffer pointed by hl, end with 0
                        ; hl ... line buffer pointer
                        ; c  .... buffer limit length
F0C5:                   getln:
F0C5: 3600     [10]     		ld 		(hl), 0
F0C7: 0600     [17]     		ld 		b, 0		; char count
F0C9: CD2DF1   [34]     		call 	print_endl
F0CC: 3E2A     [41]     		ld 		a, '*'
F0CE: D301     [52]     		out 	(CONIO), a
                                ;
F0D0:                   getln_wait:
F0D0: DB00     [11]     		in 		a, (CONSTA)
F0D2: A7       [15]     		and 	a
F0D3: 28FB     [22|27]  		jr 		z, getln_wait
                        ;
                        ; no echo back
F0D5: DB01     [33]     		in 		a, (CONIO)
F0D7: FE08     [40]     		cp 		$08 	;backspace
F0D9: 2812     [47|52]  		jr 		z, getln_bkspc
F0DB: FE7F     [54]     		cp 		$7f		; del
F0DD: 280E     [61|66]  		jr 		z, getln_bkspc
F0DF: FE0A     [68]     		cp 		$0a
F0E1: 282D     [75|80]  		jr 		z, getln_end
F0E3: FE0D     [82]     		cp 		$0d
F0E5: 2829     [89|94]  		jr 		z, getln_end
                        ; other ctrl codes
F0E7: FE20     [96]     		cp 		$20
F0E9: 3018     [103|108]		jr 		nc, getln_echo_proceed
F0EB: 18E3     [115]    		jr 		getln_wait
                        
F0ED:                   getln_bkspc:
F0ED: 78       [ 4]     		ld 		a, b
F0EE: A7       [ 8]     		and 	a
F0EF: 28DF     [15|20]  		jr 		z, getln_wait
F0F1: 3E08     [22]     		ld 		a, $08
F0F3: D301     [33]     		out 	(CONIO), a
F0F5: 3E20     [40]     		ld 		a, ' '
F0F7: D301     [51]     		out 	(CONIO), a
F0F9: 3E08     [58]     		ld 		a, $08
F0FB: D301     [69]     		out 	(CONIO), a
F0FD: 2B       [75]     		dec 	hl
F0FE: 3600     [85]     		ld 		(hl), $0
F100: 05       [89]     		dec 	b
F101: 18CD     [101]    		jr 		getln_wait
                        
F103:                   getln_echo_proceed:
F103: D301     [11]     		out 	(CONIO), a 		; echo back
                        		;
F105: 77       [18]     		ld 		(hl),a		; *ptr++ = a
F106: 23       [24]     		inc 	hl
F107: 3600     [34]     		ld 		(hl), $0	; *ptr = NULL
F109: 04       [38]     		inc 	b
F10A: 78       [42]     		ld 		a, b
F10B: B9       [46]     		cp 		c
F10C: 3002     [53|58]  		jr 		nc, getln_end  ; force terminate line
F10E: 18C0     [65]     		jr 		getln_wait
                        
F110:                   getln_end:	; parse lbuf
F110: C9       [10]     		ret
                        
                        ;
                        ; print a nibble in A
F111:                   print_nibble:
F111: E60F     [ 7]     		and 	$0f
F113: FE0A     [14]     		cp 		$a
F115: C630     [21]     		add 	'0'
F117: FE3A     [28]     		cp 		':'
F119: 3802     [35|40]  		jr 		c, print_nibble_out
F11B: C607     [42]     		add 	7
F11D:                   print_nibble_out:
F11D: D301     [11]     		out 	(CONIO), a
F11F: C9       [21]     		ret
                        
                        ; print a byte in A
F120:                   print_byte:
F120: F5       [11]     		push 	af
F121: 07       [15]     		rlca
F122: 07       [19]     		rlca
F123: 07       [23]     		rlca
F124: 07       [27]     		rlca
F125: CD11F1   [44]     		call 	print_nibble
F128: F1       [54]     		pop 	af
F129: CD11F1   [71]     		call 	print_nibble
F12C: C9       [81]     		ret
                        
F12D:                   print_endl:
F12D: 3E0A     [ 7]     		ld 		a, $0a
F12F: D301     [18]     		out 	(CONIO), A
F131: 3E0D     [25]     		ld 		a, $0d
F133: D301     [36]     		out 	(CONIO), A
F135: C9       [46]     		ret
                        ;
F136:                   print_str_hl:
F136: 7E       [ 7]     		ld 		a,(hl)
F137: A7       [11]     		and 	A
F138: C8       [16|22]  		ret 	z
F139: D301     [27]     		out 	(CONIO), a
F13B: 23       [33]     		inc 	hl
F13C: 18F8     [45]     		jr 		print_str_hl
                        ;
                        ;
F13E:                   print_err_msg:
F13E: E5       [11]     		push 	hl
F13F: F5       [22]     		push 	af
F140: CD2DF1   [39]     		call 	print_endl
F143: 215AF1   [49]     		ld 		hl, str_err
F146: CD36F1   [66]     		call 	print_str_hl
F149: F1       [76]     		pop 	af
F14A: CD20F1   [93]     		call 	print_byte
F14D: CD2DF1   [110]    		call 	print_endl
F150: E1       [120]    		pop 	hl
F151: 7C       [124]    		ld 		a, h
F152: CD20F1   [141]    		call 	print_byte
F155: 7D       [145]    		ld 		a, l
F156: CD20F1   [162]    		call 	print_byte
F159: C9       [172]    		ret
                        		;
F15A:                   str_err:
F15A: 0A0D6572          		db 	$0a, $0d, "error"
F15E: 726F72            
F161:                   str_endl:
F161: 0A0D00            		db $0a, $0d, 0
                        ;
                        
                        ; dump : dump memory from addr to addr+2 (value)
                        ; hl ... start address (will be trucated)
                        ; de ... end address
                        ;
                        ; bc ... the original start address
                        
F164:                   dump:
F164: 44       [ 4]     	ld 		b, h
F165: 4D       [ 8]     	ld 		c, l
F166: 3EF0     [15]     	ld 		a, $F0
F168: A5       [19]     	and 	l
F169: 6F       [23]     	ld 		l, a
F16A:                   dump.print_header:
F16A: CD2DF1   [17]     	call 	print_endl
F16D: 78       [21]     	ld 		a, b
F16E: CD20F1   [38]     	call 	print_byte
F171: 79       [42]     	ld 		a, c
F172: CD20F1   [59]     	call 	print_byte
F175: 3E20     [66]     	ld 		a, ' '
F177: D301     [77]     	out 	(CONIO), a
F179: 3E3A     [84]     	ld 		a, ':'
F17B: D301     [95]     	out 	(CONIO), a
F17D: 3E20     [102]    	ld 		a, ' '
F17F: D301     [113]    	out 	(CONIO), a
                            ;
F181:                   dump.bytes:
                        	;cp 	bc, hl
F181: 78       [ 4]     	ld 		a, b
F182: BC       [ 8]     	cp 		h
F183: 2002     [15|20]  	jr 		nz, $+4
F185: 79       [19]     	ld 		a, c
F186: BD       [23]     	cp 		l
                        	;
F187: 380A     [30|35]  	jr 		c, dump.print_byte
F189: 2808     [37|42]  	jr 		z, dump.print_byte
                        ; print two-spaces
F18B: 3E20     [44]     	ld 		a, ' '
F18D: D301     [55]     	out 	(CONIO), a
F18F: D301     [66]     	out 	(CONIO), a
F191: 1804     [78]     	jr 		dump.print_spc
F193:                   dump.print_byte
F193: 7E       [ 7]     	ld 		a, (hl)
F194: CD20F1   [24]     	call 	print_byte
F197:                   dump.print_spc:
F197: 3E20     [ 7]     	ld 		a, ' '
F199: D301     [18]     	out 	(CONIO), a
F19B: 23       [24]     	inc 	hl
                        	; cp 	de, hl
F19C: 7A       [28]     	ld 		a, d
F19D: BC       [32]     	cp 		h
F19E: 2002     [39|44]  	jr 		nz, $+4; dump.cp_de_hl_end
F1A0: 7B       [43]     	ld 		a, e
F1A1: BD       [47]     	cp 		l
                        	; cp 	de, hl end
F1A2: C8       [52|58]  	ret 	z ; de == hl, then exit dump
F1A3: D8       [57|63]  	ret 	c ; de < hl, then exit dump
F1A4: 7D       [61]     	ld 		a, l 	; test whether the least 4 bits of address is zero
F1A5: E60F     [68]     	and 	$0f
F1A7: 20D8     [75|80]  	jr 		nz, dump.bytes
F1A9: 44       [79]     	ld 		b, h 
F1AA: 4D       [83]     	ld 		c, l
F1AB: 18BD     [95]     	jr 		dump.print_header  ; if so print address header
                            ;
                        
                        ; convert one char expressing a hexadecimal digit 
                        ; in A reg. to nibble in A
                        ; set carry flag if got a wrong char
                        ;
F1AD:                   hex2nib:
F1AD: FE30     [ 7]     		cp 		'0'
F1AF: D8       [12|18]  		ret 	c		; A < '0'
F1B0: FE3A     [19]     		cp 		'9' + 1
F1B2: 3003     [26|31]  		jr 		nc, hex2nib.alpha
F1B4: D630     [33]     		sub 	'0' 	; A was digit, results carry reset
F1B6: C9       [43]     		ret
F1B7:                   hex2nib.alpha:
F1B7: FE61     [ 7]     		cp 		'a'
F1B9: 3806     [14|19]  		jr 		c, hex2nib.upper
F1BB: FE67     [21]     		cp 		'f'+1
F1BD: 3F       [25]     		ccf		; set carry if A >= 'f'+1
F1BE: D8       [30|36]  		ret 	c
F1BF: E6DF     [37]     		and 	$df		; a - f to upper char
F1C1:                   hex2nib.upper:
F1C1: FE41     [ 7]     		cp 		'A'
F1C3: D8       [12|18]  		ret 	c
F1C4: FE47     [19]     		cp      'F' + 1
F1C6: 3F       [23]     		ccf
F1C7: D8       [28|34]  		ret 	c      ; error if it is larger than 'F'
F1C8: D637     [35]     		sub 	'A'-10
F1CA: C9       [45]     		ret
                        
                        ; read hexadecimal string char upto 2 or 4 (set in C) 
                        ; bytes from (HL) and return int val in DE
                        ; if non hexdec char is encountered at (HL), returns with current de value without inc hl.
                        ; if C upper-limit bytes has been read, returns with current de value with increment hl.
                        ; A reg. hold the last char read from (HL).
                        ;
F1CB:                   hexstr_de:
F1CB: 110000   [10]     		ld      de, 0000h
F1CE:                   hexstr_de.loop:
F1CE: 7E       [ 7]     		ld      a, (hl)
F1CF: CDADF1   [24]     		call 	hex2nib
F1D2: D8       [29|35]  		ret 	c 			; encountered non-hexdec char.
F1D3:                   hexstr_de.hex2nib_succ:
F1D3: 0604     [ 7]     		ld 		b, 4
F1D5:                   hexstr_de.rl4:
F1D5: CB13     [ 8]     		rl      e		 ;rotate left entire de
F1D7: CB12     [16]     		rl      d
F1D9: 10FA     [24|29]  		djnz    hexstr_de.rl4
F1DB: 83       [28]     		add 	e
F1DC: 5F       [32]     		ld 		e, a
F1DD: 23       [38]     		inc 	hl 		; 
F1DE: 0D       [42]     		dec 	c
F1DF: 20ED     [49|54]  		jr      nz, hexstr_de.loop
F1E1: C9       [59]     		ret 			; return after c bytes read
                        
                        ;
F1E2:                   clk_spd_change:
F1E2: E607     [ 7]     		and 	$07
F1E4: D380     [18]     		out		(CLKMODE), a
F1E6: C9       [28]     		ret


; +++ segments +++

#CODE          = $F000 = 61440,  size = $01E7 =   487

; +++ global symbols +++

BUFSIZE           = $003F =    63          rom_mon_F000.asm:43
BUSDISP           = $0081 =   129          rom_mon_F000.asm:16 (unused)
CLKMODE           = $0080 =   128          rom_mon_F000.asm:15
CONIO             = $0001 =     1          rom_mon_F000.asm:13
CONSTA            = $0000 =     0          rom_mon_F000.asm:12
_end              = $F1E7 = 61927          rom_mon_F000.asm:46 (unused)
_size             = $01E7 =   487          rom_mon_F000.asm:46 (unused)
addr              = $EFA0 = 61344          rom_mon_F000.asm:40
addr2             = $EFA2 = 61346          rom_mon_F000.asm:41
clk_mode          = $F0BD = 61629          rom_mon_F000.asm:150
clk_spd_change    = $F1E2 = 61922          rom_mon_F000.asm:402
default_dump      = $F063 = 61539          rom_mon_F000.asm:100
do_dump           = $F07B = 61563          rom_mon_F000.asm:114
dump              = $F164 = 61796          rom_mon_F000.asm:291
dump.bytes        = $F181 = 61825          rom_mon_F000.asm:310
dump.print_byte   = $F193 = 61843          rom_mon_F000.asm:325
dump.print_header = $F16A = 61802          rom_mon_F000.asm:297
dump.print_spc    = $F197 = 61847          rom_mon_F000.asm:328
getln             = $F0C5 = 61637          rom_mon_F000.asm:165
getln_bkspc       = $F0ED = 61677          rom_mon_F000.asm:192
getln_echo_proceed = $F103 = 61699          rom_mon_F000.asm:207
getln_end         = $F110 = 61712          rom_mon_F000.asm:219
getln_wait        = $F0D0 = 61648          rom_mon_F000.asm:172
hex2nib           = $F1AD = 61869          rom_mon_F000.asm:353
hex2nib.alpha     = $F1B7 = 61879          rom_mon_F000.asm:360
hex2nib.upper     = $F1C1 = 61889          rom_mon_F000.asm:367
hexstr_de         = $F1CB = 61899          rom_mon_F000.asm:382
hexstr_de.hex2nib_succ = $F1D3 = 61907          rom_mon_F000.asm:388 (unused)
hexstr_de.loop    = $F1CE = 61902          rom_mon_F000.asm:384
hexstr_de.rl4     = $F1D5 = 61909          rom_mon_F000.asm:390
lbuf              = $EFB0 = 61360          rom_mon_F000.asm:42
mon               = $F000 = 61440          rom_mon_F000.asm:47
mon_halt          = $F0C4 = 61636          rom_mon_F000.asm:155
print_byte        = $F120 = 61728          rom_mon_F000.asm:236
print_endl        = $F12D = 61741          rom_mon_F000.asm:247
print_err_msg     = $F13E = 61758          rom_mon_F000.asm:263
print_nibble      = $F111 = 61713          rom_mon_F000.asm:224
print_nibble_out  = $F11D = 61725          rom_mon_F000.asm:231
print_str_hl      = $F136 = 61750          rom_mon_F000.asm:254
read_line         = $F00F = 61455          rom_mon_F000.asm:52
run_mode          = $F0B9 = 61625          rom_mon_F000.asm:145
specify_end       = $F04F = 61519          rom_mon_F000.asm:89
str_endl          = $F161 = 61793          rom_mon_F000.asm:281 (unused)
str_err           = $F15A = 61786          rom_mon_F000.asm:279
write_mode        = $F092 = 61586          rom_mon_F000.asm:123
write_mode.exit   = $F0B6 = 61622          rom_mon_F000.asm:142


total time: 0.0016 sec.
no errors
