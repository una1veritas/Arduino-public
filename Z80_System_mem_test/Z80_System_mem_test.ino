/* by sin, Aug, 2025 */
#include <LiquidCrystal.h>

#include "Mega100Bus.h"

//#define BUS_DEBUG

typedef uint8_t uint8;
typedef uint16_t uint16;
typedef uint32_t uint32;

enum Mega_pin_assign {
  // z80
  CLK     = 13, // input on Z80
  _INT    = 3,  // in
  _NMI    = 4,  // in
  _HALT   = 5, // output on Z80
  _MREQ   = 39, // out
  _IORQ   = 6, // out 
  _RD     = 40, // out
  _WR     = 41, // out
  _BUSACK =  7,  // out
  _WAIT   =  8,  // in
  _BUSREQ =  9,  // in 
  _RESET  = 10,  // in
  _M1     = 11,  // out
  _RFSH   = 12,  // out

  // sram
  MEMEN   = 38, // E2 (positive neable)
};

Mega100Bus m100bus(
  //CLK, fixed
  _INT, _NMI, _HALT, _MREQ, _IORQ, 
  _RD, _WR, _BUSACK, _WAIT, _BUSREQ, _RESET, _M1, _RFSH,
  MEMEN);

const int LCD_RS = 14, LCD_EN = 15, LCD_D4 = 16, LCD_D5 = 17, LCD_D6 = 18, LCD_D7 = 19;
LiquidCrystal lcd(LCD_RS, LCD_EN, LCD_D4, LCD_D5, LCD_D6, LCD_D7);

struct Terminal {
  const LiquidCrystal & lcd;
  char line_buf[4][24];
  int row, col;

  Terminal(const LiquidCrystal & _lcd) : lcd(_lcd) {
    lcd.begin(20,4);
    lcd.clear();
    col = 0;
    row = 0;
  }

  void print(uint8 r, uint8 c, const char * str) {
    /*
    for(int i = 0; (c%20)+i < 20; ++i) {
      line_buf[r%4][(c%20)+i] = str[i];
    }
    */
    row = r % 4;
    snprintf(line_buf[row], 21, "%-20s", str);
    //line_buf[row][20] = '\0';
    lcd.setCursor(0,row);
    lcd.print(line_buf[row]);
  }

  void clear() {
    lcd.clear();
    row = 0;
    col = 0;
  }
} lcdt(lcd);

uint16 addr;
uint8 data;
uint8 flag;
char buf[32];

const uint16 MEM_MAX = 0x0100;
const uint16 MEM_START = 0x0000;
const uint16 MEM_ADDR_MASK = MEM_MAX - 1;
const uint8 mem[MEM_MAX] PROGMEM = {
  /* example 2 */
  /*
0x31, 0x00, 0x01, 0x21, 0x13, 0x00, 0xcd, 0x0a, 0x00, 0x76, 0x7e, 0xb7, 0xc8, 0xd3, 0x02, 0x23, 
0xc3, 0x0a, 0x00, 0x0d, 0x0a, 0x47, 0x6f, 0x6f, 0x64, 0x20, 0x6d, 0x6f, 0x72, 0x6e, 0x69, 0x6e, 
0x67, 0x2c, 0x20, 0x6c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x67, 0x65, 
0x6e, 0x74, 0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x21, 0x0d, 0x0a, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 
0x73, 0x20, 0x5a, 0x38, 0x30, 0x20, 0x63, 0x70, 0x75, 0x2c, 0x20, 0x38, 0x2d, 0x62, 0x69, 0x74, 
0x20, 0x63, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x21, 0x0d, 0x0a, 0x00,
*/
  /* example 1 */
  /*
0xc3, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x31, 0x00, 0x02, 0x06, 0x0a, 0xcd, 0x55, 0x00, 0x21, 0xae, 0x00, 0xcd, 0xa2, 0x00, 0x2a, 0x72, 
0x00, 0xcd, 0x74, 0x00, 0x76, 0x21, 0x01, 0x00, 0x22, 0x70, 0x00, 0x22, 0x72, 0x00, 0x2a, 0x70, 
0x00, 0x54, 0x5d, 0x2a, 0x72, 0x00, 0x22, 0x70, 0x00, 0x19, 0x22, 0x72, 0x00, 0x10, 0xef, 0xc9, 
0x00, 0x00, 0x00, 0x00, 0x06, 0x04, 0xcd, 0x99, 0x00, 0xc6, 0x30, 0xd3, 0x02, 0x06, 0x04, 0xcd, 
0x99, 0x00, 0xc6, 0x30, 0xd3, 0x02, 0x06, 0x04, 0xcd, 0x99, 0x00, 0xc6, 0x30, 0xd3, 0x02, 0x06, 
0x04, 0xcd, 0x99, 0x00, 0xc6, 0x30, 0xd3, 0x02, 0xc9, 0xaf, 0xcb, 0x15, 0xcb, 0x14, 0x17, 0x10, 
0xf9, 0xc9, 0x7e, 0xb7, 0xc8, 0x01, 0x02, 0x00, 0xed, 0x79, 0x23, 0xc3, 0xa2, 0x00, 0x0d, 0x0a, 
0x47, 0x6f, 0x6f, 0x64, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x69, 0x6e, 0x67, 0x20, 0x65, 0x76, 0x65, 
0x72, 0x79, 0x6f, 0x6e, 0x65, 0x21, 0x21, 0x0d, 0x0a, 0x00,
*/
0x31, 0x00, 0x02, 0x2a, 0x73, 0x00, 0xed, 0x4b, 0x71, 0x00, 0xcd, 0x39, 0x00, 0xca, 0x17, 0x00, 
0xda, 0x29, 0x00, 0xc3, 0x20, 0x00, 0x76, 0x21, 0x48, 0x00, 0xcd, 0x40, 0x00, 0xc3, 0x2f, 0x00, 
0x21, 0x55, 0x00, 0xcd, 0x40, 0x00, 0xc3, 0x2f, 0x00, 0x21, 0x62, 0x00, 0xcd, 0x40, 0x00, 0x2a, 
0x73, 0x00, 0x23, 0x22, 0x73, 0x00, 0xc3, 0x03, 0x00, 0x7c, 0xb8, 0x20, 0x02, 0x7d, 0xb9, 0xc9, 
0x7e, 0xa7, 0xc8, 0xd3, 0x02, 0x23, 0x18, 0xf8, 0x61, 0x72, 0x65, 0x20, 0x65, 0x71, 0x75, 0x61, 
0x6c, 0x2e, 0x0a, 0x0d, 0x00, 0x69, 0x73, 0x20, 0x6c, 0x61, 0x72, 0x67, 0x65, 0x72, 0x2e, 0x0a, 
0x0d, 0x00, 0x69, 0x73, 0x20, 0x73, 0x6d, 0x61, 0x6c, 0x6c, 0x65, 0x72, 0x2e, 0x2e, 0x0a, 0x0d, 
0x00, 0x03, 0x21, 0xfa, 0x20, 0x00, 0x00, 0x00, 0x00,
};
 

void setup() {
  // put your setup code here, to run once:
  lcdt.print(0,0, "System Starting.");

  Serial.begin(38400);
  while (! Serial) {}
  Serial.println("***********************");
  Serial.println("  Z80 system starting. ");
  Serial.println("***********************");

  // nop test
  //m100bus.mem_disable();
  m100bus.clock_start(5, 400);
  Serial.println("Reset Z80.");
  lcdt.print(0,0,"CPU Reset.");
  m100bus.cpu_reset();
  /*
  m100bus.address_bus16_mode(INPUT);
  m100bus.data_bus_mode(INPUT);

  lcdt.print(0,0, "Lowering BUSREQ");
  m100bus.BUSREQ(LOW);
  for(uint8 t = 0; t < 8; ++t) {
    m100bus.clock_wait_rising_edge();
    if ( !m100bus.BUSACK() ) break;
  }
  lcdt.print(1,0, "BUSACK.");  
  */
  if (!m100bus.DMA_mode() ) {
    lcdt.print(0,0,"DMA mode failed.");
    while (true) ;
  } else {
    Serial.println("Entered DMA mode.");
    lcdt.print(0,0,"DMA mode.");
  
    for(uint16 ix = 0; ix < MEM_MAX - MEM_START; ++ix) {
      addr = MEM_START + ix;
      data = pgm_read_byte_near(mem + ix);
      snprintf(buf, 32, "Write %02X to %04X", data, addr);
      lcdt.print(1,0,buf);
      m100bus.mem_write(addr, data);
      //delay(500);
    }

    lcdt.print(1,0,"Verifying.");
    uint16 errcount = 0;
    for(uint16 ix = 0; ix < MEM_MAX - MEM_START; ++ix) {
      addr = MEM_START + ix;
      data = m100bus.mem_read(addr);
      snprintf(buf, 32, "Read %02X from %04X", data, addr);
      lcdt.print(1,0,buf);
      uint8 t = pgm_read_byte_near(mem + ix);
      if (data != t) {
        errcount++;
        snprintf(buf, 32, "Error %02X but %02X", data, t);
        lcdt.print(2,0,buf);
        delay(1000);
      } else {
        lcdt.print(2,0,"Ok!!");
      }
    }
    if (errcount == 0) {
      lcdt.print(0,0,"Check passed.");
      //delay(500);
    } else {
      snprintf(buf, 32, "Error: %d", errcount);
      lcdt.print(0,0,buf);
      while (true);
    }
    Serial.println("Exit to Z08 mode.");
    m100bus.Z80_mode();
  }
  Serial.println("_RESET goes HIGH.");
  m100bus.RESET(HIGH);
  lcdt.clear();
  lcdt.print(0,0,"Recover from RESET.");
}

void loop() {
  m100bus.clock_wait_rising_edge();
  snprintf(buf, 21, "%-4s %-2s %-2s", 
  (m100bus.MREQ() ? (m100bus.IORQ() ? "" : "IORQ") : "MREQ"), 
  (m100bus.M1() ? "" : "M1"), 
  (m100bus.RD() ? (m100bus.WR() ? "" : "WR") : "RD") 
  );
  lcdt.print(0,0, buf);
  snprintf(buf, 21, "%-3s %-3s %-3s %-3s", 
  (m100bus.WAIT() ? "" : "WAT"), 
  (m100bus.BUSACK() ? "" : "BAK"), 
  (m100bus.HALT() ? "" : "HLT"),
  (m100bus.RFSH() ? "" : "RFH") );
  lcdt.print(2,0, buf);

  if ( !m100bus.MREQ() ) {
    if ( ! m100bus.RD() ) {
      addr = m100bus.address_bus16_get();
      m100bus.clock_wait_rising_edge();
      data = m100bus.data_bus_get();
    } else if ( ! m100bus.WR() ) {
      addr = m100bus.address_bus16_get();
      m100bus.clock_wait_rising_edge();
      data = m100bus.data_bus_get();
    }
    snprintf(buf, 32, "%04X %02X", addr, data);
    lcdt.print(1,0,buf);
  } else if ( !m100bus.IORQ() and m100bus.MREQ() ) {
    if ( ! m100bus.RD() ) {
      // in operation
      addr = m100bus.address_bus16_get();
      data = m100bus.ioport(addr, 0, INPUT);
      m100bus.data_bus_mode(OUTPUT);
      m100bus.data_bus_set(data);
      m100bus.clock_wait_rising_edge(2);
      m100bus.data_bus_mode(INPUT);
    } else if ( ! m100bus.WR() ) {
      // out operation
      m100bus.data_bus_mode(INPUT);
      addr = m100bus.address_bus16_get();
      m100bus.clock_wait_rising_edge(2);
      data = m100bus.data_bus_get();
      m100bus.ioport(addr, data, OUTPUT);
    } 
    snprintf(buf, 32, "%04X %02X", addr, data);
    lcdt.print(1,0,buf);
  }
}
